name: COMPILATION FIXED - v4.9.129

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create consistent signing keystore
        run: |
          cd android/app
          # Remove existing keystore if it exists
          rm -f miletracker.keystore
          # Create new keystore with consistent credentials and date
          keytool -genkey -v -keystore miletracker.keystore -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker Pro LLC, L=Charlotte, S=NC, C=US"

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 49129
                  versionName "4.9.129"
              }

              signingConfigs {
                  release {
                      storeFile file("miletracker.keystore")
                      storePassword "miletracker123"
                      keyAlias "miletracker"
                      keyPassword "miletracker123"
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.release
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              implementation 'org.json:json:20231013'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name=".MainActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="${applicationId}.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">mileage-tracker-codenurse.replit.app</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <files-path name="files" path="." />
              <cache-path name="cache" path="." />
              <external-files-path name="external_files" path="." />
              <external-cache-path name="external_cache" path="." />
          </paths>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#667eea</color>
              <color name="primary_dark">#5a6fd8</color>
              <color name="accent">#667eea</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
              <color name="success">#28a745</color>
              <color name="danger">#dc3545</color>
              <color name="warning">#ffc107</color>
              <color name="tab_active">#667eea</color>
              <color name="tab_inactive">#9CA3AF</color>
              <color name="background">#f5f5f5</color>
              <color name="card_background">#ffffff</color>
              <color name="text_primary">#495057</color>
              <color name="text_secondary">#6C757D</color>
          </resources>
          EOF

      - name: Create red car icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24.0"
              android:viewportHeight="24.0">
              <path
                  android:fillColor="#dc3545"
                  android:pathData="M18.92,6.01C18.72,5.42 18.16,5 17.5,5h-11C5.84,5 5.28,5.42 5.08,6.01L3,12v8c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-1h12v1c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-8L18.92,6.01zM6.5,16C5.67,16 5,15.33 5,14.5S5.67,13 6.5,13S8,13.67 8,14.5S7.33,16 6.5,16zM17.5,16c-0.83,0 -1.5,-0.67 -1.5,-1.5s0.67,-1.5 1.5,-1.5s1.5,0.67 1.5,1.5S18.33,16 17.5,16zM5,11l1.5,-4.5h11L19,11H5z"/>
          </vector>
          EOF

      - name: Create DeviceIdentification utility for stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/DeviceIdentification.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;

          import java.security.MessageDigest;
          import java.util.UUID;

          public class DeviceIdentification {
              private static final String TAG = "DeviceIdentification";
              private static final String PREFS_NAME = "DeviceIdentificationPrefs";
              private static final String STABLE_DEVICE_ID_KEY = "stable_device_id";
              private static final String USER_ID_KEY = "user_id";

              public static String getStableDeviceId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String stableId = prefs.getString(STABLE_DEVICE_ID_KEY, null);

                  if (stableId == null) {
                      // Generate a new stable device ID
                      stableId = generateStableDeviceId(context);
                      
                      // Save it for future use
                      SharedPreferences.Editor editor = prefs.edit();
                      editor.putString(STABLE_DEVICE_ID_KEY, stableId);
                      editor.apply();
                      
                      Log.d(TAG, "Generated new stable device ID: " + stableId);
                  }

                  return stableId;
              }

              private static String generateStableDeviceId(Context context) {
                  try {
                      // Use device-specific information to create a stable ID
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                      
                      // Fallback to random UUID if Android ID is not available
                      if (androidId == null || "9774d56d682e549c".equals(androidId)) {
                          androidId = UUID.randomUUID().toString();
                      }
                      
                      // Combine with device model and manufacturer for additional uniqueness
                      String deviceInfo = Build.MODEL + Build.MANUFACTURER + androidId;
                      
                      // Create a hash of the device information
                      MessageDigest md = MessageDigest.getInstance("SHA-256");
                      byte[] hash = md.digest(deviceInfo.getBytes("UTF-8"));
                      
                      // Convert to hex string
                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }
                      
                      // Return first 16 characters for a reasonable device ID length
                      return hexString.toString().substring(0, 16);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error generating device ID", e);
                      // Fallback to simple UUID if hashing fails
                      return UUID.randomUUID().toString().replace("-", "").substring(0, 16);
                  }
              }

              public static void setUserId(Context context, String userId) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.putString(USER_ID_KEY, userId);
                  editor.apply();
                  Log.d(TAG, "Set user ID: " + userId);
              }

              public static String getUserId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  return prefs.getString(USER_ID_KEY, null);
              }

              public static void clearUserId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.remove(USER_ID_KEY);
                  editor.apply();
                  Log.d(TAG, "Cleared user ID");
              }

              public static String getDeviceInfo(Context context) {
                  return "Device: " + Build.MODEL + " (" + Build.MANUFACTURER + "), Android " + Build.VERSION.RELEASE;
              }
          }
          EOF

      - name: Create Trip model class
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import org.json.JSONException;
          import org.json.JSONObject;

          public class Trip {
              private long id;
              private String startLocation;
              private String endLocation;
              private double distance;
              private long duration; // in milliseconds
              private long startTime;
              private long endTime;
              private boolean isAutoDetected;
              private String category;
              private String notes;
              private String clientName;
              private boolean isUploaded;

              // Constructor
              public Trip() {
                  this.id = System.currentTimeMillis(); // Simple ID generation
                  this.isUploaded = false;
                  this.category = "Uncategorized";
              }

              // Constructor with parameters
              public Trip(String startLocation, String endLocation, double distance, long duration, boolean isAutoDetected) {
                  this();
                  this.startLocation = startLocation;
                  this.endLocation = endLocation;
                  this.distance = distance;
                  this.duration = duration;
                  this.isAutoDetected = isAutoDetected;
                  this.startTime = System.currentTimeMillis() - duration;
                  this.endTime = System.currentTimeMillis();
              }

              // Getters and Setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartLocation() { return startLocation; }
              public void setStartLocation(String startLocation) { this.startLocation = startLocation; }

              public String getEndLocation() { return endLocation; }
              public void setEndLocation(String endLocation) { this.endLocation = endLocation; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return isAutoDetected; }
              public void setAutoDetected(boolean autoDetected) { isAutoDetected = autoDetected; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public boolean isUploaded() { return isUploaded; }
              public void setUploaded(boolean uploaded) { isUploaded = uploaded; }

              // Utility methods
              public String getDurationFormatted() {
                  long seconds = duration / 1000;
                  long minutes = seconds / 60;
                  long hours = minutes / 60;
                  
                  if (hours > 0) {
                      return String.format("%dh %dm", hours, minutes % 60);
                  } else {
                      return String.format("%dm", minutes);
                  }
              }

              public String getDistanceFormatted() {
                  return String.format("%.1f mi", distance);
              }

              // JSON serialization
              public JSONObject toJSON() throws JSONException {
                  JSONObject json = new JSONObject();
                  json.put("id", id);
                  json.put("startLocation", startLocation);
                  json.put("endLocation", endLocation);
                  json.put("distance", distance);
                  json.put("duration", duration);
                  json.put("startTime", startTime);
                  json.put("endTime", endTime);
                  json.put("isAutoDetected", isAutoDetected);
                  json.put("category", category);
                  json.put("notes", notes);
                  json.put("clientName", clientName);
                  json.put("isUploaded", isUploaded);
                  return json;
              }

              public static Trip fromJSON(JSONObject json) throws JSONException {
                  Trip trip = new Trip();
                  trip.id = json.optLong("id", System.currentTimeMillis());
                  trip.startLocation = json.optString("startLocation", "");
                  trip.endLocation = json.optString("endLocation", "");
                  trip.distance = json.optDouble("distance", 0.0);
                  trip.duration = json.optLong("duration", 0);
                  trip.startTime = json.optLong("startTime", 0);
                  trip.endTime = json.optLong("endTime", 0);
                  trip.isAutoDetected = json.optBoolean("isAutoDetected", false);
                  trip.category = json.optString("category", "Uncategorized");
                  trip.notes = json.optString("notes", "");
                  trip.clientName = json.optString("clientName", "");
                  trip.isUploaded = json.optBoolean("isUploaded", false);
                  return trip;
              }
          }
          EOF

      - name: Create TripStorage class
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import org.json.JSONArray;
          import org.json.JSONException;
          import org.json.JSONObject;
          import java.util.ArrayList;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "TripStoragePrefs";
              private static final String TRIPS_KEY = "trips";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              private static final String STATISTICS_KEY = "statistics";
              
              private final SharedPreferences prefs;
              private final Context context;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              // Trip management methods
              public void saveTrip(Trip trip) {
                  try {
                      List<Trip> trips = getAllTrips();
                      
                      // Check if trip already exists (update) or add new
                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }
                      
                      if (!updated) {
                          trips.add(trip);
                      }
                      
                      saveAllTrips(trips);
                      Log.d(TAG, "Trip saved: " + trip.getId());
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray jsonArray = new JSONArray(tripsJson);
                      
                      for (int i = 0; i < jsonArray.length(); i++) {
                          JSONObject tripJson = jsonArray.getJSONObject(i);
                          Trip trip = Trip.fromJSON(tripJson);
                          trips.add(trip);
                      }
                      
                  } catch (JSONException e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (Trip trip : trips) {
                          jsonArray.put(trip.toJSON());
                      }
                      
                      SharedPreferences.Editor editor = prefs.edit();
                      editor.putString(TRIPS_KEY, jsonArray.toString());
                      editor.apply();
                      
                      Log.d(TAG, "Saved " + trips.size() + " trips");
                      
                  } catch (JSONException e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      Log.d(TAG, "Trip deleted: " + tripId);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              public Trip getTripById(long tripId) {
                  List<Trip> trips = getAllTrips();
                  for (Trip trip : trips) {
                      if (trip.getId() == tripId) {
                          return trip;
                      }
                  }
                  return null;
              }

              // Statistics methods
              public double getTotalMiles() {
                  double total = 0;
                  for (Trip trip : getAllTrips()) {
                      total += trip.getDistance();
                  }
                  return total;
              }

              public int getTotalTrips() {
                  return getAllTrips().size();
              }

              public double getTotalMilesByCategory(String category) {
                  double total = 0;
                  for (Trip trip : getAllTrips()) {
                      if (category.equals(trip.getCategory())) {
                          total += trip.getDistance();
                      }
                  }
                  return total;
              }

              // API sync settings
              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, false);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.putBoolean(API_SYNC_KEY, enabled);
                  editor.apply();
                  Log.d(TAG, "API sync " + (enabled ? "enabled" : "disabled"));
              }

              // Clear all data
              public void clearAllData() {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.clear();
                  editor.apply();
                  Log.d(TAG, "All data cleared");
              }

              // Merge trips
              public void mergeTrips(List<String> tripIds) {
                  if (tripIds.size() < 2) return;
                  
                  List<Trip> trips = getAllTrips();
                  List<Trip> tripsToMerge = new ArrayList<>();
                  
                  // Find trips to merge
                  for (String idStr : tripIds) {
                      long id = Long.parseLong(idStr);
                      for (Trip trip : trips) {
                          if (trip.getId() == id) {
                              tripsToMerge.add(trip);
                              break;
                          }
                      }
                  }
                  
                  if (tripsToMerge.size() < 2) return;
                  
                  // Create merged trip
                  Trip mergedTrip = new Trip();
                  double totalDistance = 0;
                  long totalDuration = 0;
                  long earliestStart = Long.MAX_VALUE;
                  long latestEnd = 0;
                  
                  for (Trip trip : tripsToMerge) {
                      totalDistance += trip.getDistance();
                      totalDuration += trip.getDuration();
                      earliestStart = Math.min(earliestStart, trip.getStartTime());
                      latestEnd = Math.max(latestEnd, trip.getEndTime());
                  }
                  
                  mergedTrip.setStartLocation(tripsToMerge.get(0).getStartLocation());
                  mergedTrip.setEndLocation(tripsToMerge.get(tripsToMerge.size() - 1).getEndLocation());
                  mergedTrip.setDistance(totalDistance);
                  mergedTrip.setDuration(totalDuration);
                  mergedTrip.setStartTime(earliestStart);
                  mergedTrip.setEndTime(latestEnd);
                  mergedTrip.setCategory("Business"); // Default merged trips to Business
                  
                  // Remove original trips and add merged trip
                  for (String idStr : tripIds) {
                      deleteTrip(Long.parseLong(idStr));
                  }
                  saveTrip(mergedTrip);
                  
                  Log.d(TAG, "Merged " + tripIds.size() + " trips into one");
              }
          }
          EOF

      - name: Create MainActivity with complete UI and search functionality
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.AlertDialog;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Bundle;
          import android.os.Handler;
          import android.os.Looper;
          import android.text.Editable;
          import android.text.TextWatcher;
          import android.util.Log;
          import android.view.Gravity;
          import android.view.GestureDetector;
          import android.view.MotionEvent;
          import android.view.View;
          import android.widget.Button;
          import android.widget.CheckBox;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;

          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;

          import com.miletrackerpro.app.auth.AuthActivity;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.DeviceIdentification;

          import java.text.SimpleDateFormat;
          import java.util.ArrayList;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;

          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final String TAG = "MainActivity";
              private static final int LOCATION_PERMISSION_REQUEST = 1001;

              // UI Components
              private LinearLayout mainContentLayout;
              private ScrollView dashboardScroll;
              private LinearLayout dashboardLayout;
              private LinearLayout classifyContent;
              private LinearLayout classifyTripsLayout;
              private LinearLayout categorizedContent;
              private ScrollView categorizedTripsScroll;
              private LinearLayout categorizedTripsContainer;
              private LinearLayout recentTripsLayout;
              
              // Tab buttons
              private Button homeTabButton;
              private Button tripsTabButton;
              private Button categorizedTabButton;

              // Dashboard buttons and displays
              private Button autoToggle;
              private Button startTripButton;
              private Button stopTripButton;
              private Button apiToggle;
              private TextView statsDisplay;
              private TextView currentSpeedDisplay;
              private TextView currentDistanceDisplay;

              // Search and filter components
              private EditText searchBox;
              private Button sortButton;
              private Button categoryFilterButton;
              
              // State variables
              private String currentTab = "home";
              private String currentSortOrder = "Newest";
              private String currentCategoryFilter = "All";
              private String currentSearchQuery = "";
              private boolean isAutoDetectionEnabled = false;
              private boolean isManualTripActive = false;
              private boolean isLocationPermissionGranted = false;

              // Location and trip tracking
              private LocationManager locationManager;
              private Location lastKnownLocation;
              private Location tripStartLocation;
              private long tripStartTime;
              private double currentTripDistance = 0.0;
              private double currentSpeed = 0.0;
              private final List<Location> tripLocations = new ArrayList<>();

              // Storage and data
              private TripStorage tripStorage;
              private final List<String> selectedTripIds = new ArrayList<>();
              private boolean mergeMode = false;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  try {
                      // Initialize storage
                      tripStorage = new TripStorage(this);
                      
                      // Setup main layout
                      setupMainLayout();
                      
                      // Setup location services
                      setupLocationServices();
                      
                      // Initialize UI components
                      initializeComponents();
                      
                      // Check permissions and start
                      checkLocationPermissions();
                      
                      Log.d(TAG, "MainActivity created successfully");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onCreate: " + e.getMessage(), e);
                      showErrorAndExit("Failed to initialize app: " + e.getMessage());
                  }
              }

              private void setupMainLayout() {
                  // Create main container
                  LinearLayout mainContainer = new LinearLayout(this);
                  mainContainer.setOrientation(LinearLayout.VERTICAL);
                  mainContainer.setBackgroundColor(0xFFf5f5f5);

                  // Create tab buttons layout
                  LinearLayout tabLayout = createTabButtons();
                  mainContainer.addView(tabLayout);

                  // Create main content area
                  mainContentLayout = new LinearLayout(this);
                  mainContentLayout.setOrientation(LinearLayout.VERTICAL);
                  
                  LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      0,
                      1.0f
                  );
                  mainContentLayout.setLayoutParams(contentParams);
                  mainContainer.addView(mainContentLayout);

                  setContentView(mainContainer);
              }

              private LinearLayout createTabButtons() {
                  LinearLayout tabLayout = new LinearLayout(this);
                  tabLayout.setOrientation(LinearLayout.HORIZONTAL);
                  tabLayout.setBackgroundColor(0xFF667eea);
                  tabLayout.setPadding(0, 10, 0, 10);

                  // Equal weight for all tabs
                  LinearLayout.LayoutParams tabParams = new LinearLayout.LayoutParams(
                      0,
                      LinearLayout.LayoutParams.WRAP_CONTENT,
                      1.0f
                  );

                  // Home Tab Button
                  homeTabButton = new Button(this);
                  homeTabButton.setText("üè†\nHome");
                  homeTabButton.setTextSize(12);
                  homeTabButton.setBackgroundColor(0xFF667eea);
                  homeTabButton.setTextColor(0xFFFFFFFF);
                  homeTabButton.setLayoutParams(tabParams);
                  homeTabButton.setOnClickListener(v -> switchToTab("home"));
                  tabLayout.addView(homeTabButton);

                  // Classify Tab Button  
                  tripsTabButton = new Button(this);
                  tripsTabButton.setText("üìù\nSort Trips");
                  tripsTabButton.setTextSize(12);
                  tripsTabButton.setBackgroundColor(0xFF9CA3AF);
                  tripsTabButton.setTextColor(0xFFFFFFFF);
                  tripsTabButton.setLayoutParams(tabParams);
                  tripsTabButton.setOnClickListener(v -> switchToTab("trips"));
                  tabLayout.addView(tripsTabButton);

                  // Categorized Tab Button
                  categorizedTabButton = new Button(this);
                  categorizedTabButton.setText("üìÇ\nFiled Trips");
                  categorizedTabButton.setTextSize(12);
                  categorizedTabButton.setBackgroundColor(0xFF9CA3AF);
                  categorizedTabButton.setTextColor(0xFFFFFFFF);
                  categorizedTabButton.setLayoutParams(tabParams);
                  categorizedTabButton.setOnClickListener(v -> switchToTab("categorized"));
                  tabLayout.addView(categorizedTabButton);

                  return tabLayout;
              }

              private void initializeComponents() {
                  createDashboardContent();
                  createClassifyContent();
                  createCategorizedContent();
                  
                  // Start with dashboard
                  switchToTab("home");
              }

              private void createDashboardContent() {
                  dashboardScroll = new ScrollView(this);
                  dashboardLayout = new LinearLayout(this);
                  dashboardLayout.setOrientation(LinearLayout.VERTICAL);
                  dashboardLayout.setPadding(15, 15, 15, 15);

                  // Auto Detection Control
                  createAutoDetectionSection();
                  
                  // Manual Trip Controls
                  createManualTripSection();
                  
                  // Current Status Display
                  createStatusSection();
                  
                  // Statistics Display
                  createStatsSection();
                  
                  // API Sync Control
                  createApiSyncSection();
                  
                  // Recent Trips Section
                  createRecentTripsSection();

                  dashboardScroll.addView(dashboardLayout);
              }

              private void createAutoDetectionSection() {
                  TextView autoLabel = new TextView(this);
                  autoLabel.setText("üîÑ Auto Detection");
                  autoLabel.setTextSize(16);
                  autoLabel.setTextColor(0xFF333333);
                  autoLabel.setPadding(0, 0, 0, 8);
                  dashboardLayout.addView(autoLabel);

                  autoToggle = new Button(this);
                  autoToggle.setText("Auto Detection: OFF");
                  autoToggle.setTextSize(14);
                  autoToggle.setBackgroundColor(0xFF9CA3AF);
                  autoToggle.setTextColor(0xFFFFFFFF);
                  autoToggle.setPadding(20, 15, 20, 15);
                  autoToggle.setOnClickListener(v -> toggleAutoDetection());
                  dashboardLayout.addView(autoToggle);

                  // Add spacing
                  TextView spacer1 = new TextView(this);
                  spacer1.setHeight(20);
                  dashboardLayout.addView(spacer1);
              }

              private void createManualTripSection() {
                  TextView manualLabel = new TextView(this);
                  manualLabel.setText("‚úã Manual Trip Controls");
                  manualLabel.setTextSize(16);
                  manualLabel.setTextColor(0xFF333333);
                  manualLabel.setPadding(0, 0, 0, 8);
                  dashboardLayout.addView(manualLabel);

                  LinearLayout manualButtonsLayout = new LinearLayout(this);
                  manualButtonsLayout.setOrientation(LinearLayout.HORIZONTAL);

                  startTripButton = new Button(this);
                  startTripButton.setText("START TRIP");
                  startTripButton.setTextSize(14);
                  startTripButton.setBackgroundColor(0xFF28a745);
                  startTripButton.setTextColor(0xFFFFFFFF);
                  startTripButton.setPadding(20, 15, 20, 15);
                  startTripButton.setOnClickListener(v -> startManualTrip());

                  stopTripButton = new Button(this);
                  stopTripButton.setText("STOP TRIP");
                  stopTripButton.setTextSize(14);
                  stopTripButton.setBackgroundColor(0xFFdc3545);
                  stopTripButton.setTextColor(0xFFFFFFFF);
                  stopTripButton.setPadding(20, 15, 20, 15);
                  stopTripButton.setEnabled(false);
                  stopTripButton.setOnClickListener(v -> stopManualTrip());

                  LinearLayout.LayoutParams buttonParams = new LinearLayout.LayoutParams(
                      0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  buttonParams.setMargins(0, 0, 10, 0);
                  startTripButton.setLayoutParams(buttonParams);

                  buttonParams = new LinearLayout.LayoutParams(
                      0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  stopTripButton.setLayoutParams(buttonParams);

                  manualButtonsLayout.addView(startTripButton);
                  manualButtonsLayout.addView(stopTripButton);
                  dashboardLayout.addView(manualButtonsLayout);

                  // Add spacing
                  TextView spacer2 = new TextView(this);
                  spacer2.setHeight(20);
                  dashboardLayout.addView(spacer2);
              }

              private void createStatusSection() {
                  TextView statusLabel = new TextView(this);
                  statusLabel.setText("üìç Current Status");
                  statusLabel.setTextSize(16);
                  statusLabel.setTextColor(0xFF333333);
                  statusLabel.setPadding(0, 0, 0, 8);
                  dashboardLayout.addView(statusLabel);

                  currentSpeedDisplay = new TextView(this);
                  currentSpeedDisplay.setText("Speed: 0.0 mph");
                  currentSpeedDisplay.setTextSize(14);
                  currentSpeedDisplay.setTextColor(0xFF666666);
                  currentSpeedDisplay.setPadding(10, 5, 10, 5);
                  dashboardLayout.addView(currentSpeedDisplay);

                  currentDistanceDisplay = new TextView(this);
                  currentDistanceDisplay.setText("Distance: 0.0 miles");
                  currentDistanceDisplay.setTextSize(14);
                  currentDistanceDisplay.setTextColor(0xFF666666);
                  currentDistanceDisplay.setPadding(10, 5, 10, 5);
                  dashboardLayout.addView(currentDistanceDisplay);

                  // Add spacing
                  TextView spacer3 = new TextView(this);
                  spacer3.setHeight(20);
                  dashboardLayout.addView(spacer3);
              }

              private void createStatsSection() {
                  TextView statsLabel = new TextView(this);
                  statsLabel.setText("üìä Statistics");
                  statsLabel.setTextSize(16);
                  statsLabel.setTextColor(0xFF333333);
                  statsLabel.setPadding(0, 0, 0, 8);
                  dashboardLayout.addView(statsLabel);

                  statsDisplay = new TextView(this);
                  statsDisplay.setTextSize(14);
                  statsDisplay.setTextColor(0xFF666666);
                  statsDisplay.setPadding(10, 10, 10, 10);
                  statsDisplay.setBackgroundColor(0xFFFFFFFF);
                  dashboardLayout.addView(statsDisplay);

                  // Add spacing
                  TextView spacer4 = new TextView(this);
                  spacer4.setHeight(20);
                  dashboardLayout.addView(spacer4);
              }

              private void createApiSyncSection() {
                  TextView apiLabel = new TextView(this);
                  apiLabel.setText("üåê Cloud Backup");
                  apiLabel.setTextSize(16);
                  apiLabel.setTextColor(0xFF333333);
                  apiLabel.setPadding(0, 0, 0, 8);
                  dashboardLayout.addView(apiLabel);

                  apiToggle = new Button(this);
                  apiToggle.setText("üåê API OFF");
                  apiToggle.setTextSize(14);
                  apiToggle.setBackgroundColor(0xFF9CA3AF);
                  apiToggle.setTextColor(0xFFFFFFFF);
                  apiToggle.setPadding(20, 15, 20, 15);
                  apiToggle.setOnClickListener(v -> toggleApiSync());
                  dashboardLayout.addView(apiToggle);

                  // Add spacing
                  TextView spacer5 = new TextView(this);
                  spacer5.setHeight(20);
                  dashboardLayout.addView(spacer5);
              }

              private void createRecentTripsSection() {
                  TextView recentLabel = new TextView(this);
                  recentLabel.setText("üìã Recent Trips");
                  recentLabel.setTextSize(16);
                  recentLabel.setTextColor(0xFF333333);
                  recentLabel.setPadding(0, 0, 0, 8);
                  dashboardLayout.addView(recentLabel);

                  ScrollView recentTripsScroll = new ScrollView(this);
                  recentTripsLayout = new LinearLayout(this);
                  recentTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  recentTripsLayout.setBackgroundColor(0xFFFFFFFF);
                  recentTripsLayout.setPadding(10, 10, 10, 10);

                  LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 400);
                  recentTripsScroll.setLayoutParams(scrollParams);
                  recentTripsScroll.addView(recentTripsLayout);
                  dashboardLayout.addView(recentTripsScroll);
              }

              private void createClassifyContent() {
                  classifyContent = new LinearLayout(this);
                  classifyContent.setOrientation(LinearLayout.VERTICAL);
                  classifyContent.setPadding(15, 15, 15, 15);

                  // Header
                  TextView classifyHeader = new TextView(this);
                  classifyHeader.setText("Swipe trips left for Personal, right for Business");
                  classifyHeader.setTextSize(14);
                  classifyHeader.setTextColor(0xFF666666);
                  classifyHeader.setGravity(Gravity.CENTER);
                  classifyHeader.setPadding(0, 0, 0, 15);
                  classifyContent.addView(classifyHeader);

                  // Action buttons
                  createClassifyActionButtons();

                  // Scrollable trips container
                  ScrollView classifyScroll = new ScrollView(this);
                  classifyTripsLayout = new LinearLayout(this);
                  classifyTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  classifyScroll.addView(classifyTripsLayout);

                  LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      0,
                      1.0f
                  );
                  classifyScroll.setLayoutParams(scrollParams);
                  classifyContent.addView(classifyScroll);
              }

              private void createClassifyActionButtons() {
                  LinearLayout buttonLayout = new LinearLayout(this);
                  buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                  buttonLayout.setPadding(0, 0, 0, 15);

                  // Equal weight for all buttons
                  LinearLayout.LayoutParams buttonParams = new LinearLayout.LayoutParams(
                      0, 50, 1.0f);
                  buttonParams.setMargins(2, 0, 2, 0);

                  Button refreshButton = new Button(this);
                  refreshButton.setText("REFRESH");
                  refreshButton.setTextSize(11);
                  refreshButton.setBackgroundColor(0xFF667eea);
                  refreshButton.setTextColor(0xFFFFFFFF);
                  refreshButton.setLayoutParams(buttonParams);
                  refreshButton.setOnClickListener(v -> updateClassifyTrips());
                  buttonLayout.addView(refreshButton);

                  Button mergeButton = new Button(this);
                  mergeButton.setText("MERGE");
                  mergeButton.setTextSize(11);
                  mergeButton.setBackgroundColor(0xFF9CA3AF);
                  mergeButton.setTextColor(0xFFFFFFFF);
                  mergeButton.setLayoutParams(buttonParams);
                  mergeButton.setOnClickListener(v -> toggleMergeMode());
                  buttonLayout.addView(mergeButton);

                  Button exportButton = new Button(this);
                  exportButton.setText("EXPORT");
                  exportButton.setTextSize(11);
                  exportButton.setBackgroundColor(0xFF28a745);
                  exportButton.setTextColor(0xFFFFFFFF);
                  exportButton.setLayoutParams(buttonParams);
                  exportButton.setOnClickListener(v -> exportTrips());
                  buttonLayout.addView(exportButton);

                  classifyContent.addView(buttonLayout);
              }

              private void createCategorizedContent() {
                  categorizedContent = new LinearLayout(this);
                  categorizedContent.setOrientation(LinearLayout.VERTICAL);
                  categorizedContent.setPadding(15, 15, 15, 15);

                  // Action buttons
                  createCategorizedActionButtons();

                  // Search and filter controls
                  createSearchAndFilterControls();

                  // Scrollable trips container
                  categorizedTripsScroll = new ScrollView(this);
                  categorizedTripsContainer = new LinearLayout(this);
                  categorizedTripsContainer.setOrientation(LinearLayout.VERTICAL);
                  categorizedTripsScroll.addView(categorizedTripsContainer);

                  LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      0,
                      1.0f
                  );
                  categorizedTripsScroll.setLayoutParams(scrollParams);
                  categorizedContent.addView(categorizedTripsScroll);
              }

              private void createCategorizedActionButtons() {
                  LinearLayout buttonLayout = new LinearLayout(this);
                  buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                  buttonLayout.setPadding(0, 0, 0, 10);

                  // Equal weight for all buttons
                  LinearLayout.LayoutParams buttonParams = new LinearLayout.LayoutParams(
                      0, 50, 1.0f);
                  buttonParams.setMargins(2, 0, 2, 0);

                  Button refreshButton = new Button(this);
                  refreshButton.setText("REFRESH");
                  refreshButton.setTextSize(11);
                  refreshButton.setBackgroundColor(0xFF667eea);
                  refreshButton.setTextColor(0xFFFFFFFF);
                  refreshButton.setLayoutParams(buttonParams);
                  refreshButton.setOnClickListener(v -> updateCategorizedTrips());
                  buttonLayout.addView(refreshButton);

                  Button mergeButton = new Button(this);
                  mergeButton.setText("MERGE");
                  mergeButton.setTextSize(11);
                  mergeButton.setBackgroundColor(0xFF9CA3AF);
                  mergeButton.setTextColor(0xFFFFFFFF);
                  mergeButton.setLayoutParams(buttonParams);
                  mergeButton.setOnClickListener(v -> executeCategorizedMerge());
                  buttonLayout.addView(mergeButton);

                  Button exportButton = new Button(this);
                  exportButton.setText("EXPORT");
                  exportButton.setTextSize(11);
                  exportButton.setBackgroundColor(0xFF28a745);
                  exportButton.setTextColor(0xFFFFFFFF);
                  exportButton.setLayoutParams(buttonParams);
                  exportButton.setOnClickListener(v -> exportTrips());
                  buttonLayout.addView(exportButton);

                  categorizedContent.addView(buttonLayout);
              }

              private void createSearchAndFilterControls() {
                  LinearLayout searchSortLayout = new LinearLayout(this);
                  searchSortLayout.setOrientation(LinearLayout.VERTICAL);
                  searchSortLayout.setPadding(0, 5, 0, 10);

                  // First row - Search box
                  LinearLayout searchRowLayout = new LinearLayout(this);
                  searchRowLayout.setOrientation(LinearLayout.HORIZONTAL);
                  searchRowLayout.setPadding(0, 0, 0, 5);

                  TextView searchLabel = new TextView(this);
                  searchLabel.setText("Search:");
                  searchLabel.setTextSize(10);
                  searchLabel.setTextColor(0xFF333333);
                  searchLabel.setPadding(0, 0, 5, 0);
                  searchRowLayout.addView(searchLabel);

                  searchBox = new EditText(this);
                  searchBox.setHint("Filter trips...");
                  searchBox.setTextSize(10);
                  searchBox.setPadding(8, 2, 8, 2);
                  searchBox.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams searchParams = new LinearLayout.LayoutParams(
                      0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  searchBox.setLayoutParams(searchParams);
                  searchBox.addTextChangedListener(new TextWatcher() {
                      @Override
                      public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

                      @Override
                      public void onTextChanged(CharSequence s, int start, int before, int count) {
                          currentSearchQuery = s.toString();
                          updateCategorizedTrips();
                      }

                      @Override
                      public void afterTextChanged(Editable s) {}
                  });
                  searchRowLayout.addView(searchBox);

                  searchSortLayout.addView(searchRowLayout);

                  // Second row - Sort and Category filter
                  LinearLayout controlsRowLayout = new LinearLayout(this);
                  controlsRowLayout.setOrientation(LinearLayout.HORIZONTAL);

                  TextView sortLabel = new TextView(this);
                  sortLabel.setText("Sort:");
                  sortLabel.setTextSize(10);
                  sortLabel.setTextColor(0xFF333333);
                  sortLabel.setPadding(0, 0, 5, 0);
                  controlsRowLayout.addView(sortLabel);
                  
                  sortButton = new Button(this);
                  sortButton.setText("Newest");
                  sortButton.setTextSize(10);
                  sortButton.setBackgroundColor(0xFF9CA3AF);
                  sortButton.setTextColor(0xFFFFFFFF);
                  sortButton.setPadding(8, 2, 8, 2);
                  sortButton.setOnClickListener(v -> {
                      String[] sortOptions = {"Newest", "Oldest", "Distance", "Duration"};
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Sort Trips")
                          .setItems(sortOptions, (dialog, which) -> {
                              sortButton.setText(sortOptions[which]);
                              currentSortOrder = sortOptions[which];
                              updateCategorizedTrips();
                          })
                          .show();
                  });
                  controlsRowLayout.addView(sortButton);
                  
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText(" Category:");
                  categoryLabel.setTextSize(10);
                  categoryLabel.setTextColor(0xFF333333);
                  categoryLabel.setPadding(0, 0, 5, 0);
                  controlsRowLayout.addView(categoryLabel);
                  
                  categoryFilterButton = new Button(this);
                  categoryFilterButton.setText("All");
                  categoryFilterButton.setTextSize(10);
                  categoryFilterButton.setBackgroundColor(0xFF9CA3AF);
                  categoryFilterButton.setTextColor(0xFFFFFFFF);
                  categoryFilterButton.setPadding(8, 2, 8, 2);
                  categoryFilterButton.setOnClickListener(v -> {
                      String[] categories = {"All", "Business", "Personal", "Medical", "Charity"};
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Filter by Category")
                          .setItems(categories, (dialog, which) -> {
                              categoryFilterButton.setText(categories[which]);
                              currentCategoryFilter = categories[which];
                              updateCategorizedTrips();
                          })
                          .show();
                  });
                  controlsRowLayout.addView(categoryFilterButton);
                  
                  searchSortLayout.addView(controlsRowLayout);
                  categorizedContent.addView(searchSortLayout);
              }

              private void toggleApiSync() {
                  try {
                      boolean currentState = tripStorage.isApiSyncEnabled();
                      tripStorage.setApiSyncEnabled(!currentState);
                      updateApiToggleUI();
                      updateStats();

                      String message = tripStorage.isApiSyncEnabled() ? 
                          "API sync ON - downloading ALL your trips..." : 
                          "API sync OFF - local storage only";
                      Toast.makeText(this, message, Toast.LENGTH_SHORT).show();

                      // Trigger download when API sync is turned ON
                      if (tripStorage.isApiSyncEnabled()) {
                          triggerAllUserTripsDownload();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling API sync: " + e.getMessage(), e);
                  }
              }

              private void updateApiToggleUI() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          apiToggle.setText("üåê API ON");
                          apiToggle.setBackgroundColor(0xFF28a745);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      } else {
                          apiToggle.setText("üåê API OFF");
                          apiToggle.setBackgroundColor(0xFF9CA3AF);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating API toggle UI: " + e.getMessage(), e);
                  }
              }

              private void switchToTab(String tabName) {
                  try {
                      currentTab = tabName;
                      mainContentLayout.removeAllViews();

                      if ("home".equals(tabName)) {
                          // Use persistent ScrollView for dashboard
                          mainContentLayout.addView(dashboardScroll);
                          homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          categorizedTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          updateRecentTrips();
                      } else if ("trips".equals(tabName)) {
                          mainContentLayout.addView(classifyContent);
                          homeTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          tripsTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          categorizedTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          updateClassifyTrips();
                      } else if ("categorized".equals(tabName)) {
                          mainContentLayout.addView(categorizedContent);
                          homeTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          categorizedTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          updateCategorizedTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error switching tabs: " + e.getMessage(), e);
                  }
              }

              private void updateRecentTrips() {
                  try {
                      recentTripsLayout.removeAllViews();
                      List<Trip> trips = tripStorage.getAllTrips();

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips yet. API sync will download ALL your historic trips!");
                          noTripsText.setTextSize(12);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(10, 10, 10, 10);
                          recentTripsLayout.addView(noTripsText);
                      } else {
                          // Sort trips by date/time descending to show newest first
                          trips.sort((t1, t2) -> {
                              if (t1.getStartTime() != 0 && t2.getStartTime() != 0) {
                                  return Long.compare(t2.getStartTime(), t1.getStartTime());
                              }
                              return Long.compare(t2.getId(), t1.getId());
                          });
                          
                          int maxTrips = Math.min(3, trips.size());
                          for (int i = 0; i < maxTrips; i++) {
                              Trip trip = trips.get(i);
                              addTripCard(recentTripsLayout, trip, true);
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
                  }
              }

              private void updateClassifyTrips() {
                  try {
                      classifyTripsLayout.removeAllViews();
                      
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      List<Trip> uncategorizedTrips = new ArrayList<>();
                      
                      // Filter to only uncategorized trips
                      for (Trip trip : allTrips) {
                          if (trip.getCategory() == null || 
                              trip.getCategory().isEmpty() || 
                              "Uncategorized".equals(trip.getCategory())) {
                              uncategorizedTrips.add(trip);
                          }
                      }
                      
                      if (uncategorizedTrips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips need classification. All trips are categorized!");
                          noTripsText.setTextSize(14);
                          noTripsText.setTextColor(0xFF666666);
                          noTripsText.setGravity(Gravity.CENTER);
                          noTripsText.setPadding(20, 40, 20, 40);
                          classifyTripsLayout.addView(noTripsText);
                          return;
                      }
                      
                      // Create trip cards with swipe gestures
                      for (Trip trip : uncategorizedTrips) {
                          addTripCard(classifyTripsLayout, trip, false);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating classify trips: " + e.getMessage(), e);
                  }
              }

              private void updateCategorizedTrips() {
                  try {
                      categorizedTripsContainer.removeAllViews();
                      
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      List<Trip> filteredTrips = new ArrayList<>();
                      
                      // Filter by category and search query
                      for (Trip trip : allTrips) {
                          // Skip uncategorized trips
                          if (trip.getCategory() == null || 
                              trip.getCategory().isEmpty() || 
                              "Uncategorized".equals(trip.getCategory())) {
                              continue;
                          }
                          
                          // Category filter
                          if (!"All".equals(currentCategoryFilter) && 
                              !currentCategoryFilter.equals(trip.getCategory())) {
                              continue;
                          }
                          
                          // Search filter
                          if (!currentSearchQuery.isEmpty()) {
                              String searchLower = currentSearchQuery.toLowerCase();
                              boolean matches = false;
                              
                              if (trip.getStartLocation() != null && 
                                  trip.getStartLocation().toLowerCase().contains(searchLower)) {
                                  matches = true;
                              }
                              if (trip.getEndLocation() != null && 
                                  trip.getEndLocation().toLowerCase().contains(searchLower)) {
                                  matches = true;
                              }
                              if (trip.getCategory() != null && 
                                  trip.getCategory().toLowerCase().contains(searchLower)) {
                                  matches = true;
                              }
                              if (trip.getNotes() != null && 
                                  trip.getNotes().toLowerCase().contains(searchLower)) {
                                  matches = true;
                              }
                              
                              if (!matches) {
                                  continue;
                              }
                          }
                          
                          filteredTrips.add(trip);
                      }
                      
                      // Sort trips based on current sort order
                      switch (currentSortOrder) {
                          case "Newest":
                              filteredTrips.sort((t1, t2) -> Long.compare(t2.getStartTime(), t1.getStartTime()));
                              break;
                          case "Oldest":
                              filteredTrips.sort((t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));
                              break;
                          case "Distance":
                              filteredTrips.sort((t1, t2) -> Double.compare(t2.getDistance(), t1.getDistance()));
                              break;
                          case "Duration":
                              filteredTrips.sort((t1, t2) -> Long.compare(t2.getDuration(), t1.getDuration()));
                              break;
                      }
                      
                      if (filteredTrips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          if (!currentSearchQuery.isEmpty()) {
                              noTripsText.setText("No trips match your search: \"" + currentSearchQuery + "\"");
                          } else if (!"All".equals(currentCategoryFilter)) {
                              noTripsText.setText("No " + currentCategoryFilter + " trips found. Use 'Sort Trips' tab to classify trips.");
                          } else {
                              noTripsText.setText("No categorized trips yet. Use 'Sort Trips' tab to classify your trips!");
                          }
                          noTripsText.setTextSize(14);
                          noTripsText.setTextColor(0xFF666666);
                          noTripsText.setGravity(Gravity.CENTER);
                          noTripsText.setPadding(20, 40, 20, 40);
                          categorizedTripsContainer.addView(noTripsText);
                          return;
                      }
                      
                      // Create trip cards
                      for (Trip trip : filteredTrips) {
                          addTripCard(categorizedTripsContainer, trip, false);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating categorized trips: " + e.getMessage(), e);
                  }
              }

              private void addTripCard(LinearLayout container, Trip trip, boolean isCompact) {
                  try {
                      LinearLayout tripCard = new LinearLayout(this);
                      tripCard.setOrientation(LinearLayout.VERTICAL);
                      tripCard.setBackgroundColor(0xFFFFFFFF);
                      tripCard.setPadding(15, 10, 15, 10);
                      
                      LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT,
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      cardParams.setMargins(0, 0, 0, 8);
                      tripCard.setLayoutParams(cardParams);

                      // Add swipe gesture detection for classify tab
                      if ("trips".equals(currentTab)) {
                          setupSwipeGesture(tripCard, trip);
                      }

                      // Trip distance and duration
                      TextView tripInfo = new TextView(this);
                      String infoText = String.format("%.1f mi ‚Ä¢ %s", 
                          trip.getDistance(), trip.getDurationFormatted());
                      
                      if (!isCompact && trip.getCategory() != null && !trip.getCategory().isEmpty()) {
                          infoText += " ‚Ä¢ " + trip.getCategory();
                      }
                      
                      tripInfo.setText(infoText);
                      tripInfo.setTextSize(isCompact ? 12 : 14);
                      tripInfo.setTextColor(0xFF333333);
                      tripCard.addView(tripInfo);

                      // Trip locations (if not compact)
                      if (!isCompact) {
                          TextView locations = new TextView(this);
                          String locationText = "";
                          if (trip.getStartLocation() != null && !trip.getStartLocation().isEmpty()) {
                              locationText = trip.getStartLocation();
                          }
                          if (trip.getEndLocation() != null && !trip.getEndLocation().isEmpty()) {
                              if (!locationText.isEmpty()) locationText += " ‚Üí ";
                              locationText += trip.getEndLocation();
                          }
                          if (locationText.isEmpty()) {
                              locationText = "No location data";
                          }
                          
                          locations.setText(locationText);
                          locations.setTextSize(12);
                          locations.setTextColor(0xFF666666);
                          tripCard.addView(locations);
                      }

                      // Date/time
                      if (trip.getStartTime() > 0) {
                          TextView dateTime = new TextView(this);
                          SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy HH:mm", Locale.getDefault());
                          dateTime.setText(dateFormat.format(new Date(trip.getStartTime())));
                          dateTime.setTextSize(isCompact ? 10 : 12);
                          dateTime.setTextColor(0xFF999999);
                          tripCard.addView(dateTime);
                      }

                      // Add checkbox for merge mode (categorized tab only)
                      if ("categorized".equals(currentTab) && mergeMode) {
                          CheckBox mergeCheckbox = new CheckBox(this);
                          mergeCheckbox.setText("Select for merge");
                          mergeCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                              String tripId = String.valueOf(trip.getId());
                              if (isChecked) {
                                  if (!selectedTripIds.contains(tripId)) {
                                      selectedTripIds.add(tripId);
                                  }
                              } else {
                                  selectedTripIds.remove(tripId);
                              }
                          });
                          tripCard.addView(mergeCheckbox);
                      }

                      container.addView(tripCard);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding trip card: " + e.getMessage(), e);
                  }
              }

              private void setupSwipeGesture(LinearLayout tripCard, Trip trip) {
                  GestureDetector gestureDetector = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {
                      @Override
                      public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                          float diffX = e2.getX() - e1.getX();
                          float diffY = e2.getY() - e1.getY();
                          
                          if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 100 && Math.abs(velocityX) > 100) {
                              if (diffX > 0) {
                                  // Swipe right - Business
                                  classifyTrip(trip, "Business");
                                  return true;
                              } else {
                                  // Swipe left - Personal
                                  classifyTrip(trip, "Personal");
                                  return true;
                              }
                          }
                          return false;
                      }
                  });

                  tripCard.setOnTouchListener((v, event) -> {
                      gestureDetector.onTouchEvent(event);
                      return true;
                  });
              }

              private void classifyTrip(Trip trip, String category) {
                  try {
                      trip.setCategory(category);
                      tripStorage.saveTrip(trip);
                      
                      // Visual feedback
                      int color = "Business".equals(category) ? 0xFF28a745 : 0xFF007BFF;
                      Toast.makeText(this, "Classified as " + category, Toast.LENGTH_SHORT).show();
                      
                      // Refresh the classify view
                      updateClassifyTrips();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error classifying trip: " + e.getMessage(), e);
                  }
              }

              private void toggleMergeMode() {
                  mergeMode = !mergeMode;
                  selectedTripIds.clear();
                  
                  if (mergeMode) {
                      Toast.makeText(this, "Select trips to merge, then tap MERGE again", Toast.LENGTH_SHORT).show();
                  } else {
                      Toast.makeText(this, "Merge mode cancelled", Toast.LENGTH_SHORT).show();
                  }
                  
                  updateClassifyTrips();
              }

              private void executeCategorizedMerge() {
                  if (!mergeMode) {
                      mergeMode = true;
                      selectedTripIds.clear();
                      Toast.makeText(this, "Select trips to merge, then tap MERGE again", Toast.LENGTH_SHORT).show();
                      updateCategorizedTrips();
                      return;
                  }
                  
                  if (selectedTripIds.size() < 2) {
                      Toast.makeText(this, "Select at least 2 trips to merge", Toast.LENGTH_SHORT).show();
                      return;
                  }
                  
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Merge Trips")
                      .setMessage("Merge " + selectedTripIds.size() + " trips into one?")
                      .setPositiveButton("Merge", (dialog, which) -> {
                          tripStorage.mergeTrips(selectedTripIds);
                          mergeMode = false;
                          selectedTripIds.clear();
                          updateCategorizedTrips();
                          Toast.makeText(this, "Trips merged successfully", Toast.LENGTH_SHORT).show();
                      })
                      .setNegativeButton("Cancel", (dialog, which) -> {
                          mergeMode = false;
                          selectedTripIds.clear();
                          updateCategorizedTrips();
                      })
                      .show();
              }

              private void exportTrips() {
                  Toast.makeText(this, "Export functionality coming soon", Toast.LENGTH_SHORT).show();
              }

              private void updateStats() {
                  try {
                      double totalMiles = tripStorage.getTotalMiles();
                      int totalTrips = tripStorage.getTotalTrips();
                      double businessMiles = tripStorage.getTotalMilesByCategory("Business");
                      double personalMiles = tripStorage.getTotalMilesByCategory("Personal");

                      String statsText = String.format(
                          "‚Ä¢ Total Trips: %d\n‚Ä¢ Total Miles: %.1f\n‚Ä¢ Business Miles: %.1f\n‚Ä¢ Personal Miles: %.1f\n‚Ä¢ Auto Detection: %s",
                          totalTrips, totalMiles, businessMiles, personalMiles,
                          isAutoDetectionEnabled ? "ON" : "OFF"
                      );

                      statsDisplay.setText(statsText);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                  }
              }

              private void toggleAutoDetection() {
                  isAutoDetectionEnabled = !isAutoDetectionEnabled;
                  
                  if (isAutoDetectionEnabled) {
                      autoToggle.setText("Auto Detection: ON");
                      autoToggle.setBackgroundColor(0xFF28a745);
                      Toast.makeText(this, "Auto detection enabled", Toast.LENGTH_SHORT).show();
                  } else {
                      autoToggle.setText("Auto Detection: OFF");
                      autoToggle.setBackgroundColor(0xFF9CA3AF);
                      Toast.makeText(this, "Auto detection disabled", Toast.LENGTH_SHORT).show();
                  }
                  
                  updateStats();
              }

              private void startManualTrip() {
                  if (!isLocationPermissionGranted) {
                      Toast.makeText(this, "Location permission required", Toast.LENGTH_SHORT).show();
                      return;
                  }
                  
                  isManualTripActive = true;
                  tripStartTime = System.currentTimeMillis();
                  tripStartLocation = lastKnownLocation;
                  currentTripDistance = 0.0;
                  tripLocations.clear();
                  
                  startTripButton.setEnabled(false);
                  stopTripButton.setEnabled(true);
                  
                  Toast.makeText(this, "Manual trip started", Toast.LENGTH_SHORT).show();
              }

              private void stopManualTrip() {
                  if (!isManualTripActive) return;
                  
                  isManualTripActive = false;
                  long tripEndTime = System.currentTimeMillis();
                  long duration = tripEndTime - tripStartTime;
                  
                  Trip trip = new Trip();
                  trip.setStartLocation("Manual Start");
                  trip.setEndLocation("Manual End");
                  trip.setDistance(currentTripDistance);
                  trip.setDuration(duration);
                  trip.setStartTime(tripStartTime);
                  trip.setEndTime(tripEndTime);
                  trip.setAutoDetected(false);
                  trip.setCategory("Uncategorized");
                  
                  tripStorage.saveTrip(trip);
                  
                  startTripButton.setEnabled(true);
                  stopTripButton.setEnabled(false);
                  
                  updateStats();
                  updateRecentTrips();
                  
                  Toast.makeText(this, String.format("Trip saved: %.1f miles", currentTripDistance), Toast.LENGTH_SHORT).show();
              }

              private void triggerAllUserTripsDownload() {
                  // Placeholder for API sync functionality
                  Toast.makeText(this, "API sync functionality coming soon", Toast.LENGTH_SHORT).show();
              }

              // Location services setup and management
              private void setupLocationServices() {
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
              }

              private void checkLocationPermissions() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                      != PackageManager.PERMISSION_GRANTED) {
                      ActivityCompat.requestPermissions(this, 
                          new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 
                          LOCATION_PERMISSION_REQUEST);
                  } else {
                      isLocationPermissionGranted = true;
                      startLocationUpdates();
                  }
              }

              private void startLocationUpdates() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                          == PackageManager.PERMISSION_GRANTED) {
                          locationManager.requestLocationUpdates(
                              LocationManager.GPS_PROVIDER, 
                              5000, // 5 seconds
                              10,   // 10 meters
                              this
                          );
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting location updates: " + e.getMessage(), e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  lastKnownLocation = location;
                  
                  if (location.hasSpeed()) {
                      currentSpeed = location.getSpeed() * 2.237; // Convert m/s to mph
                      currentSpeedDisplay.setText(String.format("Speed: %.1f mph", currentSpeed));
                  }
                  
                  if (isManualTripActive && tripLocations.size() > 0) {
                      Location lastLocation = tripLocations.get(tripLocations.size() - 1);
                      float distance = lastLocation.distanceTo(location) / 1609.34f; // Convert meters to miles
                      currentTripDistance += distance;
                      currentDistanceDisplay.setText(String.format("Distance: %.1f miles", currentTripDistance));
                  }
                  
                  if (isManualTripActive) {
                      tripLocations.add(location);
                  }
              }

              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  if (requestCode == LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          isLocationPermissionGranted = true;
                          startLocationUpdates();
                      } else {
                          Toast.makeText(this, "Location permission required for trip tracking", Toast.LENGTH_LONG).show();
                      }
                  }
              }

              private void showErrorAndExit(String message) {
                  new AlertDialog.Builder(this)
                      .setTitle("Error")
                      .setMessage(message)
                      .setPositiveButton("OK", (dialog, which) -> finish())
                      .setCancelable(false)
                      .show();
              }

              @Override
              protected void onResume() {
                  super.onResume();
                  updateStats();
                  updateApiToggleUI();
                  if ("home".equals(currentTab)) {
                      updateRecentTrips();
                  }
              }

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  if (locationManager != null) {
                      locationManager.removeUpdates(this);
                  }
              }
          }
          EOF

      - name: Create UserAuthManager class
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.util.Log;

          import com.miletrackerpro.app.utils.DeviceIdentification;

          import org.json.JSONException;
          import org.json.JSONObject;

          import java.io.IOException;
          import java.util.concurrent.TimeUnit;

          import okhttp3.Call;
          import okhttp3.Callback;
          import okhttp3.MediaType;
          import okhttp3.OkHttpClient;
          import okhttp3.Request;
          import okhttp3.RequestBody;
          import okhttp3.Response;
          import okhttp3.logging.HttpLoggingInterceptor;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "UserAuthPrefs";
              private static final String AUTH_TOKEN_KEY = "auth_token";
              private static final String USER_EMAIL_KEY = "user_email";
              private static final String USER_TIER_KEY = "user_tier";
              private static final String IS_AUTHENTICATED_KEY = "is_authenticated";
              
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";

              private final Context context;
              private final SharedPreferences prefs;
              private final OkHttpClient httpClient;

              public interface AuthCallback {
                  void onSuccess(String email, String tier);
                  void onError(String error);
              }

              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Create HTTP client with logging
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
                  logging.setLevel(HttpLoggingInterceptor.Level.BODY);
                  
                  this.httpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(30, TimeUnit.SECONDS)
                      .readTimeout(30, TimeUnit.SECONDS)
                      .writeTimeout(30, TimeUnit.SECONDS)
                      .build();
              }

              public void login(String email, String password, AuthCallback callback) {
                  if (!isNetworkAvailable()) {
                      callback.onError("No internet connection available");
                      return;
                  }

                  try {
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      loginData.put("device_id", DeviceIdentification.getStableDeviceId(context));

                      RequestBody body = RequestBody.create(
                          loginData.toString(),
                          MediaType.parse("application/json")
                      );

                      Request request = new Request.Builder()
                          .url(API_BASE_URL + "/api/auth/login")
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .build();

                      httpClient.newCall(request).enqueue(new Callback() {
                          @Override
                          public void onFailure(Call call, IOException e) {
                              Log.e(TAG, "Login request failed", e);
                              callback.onError("Connection failed: " + e.getMessage());
                          }

                          @Override
                          public void onResponse(Call call, Response response) throws IOException {
                              String responseBody = response.body().string();
                              
                              try {
                                  JSONObject jsonResponse = new JSONObject(responseBody);
                                  
                                  if (response.isSuccessful() && jsonResponse.getBoolean("success")) {
                                      String token = jsonResponse.getString("token");
                                      JSONObject user = jsonResponse.getJSONObject("user");
                                      String userEmail = user.getString("email");
                                      String userTier = user.optString("tier", "free");
                                      
                                      // Save authentication data
                                      saveAuthData(token, userEmail, userTier);
                                      
                                      Log.d(TAG, "Login successful for user: " + userEmail);
                                      callback.onSuccess(userEmail, userTier);
                                      
                                  } else {
                                      String error = jsonResponse.optString("message", "Login failed");
                                      Log.e(TAG, "Login failed: " + error);
                                      callback.onError(error);
                                  }
                                  
                              } catch (JSONException e) {
                                  Log.e(TAG, "Error parsing login response", e);
                                  callback.onError("Invalid response from server");
                              }
                          }
                      });

                  } catch (JSONException e) {
                      Log.e(TAG, "Error creating login request", e);
                      callback.onError("Error creating login request: " + e.getMessage());
                  }
              }

              public void register(String email, String password, AuthCallback callback) {
                  if (!isNetworkAvailable()) {
                      callback.onError("No internet connection available");
                      return;
                  }

                  try {
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("device_id", DeviceIdentification.getStableDeviceId(context));

                      RequestBody body = RequestBody.create(
                          registerData.toString(),
                          MediaType.parse("application/json")
                      );

                      Request request = new Request.Builder()
                          .url(API_BASE_URL + "/api/register")
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .build();

                      httpClient.newCall(request).enqueue(new Callback() {
                          @Override
                          public void onFailure(Call call, IOException e) {
                              Log.e(TAG, "Registration request failed", e);
                              callback.onError("Connection failed: " + e.getMessage());
                          }

                          @Override
                          public void onResponse(Call call, Response response) throws IOException {
                              String responseBody = response.body().string();
                              
                              try {
                                  JSONObject jsonResponse = new JSONObject(responseBody);
                                  
                                  if (response.isSuccessful() && jsonResponse.getBoolean("success")) {
                                      String token = jsonResponse.getString("token");
                                      JSONObject user = jsonResponse.getJSONObject("user");
                                      String userEmail = user.getString("email");
                                      String userTier = user.optString("tier", "free");
                                      
                                      // Save authentication data
                                      saveAuthData(token, userEmail, userTier);
                                      
                                      Log.d(TAG, "Registration successful for user: " + userEmail);
                                      callback.onSuccess(userEmail, userTier);
                                      
                                  } else {
                                      String error = jsonResponse.optString("message", "Registration failed");
                                      Log.e(TAG, "Registration failed: " + error);
                                      callback.onError(error);
                                  }
                                  
                              } catch (JSONException e) {
                                  Log.e(TAG, "Error parsing registration response", e);
                                  callback.onError("Invalid response from server");
                              }
                          }
                      });

                  } catch (JSONException e) {
                      Log.e(TAG, "Error creating registration request", e);
                      callback.onError("Error creating registration request: " + e.getMessage());
                  }
              }

              public void recoverDataWithCredentials(String email, String password, AuthCallback callback) {
                  // For data recovery, we can reuse the login method
                  login(email, password, callback);
              }

              private void saveAuthData(String token, String email, String tier) {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.putString(AUTH_TOKEN_KEY, token);
                  editor.putString(USER_EMAIL_KEY, email);
                  editor.putString(USER_TIER_KEY, tier);
                  editor.putBoolean(IS_AUTHENTICATED_KEY, true);
                  editor.apply();
                  
                  // Also save user ID in DeviceIdentification
                  DeviceIdentification.setUserId(context, email);
                  
                  Log.d(TAG, "Authentication data saved for user: " + email);
              }

              public boolean isAuthenticated() {
                  return prefs.getBoolean(IS_AUTHENTICATED_KEY, false) && 
                         prefs.getString(AUTH_TOKEN_KEY, null) != null;
              }

              public String getAuthToken() {
                  return prefs.getString(AUTH_TOKEN_KEY, null);
              }

              public String getUserEmail() {
                  return prefs.getString(USER_EMAIL_KEY, null);
              }

              public String getUserTier() {
                  return prefs.getString(USER_TIER_KEY, "free");
              }

              public void logout() {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.clear();
                  editor.apply();
                  
                  DeviceIdentification.clearUserId(context);
                  
                  Log.d(TAG, "User logged out");
              }

              private boolean isNetworkAvailable() {
                  ConnectivityManager connectivityManager = 
                      (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                  NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
                  return activeNetworkInfo != null && activeNetworkInfo.isConnected();
              }
          }
          EOF

      - name: Create AuthActivity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.TextView;
          import android.widget.Toast;

          import androidx.appcompat.app.AppCompatActivity;

          import com.miletrackerpro.app.MainActivity;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private EditText emailInput;
              private EditText passwordInput;
              private Button loginButton;
              private Button registerButton;
              private Button dataRecoveryButton;
              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  authManager = new UserAuthManager(this);
                  
                  // Check if already authenticated
                  if (authManager.isAuthenticated()) {
                      startMainActivity();
                      return;
                  }
                  
                  setupUI();
              }

              private void setupUI() {
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 60, 40, 40);
                  mainLayout.setBackgroundColor(0xFFf5f5f5);
                  mainLayout.setGravity(Gravity.CENTER);

                  // App title
                  TextView titleText = new TextView(this);
                  titleText.setText("MileTracker Pro");
                  titleText.setTextSize(28);
                  titleText.setTextColor(0xFF667eea);
                  titleText.setGravity(Gravity.CENTER);
                  titleText.setPadding(0, 0, 0, 40);
                  mainLayout.addView(titleText);

                  // Email input
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF333333);
                  emailLabel.setPadding(0, 0, 0, 8);
                  mainLayout.addView(emailLabel);

                  emailInput = new EditText(this);
                  emailInput.setHint("Enter your email");
                  emailInput.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setTextSize(16);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 20);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  // Password input
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF333333);
                  passwordLabel.setPadding(0, 0, 0, 8);
                  mainLayout.addView(passwordLabel);

                  passwordInput = new EditText(this);
                  passwordInput.setHint("Enter your password");
                  passwordInput.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setTextSize(16);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 30);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  // Login button
                  loginButton = new Button(this);
                  loginButton.setText("LOG IN");
                  loginButton.setTextSize(16);
                  loginButton.setBackgroundColor(0xFF667eea);
                  loginButton.setTextColor(0xFFFFFFFF);
                  loginButton.setPadding(20, 15, 20, 15);
                  loginButton.setOnClickListener(v -> handleLogin());
                  LinearLayout.LayoutParams loginParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  loginParams.setMargins(0, 0, 0, 15);
                  loginButton.setLayoutParams(loginParams);
                  mainLayout.addView(loginButton);

                  // Register button
                  registerButton = new Button(this);
                  registerButton.setText("REGISTER");
                  registerButton.setTextSize(16);
                  registerButton.setBackgroundColor(0xFF28a745);
                  registerButton.setTextColor(0xFFFFFFFF);
                  registerButton.setPadding(20, 15, 20, 15);
                  registerButton.setOnClickListener(v -> handleRegister());
                  LinearLayout.LayoutParams registerParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  registerParams.setMargins(0, 0, 0, 15);
                  registerButton.setLayoutParams(registerParams);
                  mainLayout.addView(registerButton);

                  // Data recovery button
                  dataRecoveryButton = new Button(this);
                  dataRecoveryButton.setText("RECOVER MY DATA");
                  dataRecoveryButton.setTextSize(14);
                  dataRecoveryButton.setBackgroundColor(0xFF9CA3AF);
                  dataRecoveryButton.setTextColor(0xFFFFFFFF);
                  dataRecoveryButton.setPadding(20, 15, 20, 15);
                  dataRecoveryButton.setOnClickListener(v -> handleDataRecovery());
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  dataRecoveryButton.setLayoutParams(recoveryParams);
                  mainLayout.addView(dataRecoveryButton);

                  setContentView(mainLayout);
              }

              private void handleLogin() {
                  String email = emailInput.getText().toString().trim();
                  String password = passwordInput.getText().toString().trim();

                  if (email.isEmpty() || password.isEmpty()) {
                      Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                      return;
                  }

                  setButtonsEnabled(false);
                  Toast.makeText(this, "Logging in...", Toast.LENGTH_SHORT).show();

                  authManager.login(email, password, new UserAuthManager.AuthCallback() {
                      @Override
                      public void onSuccess(String userEmail, String tier) {
                          runOnUiThread(() -> {
                              Toast.makeText(AuthActivity.this, "Login successful!", Toast.LENGTH_SHORT).show();
                              startMainActivity();
                          });
                      }

                      @Override
                      public void onError(String error) {
                          runOnUiThread(() -> {
                              setButtonsEnabled(true);
                              Toast.makeText(AuthActivity.this, "Login failed: " + error, Toast.LENGTH_LONG).show();
                              Log.e(TAG, "Login error: " + error);
                          });
                      }
                  });
              }

              private void handleRegister() {
                  String email = emailInput.getText().toString().trim();
                  String password = passwordInput.getText().toString().trim();

                  if (email.isEmpty() || password.isEmpty()) {
                      Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                      return;
                  }

                  if (password.length() < 6) {
                      Toast.makeText(this, "Password must be at least 6 characters", Toast.LENGTH_SHORT).show();
                      return;
                  }

                  setButtonsEnabled(false);
                  Toast.makeText(this, "Creating account...", Toast.LENGTH_SHORT).show();

                  authManager.register(email, password, new UserAuthManager.AuthCallback() {
                      @Override
                      public void onSuccess(String userEmail, String tier) {
                          runOnUiThread(() -> {
                              Toast.makeText(AuthActivity.this, "Account created successfully!", Toast.LENGTH_SHORT).show();
                              startMainActivity();
                          });
                      }

                      @Override
                      public void onError(String error) {
                          runOnUiThread(() -> {
                              setButtonsEnabled(true);
                              Toast.makeText(AuthActivity.this, "Registration failed: " + error, Toast.LENGTH_LONG).show();
                              Log.e(TAG, "Registration error: " + error);
                          });
                      }
                  });
              }

              private void handleDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void setButtonsEnabled(boolean enabled) {
                  loginButton.setEnabled(enabled);
                  registerButton.setEnabled(enabled);
                  dataRecoveryButton.setEnabled(enabled);
              }

              private void startMainActivity() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create DataRecoveryActivity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.TextView;
          import android.widget.Toast;

          import androidx.appcompat.app.AppCompatActivity;

          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private EditText emailInput;
              private EditText passwordInput;
              private Button recoverButton;
              private Button backButton;
              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  authManager = new UserAuthManager(this);
                  setupUI();
              }

              private void setupUI() {
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 60, 40, 40);
                  mainLayout.setBackgroundColor(0xFFf5f5f5);
                  mainLayout.setGravity(Gravity.CENTER);

                  // Title
                  TextView titleText = new TextView(this);
                  titleText.setText("Recover My Data");
                  titleText.setTextSize(24);
                  titleText.setTextColor(0xFF667eea);
                  titleText.setGravity(Gravity.CENTER);
                  titleText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(titleText);

                  // Instructions
                  TextView instructionsText = new TextView(this);
                  instructionsText.setText("Enter your account credentials to download your cloud-stored trips");
                  instructionsText.setTextSize(14);
                  instructionsText.setTextColor(0xFF666666);
                  instructionsText.setGravity(Gravity.CENTER);
                  instructionsText.setPadding(0, 0, 0, 30);
                  mainLayout.addView(instructionsText);

                  // Email input
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF333333);
                  emailLabel.setPadding(0, 0, 0, 8);
                  mainLayout.addView(emailLabel);

                  emailInput = new EditText(this);
                  emailInput.setHint("Enter your email");
                  emailInput.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setTextSize(16);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 20);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  // Password input
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF333333);
                  passwordLabel.setPadding(0, 0, 0, 8);
                  mainLayout.addView(passwordLabel);

                  passwordInput = new EditText(this);
                  passwordInput.setHint("Enter your password");
                  passwordInput.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setTextSize(16);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 30);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  // Recover button
                  recoverButton = new Button(this);
                  recoverButton.setText("RECOVER MY TRIPS");
                  recoverButton.setTextSize(16);
                  recoverButton.setBackgroundColor(0xFF667eea);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setPadding(20, 15, 20, 15);
                  recoverButton.setOnClickListener(v -> handleDataRecovery());
                  LinearLayout.LayoutParams recoverParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoverParams.setMargins(0, 0, 0, 15);
                  recoverButton.setLayoutParams(recoverParams);
                  mainLayout.addView(recoverButton);

                  // Back button
                  backButton = new Button(this);
                  backButton.setText("BACK TO LOGIN");
                  backButton.setTextSize(14);
                  backButton.setBackgroundColor(0xFF9CA3AF);
                  backButton.setTextColor(0xFFFFFFFF);
                  backButton.setPadding(20, 15, 20, 15);
                  backButton.setOnClickListener(v -> finish());
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backButton.setLayoutParams(backParams);
                  mainLayout.addView(backButton);

                  setContentView(mainLayout);
              }

              private void handleDataRecovery() {
                  String email = emailInput.getText().toString().trim();
                  String password = passwordInput.getText().toString().trim();

                  if (email.isEmpty() || password.isEmpty()) {
                      Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                      return;
                  }

                  setButtonsEnabled(false);
                  Toast.makeText(this, "Recovering your data...", Toast.LENGTH_SHORT).show();

                  authManager.recoverDataWithCredentials(email, password, new UserAuthManager.AuthCallback() {
                      @Override
                      public void onSuccess(String userEmail, String tier) {
                          runOnUiThread(() -> {
                              Toast.makeText(DataRecoveryActivity.this, "Data recovery successful!", Toast.LENGTH_SHORT).show();
                              startMainActivity();
                          });
                      }

                      @Override
                      public void onError(String error) {
                          runOnUiThread(() -> {
                              setButtonsEnabled(true);
                              Toast.makeText(DataRecoveryActivity.this, "Recovery failed: " + error, Toast.LENGTH_LONG).show();
                              Log.e(TAG, "Data recovery error: " + error);
                          });
                      }
                  });
              }

              private void setButtonsEnabled(boolean enabled) {
                  recoverButton.setEnabled(enabled);
                  backButton.setEnabled(enabled);
              }

              private void startMainActivity() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Build APK
        run: |
          cd android
          chmod +x gradlew
          ./gradlew clean assembleRelease

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: MileTrackerPro-v4.9.129.apk
          path: android/app/build/outputs/apk/release/app-release.apk

      - name: Display APK info
        run: |
          echo "‚úÖ APK Build Complete!"
          echo "üì± App Name: MileTracker Pro"
          echo "üî¢ Version: 4.9.129 (49129)"
          echo "üì¶ APK Location: android/app/build/outputs/apk/release/app-release.apk"
          echo "üéØ Features: Search/Filter on Filed Trips tab, Professional three-tab interface"
