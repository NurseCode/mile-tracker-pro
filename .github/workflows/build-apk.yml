name: Build MileTracker Pro APK - AUTH INTEGRATED + FIXED API SYNC + USER FEEDBACK
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      
    - name: Setup Java JDK
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
      
    - name: Build APK
      run: |
        cd android
        
        echo "BUILDING v4.9.50 - AUTHENTICATION + FIXED API SYNC + USER FEEDBACK"
        echo "‚úÖ FIXED: Stable device ID with proper user linking"
        echo "‚úÖ FIXED: Edit/Delete operations sync to API immediately"
        echo "‚úÖ FIXED: Refresh button with visual loading feedback"
        echo "‚úÖ FIXED: Downloads ALL user trips regardless of device ID"
        echo "‚úÖ ENHANCED: Toast notifications for all API operations"
        echo "‚úÖ PRESERVED: Complete authentication system and all features"
        
        chmod +x gradlew
        ./gradlew assembleRelease
        
    - name: Sign APK
      run: |
        cd android/app/build/outputs/apk/release
        
        # Create keystore
        keytool -genkey -v -keystore miletracker-release-key.keystore -alias upload -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Mobile Apps, O=CodeNurse, L=Archdale, ST=NC, C=US"
        
        # Sign APK
        jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore miletracker-release-key.keystore -storepass miletracker123 -keypass miletracker123 app-release-unsigned.apk upload
        
        # Zipalign
        $ANDROID_HOME/build-tools/33.0.1/zipalign -v 4 app-release-unsigned.apk MileTracker-Pro-v4.9.50-AUTH-API-SYNC.apk
        
    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: MileTrackerPro-AUTH-API-SYNC-v4.9.50
        path: android/app/build/outputs/apk/release/MileTracker-Pro-v4.9.50-AUTH-API-SYNC.apk

---
# Complete Android Application Files
# android/app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.miletrackerpro.app"
    android:versionCode="49050"
    android:versionName="4.9.50">

    <!-- AUTHENTICATION + API SYNC + USER FEEDBACK VERSION -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <application
        android:allowBackup="true"
        android:icon="@android:drawable/ic_menu_mylocation"
        android:label="MileTracker Pro"
        android:theme="@style/AppTheme"
        android:usesCleartextTraffic="true">
        
        <!-- AUTHENTICATION ACTIVITY -->
        <activity
            android:name=".AuthActivity"
            android:exported="true"
            android:theme="@style/AppTheme">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <!-- MAIN APPLICATION ACTIVITY -->
        <activity
            android:name=".MainActivity"
            android:exported="false"
            android:theme="@style/AppTheme" />
            
        <!-- DATA RECOVERY ACTIVITY -->
        <activity
            android:name=".DataRecoveryActivity"
            android:exported="false"
            android:theme="@style/AppTheme" />

        <!-- BACKGROUND GPS SERVICE -->
        <service
            android:name=".service.BackgroundLocationService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="location" />
            
        <!-- CLOUD BACKUP SERVICE -->
        <service
            android:name=".service.CloudBackupService"
            android:enabled="true"
            android:exported="false" />
    </application>
</manifest>

---
# android/app/src/main/java/com/miletrackerpro/app/MainActivity.java
package com.miletrackerpro.app;

import android.Manifest;
import android.app.AlertDialog;
import android.app.DatePickerDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.graphics.Typeface;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.text.InputType;
import android.util.Log;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.miletrackerpro.app.model.Trip;
import com.miletrackerpro.app.service.BackgroundLocationService;
import com.miletrackerpro.app.service.CloudBackupService;
import com.miletrackerpro.app.storage.TripStorage;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MainActivity extends AppCompatActivity implements LocationListener {
    private static final String TAG = "MileTrackerPro";
    private static final int LOCATION_PERMISSION_REQUEST_CODE = 1;
    
    // ENHANCED API SYNC + USER FEEDBACK VERSION 4.9.50
    private static final String VERSION = "v4.9.50 - AUTH + API SYNC + FEEDBACK";
    
    // API Configuration with fallback
    private static final String PRIMARY_API_URL = "https://18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev/api";
    private static final String FALLBACK_API_URL = "http://10.0.2.2:5000/api"; // Android emulator localhost
    private String currentApiUrl = PRIMARY_API_URL;
    
    // UI Components
    private LinearLayout mainContentLayout;
    private TextView statusText, speedText, distanceText, accuracyText;
    private Button toggleButton, homeTabButton, tripsTabButton;
    private Button refreshButton; // ENHANCED: With loading feedback
    private ScrollView tripsScrollView;
    private LinearLayout tripsLayout;
    private String currentTab = "home";
    
    // Location and Trip Management
    private LocationManager locationManager;
    private TripStorage tripStorage;
    private CloudBackupService cloudBackupService;
    private Trip currentTrip;
    private boolean isTracking = false;
    private boolean autoDetectionEnabled = false;
    private List<Location> tripLocations = new ArrayList<>();
    private ExecutorService executorService = Executors.newCachedThreadPool();

    // GPS State Management
    private Location lastLocation;
    private long lastLocationTime = 0;
    private double totalDistance = 0.0;
    private List<Double> recentSpeeds = new ArrayList<>();
    private static final int SPEED_HISTORY_SIZE = 5;
    private static final double TRIP_START_SPEED_THRESHOLD = 8.0; // mph
    private static final double TRIP_END_SPEED_THRESHOLD = 3.0; // mph
    private static final int CONSECUTIVE_READINGS_REQUIRED = 3;
    private int consecutiveHighSpeedReadings = 0;
    private int consecutiveLowSpeedReadings = 0;
    
    // Background Service Communication
    private BroadcastReceiver locationReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if ("LOCATION_UPDATE".equals(intent.getAction())) {
                double latitude = intent.getDoubleExtra("latitude", 0);
                double longitude = intent.getDoubleExtra("longitude", 0);
                float accuracy = intent.getFloatExtra("accuracy", 0);
                float speed = intent.getFloatExtra("speed", 0);
                
                runOnUiThread(() -> {
                    statusText.setText("üåç Background GPS Active");
                    speedText.setText(String.format("Speed: %.1f mph", speed * 2.237));
                    accuracyText.setText(String.format("Accuracy: %.0f meters", accuracy));
                    
                    Location location = new Location("background");
                    location.setLatitude(latitude);
                    location.setLongitude(longitude);
                    location.setAccuracy(accuracy);
                    location.setSpeed(speed);
                    location.setTime(System.currentTimeMillis());
                    
                    onLocationChanged(location);
                });
            } else if ("TRIP_STARTED".equals(intent.getAction())) {
                runOnUiThread(() -> {
                    statusText.setText("üöó Trip Started Automatically");
                    Toast.makeText(MainActivity.this, "üöó Trip started automatically!", Toast.LENGTH_SHORT).show();
                });
            } else if ("TRIP_ENDED".equals(intent.getAction())) {
                runOnUiThread(() -> {
                    statusText.setText("‚úÖ Trip Ended - Processing");
                    Toast.makeText(MainActivity.this, "‚úÖ Trip completed and saved!", Toast.LENGTH_SHORT).show();
                    // ENHANCED: Sync to API immediately when trip ends
                    syncLatestTripToAPI();
                    // Refresh displays after brief delay
                    new Handler().postDelayed(() -> {
                        updateRecentTrips();
                        updateAllTrips();
                    }, 2000);
                });
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        Log.d(TAG, "MainActivity onCreate - " + VERSION);
        
        // Initialize services and storage
        tripStorage = new TripStorage(this);
        cloudBackupService = new CloudBackupService(this);
        
        // Create main UI
        createMainInterface();
        
        // Setup location services
        setupLocationServices();
        
        // Load settings and trips
        loadSettings();
        
        // Register for background service updates
        IntentFilter filter = new IntentFilter();
        filter.addAction("LOCATION_UPDATE");
        filter.addAction("TRIP_STARTED");
        filter.addAction("TRIP_ENDED");
        LocalBroadcastManager.getInstance(this).registerReceiver(locationReceiver, filter);
        
        Log.d(TAG, "MainActivity initialization complete");
    }

    private void createMainInterface() {
        // Main container
        LinearLayout mainLayout = new LinearLayout(this);
        mainLayout.setOrientation(LinearLayout.VERTICAL);
        mainLayout.setBackgroundColor(0xFFF8FAFC);
        mainLayout.setPadding(20, 20, 20, 20);

        // Header with logo and title
        LinearLayout headerLayout = new LinearLayout(this);
        headerLayout.setOrientation(LinearLayout.HORIZONTAL);
        headerLayout.setGravity(Gravity.CENTER_VERTICAL);
        headerLayout.setPadding(0, 0, 0, 30);

        TextView logoText = new TextView(this);
        logoText.setText("üöó");
        logoText.setTextSize(32);
        logoText.setPadding(0, 0, 15, 0);

        TextView titleText = new TextView(this);
        titleText.setText("MileTracker Pro " + VERSION);
        titleText.setTextSize(24);
        titleText.setTypeface(null, Typeface.BOLD);
        titleText.setTextColor(0xFF1E40AF);

        headerLayout.addView(logoText);
        headerLayout.addView(titleText);

        // Tab Navigation
        LinearLayout tabLayout = new LinearLayout(this);
        tabLayout.setOrientation(LinearLayout.HORIZONTAL);
        tabLayout.setGravity(Gravity.CENTER);
        tabLayout.setPadding(0, 0, 0, 20);

        // Home Tab Button
        homeTabButton = new Button(this);
        homeTabButton.setText("üè† Dashboard");
        homeTabButton.setBackgroundColor(0xFF667eea); // ACTIVE PERIWINKLE
        homeTabButton.setTextColor(Color.WHITE);
        homeTabButton.setPadding(30, 15, 30, 15);
        homeTabButton.setOnClickListener(v -> switchToHomeTab());

        // Trips Tab Button
        tripsTabButton = new Button(this);
        tripsTabButton.setText("üöó Trips");
        tripsTabButton.setBackgroundColor(0xFF9CA3AF); // INACTIVE GRAY
        tripsTabButton.setTextColor(Color.WHITE);
        tripsTabButton.setPadding(30, 15, 30, 15);
        tripsTabButton.setOnClickListener(v -> switchToTripsTab());

        // ENHANCED: Refresh Button with Loading Feedback
        refreshButton = new Button(this);
        refreshButton.setText("üîÑ Refresh");
        refreshButton.setBackgroundColor(0xFF059669); // GREEN
        refreshButton.setTextColor(Color.WHITE);
        refreshButton.setPadding(20, 15, 20, 15);
        refreshButton.setOnClickListener(v -> performRefreshWithFeedback());

        LinearLayout.LayoutParams buttonParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
        buttonParams.setMargins(5, 0, 5, 0);

        tabLayout.addView(homeTabButton, buttonParams);
        tabLayout.addView(tripsTabButton, buttonParams);
        tabLayout.addView(refreshButton, buttonParams);

        // Main content area (will be switched between dashboard and trips)
        mainContentLayout = new LinearLayout(this);
        mainContentLayout.setOrientation(LinearLayout.VERTICAL);

        // Add all components to main layout
        mainLayout.addView(headerLayout);
        mainLayout.addView(tabLayout);
        mainLayout.addView(mainContentLayout);

        setContentView(mainLayout);

        // Start with dashboard
        switchToHomeTab();
    }

    // ENHANCED: Refresh with visual feedback and API sync
    private void performRefreshWithFeedback() {
        // Show loading state
        refreshButton.setText("‚è≥ Loading...");
        refreshButton.setEnabled(false);
        
        Toast.makeText(this, "üîÑ Refreshing trips from API...", Toast.LENGTH_SHORT).show();
        
        executorService.execute(() -> {
            try {
                // Download latest trips from API
                downloadTripsFromAPI();
                
                // Update UI on main thread
                runOnUiThread(() -> {
                    // Reset button
                    refreshButton.setText("üîÑ Refresh");
                    refreshButton.setEnabled(true);
                    
                    // Update displays
                    updateRecentTrips();
                    updateAllTrips();
                    
                    // Show success feedback
                    Toast.makeText(MainActivity.this, "‚úÖ Trips refreshed successfully!", Toast.LENGTH_SHORT).show();
                    
                    Log.d(TAG, "Refresh completed successfully");
                });
                
            } catch (Exception e) {
                Log.e(TAG, "Error during refresh: " + e.getMessage(), e);
                
                runOnUiThread(() -> {
                    // Reset button
                    refreshButton.setText("üîÑ Refresh");
                    refreshButton.setEnabled(true);
                    
                    // Show error feedback
                    Toast.makeText(MainActivity.this, "‚ö†Ô∏è Refresh failed - using local data", Toast.LENGTH_SHORT).show();
                });
            }
        });
    }

    // ENHANCED: Download trips with improved user association
    private void downloadTripsFromAPI() {
        try {
            // Get current user email from authentication
            String userEmail = getCurrentUserEmail();
            if (userEmail == null) {
                Log.w(TAG, "No user email found for API sync");
                return;
            }
            
            // Try primary API first, then fallback
            String[] apiUrls = {PRIMARY_API_URL, FALLBACK_API_URL};
            
            for (String apiUrl : apiUrls) {
                try {
                    URL url = new URL(apiUrl + "/trips/user/" + userEmail);
                    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                    conn.setRequestMethod("GET");
                    conn.setConnectTimeout(5000);
                    conn.setReadTimeout(10000);
                    
                    int responseCode = conn.getResponseCode();
                    if (responseCode == 200) {
                        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                        StringBuilder response = new StringBuilder();
                        String line;
                        while ((line = reader.readLine()) != null) {
                            response.append(line);
                        }
                        reader.close();
                        
                        // Parse and save trips
                        JSONArray tripsArray = new JSONArray(response.toString());
                        List<Trip> downloadedTrips = new ArrayList<>();
                        
                        for (int i = 0; i < tripsArray.length(); i++) {
                            JSONObject tripJson = tripsArray.getJSONObject(i);
                            Trip trip = Trip.fromJson(tripJson);
                            downloadedTrips.add(trip);
                        }
                        
                        // Save downloaded trips (merge with existing)
                        tripStorage.mergeTripsFromAPI(downloadedTrips);
                        
                        currentApiUrl = apiUrl; // Remember working API URL
                        Log.d(TAG, "Successfully downloaded " + downloadedTrips.size() + " trips from API");
                        return;
                        
                    } else {
                        Log.w(TAG, "API returned status " + responseCode + " for URL: " + apiUrl);
                    }
                    
                } catch (Exception e) {
                    Log.w(TAG, "Failed to connect to API URL: " + apiUrl + " - " + e.getMessage());
                }
            }
            
            Log.w(TAG, "All API URLs failed, using local data only");
            
        } catch (Exception e) {
            Log.e(TAG, "Error downloading trips from API: " + e.getMessage(), e);
        }
    }

    // ENHANCED: Sync latest trip to API immediately
    private void syncLatestTripToAPI() {
        executorService.execute(() -> {
            try {
                List<Trip> trips = tripStorage.getAllTrips();
                if (trips.isEmpty()) return;
                
                // Get the most recent trip
                Trip latestTrip = trips.get(0); // Trips are sorted by date descending
                
                // Sync to API
                syncTripToAPI(latestTrip, "CREATE");
                
                Log.d(TAG, "Latest trip synced to API: " + latestTrip.getStartLocation());
                
            } catch (Exception e) {
                Log.e(TAG, "Error syncing latest trip to API: " + e.getMessage(), e);
            }
        });
    }

    // ENHANCED: Improved API sync method with retry logic
    private void syncTripToAPI(Trip trip, String operation) {
        try {
            String userEmail = getCurrentUserEmail();
            if (userEmail == null) {
                Log.w(TAG, "Cannot sync trip - no user email");
                return;
            }
            
            JSONObject tripJson = trip.toJson();
            tripJson.put("userEmail", userEmail); // Associate with user
            
            String[] apiUrls = {currentApiUrl, (currentApiUrl.equals(PRIMARY_API_URL) ? FALLBACK_API_URL : PRIMARY_API_URL)};
            
            for (String apiUrl : apiUrls) {
                try {
                    String endpoint;
                    String method;
                    
                    switch (operation) {
                        case "CREATE":
                            endpoint = apiUrl + "/trips";
                            method = "POST";
                            break;
                        case "UPDATE":
                            endpoint = apiUrl + "/trips/" + trip.getId();
                            method = "PUT";
                            break;
                        case "DELETE":
                            endpoint = apiUrl + "/trips/" + trip.getId();
                            method = "DELETE";
                            break;
                        default:
                            return;
                    }
                    
                    URL url = new URL(endpoint);
                    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                    conn.setRequestMethod(method);
                    conn.setRequestProperty("Content-Type", "application/json");
                    conn.setConnectTimeout(5000);
                    conn.setReadTimeout(10000);
                    
                    if (!method.equals("DELETE")) {
                        conn.setDoOutput(true);
                        OutputStream os = conn.getOutputStream();
                        os.write(tripJson.toString().getBytes("UTF-8"));
                        os.close();
                    }
                    
                    int responseCode = conn.getResponseCode();
                    if (responseCode >= 200 && responseCode < 300) {
                        currentApiUrl = apiUrl; // Remember working API
                        Log.d(TAG, "Successfully " + operation + "d trip to API: " + trip.getStartLocation());
                        
                        // Show success toast on UI thread
                        runOnUiThread(() -> {
                            String message = operation.equals("CREATE") ? "‚úÖ Trip saved to cloud" :
                                           operation.equals("UPDATE") ? "‚úÖ Trip updated in cloud" :
                                           "‚úÖ Trip deleted from cloud";
                            Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show();
                        });
                        return;
                    } else {
                        Log.w(TAG, "API " + operation + " failed with status " + responseCode);
                    }
                    
                } catch (Exception e) {
                    Log.w(TAG, "API sync failed for URL " + apiUrl + ": " + e.getMessage());
                }
            }
            
            // If we get here, all API URLs failed
            runOnUiThread(() -> {
                Toast.makeText(MainActivity.this, "‚ö†Ô∏è Saved locally - will sync when online", Toast.LENGTH_SHORT).show();
            });
            
        } catch (Exception e) {
            Log.e(TAG, "Error syncing trip to API: " + e.getMessage(), e);
        }
    }

    private String getCurrentUserEmail() {
        SharedPreferences prefs = getSharedPreferences("MileTrackerAuth", MODE_PRIVATE);
        return prefs.getString("user_email", null);
    }

    private void switchToHomeTab() {
        try {
            currentTab = "home";
            mainContentLayout.removeAllViews();
            
            LinearLayout homeContent = createDashboardContent();
            mainContentLayout.addView(homeContent);
            
            homeTabButton.setBackgroundColor(0xFF667eea); // ACTIVE PERIWINKLE
            tripsTabButton.setBackgroundColor(0xFF9CA3AF); // INACTIVE GRAY
            
            updateRecentTrips();
        } catch (Exception e) {
            Log.e(TAG, "Error switching to home tab: " + e.getMessage(), e);
        }
    }

    private void switchToTripsTab() {
        try {
            currentTab = "trips";
            mainContentLayout.removeAllViews();
            
            ScrollView tripsContent = createTripsContent();
            mainContentLayout.addView(tripsContent);
            homeTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
            tripsTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
            updateAllTrips();
        } catch (Exception e) {
            Log.e(TAG, "Error switching tabs: " + e.getMessage(), e);
        }
    }

    private LinearLayout createDashboardContent() {
        LinearLayout dashboardLayout = new LinearLayout(this);
        dashboardLayout.setOrientation(LinearLayout.VERTICAL);

        // GPS Status Card
        LinearLayout statusCard = createStatusCard();
        dashboardLayout.addView(statusCard);

        // Controls Card
        LinearLayout controlsCard = createControlsCard();
        dashboardLayout.addView(controlsCard);

        // Monthly Summary Card
        LinearLayout summaryCard = createMonthlySummaryCard();
        dashboardLayout.addView(summaryCard);

        // Recent Trips Preview
        TextView recentTripsTitle = new TextView(this);
        recentTripsTitle.setText("üìã Recent Trips");
        recentTripsTitle.setTextSize(18);
        recentTripsTitle.setTypeface(null, Typeface.BOLD);
        recentTripsTitle.setTextColor(0xFF1F2937);
        recentTripsTitle.setPadding(0, 20, 0, 10);

        // Recent trips container (fixed height)
        ScrollView recentTripsScroll = new ScrollView(this);
        recentTripsScroll.setLayoutParams(new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, 400)); // Fixed height

        LinearLayout recentTripsContainer = new LinearLayout(this);
        recentTripsContainer.setOrientation(LinearLayout.VERTICAL);
        recentTripsContainer.setId(R.id.recent_trips_container);
        recentTripsScroll.addView(recentTripsContainer);

        dashboardLayout.addView(recentTripsTitle);
        dashboardLayout.addView(recentTripsScroll);

        return dashboardLayout;
    }

    private LinearLayout createStatusCard() {
        LinearLayout statusCard = new LinearLayout(this);
        statusCard.setOrientation(LinearLayout.VERTICAL);
        statusCard.setBackgroundColor(Color.WHITE);
        statusCard.setPadding(20, 20, 20, 20);
        statusCard.setElevation(4);

        TextView statusTitle = new TextView(this);
        statusTitle.setText("üåç GPS Status");
        statusTitle.setTextSize(16);
        statusTitle.setTypeface(null, Typeface.BOLD);
        statusTitle.setTextColor(0xFF1F2937);

        statusText = new TextView(this);
        statusText.setText("‚è≥ Initializing GPS...");
        statusText.setTextSize(14);
        statusText.setTextColor(0xFF6B7280);
        statusText.setPadding(0, 5, 0, 0);

        speedText = new TextView(this);
        speedText.setText("Speed: -- mph");
        speedText.setTextSize(14);
        speedText.setTextColor(0xFF6B7280);

        accuracyText = new TextView(this);
        accuracyText.setText("Accuracy: -- meters");
        accuracyText.setTextSize(14);
        accuracyText.setTextColor(0xFF6B7280);

        distanceText = new TextView(this);
        distanceText.setText("Trip Distance: 0.0 miles");
        distanceText.setTextSize(14);
        distanceText.setTextColor(0xFF6B7280);

        statusCard.addView(statusTitle);
        statusCard.addView(statusText);
        statusCard.addView(speedText);
        statusCard.addView(accuracyText);
        statusCard.addView(distanceText);

        LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        cardParams.setMargins(0, 0, 0, 20);
        statusCard.setLayoutParams(cardParams);

        return statusCard;
    }

    private LinearLayout createControlsCard() {
        LinearLayout controlsCard = new LinearLayout(this);
        controlsCard.setOrientation(LinearLayout.VERTICAL);
        controlsCard.setBackgroundColor(Color.WHITE);
        controlsCard.setPadding(20, 20, 20, 20);
        controlsCard.setElevation(4);

        TextView controlsTitle = new TextView(this);
        controlsTitle.setText("üéÆ Trip Controls");
        controlsTitle.setTextSize(16);
        controlsTitle.setTypeface(null, Typeface.BOLD);
        controlsTitle.setTextColor(0xFF1F2937);
        controlsTitle.setPadding(0, 0, 0, 15);

        // Auto Detection Toggle
        LinearLayout autoDetectionLayout = new LinearLayout(this);
        autoDetectionLayout.setOrientation(LinearLayout.HORIZONTAL);
        autoDetectionLayout.setGravity(Gravity.CENTER_VERTICAL);
        autoDetectionLayout.setPadding(0, 0, 0, 15);

        TextView autoLabel = new TextView(this);
        autoLabel.setText("ü§ñ Auto Detection");
        autoLabel.setTextSize(14);
        autoLabel.setTextColor(0xFF374151);

        Switch autoSwitch = new Switch(this);
        autoSwitch.setChecked(autoDetectionEnabled);
        autoSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            autoDetectionEnabled = isChecked;
            saveSettings();
            if (isChecked) {
                startBackgroundLocationService();
                statusText.setText("ü§ñ Auto Detection Active");
            } else {
                stopBackgroundLocationService();
                statusText.setText("‚è∏Ô∏è Auto Detection Paused");
            }
        });

        LinearLayout.LayoutParams labelParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
        autoDetectionLayout.addView(autoLabel, labelParams);
        autoDetectionLayout.addView(autoSwitch);

        // Manual Control Button
        toggleButton = new Button(this);
        updateToggleButton();
        toggleButton.setTextColor(Color.WHITE);
        toggleButton.setPadding(20, 15, 20, 15);
        toggleButton.setOnClickListener(v -> toggleManualTracking());

        // Add Trip Button
        Button addTripButton = new Button(this);
        addTripButton.setText("‚ûï Add Trip Manually");
        addTripButton.setBackgroundColor(0xFF059669);
        addTripButton.setTextColor(Color.WHITE);
        addTripButton.setPadding(20, 15, 20, 15);
        addTripButton.setOnClickListener(v -> showAddTripDialog());

        controlsCard.addView(controlsTitle);
        controlsCard.addView(autoDetectionLayout);
        controlsCard.addView(toggleButton);
        controlsCard.addView(addTripButton);

        LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        cardParams.setMargins(0, 0, 0, 20);
        controlsCard.setLayoutParams(cardParams);

        return controlsCard;
    }

    private LinearLayout createMonthlySummaryCard() {
        LinearLayout summaryCard = new LinearLayout(this);
        summaryCard.setOrientation(LinearLayout.VERTICAL);
        summaryCard.setBackgroundColor(Color.WHITE);
        summaryCard.setPadding(20, 20, 20, 20);
        summaryCard.setElevation(4);

        TextView summaryTitle = new TextView(this);
        summaryTitle.setText("üìä June 2025 Summary");
        summaryTitle.setTextSize(16);
        summaryTitle.setTypeface(null, Typeface.BOLD);
        summaryTitle.setTextColor(0xFF1F2937);
        summaryTitle.setPadding(0, 0, 0, 15);

        // Calculate actual statistics
        List<Trip> allTrips = tripStorage.getAllTrips();
        int totalTrips = allTrips.size();
        double totalMiles = 0;
        double businessMiles = 0;
        double personalMiles = 0;
        double medicalMiles = 0;

        for (Trip trip : allTrips) {
            totalMiles += trip.getDistance();
            switch (trip.getCategory().toLowerCase()) {
                case "business":
                    businessMiles += trip.getDistance();
                    break;
                case "medical":
                    medicalMiles += trip.getDistance();
                    break;
                default:
                    personalMiles += trip.getDistance();
                    break;
            }
        }

        double businessDeduction = businessMiles * 0.70; // 2025 IRS rate
        double medicalDeduction = medicalMiles * 0.21;   // 2025 IRS rate
        double totalDeduction = businessDeduction + medicalDeduction;

        LinearLayout statsRow = new LinearLayout(this);
        statsRow.setOrientation(LinearLayout.HORIZONTAL);

        TextView tripsCount = createStatItem("Trips", String.valueOf(totalTrips));
        TextView milesCount = createStatItem("Miles", String.format("%.1f", totalMiles));
        TextView deductionCount = createStatItem("Tax Saved", String.format("$%.0f", totalDeduction));

        LinearLayout.LayoutParams statParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
        statsRow.addView(tripsCount, statParams);
        statsRow.addView(milesCount, statParams);
        statsRow.addView(deductionCount, statParams);

        // IRS explanation
        TextView irsExplanation = new TextView(this);
        irsExplanation.setText("IRS deduction = Business miles (√ó$0.70) + Medical miles (√ó$0.21)");
        irsExplanation.setTextSize(12);
        irsExplanation.setTextColor(0xFF6B7280);
        irsExplanation.setPadding(0, 10, 0, 0);

        summaryCard.addView(summaryTitle);
        summaryCard.addView(statsRow);
        summaryCard.addView(irsExplanation);

        LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        cardParams.setMargins(0, 0, 0, 20);
        summaryCard.setLayoutParams(cardParams);

        return summaryCard;
    }

    private TextView createStatItem(String label, String value) {
        LinearLayout statLayout = new LinearLayout(this);
        statLayout.setOrientation(LinearLayout.VERTICAL);
        statLayout.setGravity(Gravity.CENTER);

        TextView valueText = new TextView(this);
        valueText.setText(value);
        valueText.setTextSize(24);
        valueText.setTypeface(null, Typeface.BOLD);
        valueText.setTextColor(0xFF667eea);
        valueText.setGravity(Gravity.CENTER);

        TextView labelText = new TextView(this);
        labelText.setText(label);
        labelText.setTextSize(12);
        labelText.setTextColor(0xFF6B7280);
        labelText.setGravity(Gravity.CENTER);

        statLayout.addView(valueText);
        statLayout.addView(labelText);

        return valueText; // Return the main text view
    }

    private ScrollView createTripsContent() {
        ScrollView scrollView = new ScrollView(this);
        
        LinearLayout tripsContent = new LinearLayout(this);
        tripsContent.setOrientation(LinearLayout.VERTICAL);
        tripsContent.setPadding(0, 10, 0, 10);
        
        // Trips title
        TextView tripsTitle = new TextView(this);
        tripsTitle.setText("üöó All Trips");
        tripsTitle.setTextSize(20);
        tripsTitle.setTypeface(null, Typeface.BOLD);
        tripsTitle.setTextColor(0xFF1F2937);
        tripsTitle.setPadding(0, 0, 0, 20);
        tripsContent.addView(tripsTitle);
        
        // Trips container
        tripsLayout = new LinearLayout(this);
        tripsLayout.setOrientation(LinearLayout.VERTICAL);
        tripsLayout.setId(R.id.trips_layout);
        tripsContent.addView(tripsLayout);
        
        scrollView.addView(tripsContent);
        return scrollView;
    }

    private void updateRecentTrips() {
        try {
            LinearLayout recentTripsContainer = findViewById(R.id.recent_trips_container);
            if (recentTripsContainer != null) {
                recentTripsContainer.removeAllViews();
                
                List<Trip> trips = tripStorage.getAllTrips();
                int displayCount = Math.min(trips.size(), 3); // Show last 3 trips
                
                if (displayCount == 0) {
                    TextView noTripsText = new TextView(this);
                    noTripsText.setText("No trips recorded yet.\nStart driving or add a trip manually!");
                    noTripsText.setTextColor(0xFF6B7280);
                    noTripsText.setGravity(Gravity.CENTER);
                    noTripsText.setPadding(20, 40, 20, 40);
                    recentTripsContainer.addView(noTripsText);
                } else {
                    for (int i = 0; i < displayCount; i++) {
                        View tripCard = createTripCard(trips.get(i), true);
                        recentTripsContainer.addView(tripCard);
                    }
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
        }
    }

    private void updateAllTrips() {
        try {
            if (tripsLayout != null) {
                tripsLayout.removeAllViews();
                
                List<Trip> trips = tripStorage.getAllTrips();
                
                if (trips.isEmpty()) {
                    TextView noTripsText = new TextView(this);
                    noTripsText.setText("üìç No trips found\n\nStart auto-detection or add trips manually to begin tracking your mileage!");
                    noTripsText.setTextColor(0xFF6B7280);
                    noTripsText.setTextSize(16);
                    noTripsText.setGravity(Gravity.CENTER);
                    noTripsText.setPadding(40, 60, 40, 60);
                    tripsLayout.addView(noTripsText);
                } else {
                    for (Trip trip : trips) {
                        View tripCard = createTripCard(trip, false);
                        tripsLayout.addView(tripCard);
                    }
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error updating all trips: " + e.getMessage(), e);
        }
    }

    private View createTripCard(Trip trip, boolean isCompact) {
        LinearLayout card = new LinearLayout(this);
        card.setOrientation(LinearLayout.VERTICAL);
        card.setBackgroundColor(Color.WHITE);
        card.setPadding(isCompact ? 15 : 20, isCompact ? 15 : 20, isCompact ? 15 : 20, isCompact ? 15 : 20);
        card.setElevation(2);

        // Header with date and distance
        LinearLayout headerLayout = new LinearLayout(this);
        headerLayout.setOrientation(LinearLayout.HORIZONTAL);

        TextView dateText = new TextView(this);
        SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy 'at' h:mm a", Locale.US);
        dateText.setText(dateFormat.format(new Date(trip.getStartTime())));
        dateText.setTextSize(isCompact ? 14 : 16);
        dateText.setTypeface(null, Typeface.BOLD);
        dateText.setTextColor(0xFF1F2937);

        TextView distanceText = new TextView(this);
        DecimalFormat df = new DecimalFormat("#.##");
        distanceText.setText(df.format(trip.getDistance()) + " mi");
        distanceText.setTextSize(isCompact ? 14 : 16);
        distanceText.setTypeface(null, Typeface.BOLD);
        distanceText.setTextColor(0xFF059669);
        distanceText.setGravity(Gravity.END);

        LinearLayout.LayoutParams dateParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
        headerLayout.addView(dateText, dateParams);
        headerLayout.addView(distanceText);

        // Location info
        TextView locationText = new TextView(this);
        locationText.setText("From: " + trip.getStartLocation() + "\nTo: " + trip.getEndLocation());
        locationText.setTextSize(isCompact ? 12 : 14);
        locationText.setTextColor(0xFF6B7280);
        locationText.setPadding(0, 5, 0, 5);

        // Category and details row
        LinearLayout detailsLayout = new LinearLayout(this);
        detailsLayout.setOrientation(LinearLayout.HORIZONTAL);
        detailsLayout.setGravity(Gravity.CENTER_VERTICAL);

        TextView categoryText = new TextView(this);
        categoryText.setText(trip.getCategory());
        categoryText.setTextSize(isCompact ? 11 : 12);
        categoryText.setTextColor(Color.WHITE);
        categoryText.setBackgroundColor(trip.getCategory().equals("Business") ? 0xFF059669 : 0xFF6366F1);
        categoryText.setPadding(8, 4, 8, 4);

        TextView autoText = new TextView(this);
        autoText.setText(trip.isAutoDetected() ? "ü§ñ Auto" : "‚úã Manual");
        autoText.setTextSize(isCompact ? 11 : 12);
        autoText.setTextColor(0xFF6B7280);
        autoText.setPadding(10, 0, 0, 0);

        LinearLayout.LayoutParams categoryParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        detailsLayout.addView(categoryText, categoryParams);
        detailsLayout.addView(autoText);

        // ENHANCED: Edit and Delete buttons (full trips view only)
        if (!isCompact) {
            LinearLayout buttonLayout = new LinearLayout(this);
            buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
            buttonLayout.setGravity(Gravity.END);
            buttonLayout.setPadding(0, 10, 0, 0);

            Button editButton = new Button(this);
            editButton.setText("‚úèÔ∏è Edit");
            editButton.setTextSize(12);
            editButton.setBackgroundColor(0xFF3B82F6); // Blue
            editButton.setTextColor(Color.WHITE);
            editButton.setPadding(15, 8, 15, 8);
            editButton.setOnClickListener(v -> showEditTripDialog(trip));

            Button deleteButton = new Button(this);
            deleteButton.setText("üóëÔ∏è Delete");
            deleteButton.setTextSize(12);
            deleteButton.setBackgroundColor(0xFFEF4444); // Red
            deleteButton.setTextColor(Color.WHITE);
            deleteButton.setPadding(15, 8, 15, 8);
            deleteButton.setOnClickListener(v -> showDeleteTripDialog(trip));

            LinearLayout.LayoutParams buttonParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
            buttonParams.setMargins(10, 0, 0, 0);
            
            buttonLayout.addView(editButton);
            buttonLayout.addView(deleteButton, buttonParams);
            
            card.addView(buttonLayout);
        }

        // Add client and notes if present
        if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
            TextView clientText = new TextView(this);
            clientText.setText("Client: " + trip.getClientName());
            clientText.setTextSize(isCompact ? 11 : 12);
            clientText.setTextColor(0xFF059669);
            clientText.setTypeface(null, Typeface.BOLD);
            clientText.setPadding(0, 5, 0, 0);
            card.addView(clientText);
        }

        if (trip.getNotes() != null && !trip.getNotes().trim().isEmpty()) {
            TextView notesText = new TextView(this);
            notesText.setText("Notes: " + trip.getNotes());
            notesText.setTextSize(isCompact ? 11 : 12);
            notesText.setTextColor(0xFF6B7280);
            notesText.setPadding(0, 5, 0, 0);
            card.addView(notesText);
        }

        card.addView(headerLayout);
        card.addView(locationText);
        card.addView(detailsLayout);

        LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        cardParams.setMargins(0, 0, 0, isCompact ? 10 : 15);
        card.setLayoutParams(cardParams);

        return card;
    }

    // ENHANCED: Complete edit trip dialog with ALL fields editable
    private void showEditTripDialog(Trip trip) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("‚úèÔ∏è Edit Trip - All Fields");

        // Create scrollable layout
        ScrollView scrollView = new ScrollView(this);
        LinearLayout layout = new LinearLayout(this);
        layout.setOrientation(LinearLayout.VERTICAL);
        layout.setPadding(50, 20, 50, 20);

        // Trip Date
        TextView dateLabel = new TextView(this);
        dateLabel.setText("Trip Date:");
        dateLabel.setTextSize(14);
        dateLabel.setTypeface(null, Typeface.BOLD);
        
        Button dateButton = new Button(this);
        SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy", Locale.US);
        Calendar tripDate = Calendar.getInstance();
        tripDate.setTimeInMillis(trip.getStartTime());
        dateButton.setText(dateFormat.format(tripDate.getTime()));
        dateButton.setBackgroundColor(0xFFE5E7EB);
        dateButton.setTextColor(0xFF374151);
        
        dateButton.setOnClickListener(v -> {
            DatePickerDialog datePicker = new DatePickerDialog(this,
                (view, year, month, dayOfMonth) -> {
                    tripDate.set(year, month, dayOfMonth);
                    dateButton.setText(dateFormat.format(tripDate.getTime()));
                },
                tripDate.get(Calendar.YEAR),
                tripDate.get(Calendar.MONTH),
                tripDate.get(Calendar.DAY_OF_MONTH));
            datePicker.show();
        });

        // Start Time
        TextView startTimeLabel = new TextView(this);
        startTimeLabel.setText("Start Time:");
        startTimeLabel.setTextSize(14);
        startTimeLabel.setTypeface(null, Typeface.BOLD);
        startTimeLabel.setPadding(0, 10, 0, 0);
        
        EditText startTimeEdit = new EditText(this);
        SimpleDateFormat timeFormat = new SimpleDateFormat("h:mm a", Locale.US);
        startTimeEdit.setText(timeFormat.format(new Date(trip.getStartTime())));
        startTimeEdit.setHint("9:00 AM");

        // Duration (minutes)
        TextView durationLabel = new TextView(this);
        durationLabel.setText("Duration (minutes):");
        durationLabel.setTextSize(14);
        durationLabel.setTypeface(null, Typeface.BOLD);
        durationLabel.setPadding(0, 10, 0, 0);
        
        EditText durationEdit = new EditText(this);
        long durationMinutes = trip.getDuration() / (60 * 1000); // Convert ms to minutes
        durationEdit.setText(String.valueOf(durationMinutes));
        durationEdit.setInputType(InputType.TYPE_CLASS_NUMBER);
        durationEdit.setHint("30");

        // Start Location
        TextView startLabel = new TextView(this);
        startLabel.setText("Start Location:");
        startLabel.setTextSize(14);
        startLabel.setTypeface(null, Typeface.BOLD);
        startLabel.setPadding(0, 10, 0, 0);
        
        EditText startLocationEdit = new EditText(this);
        startLocationEdit.setText(trip.getStartLocation());
        startLocationEdit.setHint("Home, office, client address, etc.");

        // End Location
        TextView endLabel = new TextView(this);
        endLabel.setText("End Location:");
        endLabel.setTextSize(14);
        endLabel.setTypeface(null, Typeface.BOLD);
        endLabel.setPadding(0, 10, 0, 0);
        
        EditText endLocationEdit = new EditText(this);
        endLocationEdit.setText(trip.getEndLocation());
        endLocationEdit.setHint("Meeting location, store, etc.");

        // Distance
        TextView distanceLabel = new TextView(this);
        distanceLabel.setText("Distance (miles):");
        distanceLabel.setTextSize(14);
        distanceLabel.setTypeface(null, Typeface.BOLD);
        distanceLabel.setPadding(0, 10, 0, 0);
        
        EditText distanceEdit = new EditText(this);
        distanceEdit.setText(String.valueOf(trip.getDistance()));
        distanceEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
        distanceEdit.setHint("0.0");

        // Category
        TextView categoryLabel = new TextView(this);
        categoryLabel.setText("Category:");
        categoryLabel.setTextSize(14);
        categoryLabel.setTypeface(null, Typeface.BOLD);
        categoryLabel.setPadding(0, 10, 0, 0);
        
        Spinner categorySpinner = new Spinner(this);
        String[] categories = {"Personal", "Business", "Medical", "Charity"};
        ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
        categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        categorySpinner.setAdapter(categoryAdapter);
        
        // Set current category
        for (int i = 0; i < categories.length; i++) {
            if (categories[i].equals(trip.getCategory())) {
                categorySpinner.setSelection(i);
                break;
            }
        }

        // Auto-Detected Toggle
        TextView autoDetectedLabel = new TextView(this);
        autoDetectedLabel.setText("Auto-Detected:");
        autoDetectedLabel.setTextSize(14);
        autoDetectedLabel.setTypeface(null, Typeface.BOLD);
        autoDetectedLabel.setPadding(0, 10, 0, 0);
        
        LinearLayout autoDetectedLayout = new LinearLayout(this);
        autoDetectedLayout.setOrientation(LinearLayout.HORIZONTAL);
        autoDetectedLayout.setGravity(Gravity.CENTER_VERTICAL);
        
        Switch autoDetectedSwitch = new Switch(this);
        autoDetectedSwitch.setChecked(trip.isAutoDetected());
        
        TextView autoDetectedInfo = new TextView(this);
        autoDetectedInfo.setText("ü§ñ Auto vs ‚úã Manual");
        autoDetectedInfo.setTextSize(12);
        autoDetectedInfo.setTextColor(0xFF6B7280);
        autoDetectedInfo.setPadding(10, 0, 0, 0);
        
        autoDetectedLayout.addView(autoDetectedSwitch);
        autoDetectedLayout.addView(autoDetectedInfo);

        // Client Name
        TextView clientLabel = new TextView(this);
        clientLabel.setText("Client Name (optional):");
        clientLabel.setTextSize(14);
        clientLabel.setTypeface(null, Typeface.BOLD);
        clientLabel.setPadding(0, 10, 0, 0);
        
        EditText clientEdit = new EditText(this);
        clientEdit.setText(trip.getClientName() != null ? trip.getClientName() : "");
        clientEdit.setHint("Client or company name");

        // Notes
        TextView notesLabel = new TextView(this);
        notesLabel.setText("Notes (optional):");
        notesLabel.setTextSize(14);
        notesLabel.setTypeface(null, Typeface.BOLD);
        notesLabel.setPadding(0, 10, 0, 0);
        
        EditText notesEdit = new EditText(this);
        notesEdit.setText(trip.getNotes() != null ? trip.getNotes() : "");
        notesEdit.setHint("Trip purpose, meeting details, etc.");
        notesEdit.setMaxLines(3);

        // GPS Coordinates (Advanced - Optional Edit)
        TextView coordsLabel = new TextView(this);
        coordsLabel.setText("GPS Coordinates (advanced):");
        coordsLabel.setTextSize(14);
        coordsLabel.setTypeface(null, Typeface.BOLD);
        coordsLabel.setPadding(0, 15, 0, 0);

        // Start Coordinates
        LinearLayout startCoordsLayout = new LinearLayout(this);
        startCoordsLayout.setOrientation(LinearLayout.HORIZONTAL);
        
        EditText startLatEdit = new EditText(this);
        startLatEdit.setText(String.valueOf(trip.getStartLatitude()));
        startLatEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL | InputType.TYPE_NUMBER_FLAG_SIGNED);
        startLatEdit.setHint("Start Lat");
        startLatEdit.setLayoutParams(new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1));

        EditText startLonEdit = new EditText(this);
        startLonEdit.setText(String.valueOf(trip.getStartLongitude()));
        startLonEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL | InputType.TYPE_NUMBER_FLAG_SIGNED);
        startLonEdit.setHint("Start Lon");
        startLonEdit.setLayoutParams(new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1));
        startLonEdit.setPadding(10, 0, 0, 0);

        startCoordsLayout.addView(startLatEdit);
        startCoordsLayout.addView(startLonEdit);

        // End Coordinates
        LinearLayout endCoordsLayout = new LinearLayout(this);
        endCoordsLayout.setOrientation(LinearLayout.HORIZONTAL);
        
        EditText endLatEdit = new EditText(this);
        endLatEdit.setText(String.valueOf(trip.getEndLatitude()));
        endLatEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL | InputType.TYPE_NUMBER_FLAG_SIGNED);
        endLatEdit.setHint("End Lat");
        endLatEdit.setLayoutParams(new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1));

        EditText endLonEdit = new EditText(this);
        endLonEdit.setText(String.valueOf(trip.getEndLongitude()));
        endLonEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL | InputType.TYPE_NUMBER_FLAG_SIGNED);
        endLonEdit.setHint("End Lon");
        endLonEdit.setLayoutParams(new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1));
        endLonEdit.setPadding(10, 0, 0, 0);

        endCoordsLayout.addView(endLatEdit);
        endCoordsLayout.addView(endLonEdit);

        // Add all components to layout
        layout.addView(dateLabel);
        layout.addView(dateButton);
        layout.addView(startTimeLabel);
        layout.addView(startTimeEdit);
        layout.addView(durationLabel);
        layout.addView(durationEdit);
        layout.addView(startLabel);
        layout.addView(startLocationEdit);
        layout.addView(endLabel);
        layout.addView(endLocationEdit);
        layout.addView(distanceLabel);
        layout.addView(distanceEdit);
        layout.addView(categoryLabel);
        layout.addView(categorySpinner);
        layout.addView(autoDetectedLabel);
        layout.addView(autoDetectedLayout);
        layout.addView(clientLabel);
        layout.addView(clientEdit);
        layout.addView(notesLabel);
        layout.addView(notesEdit);
        layout.addView(coordsLabel);
        layout.addView(startCoordsLayout);
        layout.addView(endCoordsLayout);

        scrollView.addView(layout);
        builder.setView(scrollView);

        builder.setPositiveButton("üíæ Save Changes", (dialog, which) -> {
            try {
                // Parse and validate all fields
                String startLocation = startLocationEdit.getText().toString().trim();
                String endLocation = endLocationEdit.getText().toString().trim();
                double distance = Double.parseDouble(distanceEdit.getText().toString());
                long durationMinutes = Long.parseLong(durationEdit.getText().toString());
                String startTimeStr = startTimeEdit.getText().toString().trim();
                
                // Validation
                if (startLocation.isEmpty() || endLocation.isEmpty()) {
                    Toast.makeText(this, "Start and end locations are required", Toast.LENGTH_SHORT).show();
                    return;
                }
                
                // Update trip date and time
                Calendar updatedDate = Calendar.getInstance();
                updatedDate.setTimeInMillis(tripDate.getTimeInMillis());
                
                // Parse start time (simplified - assumes format like "9:00 AM")
                try {
                    SimpleDateFormat timeFormat = new SimpleDateFormat("h:mm a", Locale.US);
                    Date startTime = timeFormat.parse(startTimeStr);
                    if (startTime != null) {
                        Calendar timeCalendar = Calendar.getInstance();
                        timeCalendar.setTime(startTime);
                        updatedDate.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
                        updatedDate.set(Calendar.MINUTE, timeCalendar.get(Calendar.MINUTE));
                    }
                } catch (Exception e) {
                    Log.w(TAG, "Could not parse start time, keeping original time");
                }
                
                // Update all trip fields
                trip.setStartLocation(startLocation);
                trip.setEndLocation(endLocation);
                trip.setDistance(distance);
                trip.setDuration(durationMinutes * 60 * 1000); // Convert minutes to milliseconds
                trip.setCategory(categorySpinner.getSelectedItem().toString());
                trip.setAutoDetected(autoDetectedSwitch.isChecked());
                trip.setClientName(clientEdit.getText().toString().trim());
                trip.setNotes(notesEdit.getText().toString().trim());
                
                // Update timestamps
                trip.setStartTime(updatedDate.getTimeInMillis());
                trip.setEndTime(updatedDate.getTimeInMillis() + trip.getDuration());
                
                // Update GPS coordinates (optional advanced editing)
                try {
                    double startLat = Double.parseDouble(startLatEdit.getText().toString());
                    double startLon = Double.parseDouble(startLonEdit.getText().toString());
                    double endLat = Double.parseDouble(endLatEdit.getText().toString());
                    double endLon = Double.parseDouble(endLonEdit.getText().toString());
                    
                    trip.setStartLatitude(startLat);
                    trip.setStartLongitude(startLon);
                    trip.setEndLatitude(endLat);
                    trip.setEndLongitude(endLon);
                } catch (NumberFormatException e) {
                    Log.w(TAG, "GPS coordinates not updated - invalid format");
                }

                // Save to database and sync to API
                boolean success = tripStorage.updateTrip(trip);
                
                if (success) {
                    Toast.makeText(this, "‚úÖ All trip details updated successfully!", Toast.LENGTH_SHORT).show();
                    updateAllTrips(); // Refresh trips display
                    updateRecentTrips(); // Refresh dashboard
                    
                    // ENHANCED: Sync to API immediately
                    executorService.execute(() -> syncTripToAPI(trip, "UPDATE"));
                } else {
                    Toast.makeText(this, "Failed to update trip", Toast.LENGTH_SHORT).show();
                }
                
                Log.d(TAG, "Trip fully updated: " + trip.getStartLocation() + " to " + trip.getEndLocation() + 
                      " on " + dateFormat.format(new Date(trip.getStartTime())));
                
            } catch (NumberFormatException e) {
                Toast.makeText(this, "Please enter valid numbers for distance and duration", Toast.LENGTH_SHORT).show();
            } catch (Exception e) {
                Log.e(TAG, "Error updating trip: " + e.getMessage(), e);
                Toast.makeText(this, "Error updating trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
            }
        });

        builder.setNegativeButton("‚ùå Cancel", null);
        
        AlertDialog dialog = builder.create();
        dialog.show();
    }

    // ENHANCED: Delete trip dialog with API sync
    private void showDeleteTripDialog(Trip trip) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("üóëÔ∏è Delete Trip");
        builder.setMessage("Are you sure you want to delete this trip?\n\n" +
                          "From: " + trip.getStartLocation() + "\n" +
                          "To: " + trip.getEndLocation() + "\n" +
                          "Distance: " + trip.getDistance() + " miles\n\n" +
                          "This action cannot be undone.");

        builder.setPositiveButton("üóëÔ∏è Delete", (dialog, which) -> {
            try {
                boolean success = tripStorage.deleteTrip(trip.getId());
                
                if (success) {
                    Toast.makeText(this, "Trip deleted successfully!", Toast.LENGTH_SHORT).show();
                    updateAllTrips(); // Refresh trips display
                    updateRecentTrips(); // Refresh dashboard
                    Log.d(TAG, "Trip deleted: ID " + trip.getId());
                    
                    // ENHANCED: Sync deletion to API immediately
                    executorService.execute(() -> syncTripToAPI(trip, "DELETE"));
                } else {
                    Toast.makeText(this, "Failed to delete trip", Toast.LENGTH_SHORT).show();
                }
                
            } catch (Exception e) {
                Log.e(TAG, "Error deleting trip: " + e.getMessage(), e);
                Toast.makeText(this, "Error deleting trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
            }
        });

        builder.setNegativeButton("‚ùå Cancel", null);
        
        AlertDialog dialog = builder.create();
        dialog.show();
    }

    private void showAddTripDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("‚ûï Add Trip Manually");

        ScrollView scrollView = new ScrollView(this);
        LinearLayout layout = new LinearLayout(this);
        layout.setOrientation(LinearLayout.VERTICAL);
        layout.setPadding(50, 20, 50, 20);

        // Date selection
        TextView dateLabel = new TextView(this);
        dateLabel.setText("Date:");
        dateLabel.setTextSize(14);
        dateLabel.setTypeface(null, Typeface.BOLD);
        
        Button dateButton = new Button(this);
        SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy", Locale.US);
        dateButton.setText(dateFormat.format(new Date()));
        dateButton.setBackgroundColor(0xFF E5E7EB);
        dateButton.setTextColor(0xFF374151);
        
        Calendar selectedDate = Calendar.getInstance();
        dateButton.setOnClickListener(v -> {
            DatePickerDialog datePicker = new DatePickerDialog(this,
                (view, year, month, dayOfMonth) -> {
                    selectedDate.set(year, month, dayOfMonth);
                    dateButton.setText(dateFormat.format(selectedDate.getTime()));
                },
                selectedDate.get(Calendar.YEAR),
                selectedDate.get(Calendar.MONTH),
                selectedDate.get(Calendar.DAY_OF_MONTH));
            datePicker.show();
        });

        // Start Location
        TextView startLabel = new TextView(this);
        startLabel.setText("Start Location:");
        startLabel.setTextSize(14);
        startLabel.setTypeface(null, Typeface.BOLD);
        startLabel.setPadding(0, 10, 0, 0);
        
        EditText startLocationEdit = new EditText(this);
        startLocationEdit.setHint("Home, office, client address, etc.");

        // End Location
        TextView endLabel = new TextView(this);
        endLabel.setText("End Location:");
        endLabel.setTextSize(14);
        endLabel.setTypeface(null, Typeface.BOLD);
        endLabel.setPadding(0, 10, 0, 0);
        
        EditText endLocationEdit = new EditText(this);
        endLocationEdit.setHint("Meeting location, store, etc.");

        // Distance
        TextView distanceLabel = new TextView(this);
        distanceLabel.setText("Distance (miles):");
        distanceLabel.setTextSize(14);
        distanceLabel.setTypeface(null, Typeface.BOLD);
        distanceLabel.setPadding(0, 10, 0, 0);
        
        EditText distanceEdit = new EditText(this);
        distanceEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
        distanceEdit.setHint("0.0");

        // Duration
        TextView durationLabel = new TextView(this);
        durationLabel.setText("Duration (minutes):");
        durationLabel.setTextSize(14);
        durationLabel.setTypeface(null, Typeface.BOLD);
        durationLabel.setPadding(0, 10, 0, 0);
        
        EditText durationEdit = new EditText(this);
        durationEdit.setInputType(InputType.TYPE_CLASS_NUMBER);
        durationEdit.setHint("30");

        // Category
        TextView categoryLabel = new TextView(this);
        categoryLabel.setText("Category:");
        categoryLabel.setTextSize(14);
        categoryLabel.setTypeface(null, Typeface.BOLD);
        categoryLabel.setPadding(0, 10, 0, 0);
        
        Spinner categorySpinner = new Spinner(this);
        String[] categories = {"Personal", "Business", "Medical", "Charity"};
        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        categorySpinner.setAdapter(adapter);

        // Client Name
        TextView clientLabel = new TextView(this);
        clientLabel.setText("Client Name (optional):");
        clientLabel.setTextSize(14);
        clientLabel.setTypeface(null, Typeface.BOLD);
        clientLabel.setPadding(0, 10, 0, 0);
        
        EditText clientEdit = new EditText(this);
        clientEdit.setHint("Client or company name");

        // Notes
        TextView notesLabel = new TextView(this);
        notesLabel.setText("Notes (optional):");
        notesLabel.setTextSize(14);
        notesLabel.setTypeface(null, Typeface.BOLD);
        notesLabel.setPadding(0, 10, 0, 0);
        
        EditText notesEdit = new EditText(this);
        notesEdit.setHint("Trip purpose, meeting details, etc.");
        notesEdit.setMaxLines(3);

        layout.addView(dateLabel);
        layout.addView(dateButton);
        layout.addView(startLabel);
        layout.addView(startLocationEdit);
        layout.addView(endLabel);
        layout.addView(endLocationEdit);
        layout.addView(distanceLabel);
        layout.addView(distanceEdit);
        layout.addView(durationLabel);
        layout.addView(durationEdit);
        layout.addView(categoryLabel);
        layout.addView(categorySpinner);
        layout.addView(clientLabel);
        layout.addView(clientEdit);
        layout.addView(notesLabel);
        layout.addView(notesEdit);

        scrollView.addView(layout);
        builder.setView(scrollView);

        builder.setPositiveButton("üíæ Save Trip", (dialog, which) -> {
            try {
                String startLocation = startLocationEdit.getText().toString().trim();
                String endLocation = endLocationEdit.getText().toString().trim();
                String distanceStr = distanceEdit.getText().toString().trim();
                String durationStr = durationEdit.getText().toString().trim();

                if (startLocation.isEmpty() || endLocation.isEmpty() || distanceStr.isEmpty()) {
                    Toast.makeText(this, "Please fill in start location, end location, and distance", Toast.LENGTH_SHORT).show();
                    return;
                }

                double distance = Double.parseDouble(distanceStr);
                long duration = durationStr.isEmpty() ? 30 * 60 * 1000 : Long.parseLong(durationStr) * 60 * 1000; // Convert minutes to milliseconds

                // Create trip
                Trip trip = new Trip();
                trip.setId(System.currentTimeMillis()); // Simple ID generation
                trip.setStartLocation(startLocation);
                trip.setEndLocation(endLocation);
                trip.setDistance(distance);
                trip.setDuration(duration);
                trip.setCategory(categorySpinner.getSelectedItem().toString());
                trip.setClientName(clientEdit.getText().toString().trim());
                trip.setNotes(notesEdit.getText().toString().trim());
                trip.setAutoDetected(false);
                
                // Set time to selected date
                selectedDate.set(Calendar.HOUR_OF_DAY, 12); // Set to noon
                trip.setStartTime(selectedDate.getTimeInMillis());
                trip.setEndTime(selectedDate.getTimeInMillis() + duration);

                // Save trip
                boolean success = tripStorage.saveTrip(trip);
                
                if (success) {
                    Toast.makeText(this, "‚úÖ Trip added successfully!", Toast.LENGTH_SHORT).show();
                    updateAllTrips();
                    updateRecentTrips();
                    
                    // ENHANCED: Sync to API immediately
                    executorService.execute(() -> syncTripToAPI(trip, "CREATE"));
                    
                    Log.d(TAG, "Manual trip added: " + startLocation + " to " + endLocation);
                } else {
                    Toast.makeText(this, "Failed to save trip", Toast.LENGTH_SHORT).show();
                }

            } catch (NumberFormatException e) {
                Toast.makeText(this, "Please enter valid numbers for distance and duration", Toast.LENGTH_SHORT).show();
            } catch (Exception e) {
                Log.e(TAG, "Error adding trip: " + e.getMessage(), e);
                Toast.makeText(this, "Error adding trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
            }
        });

        builder.setNegativeButton("‚ùå Cancel", null);
        
        AlertDialog dialog = builder.create();
        dialog.show();
    }

    private void setupLocationServices() {
        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        
        if (checkLocationPermissions()) {
            initializeLocationServices();
        } else {
            requestLocationPermissions();
        }
    }

    private boolean checkLocationPermissions() {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED &&
               ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermissions() {
        ActivityCompat.requestPermissions(this,
            new String[]{
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.ACCESS_COARSE_LOCATION,
                Manifest.permission.ACCESS_BACKGROUND_LOCATION
            },
            LOCATION_PERMISSION_REQUEST_CODE);
    }

    private void initializeLocationServices() {
        try {
            if (checkLocationPermissions()) {
                if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
                    locationManager.requestLocationUpdates(
                        LocationManager.GPS_PROVIDER,
                        2000, // 2 seconds
                        1.0f, // 1 meter
                        this
                    );
                    
                    statusText.setText("üåç GPS Ready - Waiting for location");
                    Log.d(TAG, "Location updates requested successfully");
                } else {
                    statusText.setText("‚ö†Ô∏è Please enable GPS");
                    Toast.makeText(this, "Please enable GPS for accurate tracking", Toast.LENGTH_LONG).show();
                }
            }
        } catch (SecurityException e) {
            Log.e(TAG, "Security exception requesting location updates: " + e.getMessage());
            statusText.setText("‚ùå Location permission required");
        }
    }

    @Override
    public void onLocationChanged(Location location) {
        try {
            if (location == null) return;

            // Update location display
            double speedMph = location.getSpeed() * 2.237; // Convert m/s to mph
            speedText.setText(String.format("Speed: %.1f mph", speedMph));
            accuracyText.setText(String.format("Accuracy: %.0f meters", location.getAccuracy()));

            // Process location for trip detection
            processLocationUpdate(location, speedMph);

            lastLocation = location;
            lastLocationTime = System.currentTimeMillis();

        } catch (Exception e) {
            Log.e(TAG, "Error processing location update: " + e.getMessage(), e);
        }
    }

    private void processLocationUpdate(Location location, double speedMph) {
        // Add to recent speeds for averaging
        recentSpeeds.add(speedMph);
        if (recentSpeeds.size() > SPEED_HISTORY_SIZE) {
            recentSpeeds.remove(0);
        }

        // Calculate average speed
        double avgSpeed = recentSpeeds.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);

        // Trip detection logic
        if (!isTracking && avgSpeed >= TRIP_START_SPEED_THRESHOLD) {
            consecutiveHighSpeedReadings++;
            consecutiveLowSpeedReadings = 0;

            if (consecutiveHighSpeedReadings >= CONSECUTIVE_READINGS_REQUIRED) {
                startAutomaticTrip(location);
            } else {
                statusText.setText(String.format("üö¶ Detecting movement... (%d/%d readings)", 
                    consecutiveHighSpeedReadings, CONSECUTIVE_READINGS_REQUIRED));
            }
        } else if (isTracking && avgSpeed <= TRIP_END_SPEED_THRESHOLD) {
            consecutiveLowSpeedReadings++;
            consecutiveHighSpeedReadings = 0;

            if (consecutiveLowSpeedReadings >= CONSECUTIVE_READINGS_REQUIRED) {
                endAutomaticTrip(location);
            } else {
                statusText.setText(String.format("üõë Slowing down... (%d/%d readings until stop)", 
                    consecutiveLowSpeedReadings, CONSECUTIVE_READINGS_REQUIRED));
            }
        } else {
            // Reset counters if speed is in middle range
            if (avgSpeed > TRIP_END_SPEED_THRESHOLD && avgSpeed < TRIP_START_SPEED_THRESHOLD) {
                consecutiveHighSpeedReadings = 0;
                consecutiveLowSpeedReadings = 0;
            }
        }

        // Update trip distance if tracking
        if (isTracking && lastLocation != null) {
            double distance = calculateDistance(lastLocation, location);
            totalDistance += distance;
            distanceText.setText(String.format("Trip Distance: %.2f miles", totalDistance));
            
            tripLocations.add(location);
        }
    }

    private void startAutomaticTrip(Location location) {
        if (currentTrip != null) return; // Already tracking

        isTracking = true;
        totalDistance = 0.0;
        tripLocations.clear();
        tripLocations.add(location);

        currentTrip = new Trip();
        currentTrip.setId(System.currentTimeMillis());
        currentTrip.setStartTime(System.currentTimeMillis());
        currentTrip.setStartLatitude(location.getLatitude());
        currentTrip.setStartLongitude(location.getLongitude());
        currentTrip.setStartLocation("Starting location...");
        currentTrip.setAutoDetected(true);

        statusText.setText("üöó Trip Started Automatically!");
        updateToggleButton();

        // Reverse geocode start location
        reverseGeocodeLocation(location.getLatitude(), location.getLongitude(), true);

        Log.d(TAG, "Automatic trip started at " + location.getLatitude() + ", " + location.getLongitude());
    }

    private void endAutomaticTrip(Location location) {
        if (currentTrip == null || !isTracking) return;

        isTracking = false;
        currentTrip.setEndTime(System.currentTimeMillis());
        currentTrip.setEndLatitude(location.getLatitude());
        currentTrip.setEndLongitude(location.getLongitude());
        currentTrip.setEndLocation("Ending location...");
        currentTrip.setDistance(totalDistance);
        currentTrip.setDuration(currentTrip.getEndTime() - currentTrip.getStartTime());
        currentTrip.setCategory("Personal"); // Default category

        // Reverse geocode end location
        reverseGeocodeLocation(location.getLatitude(), location.getLongitude(), false);

        // Save trip
        boolean saved = tripStorage.saveTrip(currentTrip);
        if (saved) {
            statusText.setText("‚úÖ Trip Completed: " + String.format("%.2f miles", totalDistance));
            
            // ENHANCED: Sync to API immediately
            Trip finalTrip = currentTrip;
            executorService.execute(() -> syncTripToAPI(finalTrip, "CREATE"));
            
            // Update displays after delay
            new Handler(Looper.getMainLooper()).postDelayed(() -> {
                if ("home".equals(currentTab)) {
                    updateRecentTrips();
                } else {
                    updateAllTrips();
                }
            }, 3000); // 3 second delay
        }

        currentTrip = null;
        totalDistance = 0.0;
        tripLocations.clear();
        consecutiveHighSpeedReadings = 0;
        consecutiveLowSpeedReadings = 0;
        updateToggleButton();

        Log.d(TAG, "Automatic trip ended, distance: " + totalDistance + " miles");
    }

    private void reverseGeocodeLocation(double latitude, double longitude, boolean isStartLocation) {
        // This is a simplified implementation
        // In a real app, you'd use Android's Geocoder or a web service
        executorService.execute(() -> {
            try {
                String locationName = String.format("%.4f, %.4f", latitude, longitude);
                
                runOnUiThread(() -> {
                    if (currentTrip != null) {
                        if (isStartLocation) {
                            currentTrip.setStartLocation(locationName);
                        } else {
                            currentTrip.setEndLocation(locationName);
                        }
                    }
                });
            } catch (Exception e) {
                Log.e(TAG, "Error reverse geocoding: " + e.getMessage());
            }
        });
    }

    private double calculateDistance(Location start, Location end) {
        double earthRadius = 3959; // miles

        double lat1Rad = Math.toRadians(start.getLatitude());
        double lat2Rad = Math.toRadians(end.getLatitude());
        double deltaLatRad = Math.toRadians(end.getLatitude() - start.getLatitude());
        double deltaLonRad = Math.toRadians(end.getLongitude() - start.getLongitude());

        double a = Math.sin(deltaLatRad/2) * Math.sin(deltaLatRad/2) +
                  Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                  Math.sin(deltaLonRad/2) * Math.sin(deltaLonRad/2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return earthRadius * c;
    }

    private void toggleManualTracking() {
        if (isTracking) {
            stopManualTracking();
        } else {
            startManualTracking();
        }
        updateToggleButton();
    }

    private void startManualTracking() {
        if (lastLocation == null) {
            Toast.makeText(this, "Waiting for GPS location...", Toast.LENGTH_SHORT).show();
            return;
        }

        isTracking = true;
        totalDistance = 0.0;
        tripLocations.clear();
        tripLocations.add(lastLocation);

        currentTrip = new Trip();
        currentTrip.setId(System.currentTimeMillis());
        currentTrip.setStartTime(System.currentTimeMillis());
        currentTrip.setStartLatitude(lastLocation.getLatitude());
        currentTrip.setStartLongitude(lastLocation.getLongitude());
        currentTrip.setStartLocation("Manual start location");
        currentTrip.setAutoDetected(false);

        statusText.setText("üöó Manual Trip Started");
        reverseGeocodeLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), true);

        Log.d(TAG, "Manual trip started");
    }

    private void stopManualTracking() {
        if (currentTrip == null || lastLocation == null) return;

        isTracking = false;
        currentTrip.setEndTime(System.currentTimeMillis());
        currentTrip.setEndLatitude(lastLocation.getLatitude());
        currentTrip.setEndLongitude(lastLocation.getLongitude());
        currentTrip.setEndLocation("Manual end location");
        currentTrip.setDistance(totalDistance);
        currentTrip.setDuration(currentTrip.getEndTime() - currentTrip.getStartTime());
        currentTrip.setCategory("Personal"); // Default category

        reverseGeocodeLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), false);

        boolean saved = tripStorage.saveTrip(currentTrip);
        if (saved) {
            statusText.setText("‚úÖ Manual Trip Saved: " + String.format("%.2f miles", totalDistance));
            
            // ENHANCED: Sync to API immediately
            Trip finalTrip = currentTrip;
            executorService.execute(() -> syncTripToAPI(finalTrip, "CREATE"));
            
            // Update displays
            new Handler(Looper.getMainLooper()).postDelayed(() -> {
                if ("home".equals(currentTab)) {
                    updateRecentTrips();
                } else {
                    updateAllTrips();
                }
            }, 2000);
        }

        currentTrip = null;
        totalDistance = 0.0;
        tripLocations.clear();

        Log.d(TAG, "Manual trip stopped and saved");
    }

    private void updateToggleButton() {
        if (isTracking) {
            toggleButton.setText("‚èπÔ∏è STOP TRIP");
            toggleButton.setBackgroundColor(0xFFEF4444); // Red
        } else {
            toggleButton.setText("‚ñ∂Ô∏è START TRIP");
            toggleButton.setBackgroundColor(0xFF059669); // Green
        }
    }

    private void startBackgroundLocationService() {
        Intent serviceIntent = new Intent(this, BackgroundLocationService.class);
        ContextCompat.startForegroundService(this, serviceIntent);
        Log.d(TAG, "Background location service started");
    }

    private void stopBackgroundLocationService() {
        Intent serviceIntent = new Intent(this, BackgroundLocationService.class);
        stopService(serviceIntent);
        Log.d(TAG, "Background location service stopped");
    }

    private void loadSettings() {
        SharedPreferences prefs = getSharedPreferences("MileTrackerSettings", MODE_PRIVATE);
        autoDetectionEnabled = prefs.getBoolean("auto_detection_enabled", false);
        
        // Start background service if auto detection was enabled
        if (autoDetectionEnabled) {
            startBackgroundLocationService();
        }
    }

    private void saveSettings() {
        SharedPreferences prefs = getSharedPreferences("MileTrackerSettings", MODE_PRIVATE);
        SharedPreferences.Editor editor = prefs.edit();
        editor.putBoolean("auto_detection_enabled", autoDetectionEnabled);
        editor.apply();
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        
        if (requestCode == LOCATION_PERMISSION_REQUEST_CODE) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                initializeLocationServices();
            } else {
                statusText.setText("‚ùå Location permission required");
                Toast.makeText(this, "Location permission is required for trip tracking", Toast.LENGTH_LONG).show();
            }
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        
        if (locationManager != null) {
            try {
                locationManager.removeUpdates(this);
            } catch (SecurityException e) {
                Log.e(TAG, "Error removing location updates: " + e.getMessage());
            }
        }
        
        LocalBroadcastManager.getInstance(this).unregisterReceiver(locationReceiver);
        
        if (executorService != null && !executorService.isShutdown()) {
            executorService.shutdown();
        }
    }

    // Required LocationListener methods
    @Override
    public void onStatusChanged(String provider, int status, Bundle extras) {}

    @Override
    public void onProviderEnabled(String provider) {
        Log.d(TAG, "Location provider enabled: " + provider);
        statusText.setText("üåç GPS Enabled");
    }

    @Override
    public void onProviderDisabled(String provider) {
        Log.d(TAG, "Location provider disabled: " + provider);
        statusText.setText("‚ö†Ô∏è GPS Disabled - Please enable location services");
    }
}

---
# android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java
package com.miletrackerpro.app.storage;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Log;
import com.miletrackerpro.app.model.Trip;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.util.*;

public class TripStorage {
    private static final String TAG = "TripStorage";
    private static final String PREFS_NAME = "MileTrackerTrips";
    private static final String TRIPS_KEY = "trips_data";
    
    private Context context;
    private SharedPreferences prefs;

    public TripStorage(Context context) {
        this.context = context;
        this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
    }

    public boolean saveTrip(Trip trip) {
        try {
            List<Trip> trips = getAllTrips();
            
            // Check if trip already exists (update scenario)
            boolean updated = false;
            for (int i = 0; i < trips.size(); i++) {
                if (trips.get(i).getId() == trip.getId()) {
                    trips.set(i, trip);
                    updated = true;
                    break;
                }
            }
            
            // If not updated, add as new trip
            if (!updated) {
                trips.add(0, trip); // Add at beginning (most recent first)
            }
            
            return saveAllTrips(trips);
            
        } catch (Exception e) {
            Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
            return false;
        }
    }

    public List<Trip> getAllTrips() {
        try {
            String tripsJson = prefs.getString(TRIPS_KEY, "[]");
            JSONArray jsonArray = new JSONArray(tripsJson);
            
            List<Trip> trips = new ArrayList<>();
            for (int i = 0; i < jsonArray.length(); i++) {
                JSONObject tripJson = jsonArray.getJSONObject(i);
                Trip trip = Trip.fromJson(tripJson);
                trips.add(trip);
            }
            
            // Sort by start time descending (most recent first)
            Collections.sort(trips, (a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
            
            Log.d(TAG, "Loaded " + trips.size() + " trips from storage");
            return trips;
            
        } catch (Exception e) {
            Log.e(TAG, "Error loading trips: " + e.getMessage(), e);
            return new ArrayList<>();
        }
    }

    // ENHANCED: Update trip method with local storage only (API sync handled separately)
    public boolean updateTrip(Trip trip) {
        try {
            List<Trip> trips = getAllTrips();
            boolean found = false;
            
            for (int i = 0; i < trips.size(); i++) {
                if (trips.get(i).getId() == trip.getId()) {
                    trips.set(i, trip);
                    found = true;
                    break;
                }
            }
            
            if (found) {
                saveAllTrips(trips);
                // Note: API sync will be handled by existing CloudBackupService
                return true;
            } else {
                Log.w(TAG, "Trip not found for update: ID " + trip.getId());
                return false;
            }
            
        } catch (Exception e) {
            Log.e(TAG, "Error updating trip: " + e.getMessage(), e);
            return false;
        }
    }

    // ENHANCED: Delete trip method with local storage only (API sync handled separately)
    public boolean deleteTrip(long tripId) {
        try {
            List<Trip> trips = getAllTrips();
            boolean found = false;
            Trip deletedTrip = null;
            
            Iterator<Trip> iterator = trips.iterator();
            while (iterator.hasNext()) {
                Trip trip = iterator.next();
                if (trip.getId() == tripId) {
                    deletedTrip = trip;
                    iterator.remove();
                    found = true;
                    break;
                }
            }
            
            if (found) {
                saveAllTrips(trips);
                // Note: API sync will be handled by existing CloudBackupService
                return true;
            } else {
                Log.w(TAG, "Trip not found for deletion: ID " + tripId);
                return false;
            }
            
        } catch (Exception e) {
            Log.e(TAG, "Error deleting trip: " + e.getMessage(), e);
            return false;
        }
    }

    // ENHANCED: Merge trips from API without duplicates
    public void mergeTripsFromAPI(List<Trip> apiTrips) {
        try {
            List<Trip> localTrips = getAllTrips();
            Set<Long> localTripIds = new HashSet<>();
            
            // Get all local trip IDs
            for (Trip trip : localTrips) {
                localTripIds.add(trip.getId());
            }
            
            // Add API trips that don't exist locally
            for (Trip apiTrip : apiTrips) {
                if (!localTripIds.contains(apiTrip.getId())) {
                    localTrips.add(apiTrip);
                }
            }
            
            // Sort by start time descending
            Collections.sort(localTrips, (a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
            
            saveAllTrips(localTrips);
            Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " total trips");
            
        } catch (Exception e) {
            Log.e(TAG, "Error merging API trips: " + e.getMessage(), e);
        }
    }

    private boolean saveAllTrips(List<Trip> trips) {
        try {
            JSONArray jsonArray = new JSONArray();
            for (Trip trip : trips) {
                jsonArray.put(trip.toJson());
            }
            
            SharedPreferences.Editor editor = prefs.edit();
            editor.putString(TRIPS_KEY, jsonArray.toString());
            boolean success = editor.commit();
            
            if (success) {
                Log.d(TAG, "Saved " + trips.size() + " trips to storage");
            } else {
                Log.e(TAG, "Failed to save trips to SharedPreferences");
            }
            
            return success;
            
        } catch (Exception e) {
            Log.e(TAG, "Error saving all trips: " + e.getMessage(), e);
            return false;
        }
    }

    public void clearAllTrips() {
        SharedPreferences.Editor editor = prefs.edit();
        editor.remove(TRIPS_KEY);
        editor.apply();
        Log.d(TAG, "All trips cleared from storage");
    }

    public int getTripCount() {
        return getAllTrips().size();
    }

    public double getTotalMileage() {
        List<Trip> trips = getAllTrips();
        double total = 0.0;
        for (Trip trip : trips) {
            total += trip.getDistance();
        }
        return total;
    }
}

---
# android/app/src/main/res/values/ids.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item name="recent_trips_container" type="id" />
    <item name="trips_layout" type="id" />
</resources>

---
# android/app/src/main/res/values/styles.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="AppTheme" parent="@android:style/Theme.Material.Light.DarkActionBar">
        <item name="android:colorPrimary">#667eea</item>
        <item name="android:colorPrimaryDark">#5a67d8</item>
        <item name="android:colorAccent">#667eea</item>
        <item name="android:windowBackground">@android:color/white</item>
        <item name="android:statusBarColor">#5a67d8</item>
    </style>
</resources>

---
# android/build.gradle
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.1.4'
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

---
# android/app/build.gradle
plugins {
    id 'com.android.application'
}

android {
    namespace 'com.miletrackerpro.app'
    compileSdk 35
    
    defaultConfig {
        applicationId "com.miletrackerpro.app"
        minSdk 24
        targetSdk 35
        versionCode 49050
        versionName "4.9.50"
    }
    
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.core:core:1.12.0'
    implementation 'androidx.localbroadcastmanager:localbroadcastmanager:1.1.0'
    implementation 'com.google.android.material:material:1.11.0'
}

---
# android/gradle/wrapper/gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

---
# android/settings.gradle
pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MileTracker Pro"
include ':app'
