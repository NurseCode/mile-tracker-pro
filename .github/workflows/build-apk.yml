name: DATA SYNC FIELD MAPPING FIXED - v4.9.73

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create consistent signing keystore
        run: |
          cd android/app
          keytool -genkey -v -keystore miletracker.keystore -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker, L=City, S=State, C=US"

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 49073
                  versionName "4.9.73-data-sync-fixed"
              }

              signingConfigs {
                  release {
                      storeFile file("miletracker.keystore")
                      storePassword "miletracker123"
                      keyAlias "miletracker"
                      keyPassword "miletracker123"
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.release
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name=".MainActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="${applicationId}.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <files-path name="files" path="." />
              <cache-path name="cache" path="." />
              <external-files-path name="external_files" path="." />
              <external-cache-path name="external_cache" path="." />
          </paths>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#667eea</color>
              <color name="primary_dark">#5a6fd8</color>
              <color name="accent">#667eea</color>
              <color name="white">#FFFFFF</color>
              <color name="light_gray">#F5F5F5</color>
              <color name="gray">#E0E0E0</color>
              <color name="dark_gray">#666666</color>
              <color name="black">#000000</color>
              <color name="green">#4CAF50</color>
              <color name="orange">#FF9800</color>
              <color name="red">#F44336</color>
          </resources>
          EOF

          # Default launcher icon
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24"
              android:viewportHeight="24"
              android:tint="#667eea">
            <path
                android:fillColor="@android:color/white"
                android:pathData="M19,3H5C3.9,3 3,3.9 3,5v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2V5C21,3.9 20.1,3 19,3zM5,19V5h14v14H5z"/>
            <path
                android:fillColor="@android:color/white"
                android:pathData="M17.5,8.5c0,0.83 -0.67,1.5 -1.5,1.5s-1.5,-0.67 -1.5,-1.5S15.17,7 16,7S17.5,7.67 17.5,8.5z"/>
            <path
                android:fillColor="@android:color/white"
                android:pathData="M13,17l-3,-4 -2,3h10l-3,-4z"/>
          </vector>
          EOF

      - name: Create UserAuthManager
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import org.json.JSONObject;
          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStreamWriter;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.security.MessageDigest;
          import java.security.NoSuchAlgorithmException;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app/api";
              private static final String PREFS_NAME = "UserAuthPrefs";
              private static final String AUTH_TOKEN_KEY = "auth_token";
              private static final String USER_EMAIL_KEY = "user_email";
              private static final String USER_ID_KEY = "user_id";
              
              private Context context;
              private SharedPreferences prefs;
              private ExecutorService executor;
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  this.executor = Executors.newSingleThreadExecutor();
              }
              
              public interface AuthCallback {
                  void onSuccess(String authToken, String userEmail, int userId);
                  void onError(String errorMessage);
              }
              
              public void authenticateUser(String email, String password, AuthCallback callback) {
                  executor.execute(() -> {
                      try {
                          // Hash password for transmission
                          String hashedPassword = hashPassword(password);
                          
                          // Create JSON payload
                          JSONObject authJson = new JSONObject();
                          authJson.put("email", email);
                          authJson.put("password", hashedPassword);
                          
                          // Send to authentication endpoint
                          String response = postToAPI("/auth/login", authJson.toString());
                          
                          // Parse response
                          JSONObject responseJson = new JSONObject(response);
                          if (responseJson.has("authToken")) {
                              String authToken = responseJson.getString("authToken");
                              String userEmail = responseJson.getString("userEmail");
                              int userId = responseJson.getInt("userId");
                              
                              // Store authentication data
                              storeAuthData(authToken, userEmail, userId);
                              
                              Log.d(TAG, "Authentication successful for: " + userEmail);
                              callback.onSuccess(authToken, userEmail, userId);
                          } else {
                              String error = responseJson.optString("error", "Authentication failed");
                              Log.e(TAG, "Authentication failed: " + error);
                              callback.onError(error);
                          }
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Authentication error: " + e.getMessage());
                          callback.onError("Network error: " + e.getMessage());
                      }
                  });
              }
              
              public boolean isUserAuthenticated() {
                  String authToken = prefs.getString(AUTH_TOKEN_KEY, null);
                  String userEmail = prefs.getString(USER_EMAIL_KEY, null);
                  return authToken != null && userEmail != null;
              }
              
              public String getAuthToken() {
                  return prefs.getString(AUTH_TOKEN_KEY, null);
              }
              
              public String getUserEmail() {
                  return prefs.getString(USER_EMAIL_KEY, null);
              }
              
              public int getUserId() {
                  return prefs.getInt(USER_ID_KEY, -1);
              }
              
              public void logout() {
                  prefs.edit()
                      .remove(AUTH_TOKEN_KEY)
                      .remove(USER_EMAIL_KEY)
                      .remove(USER_ID_KEY)
                      .apply();
                  Log.d(TAG, "User logged out");
              }
              
              private void storeAuthData(String authToken, String userEmail, int userId) {
                  prefs.edit()
                      .putString(AUTH_TOKEN_KEY, authToken)
                      .putString(USER_EMAIL_KEY, userEmail)
                      .putInt(USER_ID_KEY, userId)
                      .apply();
              }
              
              private String hashPassword(String password) {
                  try {
                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(password.getBytes());
                      StringBuilder hexString = new StringBuilder();
                      
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }
                      
                      return hexString.toString();
                  } catch (NoSuchAlgorithmException e) {
                      Log.e(TAG, "Error hashing password", e);
                      return password; // Fallback to plain text (not recommended for production)
                  }
              }
              
              private String postToAPI(String endpoint, String jsonData) throws Exception {
                  URL url = new URL(API_BASE_URL + endpoint);
                  HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                  
                  conn.setRequestMethod("POST");
                  conn.setRequestProperty("Content-Type", "application/json");
                  conn.setRequestProperty("User-Agent", "MileTracker-Pro-Android");
                  conn.setDoOutput(true);
                  conn.setConnectTimeout(10000);
                  conn.setReadTimeout(15000);
                  
                  // Send JSON data
                  try (OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream())) {
                      writer.write(jsonData);
                      writer.flush();
                  }
                  
                  // Read response
                  StringBuilder response = new StringBuilder();
                  try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                      String line;
                      while ((line = reader.readLine()) != null) {
                          response.append(line);
                      }
                  }
                  
                  return response.toString();
              }
              
              public void shutdown() {
                  if (executor != null && !executor.isShutdown()) {
                      executor.shutdown();
                  }
              }
          }
          EOF

      - name: Create CloudBackupService with corrected field mapping
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.provider.Settings;
          import android.util.Log;
          import org.json.JSONObject;
          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStreamWriter;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.util.TimeZone;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          /**
           * MileTracker Pro - Cloud Backup Service
           * CRITICAL FIX: Uses correct field names to prevent data corruption
           * Field mapping corrected to match API expectations exactly
           */
          public class CloudBackupService {
              private static final String TAG = "CloudBackup";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app/api";
              private static final String PREFS_NAME = "CloudBackupPrefs";
              private static final String DEVICE_ID_KEY = "device_id";
              
              private Context context;
              private String deviceId;
              private String userTimezone;
              private ExecutorService executor;
              private SharedPreferences prefs;
              
              public CloudBackupService(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  this.userTimezone = TimeZone.getDefault().getID();
                  this.executor = Executors.newSingleThreadExecutor();
                  this.deviceId = getOrCreateDeviceId();
                  
                  Log.d(TAG, "Initialized with device ID: " + deviceId + ", timezone: " + userTimezone);
              }
              
              private String getOrCreateDeviceId() {
                  String existingId = prefs.getString(DEVICE_ID_KEY, null);
                  
                  if (existingId != null) {
                      return existingId;
                  }
                  
                  String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                  String newDeviceId = "android_" + androidId.substring(0, Math.min(androidId.length(), 16));
                  
                  prefs.edit().putString(DEVICE_ID_KEY, newDeviceId).apply();
                  
                  return newDeviceId;
              }
              
              /**
               * CRITICAL FIX: Backup trip with CORRECT field names
               * Field mapping now matches API expectations exactly
               */
              public void backupTrip(Trip trip) {
                  executor.execute(() -> {
                      try {
                          JSONObject tripJson = new JSONObject();
                          
                          // FIXED: Use correct field names that match API expectations
                          tripJson.put("device_id", deviceId);                           // NOT "deviceId"
                          tripJson.put("start_location", trip.getStartAddress());        // NOT "startAddress"
                          tripJson.put("end_location", trip.getEndAddress());            // NOT "endAddress" 
                          tripJson.put("start_latitude", trip.getStartLatitude());
                          tripJson.put("start_longitude", trip.getStartLongitude());
                          tripJson.put("end_latitude", trip.getEndLatitude());
                          tripJson.put("end_longitude", trip.getEndLongitude());
                          tripJson.put("distance", trip.getDistance());
                          tripJson.put("duration", trip.getDuration());
                          tripJson.put("start_time", trip.getStartTime());
                          tripJson.put("end_time", trip.getEndTime());
                          tripJson.put("category", trip.getCategory());
                          tripJson.put("auto_detected", trip.isAutoDetected());          // NOT "isAutoDetected"
                          tripJson.put("client_name", trip.getClientName() != null ? trip.getClientName() : "");
                          tripJson.put("notes", trip.getNotes() != null ? trip.getNotes() : "");
                          tripJson.put("user_id", 13); // pcates@catesconsultinggroup.com
                          
                          String response = postToAPI("/trips", tripJson.toString());
                          Log.d(TAG, "Trip backed up successfully with corrected field mapping: " + response);
                          
                      } catch (Exception e) {
                          Log.w(TAG, "Backup failed (continuing with local storage): " + e.getMessage());
                          // Graceful failure - app continues working with local storage
                      }
                  });
              }
              
              public void updateTripAddresses(long tripId, String startAddress, String endAddress) {
                  executor.execute(() -> {
                      try {
                          JSONObject updateJson = new JSONObject();
                          updateJson.put("device_id", deviceId);
                          updateJson.put("start_location", startAddress);    // FIXED: correct field name
                          updateJson.put("end_location", endAddress);        // FIXED: correct field name
                          
                          String response = patchToAPI("/trips/" + tripId + "/addresses", updateJson.toString());
                          Log.d(TAG, "Addresses updated: " + response);
                          
                      } catch (Exception e) {
                          Log.w(TAG, "Address update failed: " + e.getMessage());
                      }
                  });
              }
              
              private String postToAPI(String endpoint, String jsonData) throws Exception {
                  URL url = new URL(API_BASE_URL + endpoint);
                  HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                  
                  conn.setRequestMethod("POST");
                  conn.setRequestProperty("Content-Type", "application/json");
                  conn.setRequestProperty("User-Agent", "MileTracker-Pro-Android");
                  conn.setDoOutput(true);
                  conn.setConnectTimeout(5000);
                  conn.setReadTimeout(10000);
                  
                  try (OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream())) {
                      writer.write(jsonData);
                      writer.flush();
                  }
                  
                  StringBuilder response = new StringBuilder();
                  try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                      String line;
                      while ((line = reader.readLine()) != null) {
                          response.append(line);
                      }
                  }
                  
                  return response.toString();
              }
              
              private String patchToAPI(String endpoint, String jsonData) throws Exception {
                  URL url = new URL(API_BASE_URL + endpoint);
                  HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                  
                  conn.setRequestMethod("PATCH");
                  conn.setRequestProperty("Content-Type", "application/json");
                  conn.setRequestProperty("User-Agent", "MileTracker-Pro-Android");
                  conn.setDoOutput(true);
                  conn.setConnectTimeout(5000);
                  conn.setReadTimeout(10000);
                  
                  try (OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream())) {
                      writer.write(jsonData);
                      writer.flush();
                  }
                  
                  StringBuilder response = new StringBuilder();
                  try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                      String line;
                      while ((line = reader.readLine()) != null) {
                          response.append(line);
                      }
                  }
                  
                  return response.toString();
              }
              
              public void shutdown() {
                  if (executor != null && !executor.isShutdown()) {
                      executor.shutdown();
                  }
              }
          }
          EOF
