name: BLUETOOTH VEHICLE RECOGNITION - v4.9.147

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create consistent signing keystore
        run: |
          cd android/app
          # Remove existing keystore if it exists
          rm -f miletracker.keystore
          # Create new keystore with consistent credentials and date
          keytool -genkey -v -keystore miletracker.keystore -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker Pro LLC, L=Charlotte, S=NC, C=US"

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 49147
                  versionName "4.9.147"
              }

              signingConfigs {
                  release {
                      storeFile file("miletracker.keystore")
                      storePassword "miletracker123"
                      keyAlias "miletracker"
                      keyPassword "miletracker123"
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.release
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              implementation 'org.json:json:20231013'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
              implementation 'com.itextpdf:itext7-core:7.2.5'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />
              <uses-permission android:name="android.permission.BLUETOOTH" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
              <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
              <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name=".MainActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="${applicationId}.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">mileage-tracker-codenurse.replit.app</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <files-path name="files" path="." />
              <cache-path name="cache" path="." />
              <external-files-path name="external_files" path="." />
              <external-cache-path name="external_cache" path="." />
          </paths>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#667eea</color>
              <color name="primary_dark">#5a6fd8</color>
              <color name="accent">#667eea</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
              <color name="success">#28a745</color>
              <color name="danger">#dc3545</color>
              <color name="warning">#ffc107</color>
              <color name="tab_active">#667eea</color>
              <color name="tab_inactive">#9CA3AF</color>
              <color name="background">#f5f5f5</color>
              <color name="card_background">#ffffff</color>
              <color name="text_primary">#495057</color>
              <color name="text_secondary">#6C757D</color>
          </resources>
          EOF

      - name: Copy BluetoothVehicleService from repository
        run: |
          cp BluetoothVehicleService.java android/app/src/main/java/com/miletrackerpro/app/services/BluetoothVehicleService.java

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "BluetoothVehicleService";
              private static final String PREFS_NAME = "bluetooth_vehicle_prefs";

              private Context context;
              private BluetoothAdapter bluetoothAdapter;
              private Map<String, VehicleInfo> vehicleRegistry;
              private VehicleInfo currentVehicle;

              public interface VehicleConnectionListener {
                  void onVehicleConnected(VehicleInfo vehicle);
                  void onVehicleDisconnected(VehicleInfo vehicle);
              }

              private VehicleConnectionListener connectionListener;

              public BluetoothVehicleService(Context context) {
                  this.context = context;
                  this.vehicleRegistry = new HashMap<>();
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
                  this.bluetoothAdapter = bluetoothManager.getAdapter();
                  
                  registerBluetoothReceiver();
              }

              public void setConnectionListener(VehicleConnectionListener listener) {
                  this.connectionListener = listener;
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              private void registerBluetoothReceiver() {
                  IntentFilter filter = new IntentFilter();
                  filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
                  filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
                  context.registerReceiver(bluetoothReceiver, filter);
              }

              private final BroadcastReceiver bluetoothReceiver = new BroadcastReceiver() {
                  @Override
                  public void onReceive(Context context, Intent intent) {
                      String action = intent.getAction();
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      
                      if (device != null && vehicleRegistry.containsKey(device.getAddress())) {
                          VehicleInfo vehicle = vehicleRegistry.get(device.getAddress());
                          
                          if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
                              handleVehicleConnected(vehicle);
                          } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                              handleVehicleDisconnected(vehicle);
                          }
                      }
                  }
              };

              private void handleVehicleConnected(VehicleInfo vehicle) {
                  currentVehicle = vehicle;
                  Log.d(TAG, "Vehicle connected: " + vehicle.deviceName);
                  
                  if (connectionListener != null) {
                      connectionListener.onVehicleConnected(vehicle);
                  }
              }

              private void handleVehicleDisconnected(VehicleInfo vehicle) {
                  if (currentVehicle != null && currentVehicle.macAddress.equals(vehicle.macAddress)) {
                      currentVehicle = null;
                      Log.d(TAG, "Vehicle disconnected: " + vehicle.deviceName);
                      
                      if (connectionListener != null) {
                          connectionListener.onVehicleDisconnected(vehicle);
                      }
                  }
              }

              public void registerVehicle(String macAddress, String deviceName, String vehicleType) {
                  VehicleInfo vehicle = new VehicleInfo(macAddress, deviceName, vehicleType);
                  vehicleRegistry.put(macAddress, vehicle);
                  Log.d(TAG, "Vehicle registered: " + deviceName);
              }

              public void unregisterVehicle(String macAddress) {
                  VehicleInfo vehicle = vehicleRegistry.remove(macAddress);
                  if (vehicle != null) {
                      Log.d(TAG, "Vehicle unregistered: " + vehicle.deviceName);
                  }
              }

              public Map<String, VehicleInfo> getRegisteredVehicles() {
                  return new HashMap<>(vehicleRegistry);
              }

              public VehicleInfo getCurrentVehicle() {
                  return currentVehicle;
              }

              public void destroy() {
                  try {
                      context.unregisterReceiver(bluetoothReceiver);
                  } catch (IllegalArgumentException e) {
                      Log.w(TAG, "Bluetooth receiver already unregistered");
                  }
              }

              public static class VehicleInfo {
                  public String macAddress;
                  public String deviceName;
                  public String vehicleType;
                  public String suggestedCategory;

                  public VehicleInfo(String macAddress, String deviceName, String vehicleType) {
                      this.macAddress = macAddress;
                      this.deviceName = deviceName;
                      this.vehicleType = vehicleType;
                      this.suggestedCategory = "Business".equals(vehicleType) ? "Business" : "Personal";
                  }
              }
          }
          EOF

      - name: Create red car icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24.0"
              android:viewportHeight="24.0">
              <path
                  android:fillColor="#dc3545"
                  android:pathData="M18.92,6.01C18.72,5.42 18.16,5 17.5,5h-11C5.84,5 5.28,5.42 5.08,6.01L3,12v8c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-1h12v1c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-8L18.92,6.01zM6.5,16C5.67,16 5,15.33 5,14.5S5.67,13 6.5,13S8,13.67 8,14.5S7.33,16 6.5,16zM17.5,16c-0.83,0 -1.5,-0.67 -1.5,-1.5s0.67,-1.5 1.5,-1.5s1.5,0.67 1.5,1.5S18.33,16 17.5,16zM5,11l1.5,-4.5h11L19,11H5z"/>
          </vector>
          EOF

      - name: Create DeviceIdentification utility for stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/DeviceIdentification.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;

          import java.security.MessageDigest;
          import java.util.UUID;

          public class DeviceIdentification {
              private static final String TAG = "DeviceIdentification";
              private static final String PREFS_NAME = "DeviceIdentificationPrefs";
              private static final String STABLE_DEVICE_ID_KEY = "stable_device_id";
              private static final String USER_ID_KEY = "user_id";

              public static String getStableDeviceId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String stableId = prefs.getString(STABLE_DEVICE_ID_KEY, null);

                  if (stableId == null) {
                      stableId = generateStableDeviceId(context);
                      prefs.edit().putString(STABLE_DEVICE_ID_KEY, stableId).apply();
                      Log.d(TAG, "Generated new stable device ID: " + stableId);
                  }

                  return stableId;
              }

              public static String getUserId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String userId = prefs.getString(USER_ID_KEY, null);

                  if (userId == null) {
                      userId = generateUserId(context);
                      prefs.edit().putString(USER_ID_KEY, userId).apply();
                      Log.d(TAG, "Generated new user ID: " + userId);
                  }

                  return userId;
              }

              private static String generateStableDeviceId(Context context) {
                  try {
                      // Use Android ID (persists across app installs but not device resets)
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);

                      // Create a stable identifier using device characteristics
                      String deviceInfo = androidId + "-" + Build.MODEL + "-" + Build.MANUFACTURER;

                      // Hash it to create a consistent device ID
                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(deviceInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "device-" + hexString.toString().substring(0, 16);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating stable device ID", e);
                      // Fallback to random UUID if all else fails
                      return "device-" + UUID.randomUUID().toString().replace("-", "").substring(0, 16);
                  }
              }

              private static String generateUserId(Context context) {
                  try {
                      // Create a user ID that's stable across app installs
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                      String userInfo = androidId + "-user-" + Build.MODEL;

                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(userInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "user-" + hexString.toString().substring(0, 12);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating user ID", e);
                      return "user-" + UUID.randomUUID().toString().replace("-", "").substring(0, 12);
                  }
              }
          }
          EOF

      - name: Create OkHttp UserAuthManager for real API authentication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;
          import okhttp3.*;
          import okhttp3.logging.HttpLoggingInterceptor;
          import org.json.JSONObject;
          import java.io.IOException;
          import java.security.MessageDigest;
          import java.security.SecureRandom;
          import java.util.UUID;
          import java.util.concurrent.TimeUnit;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_AUTH_TOKEN = "auth_token";
              private static final String KEY_USER_ID = "user_id";
              private static final String KEY_DEVICE_EMAIL = "device_email";
              private static final String KEY_DEVICE_NAME = "device_name";
              private static final String KEY_SESSION_TOKEN = "session_token";
              
              private Context context;
              private SharedPreferences prefs;
              private OkHttpClient okHttpClient;
              
              // API endpoints - corrected production URL
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              private static final String LOGIN_ENDPOINT = "/api/auth/login";
              private static final String REGISTER_ENDPOINT = "/api/register";
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Initialize OkHttp with logging (from working version)
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor(message -> {
                      Log.d(TAG, "OkHttp: " + message);
                  });
                  logging.setLevel(HttpLoggingInterceptor.Level.HEADERS);
                  
                  this.okHttpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(15, TimeUnit.SECONDS)
                      .readTimeout(15, TimeUnit.SECONDS)
                      .writeTimeout(15, TimeUnit.SECONDS)
                      .build();
              }
              
              public boolean loginWithOkHttp(String email, String password) {
                  Log.d(TAG, "ðŸ” OKHTTP LOGIN for: '" + email + "'");
                  Log.d(TAG, "Password received: '" + password + "' (length: " + (password != null ? password.length() : "null") + ")");
                  Log.d(TAG, "Target URL: " + API_BASE_URL + LOGIN_ENDPOINT);
                  
                  // Log network state
                  logNetworkState();
                  
                  try {
                      // Create JSON payload
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      Log.d(TAG, "JSON payload: " + loginData.toString());
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          loginData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + LOGIN_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      Log.d(TAG, "ðŸŒ OkHttp Request URL: " + request.url());
                      Log.d(TAG, "ðŸŒ OkHttp Request Headers: " + request.headers());
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "ðŸŒ OkHttp Response code: " + response.code());
                          Log.d(TAG, "ðŸŒ OkHttp Response message: " + response.message());
                          Log.d(TAG, "ðŸŒ OkHttp Response headers: " + response.headers());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "ðŸŒ OkHttp Response body: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              boolean success = responseJson.optBoolean("success", false);
                              Log.d(TAG, "OkHttp response success field: " + success);
                              
                              if (success) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  Log.d(TAG, "OkHttp token received: " + (token.isEmpty() ? "empty" : "[" + token.length() + " chars]"));
                                  Log.d(TAG, "OkHttp user ID: '" + userId + "'");
                                  
                                  // Generate device information for family sharing
                                  String deviceEmail = email; // Use login email for device identification
                                  String deviceName = buildDeviceName();
                                  String sessionToken = generateSessionToken();
                                  
                                  Log.d(TAG, "Multi-device info - Email: " + deviceEmail + ", Device: " + deviceName);
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .putString(KEY_DEVICE_EMAIL, deviceEmail)
                                       .putString(KEY_DEVICE_NAME, deviceName)
                                       .putString(KEY_SESSION_TOKEN, sessionToken)
                                       .apply();
                                  
                                  Log.d(TAG, "âœ… OKHTTP login successful for: " + email);
                                  return true;
                              } else {
                                  String message = responseJson.optString("message", "Unknown error");
                                  Log.d(TAG, "âŒ OKHTTP login failed - success=false, message: " + message);
                              }
                          } else {
                              String errorBody = "";
                              try {
                                  errorBody = response.body().string();
                              } catch (Exception ex) {
                                  Log.d(TAG, "Could not read OkHttp error response: " + ex.getMessage());
                              }
                              Log.d(TAG, "âŒ OKHTTP login failed - HTTP " + response.code() + ", Error body: " + errorBody);
                          }
                      }
                      
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP login exception: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean registerWithOkHttp(String email, String password, String name) {
                  Log.d(TAG, "ðŸ“ OKHTTP registration for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("name", name);
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          registerData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + REGISTER_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "OKHTTP registration response code: " + response.code());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "OKHTTP registration response: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              if (responseJson.optBoolean("success", false)) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .apply();
                                  
                                  Log.d(TAG, "âœ… OKHTTP registration successful for: " + email);
                                  return true;
                              }
                          }
                          
                          Log.d(TAG, "âŒ OKHTTP registration failed - HTTP " + response.code());
                          return false;
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP registration error: " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public String getNetworkDiagnostics() {
                  StringBuilder info = new StringBuilder();
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          info.append("Network Type: ").append(activeNetwork.getTypeName()).append("\n");
                          info.append("Connected: ").append(activeNetwork.isConnected()).append("\n");
                          info.append("Available: ").append(activeNetwork.isAvailable()).append("\n");
                          info.append("HTTP Stack: OkHttp enabled\n");
                      } else {
                          info.append("No active network");
                      }
                  } catch (Exception e) {
                      info.append("Network check failed: ").append(e.getMessage());
                  }
                  return info.toString();
              }
              
              // Multi-device family sharing helper methods
              private String buildDeviceName() {
                  String manufacturer = Build.MANUFACTURER;
                  String model = Build.MODEL;
                  if (model.startsWith(manufacturer)) {
                      return model;
                  } else {
                      return manufacturer + " " + model;
                  }
              }
              
              private String generateSessionToken() {
                  return "session_" + UUID.randomUUID().toString().replace("-", "");
              }
              
              public String getDeviceEmail() {
                  return prefs.getString(KEY_DEVICE_EMAIL, "");
              }
              
              public String getDeviceName() {
                  return prefs.getString(KEY_DEVICE_NAME, buildDeviceName());
              }
              
              public String getSessionToken() {
                  return prefs.getString(KEY_SESSION_TOKEN, "");
              }
              
              public void showDeviceManagementDialog() {
                  // TODO: Implement device management dialog for Professional tier users
                  // Shows list of active devices when limit is reached
                  Log.d(TAG, "Device management dialog - Professional tier feature");
              }
              
              private void logNetworkState() {
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          Log.d(TAG, "ðŸŒ Network Type: " + activeNetwork.getTypeName());
                          Log.d(TAG, "ðŸŒ Network State: " + activeNetwork.getState());
                          Log.d(TAG, "ðŸŒ Network Connected: " + activeNetwork.isConnected());
                          Log.d(TAG, "ðŸŒ Network Available: " + activeNetwork.isAvailable());
                          Log.d(TAG, "ðŸŒ HTTP Stack: OkHttp v4.12.0");
                      } else {
                          Log.d(TAG, "ðŸŒ No active network detected");
                      }
                  } catch (Exception e) {
                      Log.d(TAG, "ðŸŒ Network state check failed: " + e.getMessage());
                  }
              }
              
              public boolean isLoggedIn() {
                  String email = prefs.getString(KEY_USER_EMAIL, "");
                  String token = prefs.getString(KEY_AUTH_TOKEN, "");
                  boolean loggedIn = !email.isEmpty() && !token.isEmpty();
                  Log.d(TAG, "isLoggedIn check: email=" + (!email.isEmpty()) + ", token=" + (!token.isEmpty()) + " -> " + loggedIn);
                  return loggedIn;
              }
              
              public String getCurrentUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }
              
              public String getAuthToken() {
                  return prefs.getString(KEY_AUTH_TOKEN, "");
              }
              
              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }
              
              public void logout() {
                  Log.d(TAG, "Logging out user");
                  prefs.edit().clear().apply();
              }

              // Add missing register method for AuthActivity compatibility
              public boolean register(String email, String password, String name) {
                  return registerWithOkHttp(email, password, name);
              }

              // Add missing recoverDataWithCredentials method for DataRecoveryActivity compatibility
              public boolean recoverDataWithCredentials(String email, String password) {
                  return loginWithOkHttp(email, password);
              }
          }
          EOF

      - name: Create Authentication Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;
          import android.graphics.Typeface;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private UserAuthManager authManager;
              private LinearLayout mainLayout;
              private boolean isLoginMode = true;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);

                  // If already logged in, go to main app
                  if (authManager.isLoggedIn()) {
                      goToMainApp();
                      return;
                  }

                  createAuthLayout();
              }

              private void createAuthLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(0, 0, 0, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // White header section with car icon and title
                  LinearLayout titleLayout = new LinearLayout(this);
                  titleLayout.setOrientation(LinearLayout.HORIZONTAL);
                  titleLayout.setBackgroundColor(0xFFFFFFFF);
                  titleLayout.setPadding(20, 40, 20, 20);
                  titleLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  TextView titleText = new TextView(this);
                  titleText.setText("ðŸš— MileTracker Pro");
                  titleText.setTextSize(24);
                  titleText.setTextColor(0xFF495057);
                  titleText.setTypeface(null, Typeface.BOLD);
                  titleLayout.addView(titleText);
                  
                  mainLayout.addView(titleLayout);

                  // Version text removed per user request

                  // Benefits explanation in white section
                  LinearLayout benefitsLayout = new LinearLayout(this);
                  benefitsLayout.setOrientation(LinearLayout.VERTICAL);
                  benefitsLayout.setBackgroundColor(0xFFFFFFFF);
                  benefitsLayout.setPadding(20, 0, 20, 30);
                  
                  TextView benefitsText = new TextView(this);
                  benefitsText.setText("âœ… Keep your trips safe across all devices\nâœ… Automatic backup and sync\nâœ… Recover data if phone is lost/stolen\nâœ… No constant sign-ins required");
                  benefitsText.setTextSize(14);
                  benefitsText.setTextColor(0xFF495057);
                  benefitsText.setPadding(15, 15, 15, 15);
                  benefitsText.setBackgroundColor(0xFFe8f5e8);
                  benefitsLayout.addView(benefitsText);
                  
                  mainLayout.addView(benefitsLayout);

                  showAuthForm();

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void showAuthForm() {
                  // Clear form area (now accounting for 2 sections: white header, white benefits)
                  if (mainLayout.getChildCount() > 2) {
                      for (int i = mainLayout.getChildCount() - 1; i >= 2; i--) {
                          mainLayout.removeViewAt(i);
                      }
                  }

                  // Mode toggle
                  TextView modeText = new TextView(this);
                  modeText.setText(isLoginMode ? "Login to Your Account" : "Create New Account");
                  modeText.setTextSize(20);
                  modeText.setTextColor(0xFF495057);
                  modeText.setGravity(Gravity.CENTER);
                  modeText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(modeText);

                  // Email field
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email Address:");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF495057);
                  emailLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(emailLabel);

                  EditText emailField = new EditText(this);
                  emailField.setHint("your.email@example.com");
                  emailField.setText("pcates@catesconsultinggroup.com");
                  emailField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(15, 15, 15, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password:");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF495057);
                  passwordLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(passwordLabel);

                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Your secure password");
                  passwordField.setText("password123");
                  passwordField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(15, 15, 15, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 15);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Name field (registration only)
                  EditText nameField = null;
                  if (!isLoginMode) {
                      TextView nameLabel = new TextView(this);
                      nameLabel.setText("Your Name:");
                      nameLabel.setTextSize(16);
                      nameLabel.setTextColor(0xFF495057);
                      nameLabel.setPadding(0, 0, 0, 5);
                      mainLayout.addView(nameLabel);

                      nameField = new EditText(this);
                      nameField.setHint("John Smith");
                      nameField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PERSON_NAME);
                      nameField.setTextSize(16);
                      nameField.setPadding(15, 15, 15, 15);
                      nameField.setBackgroundColor(0xFFFFFFFF);
                      LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      nameParams.setMargins(0, 0, 0, 15);
                      nameField.setLayoutParams(nameParams);
                      mainLayout.addView(nameField);
                  }

                  // Primary action button
                  Button primaryButton = new Button(this);
                  primaryButton.setText(isLoginMode ? "Login" : "Create Account");
                  primaryButton.setBackgroundColor(0xFF667eea);
                  primaryButton.setTextColor(0xFFFFFFFF);
                  primaryButton.setTextSize(18);
                  primaryButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams primaryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  primaryParams.setMargins(0, 10, 0, 15);
                  primaryButton.setLayoutParams(primaryParams);

                  EditText finalNameField = nameField;
                  primaryButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      if (isLoginMode) {
                          handleLogin(email, password);
                      } else {
                          String name = finalNameField != null ? finalNameField.getText().toString().trim() : "";
                          if (name.isEmpty()) {
                              Toast.makeText(this, "Please enter your name", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          handleRegistration(email, password, name);
                      }
                  });
                  mainLayout.addView(primaryButton);

                  // Mode toggle button
                  Button toggleButton = new Button(this);
                  toggleButton.setText(isLoginMode ? "Need an account? Sign up" : "Already have an account? Login");
                  toggleButton.setBackgroundColor(0x00000000);
                  toggleButton.setTextColor(0xFF667eea);
                  toggleButton.setTextSize(16);
                  LinearLayout.LayoutParams toggleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  toggleParams.setMargins(0, 10, 0, 20);
                  toggleButton.setLayoutParams(toggleParams);
                  toggleButton.setOnClickListener(v -> {
                      isLoginMode = !isLoginMode;
                      showAuthForm();
                  });
                  mainLayout.addView(toggleButton);

                  // Data recovery link
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("ðŸ”„ Lost device? Recover your data");
                  recoveryButton.setBackgroundColor(0x00000000);
                  recoveryButton.setTextColor(0xFF28a745);
                  recoveryButton.setTextSize(14);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoveryParams.setMargins(0, 20, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "OkHttp login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== OKHTTP LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread using OkHttp
                  new Thread(() -> {
                      Log.d(TAG, "Starting OkHttp login thread...");
                      boolean loginResult = authManager.loginWithOkHttp(email, password);
                      Log.d(TAG, "OkHttp login result: " + loginResult);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Toast.makeText(this, "Welcome back! ðŸš— (OkHttp Success)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Login failed. Check logs for OkHttp diagnostic info.", Toast.LENGTH_LONG).show();
                              Log.d(TAG, "âŒ OkHttp login failed - check connection routing");
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  if (authManager.register(email, password, name)) {
                      Toast.makeText(this, "Account created successfully! ðŸŽ‰", Toast.LENGTH_SHORT).show();
                      goToMainApp();
                  } else {
                      Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }

              private void goToDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create Data Recovery Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);
                  createRecoveryLayout();
              }

              private void createRecoveryLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("ðŸ“±ðŸ’” Data Recovery");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF495057);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(headerText);

                  // Explanation
                  TextView explanationText = new TextView(this);
                  explanationText.setText("Lost your phone, upgraded devices, or need to reinstall?\n\nEnter your email and password to recover ALL your trip data and mileage history.\n\nThis works even if your old device was stolen or broken.");
                  explanationText.setTextSize(14);
                  explanationText.setTextColor(0xFF6C757D);
                  explanationText.setPadding(15, 15, 15, 15);
                  explanationText.setBackgroundColor(0xFFfff3cd);
                  LinearLayout.LayoutParams explanationParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  explanationParams.setMargins(0, 0, 0, 30);
                  explanationText.setLayoutParams(explanationParams);
                  mainLayout.addView(explanationText);

                  TextView formTitle = new TextView(this);
                  formTitle.setText("Recover Your Trip Data");
                  formTitle.setTextSize(18);
                  formTitle.setTextColor(0xFF495057);
                  formTitle.setPadding(0, 0, 0, 15);
                  mainLayout.addView(formTitle);

                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Your email address");
                  emailInput.setText("pcates@catesconsultinggroup.com");
                  emailInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Your password");
                  passwordInput.setText("password123");
                  passwordInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  Button recoverButton = new Button(this);
                  recoverButton.setText("ðŸ”„ Recover My Trip Data");
                  recoverButton.setTextSize(16);
                  recoverButton.setBackgroundColor(0xFF28a745);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      performDataRecovery(email, password);
                  });
                  mainLayout.addView(recoverButton);

                  // Back button
                  Button backButton = new Button(this);
                  backButton.setText("â† Back to Sign In");
                  backButton.setTextSize(14);
                  backButton.setBackgroundColor(0xFF667eea);
                  backButton.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backParams.setMargins(0, 15, 0, 0);
                  backButton.setLayoutParams(backParams);
                  backButton.setOnClickListener(v -> {
                      finish(); // Go back to AuthActivity
                  });
                  mainLayout.addView(backButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void performDataRecovery(String email, String password) {
                  try {
                      // Show progress
                      Toast.makeText(this, "Recovering your data...", Toast.LENGTH_SHORT).show();

                      boolean success = authManager.recoverDataWithCredentials(email, password);

                      if (success) {
                          // Success message
                          Toast.makeText(this, "SUCCESS! Your trip data is being restored. This includes ALL your historical trips, even from previous devices.", Toast.LENGTH_LONG).show();

                          // Go to main app
                          Intent intent = new Intent(this, MainActivity.class);
                          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                          startActivity(intent);
                          finish();

                      } else {
                          Toast.makeText(this, "Recovery failed. Please check your email and password, or create a new account if you're a new user.", Toast.LENGTH_LONG).show();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Data recovery error", e);
                      Toast.makeText(this, "Recovery error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
          }
          EOF

      - name: Create Trip class - EXACT COPY FROM WORKING VERSION
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long duration;
              private String category;
              private long startTime;
              private long endTime;
              private boolean autoDetected;
              private String clientName;
              private String notes;
              private String roundTripGroupId;
              private boolean isRoundTrip;
              private int roundTripSegment; // 1=outbound, 2=return, 0=not part of round trip

              public Trip() {
                  this.category = "Uncategorized";
                  this.autoDetected = false;
                  this.clientName = null;
                  this.notes = null;
                  this.roundTripGroupId = null;
                  this.isRoundTrip = false;
                  this.roundTripSegment = 0;
              }

              // All getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getRoundTripGroupId() { return roundTripGroupId; }
              public void setRoundTripGroupId(String roundTripGroupId) { this.roundTripGroupId = roundTripGroupId; }

              public boolean isRoundTrip() { return isRoundTrip; }
              public void setRoundTrip(boolean roundTrip) { isRoundTrip = roundTrip; }

              public int getRoundTripSegment() { return roundTripSegment; }
              public void setRoundTripSegment(int roundTripSegment) { this.roundTripSegment = roundTripSegment; }

              // Formatted display methods
              public String getFormattedDate() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDuration() {
                  long minutes = duration / (60 * 1000);
                  if (minutes < 60) {
                      return minutes + "m";
                  } else {
                      long hours = minutes / 60;
                      long remainingMinutes = minutes % 60;
                      return hours + "h " + remainingMinutes + "m";
                  }
              }

              public String getFormattedStartTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getCompactDateTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDateTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedEndTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(endTime));
              }
          }
          EOF

      - name: Create TripStorage with stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.utils.DeviceIdentification;
          import org.json.JSONArray;
          import org.json.JSONObject;

          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Comparator;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerPrefs";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              private static final String LAST_API_SYNC_KEY = "last_api_sync";
              private static final String CUSTOM_CATEGORIES_KEY = "custom_categories";

              private SharedPreferences prefs;
              private Context context;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public String getStableDeviceId() {
                  return DeviceIdentification.getStableDeviceId(context);
              }

              public String getUserId() {
                  // Use authenticated user's database ID, not device ID
                  UserAuthManager authManager = new UserAuthManager(context);
                  String authUserId = authManager.getUserId();
                  if (!authUserId.isEmpty()) {
                      return authUserId;
                  }
                  // Fallback to device ID only if not authenticated
                  return DeviceIdentification.getUserId(context);
              }

              public boolean isAutoDetectionEnabled() {
                  return prefs.getBoolean(AUTO_DETECTION_KEY, false);
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  prefs.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, true);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
                  Log.d(TAG, "API sync enabled: " + enabled);
              }

              public long getLastApiSyncTime() {
                  return prefs.getLong(LAST_API_SYNC_KEY, 0);
              }

              public void setLastApiSyncTime(long timestamp) {
                  prefs.edit().putLong(LAST_API_SYNC_KEY, timestamp).apply();
              }

              // Custom categories management
              public List<String> getCustomCategories() {
                  try {
                      String customCategoriesJson = prefs.getString(CUSTOM_CATEGORIES_KEY, "[]");
                      JSONArray jsonArray = new JSONArray(customCategoriesJson);
                      List<String> categories = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          categories.add(jsonArray.getString(i));
                      }
                      return categories;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting custom categories", e);
                      return new ArrayList<>();
                  }
              }

              public void addCustomCategory(String category) {
                  try {
                      List<String> categories = getCustomCategories();
                      if (!categories.contains(category) && !category.trim().isEmpty()) {
                          categories.add(category.trim());
                          saveCustomCategories(categories);
                          Log.d(TAG, "Added custom category: " + category);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding custom category", e);
                  }
              }

              public void removeCustomCategory(String category) {
                  try {
                      List<String> categories = getCustomCategories();
                      if (categories.remove(category)) {
                          saveCustomCategories(categories);
                          Log.d(TAG, "Removed custom category: " + category);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error removing custom category", e);
                  }
              }

              private void saveCustomCategories(List<String> categories) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (String category : categories) {
                          jsonArray.put(category);
                      }
                      prefs.edit().putString(CUSTOM_CATEGORIES_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving custom categories", e);
                  }
              }

              public List<String> getAllCategories() {
                  List<String> allCategories = new ArrayList<>();
                  // Add default categories
                  allCategories.add("Business");
                  allCategories.add("Personal");
                  allCategories.add("Medical");
                  allCategories.add("Charity");
                  // Add custom categories
                  allCategories.addAll(getCustomCategories());
                  return allCategories;
              }



              public void saveTrip(Trip trip) {
                  try {
                      if (trip.getId() == 0) {
                          trip.setId(trip.getStartTime() > 0 ? trip.getStartTime() : System.currentTimeMillis());
                      }

                      Log.d(TAG, "Saving trip: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                            " (Distance: " + trip.getDistance() + " miles)");

                      List<Trip> trips = getAllTrips();

                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }

                      if (!updated) {
                          trips.add(trip);
                      }

                      saveAllTrips(trips);
                      Log.d(TAG, updated ? "Trip updated: " + trip.getId() : "Trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      // Remove from local storage
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      
                      // Delete from API if available
                      new Thread(() -> {
                          try {
                              java.net.URL url = new java.net.URL("https://mileage-tracker-codenurse.replit.app/api/trips/" + tripId);
                              java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
                              conn.setRequestMethod("DELETE");
                              // Get current user email from SharedPreferences (same pattern as auth system)
                              SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                              String userEmail = authPrefs.getString("user_email", "");
                              if (!userEmail.isEmpty()) {
                                  conn.setRequestProperty("X-User-Email", userEmail);
                              } else {
                                  Log.w(TAG, "No user email available for DELETE request");
                                  return;
                              }
                              conn.setRequestProperty("Content-Type", "application/json");
                              conn.setConnectTimeout(5000);
                              conn.setReadTimeout(5000);
                              
                              int responseCode = conn.getResponseCode();
                              Log.d(TAG, "Trip deleted from API: " + tripId + ", Response: " + responseCode);
                              conn.disconnect();
                          } catch (Exception e) {
                              Log.w(TAG, "Could not delete trip from API: " + e.getMessage());
                          }
                      }).start();
                      
                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              // Method to merge API trips with local trips
              public void mergeApiTrips(List<Trip> apiTrips) {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      List<Trip> mergedTrips = new ArrayList<>();

                      // Start with local trips
                      mergedTrips.addAll(localTrips);

                      // Add API trips that don't exist locally
                      for (Trip apiTrip : apiTrips) {
                          boolean exists = false;
                          for (Trip localTrip : localTrips) {
                              // Check if trip already exists (same start time, distance, and locations)
                              if (Math.abs(localTrip.getStartTime() - apiTrip.getStartTime()) < 60000 && // Within 1 minute
                                  Math.abs(localTrip.getDistance() - apiTrip.getDistance()) < 0.1 &&
                                  (localTrip.getStartAddress() != null && localTrip.getStartAddress().equals(apiTrip.getStartAddress()))) {
                                  exists = true;
                                  break;
                              }
                          }

                          if (!exists) {
                              mergedTrips.add(apiTrip);
                              Log.d(TAG, "Added API trip: " + apiTrip.getStartAddress() + " â†’ " + apiTrip.getEndAddress());
                          }
                      }

                      saveAllTrips(mergedTrips);
                      setLastApiSyncTime(System.currentTimeMillis());
                      Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " local trips");

                  } catch (Exception e) {
                      Log.e(TAG, "Error merging API trips", e);
                  }
              }

              // User trip merge functionality - combines selected trips into one
              public Trip mergeUserTrips(List<String> tripIds) {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      List<Trip> tripsToMerge = new ArrayList<>();
                      
                      // Find trips to merge by ID
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              for (Trip trip : allTrips) {
                                  if (trip.getId() == id) {
                                      tripsToMerge.add(trip);
                                      break;
                                  }
                              }
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format: " + tripId);
                          }
                      }
                      
                      if (tripsToMerge.size() < 2) {
                          Log.w(TAG, "Need at least 2 trips to merge");
                          return null;
                      }
                      
                      // Sort trips by start time
                      Collections.sort(tripsToMerge, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t1.getStartTime(), t2.getStartTime());
                          }
                      });
                      
                      // Create merged trip using existing Trip structure
                      Trip firstTrip = tripsToMerge.get(0);
                      Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);
                      
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(System.currentTimeMillis());
                      mergedTrip.setStartTime(firstTrip.getStartTime());
                      mergedTrip.setEndTime(lastTrip.getEndTime());
                      mergedTrip.setStartAddress(firstTrip.getStartAddress());
                      mergedTrip.setEndAddress(lastTrip.getEndAddress());
                      mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                      mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                      mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                      mergedTrip.setEndLongitude(lastTrip.getEndLongitude());

                      // Calculate total distance
                      double totalDistance = 0;
                      for (Trip trip : tripsToMerge) {
                          totalDistance += trip.getDistance();
                      }
                      mergedTrip.setDistance(totalDistance);
                      
                      // Calculate total duration
                      long totalDuration = lastTrip.getEndTime() - firstTrip.getStartTime();
                      mergedTrip.setDuration(totalDuration);
                      
                      // Use category from first trip, or "Business" if mixed
                      String category = firstTrip.getCategory();
                      for (Trip trip : tripsToMerge) {
                          if (!trip.getCategory().equals(category)) {
                              category = "Business";
                              break;
                          }
                      }
                      mergedTrip.setCategory(category);
                      
                      // Combine client info  
                      StringBuilder clientBuilder = new StringBuilder();
                      for (Trip trip : tripsToMerge) {
                          if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                              if (clientBuilder.length() > 0) clientBuilder.append(", ");
                              clientBuilder.append(trip.getClientName());
                          }
                      }
                      mergedTrip.setClientName(clientBuilder.toString());
                      
                      mergedTrip.setNotes("Merged from " + tripsToMerge.size() + " trips");
                      mergedTrip.setAutoDetected(false);
                      
                      // Save merged trip and delete originals
                      saveTrip(mergedTrip);
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              deleteTrip(id);
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format for deletion: " + tripId);
                          }
                      }
                      
                      Log.d(TAG, "Successfully merged " + tripsToMerge.size() + " trips into: " + mergedTrip.getId());
                      return mergedTrip;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging user trips", e);
                      return null;
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray array = new JSONArray(tripsJson);

                      for (int i = 0; i < array.length(); i++) {
                          JSONObject obj = array.getJSONObject(i);
                          Trip trip = new Trip();

                          trip.setId(obj.optLong("id", 0));
                          trip.setStartAddress(obj.optString("start_location", ""));
                          trip.setEndAddress(obj.optString("end_location", ""));
                          trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                          trip.setDistance(obj.optDouble("distance", 0));
                          trip.setDuration(obj.optLong("duration", 0));
                          trip.setCategory(obj.optString("category", "Uncategorized"));
                          trip.setStartTime(obj.optLong("start_time", 0));
                          trip.setEndTime(obj.optLong("end_time", 0));
                          trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                          trip.setClientName(obj.optString("client_name", ""));
                          trip.setNotes(obj.optString("notes", ""));

                          trips.add(trip);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip == null) {
                          prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                          Log.d(TAG, "Current trip cleared");
                          return;
                      }

                      JSONObject obj = new JSONObject();
                      obj.put("id", trip.getId());
                      obj.put("start_location", trip.getStartAddress());
                      obj.put("end_location", trip.getEndAddress());
                      obj.put("start_latitude", trip.getStartLatitude());
                      obj.put("start_longitude", trip.getStartLongitude());
                      obj.put("end_latitude", trip.getEndLatitude());
                      obj.put("end_longitude", trip.getEndLongitude());
                      obj.put("distance", trip.getDistance());
                      obj.put("duration", trip.getDuration());
                      obj.put("category", trip.getCategory());
                      obj.put("start_time", trip.getStartTime());
                      obj.put("end_time", trip.getEndTime());
                      obj.put("auto_detected", trip.isAutoDetected());
                      obj.put("client_name", trip.getClientName());
                      obj.put("notes", trip.getNotes());

                      prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String currentTripJson = prefs.getString(CURRENT_TRIP_KEY, null);
                      if (currentTripJson == null) return null;

                      JSONObject obj = new JSONObject(currentTripJson);
                      Trip trip = new Trip();

                      trip.setId(obj.optLong("id", 0));
                      trip.setStartAddress(obj.optString("start_location", ""));
                      trip.setEndAddress(obj.optString("end_location", ""));
                      trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                      trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                      trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                      trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                      trip.setDistance(obj.optDouble("distance", 0));
                      trip.setDuration(obj.optLong("duration", 0));
                      trip.setCategory(obj.optString("category", "Uncategorized"));
                      trip.setStartTime(obj.optLong("start_time", 0));
                      trip.setEndTime(obj.optLong("end_time", 0));
                      trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                      trip.setClientName(obj.optString("client_name", ""));
                      trip.setNotes(obj.optString("notes", ""));

                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                      return null;
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray array = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject obj = new JSONObject();
                          obj.put("id", trip.getId());
                          obj.put("start_location", trip.getStartAddress());
                          obj.put("end_location", trip.getEndAddress());
                          obj.put("start_latitude", trip.getStartLatitude());
                          obj.put("start_longitude", trip.getStartLongitude());
                          obj.put("end_latitude", trip.getEndLatitude());
                          obj.put("end_longitude", trip.getEndLongitude());
                          obj.put("distance", trip.getDistance());
                          obj.put("duration", trip.getDuration());
                          obj.put("category", trip.getCategory());
                          obj.put("start_time", trip.getStartTime());
                          obj.put("end_time", trip.getEndTime());
                          obj.put("auto_detected", trip.isAutoDetected());
                          obj.put("client_name", trip.getClientName());
                          obj.put("notes", trip.getNotes());
                          array.put(obj);
                      }
                      prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }
              
              // Work Hours Auto-Classification Methods
              private static final String WORK_HOURS_ENABLED_KEY = "work_hours_enabled";
              private static final String WORK_START_TIME_KEY = "work_start_time";
              private static final String WORK_END_TIME_KEY = "work_end_time";
              private static final String WORK_DAYS_KEY = "work_days";
              
              public boolean isWorkHoursEnabled() {
                  return prefs.getBoolean(WORK_HOURS_ENABLED_KEY, false);
              }
              
              public void setWorkHoursEnabled(boolean enabled) {
                  prefs.edit().putBoolean(WORK_HOURS_ENABLED_KEY, enabled).apply();
              }
              
              public String getWorkStartTime() {
                  return prefs.getString(WORK_START_TIME_KEY, "09:00");
              }
              
              public void setWorkStartTime(String startTime) {
                  prefs.edit().putString(WORK_START_TIME_KEY, startTime).apply();
              }
              
              public String getWorkEndTime() {
                  return prefs.getString(WORK_END_TIME_KEY, "17:00");
              }
              
              public void setWorkEndTime(String endTime) {
                  prefs.edit().putString(WORK_END_TIME_KEY, endTime).apply();
              }
              
              public List<Integer> getWorkDays() {
                  try {
                      String workDaysJson = prefs.getString(WORK_DAYS_KEY, "[2,3,4,5,6]"); // Default Mon-Fri
                      JSONArray jsonArray = new JSONArray(workDaysJson);
                      List<Integer> workDays = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          workDays.add(jsonArray.getInt(i));
                      }
                      return workDays;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading work days", e);
                      // Default to Monday-Friday
                      List<Integer> defaultDays = new ArrayList<>();
                      defaultDays.add(2); // Monday
                      defaultDays.add(3); // Tuesday
                      defaultDays.add(4); // Wednesday
                      defaultDays.add(5); // Thursday
                      defaultDays.add(6); // Friday
                      return defaultDays;
                  }
              }
              
              public void setWorkDays(List<Integer> workDays) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (Integer day : workDays) {
                          jsonArray.put(day);
                      }
                      prefs.edit().putString(WORK_DAYS_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving work days", e);
                  }
              }
              
              public boolean isWithinWorkHours(long timestamp) {
                  if (!isWorkHoursEnabled()) {
                      return false;
                  }
                  
                  try {
                      java.util.Calendar calendar = java.util.Calendar.getInstance();
                      calendar.setTimeInMillis(timestamp);
                      
                      // Check if it's a work day
                      int dayOfWeek = calendar.get(java.util.Calendar.DAY_OF_WEEK);
                      List<Integer> workDays = getWorkDays();
                      if (!workDays.contains(dayOfWeek)) {
                          return false;
                      }
                      
                      // Check if it's within work hours
                      int hour = calendar.get(java.util.Calendar.HOUR_OF_DAY);
                      int minute = calendar.get(java.util.Calendar.MINUTE);
                      int currentTimeMinutes = hour * 60 + minute;
                      
                      String startTime = getWorkStartTime();
                      String endTime = getWorkEndTime();
                      
                      String[] startParts = startTime.split(":");
                      int startHour = Integer.parseInt(startParts[0]);
                      int startMinute = Integer.parseInt(startParts[1]);
                      int startTimeMinutes = startHour * 60 + startMinute;
                      
                      String[] endParts = endTime.split(":");
                      int endHour = Integer.parseInt(endParts[0]);
                      int endMinute = Integer.parseInt(endParts[1]);
                      int endTimeMinutes = endHour * 60 + endMinute;
                      
                      return currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error checking work hours", e);
                      return false;
                  }
              }
              
              // Round-trip detection methods
              public List<List<Trip>> getRoundTripGroups() {
                  try {
                      List<List<Trip>> groups = new ArrayList<>();
                      List<Trip> allTrips = getAllTrips();
                      
                      for (Trip trip : allTrips) {
                          if (trip.isRoundTrip() && trip.getRoundTripGroupId() != null) {
                              String groupId = trip.getRoundTripGroupId();
                              boolean foundGroup = false;
                              
                              for (List<Trip> group : groups) {
                                  if (!group.isEmpty() && groupId.equals(group.get(0).getRoundTripGroupId())) {
                                      group.add(trip);
                                      foundGroup = true;
                                      break;
                                  }
                              }
                              
                              if (!foundGroup) {
                                  List<Trip> newGroup = new ArrayList<>();
                                  newGroup.add(trip);
                                  groups.add(newGroup);
                              }
                          }
                      }
                      
                      // Sort trips within each group by segment number
                      for (List<Trip> group : groups) {
                          Collections.sort(group, (t1, t2) -> Integer.compare(t1.getRoundTripSegment(), t2.getRoundTripSegment()));
                      }
                      
                      return groups;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting round trip groups", e);
                      return new ArrayList<>();
                  }
              }
              
              public void detectRoundTrips() {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      Collections.sort(allTrips, (t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));
                      
                      String groupId = String.valueOf(System.currentTimeMillis());
                      
                      // Level 1: Daily round-trips (Aâ†’Bâ†’A same day)
                      for (int i = 0; i < allTrips.size() - 1; i++) {
                          Trip trip1 = allTrips.get(i);
                          Trip trip2 = allTrips.get(i + 1);
                          
                          if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;
                          
                          double distance = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                  trip2.getEndLatitude(), trip2.getEndLongitude());
                          
                          long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                          
                          if (distance <= 0.5 && timeDiff <= 12 * 60 * 60 * 1000) { // 0.5 miles, 12 hours
                              trip1.setRoundTripGroupId(groupId);
                              trip1.setRoundTrip(true);
                              trip1.setRoundTripSegment(1);
                              
                              trip2.setRoundTripGroupId(groupId);
                              trip2.setRoundTrip(true);
                              trip2.setRoundTripSegment(2);
                              
                              saveTrip(trip1);
                              saveTrip(trip2);
                              
                              groupId = String.valueOf(System.currentTimeMillis() + 1);
                          }
                      }
                      
                      // Level 2: Multi-day business trips with airports
                      for (int i = 0; i < allTrips.size() - 2; i++) {
                          Trip trip1 = allTrips.get(i);
                          Trip trip2 = allTrips.get(i + 1);
                          Trip trip3 = allTrips.get(i + 2);
                          
                          if (trip1.isRoundTrip() || trip2.isRoundTrip() || trip3.isRoundTrip()) continue;
                          
                          boolean hasAirport = isAirportLocation(trip1.getEndAddress()) || 
                                             isAirportLocation(trip2.getStartAddress()) ||
                                             isAirportLocation(trip2.getEndAddress()) ||
                                             isAirportLocation(trip3.getStartAddress());
                          
                          if (hasAirport) {
                              double homeToAirport = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                      trip3.getEndLatitude(), trip3.getEndLongitude());
                              
                              long tripDuration = trip3.getEndTime() - trip1.getStartTime();
                              
                              if (homeToAirport <= 1.0 && tripDuration <= 7 * 24 * 60 * 60 * 1000) { // 1 mile, 7 days
                                  trip1.setRoundTripGroupId(groupId);
                                  trip1.setRoundTrip(true);
                                  trip1.setRoundTripSegment(1);
                                  
                                  trip2.setRoundTripGroupId(groupId);
                                  trip2.setRoundTrip(true);
                                  trip2.setRoundTripSegment(2);
                                  
                                  trip3.setRoundTripGroupId(groupId);
                                  trip3.setRoundTrip(true);
                                  trip3.setRoundTripSegment(3);
                                  
                                  saveTrip(trip1);
                                  saveTrip(trip2);
                                  saveTrip(trip3);
                                  
                                  groupId = String.valueOf(System.currentTimeMillis() + 2);
                              }
                          }
                      }
                      
                      Log.d(TAG, "Round-trip detection completed");
                  } catch (Exception e) {
                      Log.e(TAG, "Error in round-trip detection", e);
                  }
              }
              
              private boolean isAirportLocation(String address) {
                  if (address == null) return false;
                  String lowerAddress = address.toLowerCase();
                  return lowerAddress.contains("airport") || lowerAddress.contains("airfield") || 
                         lowerAddress.contains("international") || lowerAddress.contains("terminal");
              }
              
              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Radius of earth in kilometers
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c; // Distance in km
                  return distance * 0.621371; // Convert to miles
              }
          }
          EOF

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app/api";

              private Context context;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.executor = Executors.newSingleThreadExecutor();
              }

              // UPLOAD FUNCTIONALITY
              public void backupTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping backup");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting API backup for trip: " + trip.getId());

                          URL url = new URL(API_BASE_URL + "/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          // Use authenticated user's email and token dynamically
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          String jsonPayload = createTripJson(trip, null, tripStorage.getUserId());

                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API backup response: " + responseCode);

                          if (responseCode == 200 || responseCode == 201) {
                              Log.d(TAG, "Trip backed up successfully to API");
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip to API", e);
                      }
                  });
              }

              // DOWNLOAD ALL USER TRIPS (not just device-specific)
              public void downloadAllUserTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping download");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          String userId = tripStorage.getUserId();
                          Log.d(TAG, "Starting download ALL trips for user: " + userId);

                          // Download ALL trips from the API (not device-specific)
                          String apiUrl = API_BASE_URL + "/trips";
                          URL url = new URL(apiUrl);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          // Use authenticated user's email and token dynamically
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API download ALL trips response: " + responseCode);

                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(
                                      new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }

                              List<Trip> apiTrips = parseTripsFromJson(response.toString());
                              Log.d(TAG, "Downloaded " + apiTrips.size() + " trips from API (all user trips)");

                              if (!apiTrips.isEmpty()) {
                                  tripStorage.mergeApiTrips(apiTrips);
                                  Log.d(TAG, "Successfully merged API trips");
                              }
                          } else {
                              Log.w(TAG, "API download failed with code: " + responseCode);
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error downloading trips from API", e);
                      }
                  });
              }

              private List<Trip> parseTripsFromJson(String jsonResponse) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      // Handle server response format: { trips: [...] }
                      JSONObject responseObj = new JSONObject(jsonResponse);
                      JSONArray tripsArray = responseObj.optJSONArray("trips");
                      
                      // Fallback to direct array if no "trips" property
                      if (tripsArray == null) {
                          tripsArray = new JSONArray(jsonResponse);
                      }

                      for (int i = 0; i < tripsArray.length(); i++) {
                          JSONObject tripObj = tripsArray.getJSONObject(i);
                          Trip trip = new Trip();

                          // Parse API response fields - handle actual database structure
                          trip.setId(tripObj.optLong("id", System.currentTimeMillis()));
                          
                          // Address fields - server returns start_location/end_location (encrypted)
                          String startAddr = tripObj.optString("start_location", "Unknown");
                          String endAddr = tripObj.optString("end_location", "Unknown");
                          
                          // If still encrypted (contains colons), show coordinates instead
                          if (startAddr.contains(":")) {
                              double lat = tripObj.optDouble("start_latitude", 0);
                              double lng = tripObj.optDouble("start_longitude", 0);
                              startAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          if (endAddr.contains(":")) {
                              double lat = tripObj.optDouble("end_latitude", 0);
                              double lng = tripObj.optDouble("end_longitude", 0);
                              endAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          
                          trip.setStartAddress(startAddr);
                          trip.setEndAddress(endAddr);
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0));
                          
                          // Distance
                          trip.setDistance(tripObj.optDouble("distance", 0));
                          
                          // Duration - keep in milliseconds (as expected by Trip class)
                          long durationMs = tripObj.optLong("duration", 0);
                          trip.setDuration(durationMs);
                          
                          // Parse timestamps for trip date
                          String startTimeStr = tripObj.optString("start_time", "");
                          if (!startTimeStr.isEmpty()) {
                              long startTime = parseTimestamp(startTimeStr);
                              trip.setStartTime(startTime);
                          }
                          
                          trip.setCategory(tripObj.optString("category", "Uncategorized"));
                          
                          // Auto detection status
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          
                          // Client and notes - handle encrypted values
                          String clientName = tripObj.optString("client_name", "");
                          if (clientName.contains(":")) clientName = ""; // Skip encrypted values
                          trip.setClientName(clientName);
                          
                          String notes = tripObj.optString("notes", "");
                          if (notes.contains(":")) notes = ""; // Skip encrypted values
                          trip.setNotes(notes);

                          // Parse timestamps - use the timestamps from API
                          long startTime = tripObj.optLong("start_time", System.currentTimeMillis());
                          long endTime = tripObj.optLong("end_time", System.currentTimeMillis());

                          trip.setStartTime(startTime);
                          trip.setEndTime(endTime);

                          trips.add(trip);
                          Log.d(TAG, "Parsed API trip: " + trip.getStartAddress() + " â†’ " + trip.getEndAddress());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips JSON", e);
                  }
                  return trips;
              }
              
              private long parseTimestamp(String timestampStr) {
                  try {
                      if (timestampStr == null || timestampStr.isEmpty()) return 0;
                      
                      // Handle ISO timestamp format from database
                      if (timestampStr.contains("T")) {
                          return java.time.Instant.parse(timestampStr).toEpochMilli();
                      }
                      
                      // Handle epoch milliseconds
                      return Long.parseLong(timestampStr);
                  } catch (Exception e) {
                      Log.w(TAG, "Failed to parse timestamp: " + timestampStr);
                      return 0;
                  }
              }

              private String createTripJson(Trip trip, String deviceId, String userId) {
                  try {
                      return String.format(Locale.getDefault(),
                          "{"
                          + "\"start_location\":\"%s\","
                          + "\"end_location\":\"%s\","
                          + "\"start_latitude\":%.8f,"
                          + "\"start_longitude\":%.8f,"
                          + "\"end_latitude\":%.8f,"
                          + "\"end_longitude\":%.8f,"
                          + "\"distance\":%.6f,"
                          + "\"duration\":%d,"
                          + "\"category\":\"%s\","
                          + "\"auto_detected\":%s,"
                          + "\"start_time\":%d,"
                          + "\"end_time\":%d,"
                          + "\"client_name\":\"%s\","
                          + "\"notes\":\"%s\","
                          + "\"timezone\":\"America/New_York\""
                          + "}",
                          trip.getStartAddress() != null ? trip.getStartAddress().replace("\"", "\\\"") : "",
                          trip.getEndAddress() != null ? trip.getEndAddress().replace("\"", "\\\"") : "",
                          trip.getStartLatitude(),
                          trip.getStartLongitude(),
                          trip.getEndLatitude(),
                          trip.getEndLongitude(),
                          trip.getDistance(),
                          trip.getDuration(),
                          trip.getCategory(),
                          trip.isAutoDetected(),
                          trip.getStartTime(),
                          trip.getEndTime(),
                          trip.getClientName() != null ? trip.getClientName().replace("\"", "\\\"") : "",
                          trip.getNotes() != null ? trip.getNotes().replace("\"", "\\\"") : ""
                      );
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating trip JSON", e);
                      return "{}";
                  }
              }

              // ADVANCED ROUND-TRIP DETECTION SYSTEM
              // Superior to MileIQ's primitive A->B->A detection
              
              /**
               * Detects potential round-trip patterns using multi-level clustering
               * Level 1: Daily round-trips (hotel->meeting->hotel)
               * Level 2: Trip segments (home->airport->destination)
               * Level 3: Complete trip groups (multi-day business trips)
               */
              public void detectRoundTrips() {
                  try {
                      List<Trip> recentTrips = getAllTrips();
                      if (recentTrips.size() < 2) return;

                      // Sort by start time for chronological analysis
                      Collections.sort(recentTrips, (t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));

                      // Detect different types of round trips
                      detectDailyRoundTrips(recentTrips);
                      detectMultiDayRoundTrips(recentTrips);
                      detectComplexTripGroups(recentTrips);

                      Log.d(TAG, "Round-trip detection completed");
                  } catch (Exception e) {
                      Log.e(TAG, "Error detecting round trips", e);
                  }
              }

              /**
               * Detects same-day round trips (A->B->A within 2-12 hours)
               * Example: Hotel->Meeting->Hotel, Home->Office->Home
               */
              private void detectDailyRoundTrips(List<Trip> trips) {
                  for (int i = 0; i < trips.size() - 1; i++) {
                      Trip trip1 = trips.get(i);
                      Trip trip2 = trips.get(i + 1);

                      // Skip if already part of a round trip
                      if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;

                      // Check if trips are within 12 hours
                      long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                      if (timeDiff > 12 * 60 * 60 * 1000) continue; // 12 hours max

                      // Check if start/end locations form A->B->A pattern
                      if (isLocationMatch(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                        trip2.getEndLatitude(), trip2.getEndLongitude(), 200) &&
                          isLocationMatch(trip1.getEndLatitude(), trip1.getEndLongitude(),
                                        trip2.getStartLatitude(), trip2.getStartLongitude(), 200)) {

                          // Create round-trip group
                          String groupId = "RT_" + System.currentTimeMillis();
                          trip1.setRoundTripGroupId(groupId);
                          trip1.setRoundTrip(true);
                          trip1.setRoundTripSegment(1); // Outbound
                          
                          trip2.setRoundTripGroupId(groupId);
                          trip2.setRoundTrip(true);
                          trip2.setRoundTripSegment(2); // Return

                          // Save updated trips
                          saveTrip(trip1);
                          saveTrip(trip2);

                          Log.d(TAG, "Daily round-trip detected: " + trip1.getStartAddress() + " -> " + trip1.getEndAddress());
                      }
                  }
              }

              /**
               * Detects multi-day round trips (business travel patterns)
               * Example: Home->Airport->Client City, Client City->Airport->Home
               */
              private void detectMultiDayRoundTrips(List<Trip> trips) {
                  for (int i = 0; i < trips.size() - 1; i++) {
                      Trip trip1 = trips.get(i);
                      
                      // Look for return trip within 2-14 days
                      for (int j = i + 1; j < trips.size(); j++) {
                          Trip trip2 = trips.get(j);
                          
                          // Skip if already part of a round trip
                          if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;

                          // Check if trips are within 14 days
                          long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                          if (timeDiff > 14 * 24 * 60 * 60 * 1000) break; // 14 days max

                          // Check for business travel pattern (airports, distant locations)
                          if (isBusinessTravelPattern(trip1, trip2)) {
                              String groupId = "BT_" + System.currentTimeMillis();
                              trip1.setRoundTripGroupId(groupId);
                              trip1.setRoundTrip(true);
                              trip1.setRoundTripSegment(1); // Outbound business travel
                              
                              trip2.setRoundTripGroupId(groupId);
                              trip2.setRoundTrip(true);
                              trip2.setRoundTripSegment(2); // Return business travel

                              // Auto-classify as Business if involving airports
                              if (isAirportLocation(trip1.getStartAddress()) || 
                                  isAirportLocation(trip1.getEndAddress()) ||
                                  isAirportLocation(trip2.getStartAddress()) || 
                                  isAirportLocation(trip2.getEndAddress())) {
                                  trip1.setCategory("Business");
                                  trip2.setCategory("Business");
                              }

                              saveTrip(trip1);
                              saveTrip(trip2);

                              Log.d(TAG, "Multi-day business trip detected: " + trip1.getStartAddress() + " -> " + trip2.getEndAddress());
                              break;
                          }
                      }
                  }
              }

              /**
               * Detects complex trip groups with mixed business/personal activities
               * Example: Multi-day business trip with personal activities in destination city
               */
              private void detectComplexTripGroups(List<Trip> trips) {
                  // Group trips by time periods and geographic clusters
                  List<List<Trip>> tripClusters = new ArrayList<>();
                  
                  for (Trip trip : trips) {
                      if (trip.isRoundTrip()) continue; // Skip already grouped trips
                      
                      boolean addedToCluster = false;
                      for (List<Trip> cluster : tripClusters) {
                          if (belongsToCluster(trip, cluster)) {
                              cluster.add(trip);
                              addedToCluster = true;
                              break;
                          }
                      }
                      
                      if (!addedToCluster) {
                          List<Trip> newCluster = new ArrayList<>();
                          newCluster.add(trip);
                          tripClusters.add(newCluster);
                      }
                  }
                  
                  // Analyze clusters for business travel patterns
                  for (List<Trip> cluster : tripClusters) {
                      if (cluster.size() >= 3) {
                          analyzeComplexTripGroup(cluster);
                      }
                  }
              }

              /**
               * Determines if a trip belongs to an existing cluster
               */
              private boolean belongsToCluster(Trip trip, List<Trip> cluster) {
                  if (cluster.isEmpty()) return false;
                  
                  // Check if trip is within time window of cluster
                  long clusterStart = cluster.get(0).getStartTime();
                  long clusterEnd = cluster.get(cluster.size() - 1).getEndTime();
                  
                  return (trip.getStartTime() >= clusterStart - 24 * 60 * 60 * 1000) && // 1 day before
                         (trip.getStartTime() <= clusterEnd + 24 * 60 * 60 * 1000);     // 1 day after
              }

              /**
               * Analyzes complex trip groups for business travel patterns
               */
              private void analyzeComplexTripGroup(List<Trip> cluster) {
                  // Check if cluster represents business travel with mixed activities
                  boolean hasBusinessIndicators = false;
                  boolean hasPersonalIndicators = false;
                  
                  for (Trip trip : cluster) {
                      if (isBusinessLocation(trip.getStartAddress()) || 
                          isBusinessLocation(trip.getEndAddress()) ||
                          isAirportLocation(trip.getStartAddress()) || 
                          isAirportLocation(trip.getEndAddress())) {
                          hasBusinessIndicators = true;
                      }
                      
                      if (isPersonalLocation(trip.getStartAddress()) || 
                          isPersonalLocation(trip.getEndAddress())) {
                          hasPersonalIndicators = true;
                      }
                  }
                  
                  if (hasBusinessIndicators && hasPersonalIndicators) {
                      // Mixed business trip - create group but don't auto-classify
                      String groupId = "MX_" + System.currentTimeMillis();
                      for (int i = 0; i < cluster.size(); i++) {
                          Trip trip = cluster.get(i);
                          trip.setRoundTripGroupId(groupId);
                          trip.setRoundTrip(true);
                          trip.setRoundTripSegment(i + 1);
                          saveTrip(trip);
                      }
                      Log.d(TAG, "Complex mixed business trip detected with " + cluster.size() + " segments");
                  }
              }

              /**
               * Checks if two locations are within the specified distance (meters)
               */
              private boolean isLocationMatch(double lat1, double lon1, double lat2, double lon2, double maxDistance) {
                  double distance = calculateDistance(lat1, lon1, lat2, lon2);
                  return distance <= maxDistance;
              }

              /**
               * Determines if two trips form a business travel pattern
               */
              private boolean isBusinessTravelPattern(Trip trip1, Trip trip2) {
                  // Check for long-distance travel (>50 miles)
                  double distance = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                                    trip2.getEndLatitude(), trip2.getEndLongitude());
                  
                  if (distance < 50) return false; // Must be significant travel
                  
                  // Check for airport involvement
                  return isAirportLocation(trip1.getStartAddress()) || 
                         isAirportLocation(trip1.getEndAddress()) ||
                         isAirportLocation(trip2.getStartAddress()) || 
                         isAirportLocation(trip2.getEndAddress());
              }

              /**
               * Identifies airport locations for business travel classification
               */
              private boolean isAirportLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("airport") || lower.contains("terminal") || 
                         lower.contains("intl") || lower.contains("international");
              }

              /**
               * Identifies business locations
               */
              private boolean isBusinessLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("office") || lower.contains("corporate") || 
                         lower.contains("business") || lower.contains("company") ||
                         lower.contains("headquarters") || lower.contains("conference");
              }

              /**
               * Identifies personal/leisure locations
               */
              private boolean isPersonalLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("park") || lower.contains("mall") || 
                         lower.contains("restaurant") || lower.contains("hotel") ||
                         lower.contains("theme") || lower.contains("entertainment") ||
                         lower.contains("shopping") || lower.contains("recreation");
              }

              /**
               * Gets all round-trip groups for display
               */
              public List<String> getRoundTripGroups() {
                  List<String> groups = new ArrayList<>();
                  List<Trip> trips = getAllTrips();
                  
                  for (Trip trip : trips) {
                      if (trip.isRoundTrip() && !groups.contains(trip.getRoundTripGroupId())) {
                          groups.add(trip.getRoundTripGroupId());
                      }
                  }
                  
                  return groups;
              }

              /**
               * Gets all trips in a specific round-trip group
               */
              public List<Trip> getTripsInGroup(String groupId) {
                  List<Trip> groupTrips = new ArrayList<>();
                  List<Trip> allTrips = getAllTrips();
                  
                  for (Trip trip : allTrips) {
                      if (groupId.equals(trip.getRoundTripGroupId())) {
                          groupTrips.add(trip);
                      }
                  }
                  
                  // Sort by segment number
                  Collections.sort(groupTrips, (t1, t2) -> Integer.compare(t1.getRoundTripSegment(), t2.getRoundTripSegment()));
                  
                  return groupTrips;
              }

              /**
               * Ungroups a round-trip, allowing individual classification
               */
              public void ungroupRoundTrip(String groupId) {
                  List<Trip> groupTrips = getTripsInGroup(groupId);
                  for (Trip trip : groupTrips) {
                      trip.setRoundTripGroupId(null);
                      trip.setRoundTrip(false);
                      trip.setRoundTripSegment(0);
                      saveTrip(trip);
                  }
                  Log.d(TAG, "Ungrouped round-trip: " + groupId);
              }

              /**
               * Classifies all trips in a round-trip group with the same category
               */
              public void classifyRoundTripGroup(String groupId, String category) {
                  List<Trip> groupTrips = getTripsInGroup(groupId);
                  for (Trip trip : groupTrips) {
                      trip.setCategory(category);
                      saveTrip(trip);
                  }
                  Log.d(TAG, "Classified round-trip group " + groupId + " as " + category);
              }
              
              // Helper methods for trip operations
              private List<Trip> getAllTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  return tripStorage.getAllTrips();
              }
              
              private void saveTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  tripStorage.saveTrip(trip);
              }
              
              /**
               * Calculates distance between two geographic coordinates using Haversine formula
               * @param lat1 Latitude of first point
               * @param lon1 Longitude of first point
               * @param lat2 Latitude of second point
               * @param lon2 Longitude of second point
               * @return Distance in meters
               */
              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Radius of the earth in km
                  
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c * 1000; // convert to meters
                  
                  return distance;
              }
              
              // CUSTOM CATEGORIES API SYNC METHODS
              
              /**
               * Syncs custom categories with API - downloads from API and merges with local
               */
              public void syncCustomCategoriesWithAPI() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping category sync");
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting custom categories sync with API");
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Download categories from API
                          URL url = new URL(API_BASE_URL + "/categories");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }
                              
                              // Parse and sync categories
                              JSONObject jsonResponse = new JSONObject(response.toString());
                              JSONArray categories = jsonResponse.getJSONArray("categories");
                              
                              for (int i = 0; i < categories.length(); i++) {
                                  String category = categories.getString(i);
                                  tripStorage.addCustomCategory(category);
                              }
                              
                              Log.d(TAG, "Successfully synced " + categories.length() + " categories from API");
                          } else {
                              Log.e(TAG, "Failed to sync categories from API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error syncing categories with API", e);
                      }
                  });
              }
              
              /**
               * Adds a custom category to the API
               */
              public void addCustomCategoryToAPI(String categoryName) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, adding category locally only");
                      tripStorage.addCustomCategory(categoryName);
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Adding custom category to API: " + categoryName);
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Add category to API
                          URL url = new URL(API_BASE_URL + "/categories");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          String jsonPayload = String.format("{\"name\":\"%s\"}", categoryName.replace("\"", "\\\""));
                          
                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 201) {
                              // Add to local storage after successful API call
                              tripStorage.addCustomCategory(categoryName);
                              Log.d(TAG, "Successfully added category to API and local storage: " + categoryName);
                          } else {
                              Log.e(TAG, "Failed to add category to API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error adding category to API", e);
                      }
                  });
              }
              
              /**
               * Removes a custom category from the API
               */
              public void removeCustomCategoryFromAPI(String categoryName) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, removing category locally only");
                      tripStorage.removeCustomCategory(categoryName);
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Removing custom category from API: " + categoryName);
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Remove category from API
                          URL url = new URL(API_BASE_URL + "/categories/" + java.net.URLEncoder.encode(categoryName, "UTF-8"));
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("DELETE");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 200) {
                              // Remove from local storage after successful API call
                              tripStorage.removeCustomCategory(categoryName);
                              Log.d(TAG, "Successfully removed category from API and local storage: " + categoryName);
                          } else {
                              Log.e(TAG, "Failed to remove category from API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error removing category from API", e);
                      }
                  });
              }

          }
          EOF

      - name: Create MainActivity with enhanced user identification and ALL trips download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.ActivityManager;
          import android.app.AlertDialog;
          import android.app.DatePickerDialog;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.graphics.Color;
          import android.graphics.Typeface;
          import android.graphics.drawable.GradientDrawable;
          import android.location.Address;
          import android.location.Geocoder;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.text.Editable;
          import android.text.InputType;
          import android.text.TextUtils;
          import android.text.TextWatcher;
          import android.util.Log;
          import android.view.Gravity;
          import android.view.GestureDetector;
          import android.view.MotionEvent;
          import android.view.View;
          import android.widget.AdapterView;
          import android.widget.ArrayAdapter;
          import android.widget.Button;
          import android.widget.CheckBox;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.SearchView;
          import android.widget.SeekBar;
          import android.widget.Spinner;
          import android.widget.Switch;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.services.AutoDetectionService;
          import com.miletrackerpro.app.services.ManualTripService;
          import com.miletrackerpro.app.services.BluetoothVehicleService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import android.net.Uri;
          import java.io.File;
          import java.io.FileOutputStream;
          import java.io.ByteArrayOutputStream;
          import android.graphics.pdf.PdfDocument;
          import android.graphics.Canvas;
          import android.graphics.Paint;
          import android.graphics.Color;
          import android.graphics.Typeface;
          import java.io.FileWriter;
          import java.io.IOException;
          import java.text.SimpleDateFormat;
          import java.util.ArrayList;
          import java.util.Calendar;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;
          import androidx.core.content.FileProvider;

          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final String TAG = "MainActivity";
              private static final int LOCATION_PERMISSION_REQUEST = 1001;
              private static final int BACKGROUND_LOCATION_PERMISSION_REQUEST = 1002;

              // Main layout
              private LinearLayout mainContentLayout;
              private LinearLayout bottomTabLayout;

              // Tab content
              private LinearLayout dashboardContent;
              private ScrollView dashboardScroll;
              private LinearLayout tripsContent;
              private LinearLayout classifyContent;
              private LinearLayout categorizedContent;
              private Button homeTabButton;
              private Button categorizedTabButton;
              private Button classifyMergeButton;
              private String currentTab = "home";

              // Dashboard UI Elements
              private TextView statusText;
              private TextView speedText;
              private TextView realTimeDistanceText;
              private TextView statsText;
              private Button autoToggle;
              private Button apiToggle;
              private Button manualStartButton;
              private Button manualStopButton;
              private Button addTripButton;
              private Button periodButton;
              private LinearLayout recentTripsLayout;

              // Trips UI Elements
              private LinearLayout allTripsLayout;
              private ScrollView allTripsScroll;
              
              // Classify UI Elements
              private LinearLayout classifyTripsLayout;
              private ScrollView classifyTripsScroll;
              
              // Categorized UI Elements
              private ScrollView categorizedTripsScroll;
              private LinearLayout categorizedTripsContainer;
              private String currentCategoryFilter = "All";
              private String currentSortOrder = "Newest";
              private String currentSearchQuery = "";

              // Services and storage
              private LocationManager locationManager;
              private TripStorage tripStorage;
              private BluetoothVehicleService bluetoothVehicleService;
              private boolean autoDetectionEnabled = false;
              private boolean manualTripInProgress = false;
              
              // Statistics period tracking
              private String currentStatsPeriod = "YTD"; // YTD, Quarter, Month
              private Handler speedHandler = new Handler();
              private Runnable speedRunnable;
              
              // Real-time distance tracking
              private double realTimeDistance = 0.0;
              private android.location.Location lastDistanceLocation = null;
              
              // Enhanced auto detection variables
              private boolean isCurrentlyTracking = false;
              private boolean currentTripPaused = false;
              private long currentTripStartTime = 0;
              private double currentTripStartLatitude = 0;
              private double currentTripStartLongitude = 0;
              private String currentTripStartAddress = null;
              
              // Swipe classification variables
              private GestureDetector gestureDetector;
              private Trip currentSwipeTrip = null;
              private View currentSwipeView = null;
              private boolean swipeInProgress = false;
              
              // Auto-classification storage
              private SharedPreferences locationPrefs;
              private List<LocationPoint> currentTripPath = new ArrayList<>();
              private int movingReadingsCount = 0;
              private int stationaryReadingsCount = 0;
              private Long tripPauseStartTime = null;
              private LocationPoint pausedTripLocation = null;
              
              // Auto detection blinking animation
              private Handler blinkHandler = new Handler();
              private Runnable blinkRunnable;
              private boolean lightsOn = true;
              private boolean isBlinking = false;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  try {
                      Log.d(TAG, "MainActivity onCreate starting - v4.9.147 BLUETOOTH VEHICLE RECOGNITION...");

                      tripStorage = new TripStorage(this);
                      locationPrefs = getSharedPreferences("location_classification", MODE_PRIVATE);
                      initializeGestureDetector();
                      createCleanLayout();
                      initializeGPS();
                      setupSpeedMonitoring();
                      requestPermissions();
                      updateStats();
                      registerBroadcastReceiver();
                      restoreAutoDetectionState();

                      // TRIGGER DOWNLOAD OF ALL USER TRIPS
                      triggerAllUserTripsDownload();

                      Log.d(TAG, "MainActivity onCreate completed successfully");

                  } catch (Exception e) {
                      Log.e(TAG, "Error in onCreate: " + e.getMessage(), e);
                      Toast.makeText(this, "App initialization error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              @Override
              protected void onResume() {
                  super.onResume();
                  // Refresh trips from API when user returns to app
                  if (tripStorage.isApiSyncEnabled()) {
                      new Thread(() -> {
                          try {
                              CloudBackupService cloudBackup = new CloudBackupService(this);
                              cloudBackup.downloadAllUserTrips();
                              
                              // Update UI on main thread
                              runOnUiThread(() -> {
                                  updateStats();
                                  updateAllTrips();
                              });
                          } catch (Exception e) {
                              Log.e(TAG, "Error refreshing trips: " + e.getMessage());
                          }
                      });
                  }
              }

              // Download ALL user trips (not just device-specific)
              private void triggerAllUserTripsDownload() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudBackup = new CloudBackupService(this);
                          cloudBackup.downloadAllUserTrips();
                          Log.d(TAG, "Triggered download of ALL user trips (not device-specific)");

                          // Update UI after a short delay to allow download to complete
                          Handler handler = new Handler();
                          handler.postDelayed(() -> {
                              updateStats();
                              if ("home".equals(currentTab)) {
                                  updateRecentTrips();
                              } else {
                                  updateAllTrips();
                              }
                          }, 3000); // 3 second delay
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error triggering ALL user trips download: " + e.getMessage(), e);
                  }
              }

              private void createCleanLayout() {
                  try {
                      // MAIN CONTAINER
                      LinearLayout mainLayout = new LinearLayout(this);
                      mainLayout.setOrientation(LinearLayout.VERTICAL);
                      mainLayout.setBackgroundColor(0xFFF5F5F5);

                      // MAIN HEADER with car emoji, app title, and settings gear
                      LinearLayout mainHeader = new LinearLayout(this);
                      mainHeader.setOrientation(LinearLayout.HORIZONTAL);
                      mainHeader.setBackgroundColor(0xFF667eea); // Periwinkle matching active tab
                      mainHeader.setPadding(20, 15, 20, 15);
                      mainHeader.setGravity(Gravity.CENTER_VERTICAL);
                      
                      TextView mainHeaderText = new TextView(this);
                      mainHeaderText.setText("ðŸš— MileTracker Pro");
                      mainHeaderText.setTextSize(16); // Reduced from 20 to 16 to prevent wrapping
                      mainHeaderText.setTextColor(0xFFFFFFFF); // White text
                      mainHeaderText.setTypeface(null, Typeface.BOLD);
                      
                      LinearLayout.LayoutParams headerTextParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                      mainHeaderText.setLayoutParams(headerTextParams);
                      mainHeader.addView(mainHeaderText);
                      
                      // Settings gear icon in top-right corner
                      Button settingsButton = new Button(this);
                      settingsButton.setText("âš™");
                      settingsButton.setTextSize(18);
                      settingsButton.setTextColor(0xFFFFFFFF); // White gear
                      settingsButton.setBackgroundColor(0x00000000); // Transparent background
                      settingsButton.setPadding(15, 8, 15, 8);
                      LinearLayout.LayoutParams settingsParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                      settingsButton.setLayoutParams(settingsParams);
                      
                      settingsButton.setOnClickListener(v -> {
                          showSettingsDialog();
                      });
                      
                      mainHeader.addView(settingsButton);

                      // MAIN CONTENT AREA
                      mainContentLayout = new LinearLayout(this);
                      mainContentLayout.setOrientation(LinearLayout.VERTICAL);
                      LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          0, 
                          1.0f
                      );
                      mainContentLayout.setLayoutParams(contentParams);

                      // BOTTOM TAB BAR
                      bottomTabLayout = new LinearLayout(this);
                      bottomTabLayout.setOrientation(LinearLayout.HORIZONTAL);
                      bottomTabLayout.setBackgroundColor(0xFFFFFFFF);
                      bottomTabLayout.setPadding(0, 10, 0, 20);
                      bottomTabLayout.setGravity(Gravity.CENTER);

                      // HOME TAB BUTTON
                      homeTabButton = new Button(this);
                      homeTabButton.setText("ðŸ \nHome");
                      homeTabButton.setTextSize(12);
                      homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                      homeTabButton.setTextColor(0xFFFFFFFF);
                      homeTabButton.setOnClickListener(v -> switchToTab("home"));
                      LinearLayout.LayoutParams homeParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      homeParams.setMargins(20, 0, 10, 0);
                      homeTabButton.setLayoutParams(homeParams);
                      bottomTabLayout.addView(homeTabButton);

                      // TRIPS TAB BUTTON (second tab - all trips with category filtering)
                      categorizedTabButton = new Button(this);
                      categorizedTabButton.setText("ðŸ“‹\nTrips");
                      categorizedTabButton.setTextSize(12);
                      categorizedTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY
                      categorizedTabButton.setTextColor(0xFFFFFFFF);
                      categorizedTabButton.setOnClickListener(v -> switchToTab("categorized"));
                      LinearLayout.LayoutParams categorizedParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      categorizedParams.setMargins(10, 0, 20, 0);
                      categorizedTabButton.setLayoutParams(categorizedParams);
                      bottomTabLayout.addView(categorizedTabButton);

                      // CREATE TAB CONTENT
                      createDashboardContent();
                      createCategorizedContent();
                      
                      // Create persistent ScrollView for dashboard
                      dashboardScroll = new ScrollView(this);
                      dashboardScroll.addView(dashboardContent);

                      // Add to main layout in correct order
                      mainLayout.addView(mainHeader);
                      mainLayout.addView(mainContentLayout);
                      mainLayout.addView(bottomTabLayout);

                      switchToTab("home");
                      setContentView(mainLayout);

                  } catch (Exception e) {
                      Log.e(TAG, "Error creating layout: " + e.getMessage(), e);
                      throw e;
                  }
              }

              private void createDashboardContent() {
                  dashboardContent = new LinearLayout(this);
                  dashboardContent.setOrientation(LinearLayout.VERTICAL);
                  dashboardContent.setPadding(20, 20, 20, 20);



                  // Status
                  statusText = new TextView(this);
                  statusText.setText("Initializing...");
                  statusText.setTextSize(14);
                  statusText.setTextColor(0xFF495057);
                  statusText.setPadding(15, 15, 15, 15);
                  statusText.setBackgroundColor(0xFFe3f2fd);
                  dashboardContent.addView(statusText);

                  // Speed
                  speedText = new TextView(this);
                  speedText.setText("Speed: -- mph");
                  speedText.setTextSize(12);
                  speedText.setTextColor(0xFF6C757D);
                  speedText.setPadding(15, 5, 15, 5);
                  dashboardContent.addView(speedText);
                  
                  // Real-time Distance
                  realTimeDistanceText = new TextView(this);
                  realTimeDistanceText.setText("Distance: 0.0 miles");
                  realTimeDistanceText.setTextSize(12);
                  realTimeDistanceText.setTextColor(0xFF6C757D);
                  realTimeDistanceText.setPadding(15, 5, 15, 10);
                  dashboardContent.addView(realTimeDistanceText);



                  // AUTO DETECTION SECTION
                  TextView autoSectionHeader = new TextView(this);
                  autoSectionHeader.setText("ðŸš— Auto Detection");
                  autoSectionHeader.setTextSize(16);
                  autoSectionHeader.setTextColor(0xFF495057);
                  autoSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(autoSectionHeader);

                  autoToggle = new Button(this);
                  autoToggle.setText("Auto Detection: OFF");
                  autoToggle.setTextSize(14);
                  autoToggle.setBackgroundColor(0xFF9CA3AF);
                  autoToggle.setTextColor(0xFFFFFFFF);
                  autoToggle.setOnClickListener(v -> toggleAutoDetection());
                  dashboardContent.addView(autoToggle);

                  // MANUAL CONTROLS SECTION
                  TextView manualSectionHeader = new TextView(this);
                  manualSectionHeader.setText("âœ‹ Manual Trip Controls");
                  manualSectionHeader.setTextSize(16);
                  manualSectionHeader.setTextColor(0xFF495057);
                  manualSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(manualSectionHeader);

                  LinearLayout manualButtonLayout = new LinearLayout(this);
                  manualButtonLayout.setOrientation(LinearLayout.HORIZONTAL);

                  manualStartButton = new Button(this);
                  manualStartButton.setText("START");
                  manualStartButton.setTextSize(12);
                  manualStartButton.setBackgroundColor(0xFF28a745);
                  manualStartButton.setTextColor(0xFFFFFFFF);
                  manualStartButton.setOnClickListener(v -> startManualTrip());
                  LinearLayout.LayoutParams startParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                  startParams.setMargins(0, 0, 5, 0);
                  manualStartButton.setLayoutParams(startParams);
                  manualButtonLayout.addView(manualStartButton);

                  manualStopButton = new Button(this);
                  manualStopButton.setText("STOP");
                  manualStopButton.setTextSize(12);
                  manualStopButton.setBackgroundColor(0xFFdc3545);
                  manualStopButton.setTextColor(0xFFFFFFFF);
                  manualStopButton.setEnabled(false);
                  manualStopButton.setOnClickListener(v -> stopManualTrip());
                  LinearLayout.LayoutParams stopParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                  stopParams.setMargins(5, 0, 0, 0);
                  manualStopButton.setLayoutParams(stopParams);
                  manualButtonLayout.addView(manualStopButton);

                  dashboardContent.addView(manualButtonLayout);

                  // ADD TRIP MANUALLY
                  addTripButton = new Button(this);
                  addTripButton.setText("âž• Add Trip");
                  addTripButton.setTextSize(14);
                  addTripButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                  addTripButton.setTextColor(0xFFFFFFFF);
                  addTripButton.setOnClickListener(v -> showAddTripDialog());
                  LinearLayout.LayoutParams addParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  addParams.setMargins(0, 10, 0, 0);
                  addTripButton.setLayoutParams(addParams);
                  dashboardContent.addView(addTripButton);



                  // Period selector button
                  periodButton = new Button(this);
                  periodButton.setText("View: " + getPeriodLabel() + " (tap to change)");
                  periodButton.setTextSize(12);
                  periodButton.setBackgroundColor(0xFFE3F2FD);
                  periodButton.setTextColor(0xFF1976D2);
                  periodButton.setPadding(10, 5, 10, 5);
                  periodButton.setOnClickListener(v -> showPeriodSelector());
                  dashboardContent.addView(periodButton);

                  // Stats - Enhanced visibility
                  statsText = new TextView(this);
                  statsText.setText("Loading stats...");
                  statsText.setTextSize(14);
                  statsText.setTextColor(0xFF495057);
                  statsText.setPadding(15, 15, 15, 15);
                  statsText.setBackgroundColor(0xFFfafafa);
                  LinearLayout.LayoutParams statsParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  statsParams.setMargins(0, 10, 0, 10);
                  statsText.setLayoutParams(statsParams);
                  dashboardContent.addView(statsText);

                  // Recent Trips
                  TextView recentTripsHeader = new TextView(this);
                  recentTripsHeader.setText("ðŸ“‹ Recent Trips");
                  recentTripsHeader.setTextSize(16);
                  recentTripsHeader.setTextColor(Color.WHITE);
                  recentTripsHeader.setPadding(16, 16, 16, 16);
                  recentTripsHeader.setTypeface(null, Typeface.BOLD);
                  recentTripsHeader.setBackgroundColor(Color.parseColor("#667eea"));
                  dashboardContent.addView(recentTripsHeader);

                  ScrollView recentTripsScroll = new ScrollView(this);
                  recentTripsLayout = new LinearLayout(this);
                  recentTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  recentTripsScroll.addView(recentTripsLayout);

                  LinearLayout.LayoutParams recentScrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      500
                  );
                  recentTripsScroll.setLayoutParams(recentScrollParams);
                  dashboardContent.addView(recentTripsScroll);
              }

              private void createTripsContent() {
                  tripsContent = new LinearLayout(this);
                  tripsContent.setOrientation(LinearLayout.VERTICAL);
                  tripsContent.setPadding(20, 20, 20, 20);

                  // Header removed as requested
                  
                  // All Trips ScrollView
                  allTripsScroll = new ScrollView(this);
                  allTripsLayout = new LinearLayout(this);
                  allTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  allTripsScroll.addView(allTripsLayout);

                  // Full screen layout params - fill all available space above bottom tabs
                  LinearLayout.LayoutParams allTripsParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      0, // Use weight to fill remaining space
                      1.0f // Weight 1 = take all remaining vertical space
                  );
                  allTripsScroll.setLayoutParams(allTripsParams);
                  tripsContent.addView(allTripsScroll);
              }

              private void createClassifyContent() {
                  classifyContent = new LinearLayout(this);
                  classifyContent.setOrientation(LinearLayout.VERTICAL);
                  classifyContent.setPadding(20, 20, 20, 20);

                  // Header text
                  TextView headerText = new TextView(this);
                  headerText.setText("Classify Trips");
                  headerText.setTextSize(18);
                  headerText.setTextColor(0xFF333333);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 10);
                  classifyContent.addView(headerText);

                  // Instructions text - ULTRA COMPACT TO FIT ONE LINE
                  TextView instructionsText = new TextView(this);
                  instructionsText.setText("Swipe right for Business, left for Personal");
                  instructionsText.setTextSize(9); // Reduced from 12 to 9 for one-line fit
                  instructionsText.setTextColor(0xFF666666);
                  instructionsText.setGravity(Gravity.CENTER);
                  instructionsText.setPadding(0, 0, 0, 10); // Reduced padding
                  classifyContent.addView(instructionsText);

                  // REFRESH, MERGE, EXPORT buttons for classify tab
                  LinearLayout buttonContainer = new LinearLayout(this);
                  buttonContainer.setOrientation(LinearLayout.VERTICAL);
                  buttonContainer.setPadding(0, 10, 0, 10);
                  
                  // Button row with uniform height buttons  
                  LinearLayout buttonLayout = new LinearLayout(this);
                  buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                  buttonLayout.setGravity(Gravity.CENTER);
                  buttonLayout.setPadding(0, 0, 0, 20);
                  
                  int buttonHeight = (int) (50 * getResources().getDisplayMetrics().density);
                  
                  // Refresh button
                  Button refreshButton = new Button(this);
                  refreshButton.setText("REFRESH");
                  refreshButton.setTextSize(11);
                  refreshButton.setBackgroundColor(0xFF6C757D); // Muted gray color
                  refreshButton.setTextColor(0xFFFFFFFF);
                  refreshButton.setPadding(15, 0, 15, 0);
                  refreshButton.setOnClickListener(v -> performRefreshWithFeedback(refreshButton));
                  LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(
                      0, 
                      buttonHeight,
                      1.0f
                  );
                  refreshParams.setMargins(0, 0, 15, 0);
                  refreshButton.setLayoutParams(refreshParams);
                  buttonLayout.addView(refreshButton);
                  
                  // Merge button
                  classifyMergeButton = new Button(this);
                  classifyMergeButton.setText("MERGE");
                  classifyMergeButton.setTextSize(11);
                  classifyMergeButton.setBackgroundColor(0xFF007bff);
                  classifyMergeButton.setTextColor(0xFFFFFFFF);
                  classifyMergeButton.setPadding(15, 0, 15, 0);
                  LinearLayout.LayoutParams mergeParams = new LinearLayout.LayoutParams(
                      0, 
                      buttonHeight,
                      1.0f
                  );
                  mergeParams.setMargins(15, 0, 15, 0);
                  classifyMergeButton.setLayoutParams(mergeParams);
                  buttonLayout.addView(classifyMergeButton);
                  
                  // Export button
                  Button exportButton = new Button(this);
                  exportButton.setText("EXPORT");
                  exportButton.setTextSize(11);
                  exportButton.setBackgroundColor(0xFF28a745);
                  exportButton.setTextColor(0xFFFFFFFF);
                  exportButton.setPadding(15, 0, 15, 0);
                  LinearLayout.LayoutParams exportParams = new LinearLayout.LayoutParams(
                      0, 
                      buttonHeight,
                      1.0f
                  );
                  exportParams.setMargins(15, 0, 0, 0);
                  exportButton.setLayoutParams(exportParams);
                  buttonLayout.addView(exportButton);
                  
                  buttonContainer.addView(buttonLayout);
                  
                  // Add export button click handler
                  exportButton.setOnClickListener(v -> showExportDialog());
                  
                  // Add merge button click handler for classify tab
                  classifyMergeButton.setOnClickListener(v -> {
                      if (!mergeMode) {
                          // Enter merge mode
                          mergeMode = true;
                          classifyMergeButton.setText("Merge Trips");
                          updateClassifyTrips(); // Refresh to show checkboxes
                          Toast.makeText(MainActivity.this, "ðŸ“‹ Select trips to merge, then tap Merge Trips again (or long-press to cancel)", Toast.LENGTH_SHORT).show();
                      } else {
                          // In merge mode - show options
                          if (selectedTripIds.size() < 2) {
                              // Show cancel option when no trips selected
                              new AlertDialog.Builder(MainActivity.this)
                                  .setTitle("ðŸ”€ Merge Options")
                                  .setMessage("Select at least 2 trips to merge, or cancel to exit merge mode.")
                                  .setPositiveButton("âŒ Cancel Merge", (dialog, which) -> {
                                      // Cancel merge mode
                                      mergeMode = false;
                                      selectedTripIds.clear();
                                      classifyMergeButton.setText("MERGE");
                                      updateClassifyTrips();
                                      Toast.makeText(MainActivity.this, "Merge cancelled", Toast.LENGTH_SHORT).show();
                                  })
                                  .setNegativeButton("Continue", null)
                                  .show();
                              return;
                          }
                          
                          // Confirm merge
                          new AlertDialog.Builder(MainActivity.this)
                              .setTitle("ðŸ”€ Confirm Merge")
                              .setMessage("Merge " + selectedTripIds.size() + " selected trips?\n\nThis will combine them into one trip and delete the originals.")
                              .setPositiveButton("âœ… Merge", (dialog, which) -> {
                                  executeClassifyMerge();
                              })
                              .setNegativeButton("âŒ Cancel", (dialog, which) -> {
                                  // Cancel merge mode
                                  mergeMode = false;
                                  selectedTripIds.clear();
                                  classifyMergeButton.setText("MERGE");
                                  updateClassifyTrips();
                                  Toast.makeText(MainActivity.this, "Merge cancelled", Toast.LENGTH_SHORT).show();
                              })
                              .show();
                      }
                  });
                  
                  // Add long-press cancel for classify merge button
                  classifyMergeButton.setOnLongClickListener(v -> {
                      if (mergeMode) {
                          // Cancel merge mode on long press
                          mergeMode = false;
                          selectedTripIds.clear();
                          classifyMergeButton.setText("MERGE");
                          updateClassifyTrips();
                          Toast.makeText(MainActivity.this, "Merge cancelled", Toast.LENGTH_SHORT).show();
                          return true;
                      }
                      return false;
                  });
                  
                  classifyContent.addView(buttonContainer);

                  // Scrollable trips container
                  classifyTripsScroll = new ScrollView(this);
                  classifyTripsLayout = new LinearLayout(this);
                  classifyTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  classifyTripsScroll.addView(classifyTripsLayout);

                  LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      0,
                      1.0f
                  );
                  classifyTripsScroll.setLayoutParams(scrollParams);
                  classifyContent.addView(classifyTripsScroll);
              }

              private void createCategorizedContent() {
                  categorizedContent = new LinearLayout(this);
                  categorizedContent.setOrientation(LinearLayout.VERTICAL);
                  categorizedContent.setPadding(20, 20, 20, 20);

                  // Header text
                  TextView headerText = new TextView(this);
                  headerText.setText("Categorized Trips");
                  headerText.setTextSize(18);
                  headerText.setTextColor(0xFF333333);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  categorizedContent.addView(headerText);

                  // REFRESH, MERGE, EXPORT buttons (moved from createTripsContent)
                  LinearLayout buttonContainer = new LinearLayout(this);
                  buttonContainer.setOrientation(LinearLayout.VERTICAL);
                  buttonContainer.setPadding(0, 10, 0, 10);
                  
                  // Button row with uniform height buttons  
                  LinearLayout buttonLayout = new LinearLayout(this);
                  buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                  buttonLayout.setPadding(20, 0, 20, 0);
                  buttonLayout.setGravity(Gravity.CENTER);
                  
                  // Uniform button height (50dp converted to pixels)
                  int buttonHeight = (int) (50 * getResources().getDisplayMetrics().density);
                  
                  // Refresh button
                  Button refreshButton = new Button(this);
                  refreshButton.setText("REFRESH");
                  refreshButton.setTextSize(11);
                  refreshButton.setBackgroundColor(0xFF6C757D); // Muted gray color
                  refreshButton.setTextColor(0xFFFFFFFF);
                  refreshButton.setPadding(15, 0, 15, 0);
                  refreshButton.setOnClickListener(v -> performRefreshWithFeedback(refreshButton));
                  LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(
                      0, 
                      buttonHeight,
                      1.0f
                  );
                  refreshParams.setMargins(0, 0, 15, 0);
                  refreshButton.setLayoutParams(refreshParams);
                  buttonLayout.addView(refreshButton);
                  
                  // Merge button
                  Button mergeButton = new Button(this);
                  mergeButton.setText("MERGE");
                  mergeButton.setTextSize(11);
                  mergeButton.setBackgroundColor(0xFF007bff);
                  mergeButton.setTextColor(0xFFFFFFFF);
                  mergeButton.setPadding(15, 0, 15, 0);
                  LinearLayout.LayoutParams mergeParams = new LinearLayout.LayoutParams(
                      0, 
                      buttonHeight,
                      1.0f
                  );
                  mergeParams.setMargins(15, 0, 15, 0);
                  mergeButton.setLayoutParams(mergeParams);
                  buttonLayout.addView(mergeButton);
                  
                  // Export button
                  Button exportButton = new Button(this);
                  exportButton.setText("EXPORT");
                  exportButton.setTextSize(11);
                  exportButton.setBackgroundColor(0xFF28a745);
                  exportButton.setTextColor(0xFFFFFFFF);
                  exportButton.setPadding(15, 0, 15, 0);
                  LinearLayout.LayoutParams exportParams = new LinearLayout.LayoutParams(
                      0, 
                      buttonHeight,
                      1.0f
                  );
                  exportParams.setMargins(15, 0, 0, 0);
                  exportButton.setLayoutParams(exportParams);
                  buttonLayout.addView(exportButton);
                  
                  buttonContainer.addView(buttonLayout);
                  
                  // Add export button click handler
                  exportButton.setOnClickListener(v -> showExportDialog());
                  
                  // Add merge button click handler
                  mergeButton.setOnClickListener(v -> {
                      if (!mergeMode) {
                          // Enter merge mode
                          mergeMode = true;
                          mergeButton.setText("Merge Trips");
                          updateCategorizedTrips(); // Refresh to show checkboxes
                          Toast.makeText(MainActivity.this, "ðŸ“‹ Select trips to merge, then tap Merge Trips again (or long-press to cancel)", Toast.LENGTH_SHORT).show();
                      } else {
                          // In merge mode - show options
                          if (selectedTripIds.size() < 2) {
                              // Show cancel option when no trips selected
                              new AlertDialog.Builder(MainActivity.this)
                                  .setTitle("ðŸ”€ Merge Options")
                                  .setMessage("Select at least 2 trips to merge, or cancel to exit merge mode.")
                                  .setPositiveButton("âŒ Cancel Merge", (dialog, which) -> {
                                      // Cancel merge mode
                                      mergeMode = false;
                                      selectedTripIds.clear();
                                      mergeButton.setText("MERGE");
                                      updateCategorizedTrips();
                                      Toast.makeText(MainActivity.this, "Merge cancelled", Toast.LENGTH_SHORT).show();
                                  })
                                  .setNegativeButton("Continue", null)
                                  .show();
                              return;
                          }
                          
                          // Confirm merge
                          new AlertDialog.Builder(MainActivity.this)
                              .setTitle("ðŸ”€ Confirm Merge")
                              .setMessage("Merge " + selectedTripIds.size() + " selected trips?\n\nThis will combine them into one trip and delete the originals.")
                              .setPositiveButton("âœ… Merge", (dialog, which) -> {
                                  executeCategorizedMerge();
                              })
                              .setNegativeButton("âŒ Cancel", (dialog, which) -> {
                                  // Cancel merge mode
                                  mergeMode = false;
                                  selectedTripIds.clear();
                                  mergeButton.setText("MERGE");
                                  updateCategorizedTrips();
                                  Toast.makeText(MainActivity.this, "Merge cancelled", Toast.LENGTH_SHORT).show();
                              })
                              .show();
                      }
                  });
                  
                  // Add long-press cancel for categorized merge button
                  mergeButton.setOnLongClickListener(v -> {
                      if (mergeMode) {
                          // Cancel merge mode on long press
                          mergeMode = false;
                          selectedTripIds.clear();
                          mergeButton.setText("MERGE");
                          updateCategorizedTrips();
                          Toast.makeText(MainActivity.this, "Merge cancelled", Toast.LENGTH_SHORT).show();
                          return true;
                      }
                      return false;
                  });
                  
                  categorizedContent.addView(buttonContainer);

                  // Search and filter controls - compact layout
                  LinearLayout searchSortLayout = new LinearLayout(this);
                  searchSortLayout.setOrientation(LinearLayout.VERTICAL);
                  searchSortLayout.setPadding(10, 5, 10, 10);
                  
                  // Search box
                  LinearLayout searchRowLayout = new LinearLayout(this);
                  searchRowLayout.setOrientation(LinearLayout.HORIZONTAL);
                  searchRowLayout.setGravity(Gravity.CENTER_VERTICAL);
                  searchRowLayout.setPadding(0, 0, 0, 5);
                  
                  TextView searchLabel = new TextView(this);
                  searchLabel.setText("Search:");
                  searchLabel.setTextSize(11);
                  searchLabel.setTextColor(0xFF333333);
                  searchLabel.setPadding(0, 0, 10, 0);
                  searchRowLayout.addView(searchLabel);
                  
                  EditText searchBox = new EditText(this);
                  searchBox.setHint("Address, distance, category...");
                  searchBox.setTextSize(11);
                  searchBox.setPadding(8, 4, 8, 4);
                  searchBox.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams searchParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  searchBox.setLayoutParams(searchParams);
                  searchBox.addTextChangedListener(new TextWatcher() {
                      @Override
                      public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

                      @Override
                      public void onTextChanged(CharSequence s, int start, int before, int count) {
                          currentSearchQuery = s.toString();
                          updateCategorizedTrips();
                      }

                      @Override
                      public void afterTextChanged(Editable s) {}
                  });
                  searchRowLayout.addView(searchBox);
                  
                  searchSortLayout.addView(searchRowLayout);
                  
                  // Sort and category controls row
                  LinearLayout controlsRowLayout = new LinearLayout(this);
                  controlsRowLayout.setOrientation(LinearLayout.HORIZONTAL);
                  controlsRowLayout.setGravity(Gravity.CENTER_VERTICAL);
                  controlsRowLayout.setPadding(0, 5, 0, 0);
                  
                  // Sort dropdown
                  TextView sortLabel = new TextView(this);
                  sortLabel.setText("Sort:");
                  sortLabel.setTextSize(11);
                  sortLabel.setTextColor(0xFF333333);
                  sortLabel.setPadding(0, 0, 5, 0);
                  controlsRowLayout.addView(sortLabel);
                  
                  Button sortButton = new Button(this);
                  sortButton.setText("Newest");
                  sortButton.setTextSize(10);
                  sortButton.setBackgroundColor(0xFF667eea);
                  sortButton.setTextColor(0xFFFFFFFF);
                  sortButton.setPadding(8, 2, 8, 2);
                  LinearLayout.LayoutParams sortParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  sortParams.setMargins(0, 0, 10, 0);
                  sortButton.setLayoutParams(sortParams);
                  sortButton.setOnClickListener(v -> {
                      String[] sortOptions = {"Newest", "Oldest", "Distance", "Duration"};
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Sort by")
                          .setItems(sortOptions, (dialog, which) -> {
                              sortButton.setText(sortOptions[which]);
                              currentSortOrder = sortOptions[which];
                              updateCategorizedTrips();
                          })
                          .show();
                  });
                  controlsRowLayout.addView(sortButton);
                  
                  // Category filter
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("Category:");
                  categoryLabel.setTextSize(11);
                  categoryLabel.setTextColor(0xFF333333);
                  categoryLabel.setPadding(0, 0, 5, 0);
                  controlsRowLayout.addView(categoryLabel);
                  
                  Button categoryFilterButton = new Button(this);
                  categoryFilterButton.setText("All");
                  categoryFilterButton.setTextSize(10);
                  categoryFilterButton.setBackgroundColor(0xFF9CA3AF);
                  categoryFilterButton.setTextColor(0xFFFFFFFF);
                  categoryFilterButton.setPadding(8, 2, 8, 2);
                  categoryFilterButton.setMaxLines(1);
                  categoryFilterButton.setEllipsize(TextUtils.TruncateAt.END);
                  categoryFilterButton.setOnClickListener(v -> {
                      List<String> categoryList = new ArrayList<>();
                      categoryList.add("All");
                      categoryList.add("Uncategorized");
                      categoryList.addAll(tripStorage.getAllCategories());
                      String[] categories = categoryList.toArray(new String[0]);
                      
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Filter by Category")
                          .setItems(categories, (dialog, which) -> {
                              categoryFilterButton.setText(categories[which]);
                              currentCategoryFilter = categories[which];
                              updateCategorizedTrips();
                          })
                          .setNeutralButton("Manage Categories", (dialog, which) -> {
                              showManageCategoriesDialog();
                          })
                          .show();
                  });
                  controlsRowLayout.addView(categoryFilterButton);
                  
                  searchSortLayout.addView(controlsRowLayout);
                  categorizedContent.addView(searchSortLayout);

                  // Scrollable trips container
                  categorizedTripsScroll = new ScrollView(this);
                  categorizedTripsContainer = new LinearLayout(this);
                  categorizedTripsContainer.setOrientation(LinearLayout.VERTICAL);
                  categorizedTripsScroll.addView(categorizedTripsContainer);

                  LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      0,
                      1.0f
                  );
                  categorizedTripsScroll.setLayoutParams(scrollParams);
                  categorizedContent.addView(categorizedTripsScroll);
              }

              private void toggleApiSync() {
                  try {
                      boolean currentState = tripStorage.isApiSyncEnabled();
                      tripStorage.setApiSyncEnabled(!currentState);
                      updateApiToggleUI();
                      updateStats();

                      String message = tripStorage.isApiSyncEnabled() ? 
                          "API sync ON - downloading ALL your trips..." : 
                          "API sync OFF - local storage only";
                      Toast.makeText(this, message, Toast.LENGTH_SHORT).show();

                      // Trigger download when API sync is turned ON
                      if (tripStorage.isApiSyncEnabled()) {
                          triggerAllUserTripsDownload();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling API sync: " + e.getMessage(), e);
                  }
              }

              private void updateApiToggleUI() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          apiToggle.setText("ðŸŒ API ON");
                          apiToggle.setBackgroundColor(0xFF28a745);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      } else {
                          apiToggle.setText("ðŸŒ API OFF");
                          apiToggle.setBackgroundColor(0xFF9CA3AF);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating API toggle UI: " + e.getMessage(), e);
                  }
              }

              private void switchToTab(String tabName) {
                  try {
                      currentTab = tabName;
                      mainContentLayout.removeAllViews();

                      if ("home".equals(tabName)) {
                          // Use persistent ScrollView for dashboard
                          mainContentLayout.addView(dashboardScroll);
                          homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          categorizedTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          updateRecentTrips();
                      } else if ("categorized".equals(tabName)) {
                          mainContentLayout.addView(categorizedContent);
                          homeTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          categorizedTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          updateCategorizedTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error switching tabs: " + e.getMessage(), e);
                  }
              }

              private void updateRecentTrips() {
                  try {
                      recentTripsLayout.removeAllViews();
                      List<Trip> trips = tripStorage.getAllTrips();

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips yet. API sync will download ALL your historic trips!");
                          noTripsText.setTextSize(12);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(10, 10, 10, 10);
                          recentTripsLayout.addView(noTripsText);
                      } else {
                          // Sort trips by date/time descending to show newest first
                          trips.sort((t1, t2) -> {
                              if (t1.getStartTime() != 0 && t2.getStartTime() != 0) {
                                  return Long.compare(t2.getStartTime(), t1.getStartTime());
                              }
                              return Long.compare(t2.getId(), t1.getId());
                          });
                          
                          int maxTrips = Math.min(3, trips.size());
                          for (int i = 0; i < maxTrips; i++) {
                              Trip trip = trips.get(i);
                              addTripCard(recentTripsLayout, trip, true);
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
                  }
              }

              // Field to track selected trips for merging
              private final List<String> selectedTripIds = new ArrayList<>();
              private boolean mergeMode = false;

              private void updateAllTrips() {
                  filterAndDisplayTrips("", "Newest First", "All Categories");
              }
              
              private void updateClassifyTrips() {
                  try {
                      classifyTripsLayout.removeAllViews();
                      
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      List<Trip> uncategorizedTrips = new ArrayList<>();
                      
                      // Filter to only uncategorized trips
                      for (Trip trip : allTrips) {
                          if (trip.getCategory() == null || 
                              trip.getCategory().isEmpty() || 
                              "Uncategorized".equals(trip.getCategory())) {
                              uncategorizedTrips.add(trip);
                          }
                      }
                      
                      if (uncategorizedTrips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips need classification. All trips are categorized!");
                          noTripsText.setTextSize(14);
                          noTripsText.setTextColor(0xFF666666);
                          noTripsText.setGravity(Gravity.CENTER);
                          noTripsText.setPadding(20, 40, 20, 40);
                          classifyTripsLayout.addView(noTripsText);
                          return;
                      }
                      
                      // Create trip cards with swipe gestures
                      for (Trip trip : uncategorizedTrips) {
                          addTripCard(classifyTripsLayout, trip, false);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating classify trips: " + e.getMessage(), e);
                  }
              }

              private void updateCategorizedTrips() {
                  try {
                      categorizedTripsContainer.removeAllViews();
                      
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      List<Trip> categorizedTrips = new ArrayList<>();
                      
                      // Filter trips based on selected category
                      for (Trip trip : allTrips) {
                          if (trip.getCategory() != null && !trip.getCategory().isEmpty()) {
                              if ("All".equals(currentCategoryFilter) || 
                                  currentCategoryFilter.equals(trip.getCategory())) {
                                  categorizedTrips.add(trip);
                              }
                          }
                      }
                      
                      // Apply search filter
                      if (!currentSearchQuery.isEmpty()) {
                          List<Trip> filteredTrips = new ArrayList<>();
                          String query = currentSearchQuery.toLowerCase();
                          for (Trip trip : categorizedTrips) {
                              String startAddr = trip.getStartAddress() != null ? trip.getStartAddress().toLowerCase() : "";
                              String endAddr = trip.getEndAddress() != null ? trip.getEndAddress().toLowerCase() : "";
                              String clientName = trip.getClientName() != null ? trip.getClientName().toLowerCase() : "";
                              String notes = trip.getNotes() != null ? trip.getNotes().toLowerCase() : "";
                              String category = trip.getCategory() != null ? trip.getCategory().toLowerCase() : "";
                              
                              if (startAddr.contains(query) || endAddr.contains(query) || 
                                  clientName.contains(query) || notes.contains(query) || category.contains(query)) {
                                  filteredTrips.add(trip);
                              }
                          }
                          categorizedTrips = filteredTrips;
                      }
                      
                      // Apply sorting
                      switch (currentSortOrder) {
                          case "Newest":
                              categorizedTrips.sort((a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
                              break;
                          case "Oldest":
                              categorizedTrips.sort((a, b) -> Long.compare(a.getStartTime(), b.getStartTime()));
                              break;
                          case "Distance":
                              categorizedTrips.sort((a, b) -> Double.compare(b.getDistance(), a.getDistance()));
                              break;
                          case "Duration":
                              categorizedTrips.sort((a, b) -> Long.compare(b.getDuration(), a.getDuration()));
                              break;
                          default:
                              categorizedTrips.sort((a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
                              break;
                      }
                      
                      if (categorizedTrips.isEmpty()) {
                          TextView emptyText = new TextView(this);
                          emptyText.setText("No categorized trips found.\nSwipe trips left/right in the 'Classify' tab to categorize them.");
                          emptyText.setTextSize(16);
                          emptyText.setTextColor(0xFF666666);
                          emptyText.setGravity(Gravity.CENTER);
                          emptyText.setPadding(0, 40, 0, 40);
                          categorizedTripsContainer.addView(emptyText);
                          return;
                      }
                      
                      // Create trip cards
                      for (Trip trip : categorizedTrips) {
                          addTripCard(categorizedTripsContainer, trip, false);
                      }
                      
                  } catch (Exception e) {
                      Log.e("MainActivity", "Error updating categorized trips", e);
                  }
              }
              
              private void filterAndDisplayTrips(String searchQuery, String sortOption, String categoryFilter) {
                  try {
                      allTripsLayout.removeAllViews();
                      selectedTripIds.clear(); // Clear selection when refreshing
                      List<Trip> trips = tripStorage.getAllTrips();
                      
                      Log.d(TAG, "filterAndDisplayTrips() called - found " + trips.size() + " trips, search: '" + searchQuery + "', sort: '" + sortOption + "', category: '" + categoryFilter + "'");

                      // Apply search filter with null safety
                      if (!searchQuery.isEmpty()) {
                          List<Trip> filteredTrips = new ArrayList<>();
                          String query = searchQuery.toLowerCase();
                          for (Trip trip : trips) {
                              // Null-safe string checking
                              String startAddr = trip.getStartAddress() != null ? trip.getStartAddress().toLowerCase() : "";
                              String endAddr = trip.getEndAddress() != null ? trip.getEndAddress().toLowerCase() : "";
                              String clientName = trip.getClientName() != null ? trip.getClientName().toLowerCase() : "";
                              String notes = trip.getNotes() != null ? trip.getNotes().toLowerCase() : "";
                              
                              if (startAddr.contains(query) || endAddr.contains(query) || 
                                  clientName.contains(query) || notes.contains(query)) {
                                  filteredTrips.add(trip);
                              }
                          }
                          trips = filteredTrips;
                      }
                      
                      // Apply category filter
                      if (!"All Categories".equals(categoryFilter)) {
                          List<Trip> filteredTrips = new ArrayList<>();
                          for (Trip trip : trips) {
                              if (categoryFilter.equals(trip.getCategory())) {
                                  filteredTrips.add(trip);
                              }
                          }
                          trips = filteredTrips;
                      }
                      
                      // Apply sorting
                      switch (sortOption) {
                          case "Newest First":
                              trips.sort((a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
                              break;
                          case "Oldest First":
                              trips.sort((a, b) -> Long.compare(a.getStartTime(), b.getStartTime()));
                              break;
                          case "Distance High-Low":
                              trips.sort((a, b) -> Double.compare(b.getDistance(), a.getDistance()));
                              break;
                          case "Distance Low-High":
                              trips.sort((a, b) -> Double.compare(a.getDistance(), b.getDistance()));
                              break;
                      }

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          if (searchQuery.isEmpty() && "All Categories".equals(categoryFilter)) {
                              noTripsText.setText("No trips recorded yet.\n\nâœ… NEW FEATURE v4.9.71:\nâ€¢ DATABASE FIELD MAPPING FIXED\nâ€¢ PROPER TIMESTAMP PARSING\nâ€¢ AUTO-DETECTION STATUS RESTORED\nâ€¢ DURATION & DATE CALCULATIONS\nâ€¢ ENCRYPTED DATA HANDLING\n\nTurn ON API sync to see ALL your historic trips!");
                          } else {
                              noTripsText.setText("ðŸ” No trips match your search\n\nTry different keywords or change the category filter");
                          }
                          noTripsText.setTextSize(14);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(15, 30, 15, 15);
                          allTripsLayout.addView(noTripsText);
                      } else {
                          // Add result count header
                          TextView tripCount = new TextView(this);
                          tripCount.setText(String.format("ðŸ“Š Showing %d trip%s", trips.size(), trips.size() == 1 ? "" : "s"));
                          tripCount.setTextSize(12);
                          tripCount.setTextColor(0xFF6C757D);
                          tripCount.setPadding(15, 5, 15, 10);
                          allTripsLayout.addView(tripCount);
                          
                          for (Trip trip : trips) {
                              addTripCard(allTripsLayout, trip, false);
                          }
                      }
                      
                      // Force UI refresh - critical fix for SearchView data display issue
                      allTripsLayout.invalidate();
                      allTripsLayout.requestLayout();
                      allTripsScroll.invalidate();
                      allTripsScroll.requestLayout();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating all trips: " + e.getMessage(), e);
                  }
              }

              private void executeTripseMerge() {
                  try {
                      tripStorage.mergeUserTrips(selectedTripIds);
                      Toast.makeText(this, "âœ… Successfully merged " + selectedTripIds.size() + " trips!", Toast.LENGTH_SHORT).show();
                      
                      // Exit merge mode and refresh
                      mergeMode = false;
                      selectedTripIds.clear();
                      updateAllTrips();
                      updateStats();
                      
                      // Reset merge button - for classify tab only
                      Button mergeButton = (Button) ((LinearLayout) tripsContent.getChildAt(0)).getChildAt(1);
                      mergeButton.setText("ðŸ”€ Merge");
                      mergeButton.setBackgroundColor(0xFF007bff);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                      Toast.makeText(this, "âŒ Error merging trips: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private void executeCategorizedMerge() {
                  try {
                      tripStorage.mergeUserTrips(selectedTripIds);
                      Toast.makeText(this, "âœ… Successfully merged " + selectedTripIds.size() + " trips!", Toast.LENGTH_SHORT).show();
                      
                      // Exit merge mode and refresh
                      mergeMode = false;
                      selectedTripIds.clear();
                      updateCategorizedTrips();
                      updateStats();
                      
                      // Reset merge button for categorized tab - access through categorizedContent
                      LinearLayout buttonContainer = (LinearLayout) categorizedContent.getChildAt(1);
                      LinearLayout buttonLayout = (LinearLayout) buttonContainer.getChildAt(0);
                      Button mergeButton = (Button) buttonLayout.getChildAt(1);
                      mergeButton.setText("MERGE");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                      Toast.makeText(this, "âŒ Error merging trips: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private void executeClassifyMerge() {
                  try {
                      tripStorage.mergeUserTrips(selectedTripIds);
                      Toast.makeText(this, "âœ… Successfully merged " + selectedTripIds.size() + " trips!", Toast.LENGTH_SHORT).show();
                      
                      // Exit merge mode and refresh
                      mergeMode = false;
                      selectedTripIds.clear();
                      
                      // Reset merge button text
                      classifyMergeButton.setText("MERGE");
                      
                      updateClassifyTrips();
                      updateStats();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                      Toast.makeText(this, "âŒ Error merging trips: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private void addTripCard(LinearLayout parentLayout, Trip trip, boolean compact) {
                  try {
                      Log.d(TAG, "Adding trip card for: " + trip.getStartAddress() + " -> " + trip.getEndAddress());
                      
                      // Create container for checkbox + trip info
                      LinearLayout cardContainer = new LinearLayout(this);
                      cardContainer.setOrientation(LinearLayout.VERTICAL); // Changed to vertical for better icon attachment
                      cardContainer.setPadding(15, 15, 15, 15);
                      
                      // Add border for clear card separation with special styling for uncategorized trips
                      GradientDrawable border = new GradientDrawable();
                      
                      // Check if trip is uncategorized and apply white background with thicker border
                      if ("Uncategorized".equals(trip.getCategory())) {
                          cardContainer.setBackgroundColor(0xFFffffff); // Bright white background for uncategorized
                          border.setColor(0xFFffffff);
                          border.setStroke(3, 0xFF007bff); // Thicker blue border for uncategorized trips
                      } else {
                          cardContainer.setBackgroundColor(0xFFffffff); // White background for categorized trips
                          border.setColor(0xFFffffff);
                          border.setStroke(2, 0xFFd0d0d0); // Normal border for categorized trips
                      }
                      
                      border.setCornerRadius(8);
                      cardContainer.setBackground(border);
                      
                      // Add checkbox in merge mode
                      if (mergeMode && !compact) {
                          CheckBox checkbox = new CheckBox(this);
                          checkbox.setChecked(selectedTripIds.contains(String.valueOf(trip.getId())));
                          checkbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                              String tripId = String.valueOf(trip.getId());
                              if (isChecked) {
                                  if (!selectedTripIds.contains(tripId)) {
                                      selectedTripIds.add(tripId);
                                  }
                              } else {
                                  selectedTripIds.remove(tripId);
                              }
                              
                              // Update merge button text for categorized and classify tabs
                              try {
                                  if (currentTab.equals("categorized")) {
                                      LinearLayout buttonContainer = (LinearLayout) categorizedContent.getChildAt(1);
                                      LinearLayout buttonLayout = (LinearLayout) buttonContainer.getChildAt(0);
                                      Button mergeButton = (Button) buttonLayout.getChildAt(1);
                                      mergeButton.setText("âœ… Execute Merge (" + selectedTripIds.size() + ")");
                                  } else if (currentTab.equals("classify")) {
                                      classifyMergeButton.setText("âœ… Execute Merge (" + selectedTripIds.size() + ")");
                                  }
                              } catch (Exception e) {
                                  Log.e(TAG, "Error updating merge button text", e);
                              }
                          });
                          
                          LinearLayout.LayoutParams checkboxParams = new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.WRAP_CONTENT, 
                              LinearLayout.LayoutParams.WRAP_CONTENT
                          );
                          checkbox.setLayoutParams(checkboxParams);
                          cardContainer.addView(checkbox);
                      }
                      
                      TextView tripView = new TextView(this);
                      String tripType = trip.isAutoDetected() ? "ðŸ¤–" : "âœ‹";
                      String apiStatus = "";

                      if (compact) {
                          tripView.setText(String.format(
                              "%s â€¢ %s â€¢ %.1f mi",
                              trip.getCompactDateTime(),
                              tripType,
                              trip.getDistance()
                          ));
                          tripView.setTextSize(11);
                      } else {
                          StringBuilder tripDetails = new StringBuilder();
                          
                          // Get auto-classification suggestion
                          String startSuggestion = getAutoClassificationSuggestion(trip.getStartAddress());
                          String endSuggestion = getAutoClassificationSuggestion(trip.getEndAddress());
                          String autoSuggestion = startSuggestion != null ? startSuggestion : endSuggestion;
                          
                          // Add swipe hint if there's an auto-classification suggestion
                          String swipeHint = "";
                          if (autoSuggestion != null && !autoSuggestion.equals(trip.getCategory())) {
                              swipeHint = String.format(" (Suggest: %s)", autoSuggestion);
                          }
                          
                          tripDetails.append(String.format(
                              "%s â€¢ %s\n%.2f miles â€¢ %s â€¢ %s%s\nFrom: %s\nTo: %s",
                              tripType,
                              trip.getFormattedDateTime(),
                              trip.getDistance(),
                              trip.getFormattedDuration(),
                              trip.getCategory(),
                              swipeHint,
                              trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown",
                              trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown"
                          ));

                          // ADD CLIENT AND NOTES TO TRIP DISPLAY
                          if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                              tripDetails.append("\nClient: ").append(trip.getClientName());
                          }
                          if (trip.getNotes() != null && !trip.getNotes().trim().isEmpty()) {
                              tripDetails.append("\nNotes: ").append(trip.getNotes());
                          }
                          
                          // Swipe instructions removed - they're already shown at the top of the page

                          tripView.setText(tripDetails.toString());
                          tripView.setTextSize(12);
                      }

                      tripView.setTextColor(0xFF495057);
                      tripView.setPadding(10, 10, 10, 10);
                      // Set background color based on trip category
                      int backgroundColor = getPersistentCategoryColor(trip.getCategory());
                      tripView.setBackgroundColor(backgroundColor);
                      tripView.setMinHeight(60); // Ensure minimum height for visibility
                      
                      // Enable direct touch-based swipe detection (much more reliable)
                      if (!compact && !mergeMode) {
                          tripView.setOnTouchListener(new View.OnTouchListener() {
                              private float startX, startY;
                              private long startTime;
                              private boolean touchStarted = false;
                              
                              @Override
                              public boolean onTouch(View v, MotionEvent event) {
                                  Log.d(TAG, "Direct touch event: " + event.getAction() + " on trip: " + trip.getId());
                                  
                                  switch (event.getAction()) {
                                      case MotionEvent.ACTION_DOWN:
                                          startX = event.getX();
                                          startY = event.getY();
                                          startTime = System.currentTimeMillis();
                                          touchStarted = true;
                                          currentSwipeTrip = trip;
                                          currentSwipeView = cardContainer;
                                          Log.d(TAG, "Touch started at: " + startX + ", " + startY);
                                          return true;
                                          
                                      case MotionEvent.ACTION_MOVE:
                                          if (touchStarted && !swipeInProgress) {
                                              float deltaX = event.getX() - startX;
                                              float deltaY = event.getY() - startY;
                                              
                                              Log.d(TAG, "Touch move - deltaX: " + deltaX + ", deltaY: " + deltaY);
                                              
                                              // EXTREMELY SENSITIVE: Only need 8px movement and horizontal dominance
                                              if (Math.abs(deltaX) > 8 && Math.abs(deltaX) > Math.abs(deltaY)) {
                                                  swipeInProgress = true;
                                                  
                                                  if (deltaX > 0) {
                                                      // Right swipe - Business
                                                      Log.d(TAG, "Right swipe detected - Business");
                                                      performSwipeClassification(trip, "Business", 0xFF28A745);
                                                  } else {
                                                      // Left swipe - Personal
                                                      Log.d(TAG, "Left swipe detected - Personal");
                                                      performSwipeClassification(trip, "Personal", 0xFF0044FF);
                                                  }
                                                  return true;
                                              }
                                          }
                                          return true;
                                          
                                      case MotionEvent.ACTION_UP:
                                          if (touchStarted && !swipeInProgress) {
                                              // Normal click - only if no swipe occurred
                                              long touchDuration = System.currentTimeMillis() - startTime;
                                              if (touchDuration < 300) { // Short tap
                                                  Log.d(TAG, "Normal click detected on trip: " + trip.getId());
                                                  v.performClick();
                                              }
                                          }
                                          touchStarted = false;
                                          return true;
                                          
                                      case MotionEvent.ACTION_CANCEL:
                                          touchStarted = false;
                                          return true;
                                  }
                                  return false;
                              }
                          });
                          
                          // Make sure the view is clickable to receive touch events
                          tripView.setClickable(true);
                          tripView.setFocusable(true);
                          tripView.setLongClickable(false); // Disable long click to avoid conflicts
                          Log.d(TAG, "Swipe gestures enabled for trip: " + trip.getId());
                      }

                      // Create vertical layout for trip content + icons FIRST
                      LinearLayout tripContentLayout = new LinearLayout(this);
                      tripContentLayout.setOrientation(LinearLayout.VERTICAL);
                      tripContentLayout.addView(tripView);
                      
                      // Add icons row at the bottom of the trip content (non-compact view only)
                      if (!compact) {
                          // Icons row positioned at bottom with background to clearly attach to trip
                          LinearLayout iconsRow = new LinearLayout(this);
                          iconsRow.setOrientation(LinearLayout.HORIZONTAL);
                          iconsRow.setGravity(Gravity.CENTER);
                          iconsRow.setPadding(10, 8, 10, 8);
                          iconsRow.setBackgroundColor(0xFFF5F5F5); // Light gray background to visually attach icons to trip
                          
                          // Create rounded corners for icon area
                          GradientDrawable iconBorder = new GradientDrawable();
                          iconBorder.setColor(0xFFF5F5F5);
                          iconBorder.setCornerRadius(6);
                          iconsRow.setBackground(iconBorder);
                          
                          LinearLayout.LayoutParams iconsRowParams = new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.MATCH_PARENT,
                              LinearLayout.LayoutParams.WRAP_CONTENT
                          );
                          iconsRowParams.setMargins(0, 15, 0, 0); // Top margin to separate from trip details
                          iconsRow.setLayoutParams(iconsRowParams);
                          
                          // Edit icon - clean, no background
                          TextView editIcon = new TextView(this);
                          editIcon.setText("âœï¸");
                          editIcon.setTextSize(24);
                          editIcon.setPadding(12, 8, 12, 8);
                          editIcon.setGravity(Gravity.CENTER);
                          editIcon.setClickable(true);
                          editIcon.setOnClickListener(v -> showEditTripDialog(trip));
                          
                          LinearLayout.LayoutParams iconParams = new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.WRAP_CONTENT,
                              LinearLayout.LayoutParams.WRAP_CONTENT
                          );
                          iconParams.setMargins(15, 0, 15, 0); // Space between icons
                          
                          // Split icon - clean, no background
                          TextView splitIcon = new TextView(this);
                          splitIcon.setText("âœ‚ï¸");
                          splitIcon.setTextSize(24);
                          splitIcon.setPadding(12, 8, 12, 8);
                          splitIcon.setGravity(Gravity.CENTER);
                          splitIcon.setClickable(true);
                          splitIcon.setOnClickListener(v -> showSplitTripDialog(trip));
                          
                          // Delete icon - clean, no background
                          TextView deleteIcon = new TextView(this);
                          deleteIcon.setText("ðŸ—‘ï¸");
                          deleteIcon.setTextSize(24);
                          deleteIcon.setPadding(12, 8, 12, 8);
                          deleteIcon.setGravity(Gravity.CENTER);
                          deleteIcon.setClickable(true);
                          deleteIcon.setOnClickListener(v -> showDeleteConfirmationDialog(trip));
                          
                          iconsRow.addView(editIcon, iconParams);
                          iconsRow.addView(splitIcon, iconParams);
                          iconsRow.addView(deleteIcon, iconParams);
                          
                          tripContentLayout.addView(iconsRow);
                      }
                      
                      // Set layout params for trip content within container
                      LinearLayout.LayoutParams tripContentParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      tripContentLayout.setLayoutParams(tripContentParams);
                      cardContainer.addView(tripContentLayout);

                      // Set layout params with better spacing between cards
                      LinearLayout.LayoutParams containerParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT,
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      containerParams.setMargins(0, 5, 0, 20); // Increased bottom margin for better separation
                      cardContainer.setLayoutParams(containerParams);

                      // Add the card container to parent layout AFTER everything is built
                      parentLayout.addView(cardContainer);
                      Log.d(TAG, "Trip card added successfully to parent layout");
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding trip card: " + e.getMessage(), e);
                  }
              }

              // ENHANCED ADD TRIP DIALOG WITH DURATION INPUT FIELD
              private void showAddTripDialog() {
                  try {
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Add Trip");

                      ScrollView scrollView = new ScrollView(this);
                      LinearLayout layout = new LinearLayout(this);
                      layout.setOrientation(LinearLayout.VERTICAL);
                      layout.setPadding(40, 15, 40, 15);

                      // DATE PICKER FIELD
                      TextView dateLabel = new TextView(this);
                      dateLabel.setText("Trip Date:");
                      dateLabel.setTextSize(14);
                      dateLabel.setTextColor(0xFF495057);
                      dateLabel.setPadding(0, 0, 0, 5);
                      layout.addView(dateLabel);

                      Button datePickerButton = new Button(this);
                      datePickerButton.setText("Select Date");
                      datePickerButton.setBackgroundColor(0xFFe9ecef);
                      datePickerButton.setTextColor(0xFF495057);
                      java.util.Calendar calendar = java.util.Calendar.getInstance();
                      final int[] selectedYear = {calendar.get(java.util.Calendar.YEAR)};
                      final int[] selectedMonth = {calendar.get(java.util.Calendar.MONTH)};
                      final int[] selectedDay = {calendar.get(java.util.Calendar.DAY_OF_MONTH)};
                      
                      datePickerButton.setText(String.format("%d/%d/%d", selectedMonth[0] + 1, selectedDay[0], selectedYear[0]));
                      
                      datePickerButton.setOnClickListener(v -> {
                          android.app.DatePickerDialog datePickerDialog = new android.app.DatePickerDialog(
                              this,
                              (view, year, month, dayOfMonth) -> {
                                  selectedYear[0] = year;
                                  selectedMonth[0] = month;
                                  selectedDay[0] = dayOfMonth;
                                  datePickerButton.setText(String.format("%d/%d/%d", month + 1, dayOfMonth, year));
                              },
                              selectedYear[0], selectedMonth[0], selectedDay[0]
                          );
                          datePickerDialog.show();
                      });
                      layout.addView(datePickerButton);

                      EditText startLocationInput = new EditText(this);
                      startLocationInput.setHint("Start location (e.g., Home)");
                      layout.addView(startLocationInput);

                      EditText endLocationInput = new EditText(this);
                      endLocationInput.setHint("End location (e.g., Client Office)");
                      layout.addView(endLocationInput);

                      EditText distanceInput = new EditText(this);
                      distanceInput.setHint("Distance in miles (e.g., 12.5)");
                      distanceInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                      layout.addView(distanceInput);

                      // DURATION INPUT FIELD
                      TextView durationLabel = new TextView(this);
                      durationLabel.setText("Duration (enter your own time):");
                      durationLabel.setTextSize(14);
                      durationLabel.setTextColor(0xFF495057);
                      durationLabel.setPadding(0, 10, 0, 5);
                      layout.addView(durationLabel);

                      EditText durationInput = new EditText(this);
                      durationInput.setHint("Duration in minutes (e.g., 25)");
                      durationInput.setInputType(InputType.TYPE_CLASS_NUMBER);
                      layout.addView(durationInput);

                      Spinner categorySpinner = new Spinner(this);
                      List<String> allCategories = new ArrayList<>();
                      allCategories.add("Uncategorized");
                      allCategories.addAll(tripStorage.getAllCategories());
                      String[] categories = allCategories.toArray(new String[0]);
                      ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                      categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                      categorySpinner.setAdapter(categoryAdapter);
                      categorySpinner.setSelection(0); // Default to "Uncategorized"
                      layout.addView(categorySpinner);

                      // CLIENT DROPDOWN
                      TextView clientLabel = new TextView(this);
                      clientLabel.setText("Client (Optional):");
                      clientLabel.setTextSize(14);
                      clientLabel.setTextColor(0xFF495057);
                      clientLabel.setPadding(0, 10, 0, 5);
                      layout.addView(clientLabel);

                      Spinner clientSpinner = new Spinner(this);
                      List<String> clientOptions = getClientOptions();
                      ArrayAdapter<String> clientAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, clientOptions);
                      clientAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                      clientSpinner.setAdapter(clientAdapter);
                      layout.addView(clientSpinner);

                      // NOTES FIELD
                      TextView notesLabel = new TextView(this);
                      notesLabel.setText("Notes/Description (Optional):");
                      notesLabel.setTextSize(14);
                      notesLabel.setTextColor(0xFF495057);
                      notesLabel.setPadding(0, 10, 0, 5);
                      layout.addView(notesLabel);

                      EditText notesInput = new EditText(this);
                      notesInput.setHint("Purpose, meeting details, project notes, etc.");
                      notesInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE);
                      notesInput.setMinLines(2);
                      notesInput.setMaxLines(4);
                      layout.addView(notesInput);

                      scrollView.addView(layout);
                      builder.setView(scrollView);

                      builder.setPositiveButton("Save Trip", (dialog, which) -> {
                          String startLocation = startLocationInput.getText().toString().trim();
                          String endLocation = endLocationInput.getText().toString().trim();
                          String distanceStr = distanceInput.getText().toString().trim();
                          String durationStr = durationInput.getText().toString().trim();
                          String category = categorySpinner.getSelectedItem().toString();
                          String selectedClient = clientSpinner.getSelectedItem().toString();
                          String notes = notesInput.getText().toString().trim();

                          if (startLocation.isEmpty() || endLocation.isEmpty() || distanceStr.isEmpty() || durationStr.isEmpty()) {
                              Toast.makeText(this, "Please fill all required fields including duration", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          try {
                              double distance = Double.parseDouble(distanceStr);
                              int durationMinutes = Integer.parseInt(durationStr);

                              // Process client selection
                              String clientName = null;
                              if (!"None".equals(selectedClient) && !"+ Add New Client".equals(selectedClient)) {
                                  clientName = selectedClient;
                              }

                              // Create selected date timestamp
                              java.util.Calendar selectedDate = java.util.Calendar.getInstance();
                              selectedDate.set(selectedYear[0], selectedMonth[0], selectedDay[0], 0, 0, 0);
                              selectedDate.set(java.util.Calendar.MILLISECOND, 0);
                              long selectedDateTimestamp = selectedDate.getTimeInMillis();

                              if ("+ Add New Client".equals(selectedClient)) {
                                  // Show add new client dialog
                                  showAddClientDialog(startLocation, endLocation, distance, durationMinutes, category, notes, selectedDateTimestamp);
                                  return;
                              }
                              
                              saveManualTripWithDuration(startLocation, endLocation, distance, durationMinutes, category, clientName, notes, selectedDateTimestamp);

                          } catch (NumberFormatException e) {
                              Toast.makeText(this, "Invalid distance or duration format", Toast.LENGTH_SHORT).show();
                          }
                      });

                      builder.setNegativeButton("Cancel", null);
                      builder.show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error showing add trip dialog: " + e.getMessage(), e);
                  }
              }

              private List<String> getClientOptions() {
                  List<String> options = new ArrayList<>();
                  options.add("None");

                  // Get existing clients from trips
                  List<Trip> trips = tripStorage.getAllTrips();
                  List<String> existingClients = new ArrayList<>();
                  for (Trip trip : trips) {
                      if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                          String clientName = trip.getClientName().trim();
                          if (!existingClients.contains(clientName)) {
                              existingClients.add(clientName);
                          }
                      }
                  }

                  options.addAll(existingClients);
                  options.add("+ Add New Client");

                  return options;
              }

              private void showAddClientDialog(String startLocation, String endLocation, double distance, int durationMinutes, String category, String notes, long selectedDateTimestamp) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Add New Client");

                  EditText clientInput = new EditText(this);
                  clientInput.setHint("Client name (e.g., ABC Company)");
                  builder.setView(clientInput);

                  builder.setPositiveButton("Add Client", (dialog, which) -> {
                      String newClientName = clientInput.getText().toString().trim();
                      if (!newClientName.isEmpty()) {
                          saveManualTripWithDuration(startLocation, endLocation, distance, durationMinutes, category, newClientName, notes, selectedDateTimestamp);
                      } else {
                          Toast.makeText(this, "Client name cannot be empty", Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              // Use user-entered duration instead of calculated
              private void saveManualTripWithDuration(String startLocation, String endLocation, double distance, int durationMinutes, String category, String clientName, String notes, long selectedDateTimestamp) {
                  try {
                      Trip trip = new Trip();
                      trip.setStartAddress(startLocation);
                      trip.setEndAddress(endLocation);
                      trip.setDistance(distance);
                      trip.setCategory(category);
                      trip.setAutoDetected(false);

                      // SET CLIENT AND NOTES
                      trip.setClientName(clientName);
                      trip.setNotes(notes);

                      // Set approximate coordinates
                      trip.setStartLatitude(40.7128);
                      trip.setStartLongitude(-74.0060);
                      trip.setEndLatitude(40.7589);
                      trip.setEndLongitude(-73.9851);

                      // USE USER-ENTERED DURATION AND SELECTED DATE
                      long userDuration = durationMinutes * 60 * 1000; // Convert minutes to milliseconds
                      trip.setStartTime(selectedDateTimestamp);
                      trip.setEndTime(selectedDateTimestamp + userDuration);
                      trip.setDuration(userDuration);

                      // Generate unique ID
                      long currentTime = System.currentTimeMillis();
                      trip.setId(currentTime);

                      Log.d(TAG, String.format("Manual trip with USER duration: %.2f miles, %d minutes", distance, durationMinutes));

                      // Save locally
                      tripStorage.saveTrip(trip);

                      // Save to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudBackup = new CloudBackupService(this);
                          cloudBackup.backupTrip(trip);
                          String clientInfo = clientName != null ? " for " + clientName : "";
                          String notesInfo = notes != null && !notes.isEmpty() ? " with notes" : "";
                          Toast.makeText(this, String.format("Trip saved (%dm)%s%s and synced!", durationMinutes, clientInfo, notesInfo), Toast.LENGTH_SHORT).show();
                      } else {
                          Toast.makeText(this, String.format("Trip saved locally (%dm)!", durationMinutes), Toast.LENGTH_SHORT).show();
                      }

                      updateStats();

                      if ("home".equals(currentTab)) {
                          updateRecentTrips();
                      } else {
                          updateAllTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving manual trip with duration: " + e.getMessage(), e);
                  }
              }

              // Rest of methods - copy exactly from working version (no changes needed)
              private void startManualTrip() {
                  try {
                      if (manualTripInProgress) {
                          Toast.makeText(this, "Manual trip already in progress", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      
                      // Pause auto detection during manual trip to prevent duplicates
                      if (autoDetectionEnabled) {
                          SharedPreferences prefs = getSharedPreferences("MileTrackerPrefs", Context.MODE_PRIVATE);
                          prefs.edit().putBoolean("auto_detection_was_enabled", true).apply();
                          autoDetectionEnabled = false;
                          if (autoToggle != null) {
                              autoToggle.setText("Auto Detection: OFF");
                              autoToggle.setBackgroundColor(0xFF9CA3AF);
                          }
                          Toast.makeText(this, "Auto detection paused during manual trip", Toast.LENGTH_SHORT).show();
                      }

                      Intent serviceIntent = new Intent(this, ManualTripService.class);
                      serviceIntent.setAction("START_MANUAL_TRIP");
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                          startForegroundService(serviceIntent);
                      } else {
                          startService(serviceIntent);
                      }

                      manualTripInProgress = true;
                      manualStartButton.setEnabled(false);
                      manualStopButton.setEnabled(true);
                      statusText.setText("Manual trip recording...");

                      String apiStatus = tripStorage.isApiSyncEnabled() ? " with API sync" : " (local only)";
                      Toast.makeText(this, "Manual trip started" + apiStatus, Toast.LENGTH_SHORT).show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (!manualTripInProgress) {
                          Toast.makeText(this, "No manual trip in progress", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      Intent serviceIntent = new Intent(this, ManualTripService.class);
                      serviceIntent.setAction("STOP_MANUAL_TRIP");
                      startService(serviceIntent);

                      manualTripInProgress = false;
                      manualStartButton.setEnabled(true);
                      manualStopButton.setEnabled(false);
                      statusText.setText("Manual trip completed");

                      // Resume auto detection if it was enabled before manual trip
                      SharedPreferences prefs = getSharedPreferences("MileTrackerPrefs", Context.MODE_PRIVATE);
                      boolean wasAutoEnabled = prefs.getBoolean("auto_detection_was_enabled", false);
                      if (wasAutoEnabled) {
                          autoDetectionEnabled = true;
                          if (autoToggle != null) {
                              autoToggle.setText("Auto Detection: ON");
                              autoToggle.setBackgroundColor(0xFF667eea);
                          }
                          prefs.edit().remove("auto_detection_was_enabled").apply();
                          Toast.makeText(this, "Auto detection resumed", Toast.LENGTH_SHORT).show();
                      }

                      String apiStatus = tripStorage.isApiSyncEnabled() ? " and synced!" : " (saved locally)!";
                      Toast.makeText(this, "Trip saved" + apiStatus, Toast.LENGTH_SHORT).show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void toggleAutoDetection() {
                  try {
                      autoDetectionEnabled = !autoDetectionEnabled;

                      if (autoDetectionEnabled) {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");

                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }

                          autoToggle.setText("Auto Detection: ON");
                          autoToggle.setBackgroundColor(0xFF667eea);
                          statusText.setText("Auto detection active - Monitoring for trips");

                          String apiStatus = tripStorage.isApiSyncEnabled() ? " with API sync" : " (local only)";
                          Toast.makeText(this, "Auto detection started" + apiStatus, Toast.LENGTH_SHORT).show();
                      } else {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("STOP_AUTO_DETECTION");
                          startService(serviceIntent);

                          autoToggle.setText("Auto Detection: OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Auto detection stopped");
                          Toast.makeText(this, "Auto detection stopped", Toast.LENGTH_SHORT).show();
                      }

                      updateStats();
                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling auto detection: " + e.getMessage(), e);
                  }
              }

              private void showDeviceManagementDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("ðŸ“± Device Management");
                  
                  // Create scrollable dialog layout
                  ScrollView scrollView = new ScrollView(this);
                  scrollView.setLayoutParams(new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  ));
                  
                  LinearLayout dialogLayout = new LinearLayout(this);
                  dialogLayout.setOrientation(LinearLayout.VERTICAL);
                  dialogLayout.setPadding(30, 20, 30, 20);
                  
                  // Current Device Info
                  TextView currentDeviceHeader = new TextView(this);
                  currentDeviceHeader.setText("ðŸ”µ Current Device");
                  currentDeviceHeader.setTextSize(16);
                  currentDeviceHeader.setTextColor(0xFF495057);
                  currentDeviceHeader.setTypeface(null, Typeface.BOLD);
                  currentDeviceHeader.setPadding(0, 0, 0, 10);
                  dialogLayout.addView(currentDeviceHeader);
                  
                  UserAuthManager authManager = new UserAuthManager(this);
                  String deviceEmail = authManager.getDeviceEmail();
                  String deviceName = authManager.getDeviceName();
                  
                  TextView currentDeviceInfo = new TextView(this);
                  currentDeviceInfo.setText("Email: " + deviceEmail + "\nModel: " + deviceName + "\nStatus: Active");
                  currentDeviceInfo.setTextSize(14);
                  currentDeviceInfo.setTextColor(0xFF2E7D32);
                  currentDeviceInfo.setPadding(10, 5, 10, 15);
                  currentDeviceInfo.setBackgroundColor(0xFFE8F5E8);
                  dialogLayout.addView(currentDeviceInfo);
                  
                  // Family Device Slots
                  TextView familyDevicesHeader = new TextView(this);
                  familyDevicesHeader.setText("ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family Device Slots");
                  familyDevicesHeader.setTextSize(16);
                  familyDevicesHeader.setTextColor(0xFF495057);
                  familyDevicesHeader.setTypeface(null, Typeface.BOLD);
                  familyDevicesHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(familyDevicesHeader);
                  
                  TextView familyInfo = new TextView(this);
                  familyInfo.setText("Professional tier: 3 devices maximum\n\n" +
                      "ðŸ”µ Device 1: " + deviceEmail + " (This device)\n" +
                      "âšª Device 2: Available\n" +
                      "âšª Device 3: Available\n\n" +
                      "Perfect for couples tracking separate vehicles!");
                  familyInfo.setTextSize(14);
                  familyInfo.setTextColor(0xFF1976D2);
                  familyInfo.setPadding(10, 5, 10, 15);
                  familyInfo.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(familyInfo);
                  
                  // Instructions
                  TextView instructionsHeader = new TextView(this);
                  instructionsHeader.setText("â„¹ï¸ How It Works");
                  instructionsHeader.setTextSize(16);
                  instructionsHeader.setTextColor(0xFF495057);
                  instructionsHeader.setTypeface(null, Typeface.BOLD);
                  instructionsHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(instructionsHeader);
                  
                  TextView instructions = new TextView(this);
                  instructions.setText("â€¢ Install MileTracker Pro on spouse's phone\n" +
                      "â€¢ Login with same account credentials\n" +
                      "â€¢ Each device automatically registers\n" +
                      "â€¢ When 4th device tries to login, choose which to deactivate\n" +
                      "â€¢ Perfect for families with multiple vehicles");
                  instructions.setTextSize(14);
                  instructions.setTextColor(0xFF495057);
                  instructions.setPadding(10, 5, 10, 15);
                  instructions.setBackgroundColor(0xFFF0F8FF);
                  dialogLayout.addView(instructions);
                  
                  scrollView.addView(dialogLayout);
                  builder.setView(scrollView);
                  
                  builder.setPositiveButton("OK", (dialog, which) -> {
                      dialog.dismiss();
                  });
                  
                  AlertDialog dialog = builder.create();
                  dialog.show();
              }

              private void showSettingsDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("âš™ï¸ Settings");
                  
                  // Create scrollable dialog layout
                  ScrollView scrollView = new ScrollView(this);
                  scrollView.setLayoutParams(new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  ));
                  
                  LinearLayout dialogLayout = new LinearLayout(this);
                  dialogLayout.setOrientation(LinearLayout.VERTICAL);
                  dialogLayout.setPadding(30, 20, 30, 20);
                  
                  // Account Information Section
                  TextView accountHeader = new TextView(this);
                  accountHeader.setText("ðŸ‘¤ Account Information");
                  accountHeader.setTextSize(16);
                  accountHeader.setTextColor(0xFF495057);
                  accountHeader.setTypeface(null, Typeface.BOLD);
                  accountHeader.setPadding(0, 0, 0, 10);
                  dialogLayout.addView(accountHeader);
                  
                  TextView userInfo = new TextView(this);
                  UserAuthManager authManager = new UserAuthManager(this);
                  String userEmail = authManager.getCurrentUserEmail();
                  if (userEmail == null || userEmail.isEmpty()) {
                      userEmail = "Not authenticated";
                  }
                  String userAccess = "Professional"; // Multi-device family sharing tier
                  userInfo.setText("User: " + userEmail + "\n\nTier: " + userAccess + " (Multi-device support)");
                  userInfo.setTextSize(14);
                  userInfo.setTextColor(0xFF1976D2);
                  userInfo.setPadding(10, 5, 10, 15);
                  userInfo.setBackgroundColor(0xFFE8F5E8);
                  dialogLayout.addView(userInfo);
                  
                  // Device Management Section (Professional tier feature)
                  TextView deviceHeader = new TextView(this);
                  deviceHeader.setText("ðŸ“± Device Management");
                  deviceHeader.setTextSize(16);
                  deviceHeader.setTextColor(0xFF495057);
                  deviceHeader.setTypeface(null, Typeface.BOLD);
                  deviceHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(deviceHeader);
                  
                  TextView deviceInfo = new TextView(this);
                  String deviceEmail = authManager.getDeviceEmail();
                  String deviceName = authManager.getDeviceName();
                  deviceInfo.setText("This Device: " + deviceEmail + "\nModel: " + deviceName + "\n\nProfessional tier allows up to 3 devices per family");
                  deviceInfo.setTextSize(14);
                  deviceInfo.setTextColor(0xFF2E7D32);
                  deviceInfo.setPadding(10, 5, 10, 10);
                  deviceInfo.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(deviceInfo);
                  
                  // Device Management Button
                  Button deviceManagementButton = new Button(this);
                  deviceManagementButton.setText("ðŸ“± Manage Family Devices");
                  deviceManagementButton.setBackgroundColor(0xFF667eea);
                  deviceManagementButton.setTextColor(0xFFFFFFFF);
                  deviceManagementButton.setOnClickListener(v -> {
                      showDeviceManagementDialog();
                  });
                  dialogLayout.addView(deviceManagementButton);
                  
                  // Backup Status Section
                  TextView backupHeader = new TextView(this);
                  backupHeader.setText("â˜ï¸ Backup Status");
                  backupHeader.setTextSize(16);
                  backupHeader.setTextColor(0xFF495057);
                  backupHeader.setTypeface(null, Typeface.BOLD);
                  backupHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(backupHeader);
                  
                  String apiStatus = this.tripStorage.isApiSyncEnabled() ? "Active" : "Disabled";
                  String autoStatus = this.autoDetectionEnabled ? "Active" : "Disabled";
                  
                  TextView backupInfo = new TextView(this);
                  backupInfo.setText("Auto Detection: " + autoStatus);
                  backupInfo.setTextSize(14);
                  backupInfo.setTextColor(0xFF2E7D32);
                  backupInfo.setPadding(10, 5, 10, 5);
                  backupInfo.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(backupInfo);
                  
                  // Cloud Backup Toggle Button
                  Button cloudBackupToggle = new Button(this);
                  if (this.tripStorage.isApiSyncEnabled()) {
                      cloudBackupToggle.setText("â˜ï¸ Cloud Backup: ON");
                      cloudBackupToggle.setBackgroundColor(0xFF28a745);
                      cloudBackupToggle.setTextColor(0xFFFFFFFF);
                  } else {
                      cloudBackupToggle.setText("â˜ï¸ Cloud Backup: OFF");
                      cloudBackupToggle.setBackgroundColor(0xFF9CA3AF);
                      cloudBackupToggle.setTextColor(0xFFFFFFFF);
                  }
                  cloudBackupToggle.setTextSize(14);
                  cloudBackupToggle.setPadding(10, 10, 10, 10);
                  LinearLayout.LayoutParams cloudParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  cloudParams.setMargins(0, 0, 0, 15);
                  cloudBackupToggle.setLayoutParams(cloudParams);
                  cloudBackupToggle.setOnClickListener(v -> {
                      toggleApiSync();
                      // Update button appearance immediately after toggle
                      if (this.tripStorage.isApiSyncEnabled()) {
                          cloudBackupToggle.setText("â˜ï¸ Cloud Backup: ON");
                          cloudBackupToggle.setBackgroundColor(0xFF28a745);
                          cloudBackupToggle.setTextColor(0xFFFFFFFF);
                          Toast.makeText(this, "Cloud backup enabled", Toast.LENGTH_SHORT).show();
                          
                          // Sync custom categories when enabling cloud backup
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.syncCustomCategoriesWithAPI();
                      } else {
                          cloudBackupToggle.setText("â˜ï¸ Cloud Backup: OFF");
                          cloudBackupToggle.setBackgroundColor(0xFF9CA3AF);
                          cloudBackupToggle.setTextColor(0xFFFFFFFF);
                          Toast.makeText(this, "Cloud backup disabled", Toast.LENGTH_SHORT).show();
                      }
                  });
                  dialogLayout.addView(cloudBackupToggle);
                  
                  // IRS Tax Rates Section
                  TextView irsHeader = new TextView(this);
                  irsHeader.setText("IRS Tax Rates (" + getIrsYear() + ")");
                  irsHeader.setTextSize(16);
                  irsHeader.setTextColor(0xFF495057);
                  irsHeader.setTypeface(null, Typeface.BOLD);
                  irsHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(irsHeader);
                  
                  TextView irsInfo = new TextView(this);
                  String irsText = String.format(
                      "Business: $%.2f per mile\nMedical: $%.2f per mile\nCharity: $%.2f per mile",
                      getIrsBusinessRate(), getIrsMedicalRate(), getIrsCharityRate());
                  irsInfo.setText(irsText);
                  irsInfo.setTextSize(14);
                  irsInfo.setTextColor(0xFF2E7D32);
                  irsInfo.setPadding(10, 5, 10, 5);
                  irsInfo.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(irsInfo);
                  
                  // Update IRS Rates Button
                  Button updateIrsButton = new Button(this);
                  updateIrsButton.setText("ðŸ“ Update IRS Rates");
                  updateIrsButton.setBackgroundColor(0xFF667eea);
                  updateIrsButton.setTextColor(0xFFFFFFFF);
                  updateIrsButton.setTextSize(14);
                  updateIrsButton.setPadding(10, 10, 10, 10);
                  LinearLayout.LayoutParams irsParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  irsParams.setMargins(0, 5, 0, 15);
                  updateIrsButton.setLayoutParams(irsParams);
                  updateIrsButton.setOnClickListener(v -> showUpdateIrsRatesDialog());
                  dialogLayout.addView(updateIrsButton);
                  
                  // App Information Section
                  TextView appHeader = new TextView(this);
                  appHeader.setText("ðŸ“± App Information");
                  appHeader.setTextSize(16);
                  appHeader.setTextColor(0xFF495057);
                  appHeader.setTypeface(null, Typeface.BOLD);
                  appHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(appHeader);
                  
                  TextView appInfo = new TextView(this);
                  appInfo.setText("Version: v4.9.137\nAdvanced Round-Trip Detection");
                  appInfo.setTextSize(14);
                  appInfo.setTextColor(0xFF6C757D);
                  appInfo.setPadding(10, 5, 10, 15);
                  appInfo.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(appInfo);
                  
                  // Manage Categories Button
                  TextView categoriesHeader = new TextView(this);
                  categoriesHeader.setText("ðŸ·ï¸ Categories");
                  categoriesHeader.setTextSize(16);
                  categoriesHeader.setTextColor(0xFF495057);
                  categoriesHeader.setTypeface(null, Typeface.BOLD);
                  categoriesHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(categoriesHeader);
                  
                  Button manageCategoriesButton = new Button(this);
                  manageCategoriesButton.setText("Manage Categories");
                  manageCategoriesButton.setTextSize(14);
                  manageCategoriesButton.setTextColor(0xFFFFFFFF);
                  manageCategoriesButton.setBackgroundColor(0xFF667eea);
                  manageCategoriesButton.setPadding(20, 15, 20, 15);
                  manageCategoriesButton.setOnClickListener(v -> {
                      showManageCategoriesDialog();
                  });
                  dialogLayout.addView(manageCategoriesButton);
                  
                  // Work Hours Auto-Classification Section
                  TextView workHoursHeader = new TextView(this);
                  workHoursHeader.setText("â° Work Hours Auto-Classification");
                  workHoursHeader.setTextSize(16);
                  workHoursHeader.setTextColor(0xFF495057);
                  workHoursHeader.setTypeface(null, Typeface.BOLD);
                  workHoursHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(workHoursHeader);
                  
                  // Work Hours Status Display
                  TextView workHoursStatus = new TextView(this);
                  boolean isWorkHoursEnabled = tripStorage.isWorkHoursEnabled();
                  String workHoursText = isWorkHoursEnabled ? 
                      String.format("Status: ENABLED\nWork Hours: %s - %s\nWork Days: %s", 
                          tripStorage.getWorkStartTime(), 
                          tripStorage.getWorkEndTime(), 
                          getWorkDaysString(tripStorage.getWorkDays())) :
                      "Status: DISABLED\nOptional feature for automatic trip classification";
                  workHoursStatus.setText(workHoursText);
                  workHoursStatus.setTextSize(14);
                  workHoursStatus.setTextColor(0xFF6C757D);
                  workHoursStatus.setPadding(10, 5, 10, 15);
                  workHoursStatus.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(workHoursStatus);
                  
                  // Configure Work Hours Button
                  Button configureWorkHoursButton = new Button(this);
                  configureWorkHoursButton.setText("Configure Work Hours");
                  configureWorkHoursButton.setTextSize(14);
                  configureWorkHoursButton.setTextColor(0xFFFFFFFF);
                  configureWorkHoursButton.setBackgroundColor(0xFF667eea);
                  configureWorkHoursButton.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams workHoursParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  workHoursParams.setMargins(0, 5, 0, 15);
                  configureWorkHoursButton.setLayoutParams(workHoursParams);
                  configureWorkHoursButton.setOnClickListener(v -> {
                      showConfigureWorkHoursDialog();
                  });
                  dialogLayout.addView(configureWorkHoursButton);
                  
                  // Round-Trip Detection Section
                  TextView roundTripHeader = new TextView(this);
                  roundTripHeader.setText("ðŸ”„ Round-Trip Detection");
                  roundTripHeader.setTextSize(16);
                  roundTripHeader.setTextColor(0xFF495057);
                  roundTripHeader.setTypeface(null, Typeface.BOLD);
                  roundTripHeader.setPadding(0, 15, 0, 10);
                  dialogLayout.addView(roundTripHeader);
                  
                  // Round-Trip Status Display
                  TextView roundTripStatus = new TextView(this);
                  int roundTripCount = tripStorage.getRoundTripGroups().size();
                  String roundTripText = String.format(
                      "Round-Trip Groups: %d\n" +
                      "â€¢ Daily round-trips (Aâ†’Bâ†’A same day)\n" +
                      "â€¢ Multi-day business trips (with airports)\n" +
                      "â€¢ Complex trip groups (mixed activities)\n" +
                      "Superior to MileIQ's primitive detection!", 
                      roundTripCount);
                  roundTripStatus.setText(roundTripText);
                  roundTripStatus.setTextSize(14);
                  roundTripStatus.setTextColor(0xFF6C757D);
                  roundTripStatus.setPadding(10, 5, 10, 15);
                  roundTripStatus.setBackgroundColor(0xFFF8F9FA);
                  dialogLayout.addView(roundTripStatus);
                  
                  // Manual Round-Trip Detection Button
                  Button detectRoundTripsButton = new Button(this);
                  detectRoundTripsButton.setText("ðŸ” Detect Round-Trips");
                  detectRoundTripsButton.setTextSize(14);
                  detectRoundTripsButton.setTextColor(0xFFFFFFFF);
                  detectRoundTripsButton.setBackgroundColor(0xFF667eea);
                  detectRoundTripsButton.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams detectParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  detectParams.setMargins(0, 5, 0, 15);
                  detectRoundTripsButton.setLayoutParams(detectParams);
                  detectRoundTripsButton.setOnClickListener(v -> {
                      // Run round-trip detection in background
                      detectRoundTripsButton.setEnabled(false);
                      detectRoundTripsButton.setText("ðŸ”„ Detecting...");
                      
                      new Thread(() -> {
                          try {
                              tripStorage.detectRoundTrips();
                              runOnUiThread(() -> {
                                  detectRoundTripsButton.setEnabled(true);
                                  detectRoundTripsButton.setText("ðŸ” Detect Round-Trips");
                                  int newCount = tripStorage.getRoundTripGroups().size();
                                  Toast.makeText(this, "Round-trip detection completed. Found " + newCount + " groups.", Toast.LENGTH_SHORT).show();
                                  roundTripStatus.setText(String.format(
                                      "Round-Trip Groups: %d\n" +
                                      "â€¢ Daily round-trips (Aâ†’Bâ†’A same day)\n" +
                                      "â€¢ Multi-day business trips (with airports)\n" +
                                      "â€¢ Complex trip groups (mixed activities)\n" +
                                      "Superior to MileIQ's primitive detection!", 
                                      newCount));
                              });
                          } catch (Exception e) {
                              Log.e(TAG, "Error in round-trip detection", e);
                              runOnUiThread(() -> {
                                  detectRoundTripsButton.setEnabled(true);
                                  detectRoundTripsButton.setText("ðŸ” Detect Round-Trips");
                                  Toast.makeText(this, "Detection error: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                              });
                          }
                      }).start();
                  });
                  dialogLayout.addView(detectRoundTripsButton);
                  
                  scrollView.addView(dialogLayout);
                  builder.setView(scrollView);
                  builder.setPositiveButton("Close", null);
                  builder.show();
              }

              private void showUpdateIrsRatesDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Update IRS Tax Rates");
                  
                  // Create dialog layout
                  LinearLayout dialogLayout = new LinearLayout(this);
                  dialogLayout.setOrientation(LinearLayout.VERTICAL);
                  dialogLayout.setPadding(30, 20, 30, 20);
                  
                  // Year input
                  TextView yearLabel = new TextView(this);
                  yearLabel.setText("Tax Year:");
                  yearLabel.setTextSize(14);
                  yearLabel.setTextColor(0xFF495057);
                  yearLabel.setPadding(0, 0, 0, 5);
                  dialogLayout.addView(yearLabel);
                  
                  EditText yearInput = new EditText(this);
                  yearInput.setText(String.valueOf(getIrsYear()));
                  yearInput.setInputType(InputType.TYPE_CLASS_NUMBER);
                  yearInput.setHint("2025");
                  LinearLayout.LayoutParams yearParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  yearParams.setMargins(0, 0, 0, 15);
                  yearInput.setLayoutParams(yearParams);
                  dialogLayout.addView(yearInput);
                  
                  // Business rate input
                  TextView businessLabel = new TextView(this);
                  businessLabel.setText("Business Rate (per mile):");
                  businessLabel.setTextSize(14);
                  businessLabel.setTextColor(0xFF495057);
                  businessLabel.setPadding(0, 0, 0, 5);
                  dialogLayout.addView(businessLabel);
                  
                  EditText businessInput = new EditText(this);
                  businessInput.setText(String.format("%.2f", getIrsBusinessRate()));
                  businessInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  businessInput.setHint("0.70");
                  LinearLayout.LayoutParams businessParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  businessParams.setMargins(0, 0, 0, 15);
                  businessInput.setLayoutParams(businessParams);
                  dialogLayout.addView(businessInput);
                  
                  // Medical rate input
                  TextView medicalLabel = new TextView(this);
                  medicalLabel.setText("Medical Rate (per mile):");
                  medicalLabel.setTextSize(14);
                  medicalLabel.setTextColor(0xFF495057);
                  medicalLabel.setPadding(0, 0, 0, 5);
                  dialogLayout.addView(medicalLabel);
                  
                  EditText medicalInput = new EditText(this);
                  medicalInput.setText(String.format("%.2f", getIrsMedicalRate()));
                  medicalInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  medicalInput.setHint("0.21");
                  LinearLayout.LayoutParams medicalParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  medicalParams.setMargins(0, 0, 0, 15);
                  medicalInput.setLayoutParams(medicalParams);
                  dialogLayout.addView(medicalInput);
                  
                  // Charity rate input
                  TextView charityLabel = new TextView(this);
                  charityLabel.setText("Charity Rate (per mile):");
                  charityLabel.setTextSize(14);
                  charityLabel.setTextColor(0xFF495057);
                  charityLabel.setPadding(0, 0, 0, 5);
                  dialogLayout.addView(charityLabel);
                  
                  EditText charityInput = new EditText(this);
                  charityInput.setText(String.format("%.2f", getIrsCharityRate()));
                  charityInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  charityInput.setHint("0.14");
                  LinearLayout.LayoutParams charityParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  charityParams.setMargins(0, 0, 0, 15);
                  charityInput.setLayoutParams(charityParams);
                  dialogLayout.addView(charityInput);
                  
                  builder.setView(dialogLayout);
                  
                  builder.setPositiveButton("Save", (dialog, which) -> {
                      try {
                          int year = Integer.parseInt(yearInput.getText().toString());
                          double businessRate = Double.parseDouble(businessInput.getText().toString());
                          double medicalRate = Double.parseDouble(medicalInput.getText().toString());
                          double charityRate = Double.parseDouble(charityInput.getText().toString());
                          
                          // Save to SharedPreferences
                          SharedPreferences prefs = getSharedPreferences("miletracker_settings", MODE_PRIVATE);
                          SharedPreferences.Editor editor = prefs.edit();
                          editor.putInt("irs_year", year);
                          editor.putFloat("irs_business_rate", (float) businessRate);
                          editor.putFloat("irs_medical_rate", (float) medicalRate);
                          editor.putFloat("irs_charity_rate", (float) charityRate);
                          editor.apply();
                          
                          // Refresh statistics to reflect new rates
                          updateStats();
                          
                          Toast.makeText(this, "IRS tax rates updated successfully!", Toast.LENGTH_SHORT).show();
                      } catch (NumberFormatException e) {
                          Toast.makeText(this, "Please enter valid numbers for year and all rates", Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              private String formatMiles(double miles) {
                  if (miles >= 100000) {
                      return String.format("%.0fK+ mi", miles / 1000);
                  } else if (miles >= 10000) {
                      return String.format("%.1fK+ mi", miles / 1000);
                  } else if (miles >= 1000) {
                      return String.format("%.1fK+ mi", miles / 1000);
                  } else {
                      return String.format("%.1f mi", miles);
                  }
              }

              // IRS mileage rates for 2025 (user-configurable)
              private double getIrsBusinessRate() {
                  SharedPreferences prefs = getSharedPreferences("miletracker_settings", MODE_PRIVATE);
                  return (double) prefs.getFloat("irs_business_rate", 0.70f);
              }
              
              private double getIrsMedicalRate() {
                  SharedPreferences prefs = getSharedPreferences("miletracker_settings", MODE_PRIVATE);
                  return (double) prefs.getFloat("irs_medical_rate", 0.21f);
              }
              
              private double getIrsCharityRate() {
                  SharedPreferences prefs = getSharedPreferences("miletracker_settings", MODE_PRIVATE);
                  return (double) prefs.getFloat("irs_charity_rate", 0.14f);
              }
              
              private int getIrsYear() {
                  SharedPreferences prefs = getSharedPreferences("miletracker_settings", MODE_PRIVATE);
                  return prefs.getInt("irs_year", 2025);
              }
              
              private void updateStats() {
                  try {
                      List<Trip> trips = getTripsForCurrentPeriod();
                      double totalMiles = 0;
                      double businessMiles = 0;
                      double personalMiles = 0;
                      double medicalMiles = 0;
                      double charityMiles = 0;

                      for (Trip trip : trips) {
                          totalMiles += trip.getDistance();

                          if ("Business".equals(trip.getCategory())) {
                              businessMiles += trip.getDistance();
                          } else if ("Personal".equals(trip.getCategory())) {
                              personalMiles += trip.getDistance();
                          } else if ("Medical".equals(trip.getCategory())) {
                              medicalMiles += trip.getDistance();
                          } else if ("Charity".equals(trip.getCategory())) {
                              charityMiles += trip.getDistance();
                          }
                      }

                      double businessDeduction = businessMiles * getIrsBusinessRate();
                      double personalDeduction = 0.00; // Personal trips are not tax deductible
                      double medicalDeduction = medicalMiles * getIrsMedicalRate();
                      double charityDeduction = charityMiles * getIrsCharityRate();
                      double totalDeduction = businessDeduction + personalDeduction + medicalDeduction + charityDeduction;

                      String apiStatus = tripStorage.isApiSyncEnabled() ? "API ON" : "API OFF";
                      String autoStatus = autoDetectionEnabled ? "Auto Detection: ON" : "Auto Detection: OFF";

                      // Get authenticated user info
                      UserAuthManager authManager = new UserAuthManager(this);
                      String userEmail = authManager.getCurrentUserEmail();
                      String authUserId = authManager.getUserId();
                      String displayUserId = authUserId.isEmpty() ? tripStorage.getUserId() : authUserId;
                      
                      String userInfo = userEmail.isEmpty() ? "Not signed in" : userEmail;
                      if (!authUserId.isEmpty()) {
                          userInfo += " (Admin ID: " + authUserId + ")";
                      }
                      
                      String periodLabel = getPeriodLabel();
                      String stats = String.format(
                          "%s\nâ€¢ Total Trips: %d\nâ€¢ Total Miles: %s\nâ€¢ Business: %s ($%.2f)\nâ€¢ Personal: %s ($%.2f)\nâ€¢ Medical: %s ($%.2f)\nâ€¢ Charity: %s ($%.2f)\nâ€¢ Total Deduction: $%.2f",
                          periodLabel,
                          trips.size(), formatMiles(totalMiles),
                          formatMiles(businessMiles), businessDeduction,
                          formatMiles(personalMiles), personalDeduction,
                          formatMiles(medicalMiles), medicalDeduction,
                          formatMiles(charityMiles), charityDeduction,
                          totalDeduction
                      );

                      if (statsText != null) {
                          statsText.setText(stats);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                  }
              }
              
              private List<Trip> getTripsForCurrentPeriod() {
                  List<Trip> allTrips = tripStorage.getAllTrips();
                  Calendar cal = Calendar.getInstance();
                  long currentTime = cal.getTimeInMillis();
                  
                  // Calculate start of period based on currentStatsPeriod
                  Calendar periodStart = Calendar.getInstance();
                  
                  switch (currentStatsPeriod) {
                      case "Month":
                          periodStart.set(Calendar.DAY_OF_MONTH, 1);
                          periodStart.set(Calendar.HOUR_OF_DAY, 0);
                          periodStart.set(Calendar.MINUTE, 0);
                          periodStart.set(Calendar.SECOND, 0);
                          periodStart.set(Calendar.MILLISECOND, 0);
                          break;
                      case "Quarter":
                          int currentMonth = cal.get(Calendar.MONTH);
                          int quarterStartMonth = (currentMonth / 3) * 3; // 0, 3, 6, or 9
                          periodStart.set(Calendar.MONTH, quarterStartMonth);
                          periodStart.set(Calendar.DAY_OF_MONTH, 1);
                          periodStart.set(Calendar.HOUR_OF_DAY, 0);
                          periodStart.set(Calendar.MINUTE, 0);
                          periodStart.set(Calendar.SECOND, 0);
                          periodStart.set(Calendar.MILLISECOND, 0);
                          break;
                      case "YTD":
                      default:
                          periodStart.set(Calendar.MONTH, Calendar.JANUARY);
                          periodStart.set(Calendar.DAY_OF_MONTH, 1);
                          periodStart.set(Calendar.HOUR_OF_DAY, 0);
                          periodStart.set(Calendar.MINUTE, 0);
                          periodStart.set(Calendar.SECOND, 0);
                          periodStart.set(Calendar.MILLISECOND, 0);
                          break;
                  }
                  
                  long periodStartTime = periodStart.getTimeInMillis();
                  
                  // Filter trips to current period
                  List<Trip> periodTrips = new ArrayList<>();
                  for (Trip trip : allTrips) {
                      if (trip.getStartTime() >= periodStartTime) {
                          periodTrips.add(trip);
                      }
                  }
                  
                  return periodTrips;
              }
              
              private String getPeriodLabel() {
                  Calendar cal = Calendar.getInstance();
                  switch (currentStatsPeriod) {
                      case "Month":
                          return String.format("Current Month (%d/%d)", 
                              cal.get(Calendar.MONTH) + 1, cal.get(Calendar.YEAR));
                      case "Quarter":
                          int quarter = (cal.get(Calendar.MONTH) / 3) + 1;
                          return String.format("Q%d %d", quarter, cal.get(Calendar.YEAR));
                      case "YTD":
                      default:
                          return String.format("Year to Date (%d)", cal.get(Calendar.YEAR));
                  }
              }
              
              private void showPeriodSelector() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Select Time Period");
                  
                  String[] periods = {"Year to Date", "Current Quarter", "Current Month"};
                  String[] periodValues = {"YTD", "Quarter", "Month"};
                  
                  int currentSelection = 0;
                  for (int i = 0; i < periodValues.length; i++) {
                      if (periodValues[i].equals(currentStatsPeriod)) {
                          currentSelection = i;
                          break;
                      }
                  }
                  
                  builder.setSingleChoiceItems(periods, currentSelection, (dialog, which) -> {
                      currentStatsPeriod = periodValues[which];
                      updateStats();
                      dialog.dismiss();
                      
                      // Update period button text
                      if (periodButton != null) {
                          periodButton.setText("View: " + getPeriodLabel() + " (tap to change)");
                      }
                      
                      Toast.makeText(this, "Updated to " + periods[which], Toast.LENGTH_SHORT).show();
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              private void initializeGPS() {
                  try {
                      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                      if (locationManager != null && ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                          statusText.setText("GPS ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error initializing GPS: " + e.getMessage(), e);
                  }
              }

              private void setupSpeedMonitoring() {
                  try {
                      speedRunnable = new Runnable() {
                          @Override
                          public void run() {
                              if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED && locationManager != null) {
                                  try {
                                      android.location.Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                                      if (lastKnownLocation != null && speedText != null) {
                                          float speed = lastKnownLocation.getSpeed() * 2.237f; // Convert m/s to mph
                                          
                                          // Update real-time distance
                                          updateRealTimeDistance(lastKnownLocation);
                                          
                                          // Process enhanced auto detection if enabled
                                          if (autoDetectionEnabled) {
                                              processEnhancedAutoDetection(
                                                  (double) speed, 
                                                  lastKnownLocation.getLatitude(), 
                                                  lastKnownLocation.getLongitude(), 
                                                  System.currentTimeMillis()
                                              );
                                          } else {
                                              speedText.setText(String.format("Speed: %.1f mph", speed));
                                          }
                                      }
                                  } catch (Exception e) {
                                      Log.w(TAG, "Error getting speed: " + e.getMessage());
                                  }
                              }
                              speedHandler.postDelayed(this, 5000); // Update every 5 seconds
                          }
                      };
                      speedHandler.post(speedRunnable);
                  } catch (Exception e) {
                      Log.e(TAG, "Error setting up speed monitoring: " + e.getMessage(), e);
                  }
              }
              
              private void updateRealTimeDistance(android.location.Location currentLocation) {
                  try {
                      if (lastDistanceLocation != null) {
                          double distance = calculateDistance(
                              lastDistanceLocation.getLatitude(), lastDistanceLocation.getLongitude(),
                              currentLocation.getLatitude(), currentLocation.getLongitude()
                          );
                          realTimeDistance += distance;
                          
                          if (realTimeDistanceText != null) {
                              realTimeDistanceText.setText(String.format("Distance: %.1f miles", realTimeDistance));
                          }
                      }
                      lastDistanceLocation = currentLocation;
                  } catch (Exception e) {
                      Log.w(TAG, "Error updating real-time distance: " + e.getMessage());
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959; // Earth's radius in miles
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              // Enhanced trip segmentation for better stop detection
              private void processEnhancedAutoDetection(double speed, double latitude, double longitude, long timestamp) {
                  final double DRIVING_SPEED_THRESHOLD = 4.6; // mph to consider driving (matches MileIQ for better start location accuracy)
                  final double STATIONARY_SPEED_THRESHOLD = 2.0; // mph to consider stationary
                  final int DRIVING_READINGS_TO_START = 3; // consecutive readings to start trip
                  final int STATIONARY_READINGS_TO_PAUSE = 4; // consecutive readings to pause trip
                  final long TRIP_END_TIMEOUT = 8 * 60 * 1000; // 8 minutes to end trip
                  final long PAUSE_DETECTION_TIME = 3 * 60 * 1000; // 3 minutes to detect meaningful pause
                  final double LOCATION_CHANGE_THRESHOLD = 0.05; // miles to detect location change
                  
                  try {
                      if (speed >= DRIVING_SPEED_THRESHOLD) {
                          // Driving detected
                          movingReadingsCount++;
                          stationaryReadingsCount = 0;
                          
                          if (currentTripPaused && movingReadingsCount >= DRIVING_READINGS_TO_START) {
                              // Resume paused trip or start new trip if location changed significantly
                              if (pausedTripLocation != null) {
                                  double distanceFromPause = calculateDistance(
                                      pausedTripLocation.latitude, pausedTripLocation.longitude,
                                      latitude, longitude
                                  );
                                  
                                  if (distanceFromPause > LOCATION_CHANGE_THRESHOLD) {
                                      // Location changed significantly - end previous trip and start new one
                                      endCurrentTrip(pausedTripLocation.latitude, pausedTripLocation.longitude, timestamp);
                                      startNewTrip(latitude, longitude, speed, timestamp);
                                  } else {
                                      // Resume same trip
                                      resumeCurrentTrip(latitude, longitude, speed, timestamp);
                                  }
                              } else {
                                  startNewTrip(latitude, longitude, speed, timestamp);
                              }
                          } else if (!isCurrentlyTracking && movingReadingsCount >= DRIVING_READINGS_TO_START) {
                              // Start new trip
                              startNewTrip(latitude, longitude, speed, timestamp);
                          }
                          
                          // Update trip path if actively tracking
                          if (isCurrentlyTracking && !currentTripPaused) {
                              currentTripPath.add(new LocationPoint(latitude, longitude, speed, timestamp));
                          }
                          
                      } else if (speed <= STATIONARY_SPEED_THRESHOLD && isCurrentlyTracking) {
                          // Stationary detected during active trip
                          stationaryReadingsCount++;
                          movingReadingsCount = 0;
                          
                          if (!currentTripPaused && stationaryReadingsCount >= STATIONARY_READINGS_TO_PAUSE) {
                              // Pause the current trip
                              pauseCurrentTrip(latitude, longitude, timestamp);
                          }
                          
                          // Check if we should end the trip after extended pause
                          if (currentTripPaused && tripPauseStartTime != null) {
                              long pauseDuration = timestamp - tripPauseStartTime;
                              if (pauseDuration > TRIP_END_TIMEOUT) {
                                  endCurrentTrip(latitude, longitude, timestamp);
                              }
                          }
                      }
                      
                      // Update status display
                      updateTripStatus(speed, timestamp);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in enhanced auto detection", e);
                  }
              }

              private void startNewTrip(double latitude, double longitude, double speed, long timestamp) {
                  try {
                      isCurrentlyTracking = true;
                      currentTripPaused = false;
                      currentTripStartTime = timestamp;
                      currentTripStartLatitude = latitude;
                      currentTripStartLongitude = longitude;
                      currentTripPath.clear();
                      currentTripPath.add(new LocationPoint(latitude, longitude, speed, timestamp));
                      
                      // Reset counters
                      movingReadingsCount = 0;
                      stationaryReadingsCount = 0;
                      tripPauseStartTime = null;
                      pausedTripLocation = null;
                      
                      // Get start address
                      getAddressFromCoordinates(latitude, longitude, new AddressCallback() {
                          @Override
                          public void onAddressReceived(String address) {
                              currentTripStartAddress = address;
                              Log.d(TAG, "Trip started at: " + address);
                          }
                      });
                      
                      Log.d(TAG, "New trip started - Speed: " + speed + " mph");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting new trip", e);
                  }
              }

              private void pauseCurrentTrip(double latitude, double longitude, long timestamp) {
                  try {
                      currentTripPaused = true;
                      tripPauseStartTime = timestamp;
                      pausedTripLocation = new LocationPoint(latitude, longitude, 0, timestamp);
                      
                      Log.d(TAG, "Trip paused - Stationary detected");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error pausing trip", e);
                  }
              }

              private void resumeCurrentTrip(double latitude, double longitude, double speed, long timestamp) {
                  try {
                      currentTripPaused = false;
                      tripPauseStartTime = null;
                      pausedTripLocation = null;
                      
                      // Add resume point to path
                      currentTripPath.add(new LocationPoint(latitude, longitude, speed, timestamp));
                      
                      Log.d(TAG, "Trip resumed - Movement detected");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error resuming trip", e);
                  }
              }

              private void endCurrentTrip(double latitude, double longitude, long timestamp) {
                  try {
                      if (!isCurrentlyTracking) return;
                      
                      isCurrentlyTracking = false;
                      currentTripPaused = false;
                      
                      // Calculate trip distance from path
                      double totalDistance = 0;
                      for (int i = 1; i < currentTripPath.size(); i++) {
                          LocationPoint prev = currentTripPath.get(i - 1);
                          LocationPoint curr = currentTripPath.get(i);
                          totalDistance += calculateDistance(prev.latitude, prev.longitude, curr.latitude, curr.longitude);
                      }
                      
                      // Make totalDistance final for use in inner class
                      final double finalTotalDistance = totalDistance;
                      
                      // Get end address
                      getAddressFromCoordinates(latitude, longitude, new AddressCallback() {
                          @Override
                          public void onAddressReceived(String endAddress) {
                              // Save the completed trip
                              Trip completedTrip = new Trip();
                              completedTrip.setStartTime(currentTripStartTime);
                              completedTrip.setEndTime(timestamp);
                              completedTrip.setStartLatitude(currentTripStartLatitude);
                              completedTrip.setStartLongitude(currentTripStartLongitude);
                              completedTrip.setEndLatitude(latitude);
                              completedTrip.setEndLongitude(longitude);
                              completedTrip.setStartAddress(currentTripStartAddress != null ? currentTripStartAddress : "Unknown");
                              completedTrip.setEndAddress(endAddress != null ? endAddress : "Unknown");
                              completedTrip.setDistance(finalTotalDistance);
                              completedTrip.setAutoDetected(true);
                              completedTrip.setCategory("Business");
                              
                              tripStorage.saveTrip(completedTrip);
                              
                              // Run round-trip detection after saving new trip
                              new Thread(() -> {
                                  try {
                                      tripStorage.detectRoundTrips();
                                  } catch (Exception e) {
                                      Log.e(TAG, "Error detecting round trips", e);
                                  }
                              }).start();
                              
                              Log.d(TAG, "Trip completed - Distance: " + String.format("%.1f", finalTotalDistance) + " miles");
                              
                              // Reset for next trip
                              resetTripTracking();
                              refreshTripDisplay();
                          }
                      });
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip", e);
                  }
              }

              private void resetTripTracking() {
                  currentTripStartTime = 0;
                  currentTripStartLatitude = 0;
                  currentTripStartLongitude = 0;
                  currentTripStartAddress = null;
                  currentTripPath.clear();
                  movingReadingsCount = 0;
                  stationaryReadingsCount = 0;
                  tripPauseStartTime = null;
                  pausedTripLocation = null;
                  realTimeDistance = 0.0;
                  lastDistanceLocation = null;
              }

              private void updateTripStatus(double speed, long timestamp) {
                  try {
                      String statusText;
                      if (isCurrentlyTracking) {
                          if (currentTripPaused) {
                              long pauseDuration = timestamp - tripPauseStartTime;
                              long remainingTime = (8 * 60 * 1000) - pauseDuration; // 8 minutes timeout
                              long remainingMinutes = remainingTime / (60 * 1000);
                              statusText = String.format("Trip paused (ends in %dm)", remainingMinutes);
                          } else {
                              long tripDuration = timestamp - currentTripStartTime;
                              long minutes = tripDuration / (60 * 1000);
                              statusText = String.format("Tracking trip - %dm, %.1f mph", minutes, speed);
                          }
                      } else {
                          statusText = String.format("Monitoring - %.1f mph", speed);
                      }
                      
                      if (speedText != null) {
                          speedText.setText(statusText);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating trip status", e);
                  }
              }

              // Helper classes
              private static class LocationPoint {
                  double latitude;
                  double longitude;
                  double speed;
                  long timestamp;
                  
                  LocationPoint(double lat, double lon, double spd, long time) {
                      latitude = lat;
                      longitude = lon;
                      speed = spd;
                      timestamp = time;
                  }
              }

              private interface AddressCallback {
                  void onAddressReceived(String address);
              }

              private void getAddressFromCoordinates(double latitude, double longitude, AddressCallback callback) {
                  new Thread(() -> {
                      try {
                          Geocoder geocoder = new Geocoder(this, Locale.getDefault());
                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              StringBuilder fullAddress = new StringBuilder();
                              
                              // Build complete address with all components
                              if (address.getSubThoroughfare() != null) {
                                  fullAddress.append(address.getSubThoroughfare()).append(" ");
                              }
                              if (address.getThoroughfare() != null) {
                                  fullAddress.append(address.getThoroughfare()).append(", ");
                              }
                              if (address.getLocality() != null) {
                                  fullAddress.append(address.getLocality()).append(", ");
                              }
                              if (address.getAdminArea() != null) {
                                  fullAddress.append(address.getAdminArea()).append(" ");
                              }
                              if (address.getPostalCode() != null) {
                                  fullAddress.append(address.getPostalCode());
                              }
                              
                              String addressResult = fullAddress.toString().trim();
                              if (addressResult.endsWith(",")) {
                                  addressResult = addressResult.substring(0, addressResult.length() - 1);
                              }
                              
                              final String finalAddress = addressResult;
                              runOnUiThread(() -> {
                                  callback.onAddressReceived(finalAddress.isEmpty() ? 
                                      String.format("%.4f, %.4f", latitude, longitude) : finalAddress);
                              });
                          } else {
                              runOnUiThread(() -> {
                                  callback.onAddressReceived(String.format("%.4f, %.4f", latitude, longitude));
                              });
                          }
                      } catch (Exception e) {
                          Log.e(TAG, "Geocoding error: " + e.getMessage(), e);
                          runOnUiThread(() -> {
                              callback.onAddressReceived(String.format("%.4f, %.4f", latitude, longitude));
                          });
                      }
                  }).start();
              }

              private void batchUpdateAddresses() {
                  new Thread(() -> {
                      try {
                          List<Trip> allTrips = tripStorage.getAllTrips();
                          int updatedCount = 0;
                          
                          for (Trip trip : allTrips) {
                              // Check if trip needs address update (has coordinates but incomplete address)
                              boolean needsStartUpdate = isAddressIncomplete(trip.getStartAddress()) && 
                                                        trip.getStartLatitude() != 0 && trip.getStartLongitude() != 0;
                              boolean needsEndUpdate = isAddressIncomplete(trip.getEndAddress()) && 
                                                      trip.getEndLatitude() != 0 && trip.getEndLongitude() != 0;
                              
                              if (needsStartUpdate || needsEndUpdate) {
                                  final Trip currentTrip = trip;
                                  
                                  if (needsStartUpdate) {
                                      try {
                                          String enhancedStartAddress = getEnhancedAddress(trip.getStartLatitude(), trip.getStartLongitude());
                                          if (enhancedStartAddress != null && !enhancedStartAddress.contains("GPS")) {
                                              currentTrip.setStartAddress(enhancedStartAddress);
                                          }
                                      } catch (Exception e) {
                                          Log.w(TAG, "Failed to update start address for trip: " + trip.getId());
                                      }
                                  }
                                  
                                  if (needsEndUpdate) {
                                      try {
                                          String enhancedEndAddress = getEnhancedAddress(trip.getEndLatitude(), trip.getEndLongitude());
                                          if (enhancedEndAddress != null && !enhancedEndAddress.contains("GPS")) {
                                              currentTrip.setEndAddress(enhancedEndAddress);
                                          }
                                      } catch (Exception e) {
                                          Log.w(TAG, "Failed to update end address for trip: " + trip.getId());
                                      }
                                  }
                                  
                                  tripStorage.saveTrip(currentTrip);
                                  updatedCount++;
                                  
                                  // Small delay to avoid overwhelming the geocoding service
                                  Thread.sleep(500);
                              }
                          }
                          
                          final int finalUpdatedCount = updatedCount;
                          runOnUiThread(() -> {
                              Toast.makeText(this, "Enhanced " + finalUpdatedCount + " trip addresses with zip codes", Toast.LENGTH_LONG).show();
                              refreshTripDisplay();
                          });
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error in batch address update", e);
                          runOnUiThread(() -> {
                              Toast.makeText(this, "Address update completed with some errors", Toast.LENGTH_SHORT).show();
                          });
                      }
                  }).start();
              }
              
              private boolean isAddressIncomplete(String address) {
                  if (address == null || address.isEmpty() || address.equals("Unknown")) {
                      return true;
                  }
                  // Check if address lacks zip code (no 5-digit number at end)
                  return !address.matches(".*\\b\\d{5}\\b.*");
              }
              
              private String getEnhancedAddress(double latitude, double longitude) {
                  try {
                      Geocoder geocoder = new Geocoder(this, Locale.getDefault());
                      List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                      
                      if (addresses != null && !addresses.isEmpty()) {
                          Address address = addresses.get(0);
                          StringBuilder fullAddress = new StringBuilder();
                          
                          // Build complete address with all components
                          if (address.getSubThoroughfare() != null) {
                              fullAddress.append(address.getSubThoroughfare()).append(" ");
                          }
                          if (address.getThoroughfare() != null) {
                              fullAddress.append(address.getThoroughfare()).append(", ");
                          }
                          if (address.getLocality() != null) {
                              fullAddress.append(address.getLocality()).append(", ");
                          }
                          if (address.getAdminArea() != null) {
                              fullAddress.append(address.getAdminArea()).append(" ");
                          }
                          if (address.getPostalCode() != null) {
                              fullAddress.append(address.getPostalCode());
                          }
                          
                          String finalAddress = fullAddress.toString().trim();
                          if (finalAddress.endsWith(",")) {
                              finalAddress = finalAddress.substring(0, finalAddress.length() - 1);
                          }
                          
                          return finalAddress.isEmpty() ? null : finalAddress;
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Geocoding error: " + e.getMessage());
                  }
                  return null;
              }

              private void refreshTripDisplay() {
                  try {
                      // Refresh the trips display
                      updateStats();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error refreshing trip display", e);
                  }
              }
              
              private void resetRealTimeDistance() {
                  realTimeDistance = 0.0;
                  lastDistanceLocation = null;
                  if (realTimeDistanceText != null) {
                      realTimeDistanceText.setText("Distance: 0.0 miles");
                  }
              }

              private void registerBroadcastReceiver() {
                  try {
                      BroadcastReceiver manualTripReceiver = new BroadcastReceiver() {
                          @Override
                          public void onReceive(Context context, Intent intent) {
                              String status = intent.getStringExtra("status");
                              double distance = intent.getDoubleExtra("distance", 0);
                              long duration = intent.getLongExtra("duration", 0);

                              if ("started".equals(status)) {
                                  statusText.setText("Manual trip recording...");
                              } else if ("recording".equals(status)) {
                                  statusText.setText(String.format("Recording: %.2f miles", distance));
                              } else if ("completed".equals(status)) {
                                  statusText.setText("Manual trip completed");
                                  updateStats();
                                  if ("home".equals(currentTab)) {
                                      updateRecentTrips();
                                  } else {
                                      updateAllTrips();
                                  }
                              }
                          }
                      };

                      IntentFilter filter = new IntentFilter("MANUAL_TRIP_UPDATE");
                      registerReceiver(manualTripReceiver, filter);
                  } catch (Exception e) {
                      Log.e(TAG, "Error registering broadcast receiver: " + e.getMessage(), e);
                  }
              }

              private void restoreAutoDetectionState() {
                  try {
                      autoDetectionEnabled = tripStorage.isAutoDetectionEnabled();
                      if (autoDetectionEnabled) {
                          // MINIMAL FIX: Start the actual service when user previously enabled it
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }
                          
                          autoToggle.setText("Auto Detection: ON");
                          autoToggle.setBackgroundColor(0xFF667eea);
                          statusText.setText("Auto detection active");
                      } else {
                          autoToggle.setText("Auto Detection: OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error restoring auto detection state: " + e.getMessage(), e);
                  }
              }

              private void requestPermissions() {
                  try {
                      if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this, 
                              new String[]{
                                  Manifest.permission.ACCESS_FINE_LOCATION,
                                  Manifest.permission.ACCESS_COARSE_LOCATION
                              }, 
                              LOCATION_PERMISSION_REQUEST);
                      } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && 
                                 ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this,
                              new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION},
                              BACKGROUND_LOCATION_PERMISSION_REQUEST);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error requesting permissions: " + e.getMessage(), e);
                  }
              }

              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);

                  if (requestCode == LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Location permission granted", Toast.LENGTH_SHORT).show();
                          initializeGPS();

                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                              requestPermissions();
                          }
                      } else {
                          Toast.makeText(this, "Location permission required for trip tracking", Toast.LENGTH_LONG).show();
                      }
                  } else if (requestCode == BACKGROUND_LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Background location permission granted", Toast.LENGTH_SHORT).show();
                      } else {
                          Toast.makeText(this, "Background location permission recommended for auto detection", Toast.LENGTH_LONG).show();
                      }
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  // Handle location updates if needed
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  if (speedHandler != null && speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
              }

              // Manage Categories Dialog
              private void showManageCategoriesDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Manage Categories");
                  
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(50, 20, 50, 20);
                  
                  // Instructions
                  TextView instructionsText = new TextView(this);
                  instructionsText.setText("Default categories (Business, Personal, Medical, Charity) cannot be removed.\n\nCustom categories:");
                  instructionsText.setTextSize(14);
                  instructionsText.setTextColor(0xFF666666);
                  instructionsText.setPadding(0, 0, 0, 20);
                  layout.addView(instructionsText);
                  
                  // Current custom categories list
                  LinearLayout categoriesListLayout = new LinearLayout(this);
                  categoriesListLayout.setOrientation(LinearLayout.VERTICAL);
                  
                  List<String> customCategories = tripStorage.getCustomCategories();
                  for (String category : customCategories) {
                      LinearLayout categoryRow = new LinearLayout(this);
                      categoryRow.setOrientation(LinearLayout.HORIZONTAL);
                      categoryRow.setGravity(Gravity.CENTER_VERTICAL);
                      categoryRow.setPadding(10, 5, 10, 5);
                      
                      TextView categoryText = new TextView(this);
                      categoryText.setText(category);
                      categoryText.setTextSize(16);
                      categoryText.setTextColor(0xFF333333);
                      LinearLayout.LayoutParams textParams = new LinearLayout.LayoutParams(
                          0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                      categoryText.setLayoutParams(textParams);
                      categoryRow.addView(categoryText);
                      
                      Button removeButton = new Button(this);
                      removeButton.setText("Remove");
                      removeButton.setTextSize(12);
                      removeButton.setBackgroundColor(0xFFFF5722);
                      removeButton.setTextColor(0xFFFFFFFF);
                      removeButton.setPadding(20, 8, 20, 8);
                      removeButton.setOnClickListener(v -> {
                          // Remove from both local storage and API
                          tripStorage.removeCustomCategory(category);
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.removeCustomCategoryFromAPI(category);
                          Toast.makeText(this, "Removed category: " + category, Toast.LENGTH_SHORT).show();
                          showManageCategoriesDialog(); // Refresh dialog
                      });
                      categoryRow.addView(removeButton);
                      
                      categoriesListLayout.addView(categoryRow);
                  }
                  
                  if (customCategories.isEmpty()) {
                      TextView emptyText = new TextView(this);
                      emptyText.setText("No custom categories yet.");
                      emptyText.setTextSize(14);
                      emptyText.setTextColor(0xFF999999);
                      emptyText.setGravity(Gravity.CENTER);
                      emptyText.setPadding(0, 20, 0, 20);
                      categoriesListLayout.addView(emptyText);
                  }
                  
                  layout.addView(categoriesListLayout);
                  
                  // Add new category section
                  TextView addNewLabel = new TextView(this);
                  addNewLabel.setText("Add New Category:");
                  addNewLabel.setTextSize(16);
                  addNewLabel.setTextColor(0xFF333333);
                  addNewLabel.setPadding(0, 30, 0, 10);
                  layout.addView(addNewLabel);
                  
                  EditText newCategoryInput = new EditText(this);
                  newCategoryInput.setHint("Enter category name");
                  newCategoryInput.setTextSize(16);
                  newCategoryInput.setPadding(20, 20, 20, 20);
                  layout.addView(newCategoryInput);
                  
                  builder.setView(layout);
                  
                  builder.setPositiveButton("Add Category", (dialog, which) -> {
                      String newCategory = newCategoryInput.getText().toString().trim();
                      if (!newCategory.isEmpty()) {
                          // Check if it's a default category
                          if (newCategory.equals("Business") || newCategory.equals("Personal") || 
                              newCategory.equals("Medical") || newCategory.equals("Charity")) {
                              Toast.makeText(this, "Cannot add default category", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          
                          // Add to both local storage and API
                          tripStorage.addCustomCategory(newCategory);
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.addCustomCategoryToAPI(newCategory);
                          Toast.makeText(this, "Added category: " + newCategory, Toast.LENGTH_SHORT).show();
                          updateCategorizedTrips(); // Refresh the trips view
                      }
                  });
                  
                  builder.setNegativeButton("Close", null);
                  builder.show();
              }

              // Helper method to format work days for display
              private String getWorkDaysString(List<Integer> workDays) {
                  if (workDays == null || workDays.isEmpty()) {
                      return "None";
                  }
                  
                  StringBuilder sb = new StringBuilder();
                  String[] dayNames = {"", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
                  
                  for (int i = 0; i < workDays.size(); i++) {
                      if (i > 0) sb.append(", ");
                      int day = workDays.get(i);
                      if (day >= 1 && day <= 7) {
                          sb.append(dayNames[day]);
                      }
                  }
                  
                  return sb.toString();
              }

              // Work Hours Configuration Dialog
              private void showConfigureWorkHoursDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Configure Work Hours");
                  
                  ScrollView scrollView = new ScrollView(this);
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(30, 20, 30, 20);
                  
                  // Enable/Disable Checkbox
                  CheckBox enableCheckbox = new CheckBox(this);
                  enableCheckbox.setText("Enable Work Hours Auto-Classification");
                  enableCheckbox.setChecked(tripStorage.isWorkHoursEnabled());
                  enableCheckbox.setTextSize(16);
                  enableCheckbox.setPadding(0, 0, 0, 20);
                  layout.addView(enableCheckbox);
                  
                  // Work Start Time
                  TextView startTimeLabel = new TextView(this);
                  startTimeLabel.setText("Work Start Time:");
                  startTimeLabel.setTextSize(14);
                  startTimeLabel.setTextColor(0xFF495057);
                  startTimeLabel.setPadding(0, 0, 0, 5);
                  layout.addView(startTimeLabel);
                  
                  EditText startTimeInput = new EditText(this);
                  startTimeInput.setText(tripStorage.getWorkStartTime());
                  startTimeInput.setHint("09:00");
                  startTimeInput.setInputType(InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_TIME);
                  LinearLayout.LayoutParams startTimeParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  startTimeParams.setMargins(0, 0, 0, 15);
                  startTimeInput.setLayoutParams(startTimeParams);
                  layout.addView(startTimeInput);
                  
                  // Work End Time
                  TextView endTimeLabel = new TextView(this);
                  endTimeLabel.setText("Work End Time:");
                  endTimeLabel.setTextSize(14);
                  endTimeLabel.setTextColor(0xFF495057);
                  endTimeLabel.setPadding(0, 0, 0, 5);
                  layout.addView(endTimeLabel);
                  
                  EditText endTimeInput = new EditText(this);
                  endTimeInput.setText(tripStorage.getWorkEndTime());
                  endTimeInput.setHint("17:00");
                  endTimeInput.setInputType(InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_TIME);
                  LinearLayout.LayoutParams endTimeParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  endTimeParams.setMargins(0, 0, 0, 15);
                  endTimeInput.setLayoutParams(endTimeParams);
                  layout.addView(endTimeInput);
                  
                  // Work Days Selection
                  TextView workDaysLabel = new TextView(this);
                  workDaysLabel.setText("Work Days:");
                  workDaysLabel.setTextSize(14);
                  workDaysLabel.setTextColor(0xFF495057);
                  workDaysLabel.setPadding(0, 0, 0, 10);
                  layout.addView(workDaysLabel);
                  
                  List<Integer> currentWorkDays = tripStorage.getWorkDays();
                  CheckBox[] dayCheckboxes = new CheckBox[7];
                  String[] dayNames = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                  
                  for (int i = 0; i < 7; i++) {
                      dayCheckboxes[i] = new CheckBox(this);
                      dayCheckboxes[i].setText(dayNames[i]);
                      dayCheckboxes[i].setChecked(currentWorkDays.contains(i + 1));
                      dayCheckboxes[i].setTextSize(14);
                      dayCheckboxes[i].setPadding(10, 5, 10, 5);
                      layout.addView(dayCheckboxes[i]);
                  }
                  
                  scrollView.addView(layout);
                  builder.setView(scrollView);
                  
                  builder.setPositiveButton("Save", (dialog, which) -> {
                      try {
                          // Save enabled state
                          tripStorage.setWorkHoursEnabled(enableCheckbox.isChecked());
                          
                          // Save work times
                          String startTime = startTimeInput.getText().toString().trim();
                          String endTime = endTimeInput.getText().toString().trim();
                          
                          if (!startTime.isEmpty() && startTime.matches("^\\d{2}:\\d{2}$")) {
                              tripStorage.setWorkStartTime(startTime);
                          }
                          
                          if (!endTime.isEmpty() && endTime.matches("^\\d{2}:\\d{2}$")) {
                              tripStorage.setWorkEndTime(endTime);
                          }
                          
                          // Save work days
                          List<Integer> selectedDays = new ArrayList<>();
                          for (int i = 0; i < 7; i++) {
                              if (dayCheckboxes[i].isChecked()) {
                                  selectedDays.add(i + 1);
                              }
                          }
                          tripStorage.setWorkDays(selectedDays);
                          
                          Toast.makeText(this, "Work hours configuration saved", Toast.LENGTH_SHORT).show();
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error saving work hours configuration", e);
                          Toast.makeText(this, "Error saving configuration", Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              // ENHANCED: Refresh with visual feedback and API sync
              private void performRefreshWithFeedback(Button refreshButton) {
                  // Show loading state with pressed color
                  refreshButton.setText("Loading...");
                  refreshButton.setEnabled(false);
                  refreshButton.setBackgroundColor(0xFF5A6268); // Darker gray when pressed
                  
                  Toast.makeText(this, "Refreshing trips from API...", Toast.LENGTH_SHORT).show();
                  
                  new Thread(() -> {
                      try {
                          // Download latest trips from API if sync enabled
                          if (tripStorage.isApiSyncEnabled()) {
                              try {
                                  CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                  cloudService.downloadAllUserTrips();
                                  cloudService.syncCustomCategoriesWithAPI();
                              } catch (Exception e) {
                                  Log.e(TAG, "API download failed: " + e.getMessage());
                              }
                          }
                          
                          // Update UI on main thread
                          runOnUiThread(() -> {
                              // Reset button to original gray color
                              refreshButton.setText("Refresh Trips");
                              refreshButton.setEnabled(true);
                              refreshButton.setBackgroundColor(0xFF6C757D); // Original muted gray
                              
                              // Update displays
                              if ("home".equals(currentTab)) {
                                  updateRecentTrips();
                              } else {
                                  updateAllTrips();
                              }
                              updateStats();
                              
                              // Show success feedback
                              Toast.makeText(MainActivity.this, "âœ… Trips refreshed successfully!", Toast.LENGTH_SHORT).show();
                          });
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error during refresh: " + e.getMessage(), e);
                          
                          runOnUiThread(() -> {
                              // Reset button to original gray color
                              refreshButton.setText("Refresh Trips");
                              refreshButton.setEnabled(true);
                              refreshButton.setBackgroundColor(0xFF6C757D); // Original muted gray
                              
                              // Show error feedback
                              Toast.makeText(MainActivity.this, "âš ï¸ Refresh failed - using local data", Toast.LENGTH_SHORT).show();
                          });
                      }
                  }).start();
              }

              // ENHANCED: Complete edit dialog for all trip fields
              private void showEditTripDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("âœï¸ Edit Trip - All Fields");

                  // Create scrollable layout
                  ScrollView scrollView = new ScrollView(this);
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(50, 20, 50, 20);

                  // Trip Date
                  TextView dateLabel = new TextView(this);
                  dateLabel.setText("Trip Date:");
                  dateLabel.setTextSize(14);
                  dateLabel.setTypeface(null, Typeface.BOLD);
                  
                  Button dateButton = new Button(this);
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy", Locale.US);
                  Calendar tripDate = Calendar.getInstance();
                  tripDate.setTimeInMillis(trip.getStartTime());
                  dateButton.setText(dateFormat.format(tripDate.getTime()));
                  dateButton.setBackgroundColor(0xFFE5E7EB);
                  dateButton.setTextColor(0xFF374151);
                  
                  dateButton.setOnClickListener(v -> {
                      DatePickerDialog datePicker = new DatePickerDialog(this,
                          (view, year, month, dayOfMonth) -> {
                              tripDate.set(year, month, dayOfMonth);
                              dateButton.setText(dateFormat.format(tripDate.getTime()));
                          },
                          tripDate.get(Calendar.YEAR),
                          tripDate.get(Calendar.MONTH),
                          tripDate.get(Calendar.DAY_OF_MONTH));
                      datePicker.show();
                  });

                  // Start Time
                  TextView startTimeLabel = new TextView(this);
                  startTimeLabel.setText("Start Time:");
                  startTimeLabel.setTextSize(14);
                  startTimeLabel.setTypeface(null, Typeface.BOLD);
                  startTimeLabel.setPadding(0, 10, 0, 0);
                  
                  EditText startTimeEdit = new EditText(this);
                  SimpleDateFormat timeFormat = new SimpleDateFormat("h:mm a", Locale.US);
                  startTimeEdit.setText(timeFormat.format(new Date(trip.getStartTime())));
                  startTimeEdit.setHint("9:00 AM");

                  // Duration (minutes)
                  TextView durationLabel = new TextView(this);
                  durationLabel.setText("Duration (minutes):");
                  durationLabel.setTextSize(14);
                  durationLabel.setTypeface(null, Typeface.BOLD);
                  durationLabel.setPadding(0, 10, 0, 0);
                  
                  EditText durationEdit = new EditText(this);
                  long durationMinutes = trip.getDuration() / (60 * 1000); // Convert ms to minutes
                  durationEdit.setText(String.valueOf(durationMinutes));
                  durationEdit.setInputType(InputType.TYPE_CLASS_NUMBER);
                  durationEdit.setHint("30");

                  // Start Location
                  TextView startLabel = new TextView(this);
                  startLabel.setText("Start Location:");
                  startLabel.setTextSize(14);
                  startLabel.setTypeface(null, Typeface.BOLD);
                  startLabel.setPadding(0, 10, 0, 0);
                  
                  EditText startLocationEdit = new EditText(this);
                  startLocationEdit.setText(trip.getStartAddress());
                  startLocationEdit.setHint("Home, office, client address, etc.");

                  // End Location
                  TextView endLabel = new TextView(this);
                  endLabel.setText("End Location:");
                  endLabel.setTextSize(14);
                  endLabel.setTypeface(null, Typeface.BOLD);
                  endLabel.setPadding(0, 10, 0, 0);
                  
                  EditText endLocationEdit = new EditText(this);
                  endLocationEdit.setText(trip.getEndAddress());
                  endLocationEdit.setHint("Meeting location, store, etc.");

                  // Distance
                  TextView distanceLabel = new TextView(this);
                  distanceLabel.setText("Distance (miles):");
                  distanceLabel.setTextSize(14);
                  distanceLabel.setTypeface(null, Typeface.BOLD);
                  distanceLabel.setPadding(0, 10, 0, 0);
                  
                  EditText distanceEdit = new EditText(this);
                  distanceEdit.setText(String.valueOf(trip.getDistance()));
                  distanceEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  distanceEdit.setHint("0.0");

                  // Category
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("Category:");
                  categoryLabel.setTextSize(14);
                  categoryLabel.setTypeface(null, Typeface.BOLD);
                  categoryLabel.setPadding(0, 10, 0, 0);
                  
                  Spinner categorySpinner = new Spinner(this);
                  List<String> allCategories = tripStorage.getAllCategories();
                  String[] categories = allCategories.toArray(new String[0]);
                  ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                  categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categorySpinner.setAdapter(categoryAdapter);
                  
                  // Set current category
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(trip.getCategory())) {
                          categorySpinner.setSelection(i);
                          break;
                      }
                  }

                  // Auto-Detected Toggle
                  TextView autoDetectedLabel = new TextView(this);
                  autoDetectedLabel.setText("Auto-Detected:");
                  autoDetectedLabel.setTextSize(14);
                  autoDetectedLabel.setTypeface(null, Typeface.BOLD);
                  autoDetectedLabel.setPadding(0, 10, 0, 0);
                  
                  LinearLayout autoDetectedLayout = new LinearLayout(this);
                  autoDetectedLayout.setOrientation(LinearLayout.HORIZONTAL);
                  autoDetectedLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  Switch autoDetectedSwitch = new Switch(this);
                  autoDetectedSwitch.setChecked(trip.isAutoDetected());
                  
                  TextView autoDetectedInfo = new TextView(this);
                  autoDetectedInfo.setText("Auto vs Manual");
                  autoDetectedInfo.setTextSize(12);
                  autoDetectedInfo.setTextColor(0xFF6B7280);
                  autoDetectedInfo.setPadding(10, 0, 0, 0);
                  
                  autoDetectedLayout.addView(autoDetectedSwitch);
                  autoDetectedLayout.addView(autoDetectedInfo);

                  // Client Name
                  TextView clientLabel = new TextView(this);
                  clientLabel.setText("Client Name (optional):");
                  clientLabel.setTextSize(14);
                  clientLabel.setTypeface(null, Typeface.BOLD);
                  clientLabel.setPadding(0, 10, 0, 0);
                  
                  EditText clientEdit = new EditText(this);
                  clientEdit.setText(trip.getClientName() != null ? trip.getClientName() : "");
                  clientEdit.setHint("Client or company name");

                  // Notes
                  TextView notesLabel = new TextView(this);
                  notesLabel.setText("Notes (optional):");
                  notesLabel.setTextSize(14);
                  notesLabel.setTypeface(null, Typeface.BOLD);
                  notesLabel.setPadding(0, 10, 0, 0);
                  
                  EditText notesEdit = new EditText(this);
                  notesEdit.setText(trip.getNotes() != null ? trip.getNotes() : "");
                  notesEdit.setHint("Trip purpose, meeting details, etc.");
                  notesEdit.setMaxLines(3);

                  // Add all components to layout
                  layout.addView(dateLabel);
                  layout.addView(dateButton);
                  layout.addView(startTimeLabel);
                  layout.addView(startTimeEdit);
                  layout.addView(durationLabel);
                  layout.addView(durationEdit);
                  layout.addView(startLabel);
                  layout.addView(startLocationEdit);
                  layout.addView(endLabel);
                  layout.addView(endLocationEdit);
                  layout.addView(distanceLabel);
                  layout.addView(distanceEdit);
                  layout.addView(categoryLabel);
                  layout.addView(categorySpinner);
                  layout.addView(autoDetectedLabel);
                  layout.addView(autoDetectedLayout);
                  layout.addView(clientLabel);
                  layout.addView(clientEdit);
                  layout.addView(notesLabel);
                  layout.addView(notesEdit);

                  scrollView.addView(layout);
                  builder.setView(scrollView);

                  builder.setPositiveButton("ðŸ’¾ Save Changes", (dialog, which) -> {
                      try {
                          // Parse and validate all fields
                          String startLocation = startLocationEdit.getText().toString().trim();
                          String endLocation = endLocationEdit.getText().toString().trim();
                          double distance = Double.parseDouble(distanceEdit.getText().toString());
                          long durationMins = Long.parseLong(durationEdit.getText().toString());
                          String startTimeStr = startTimeEdit.getText().toString().trim();
                          
                          // Validation
                          if (startLocation.isEmpty() || endLocation.isEmpty()) {
                              Toast.makeText(this, "Start and end locations are required", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          
                          // Update trip date and time
                          Calendar updatedDate = Calendar.getInstance();
                          updatedDate.setTimeInMillis(tripDate.getTimeInMillis());
                          
                          // Parse start time (simplified - assumes format like "9:00 AM")
                          try {
                              Date startTime = timeFormat.parse(startTimeStr);
                              if (startTime != null) {
                                  Calendar timeCalendar = Calendar.getInstance();
                                  timeCalendar.setTime(startTime);
                                  updatedDate.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
                                  updatedDate.set(Calendar.MINUTE, timeCalendar.get(Calendar.MINUTE));
                              }
                          } catch (Exception e) {
                              Log.w(TAG, "Could not parse start time, keeping original time");
                          }
                          
                          // Update all trip fields
                          trip.setStartAddress(startLocation);
                          trip.setEndAddress(endLocation);
                          trip.setDistance(distance);
                          trip.setDuration(durationMins * 60 * 1000); // Convert minutes to milliseconds
                          trip.setCategory(categorySpinner.getSelectedItem().toString());
                          trip.setAutoDetected(autoDetectedSwitch.isChecked());
                          trip.setClientName(clientEdit.getText().toString().trim());
                          trip.setNotes(notesEdit.getText().toString().trim());
                          
                          // Update timestamps
                          trip.setStartTime(updatedDate.getTimeInMillis());
                          trip.setEndTime(updatedDate.getTimeInMillis() + trip.getDuration());

                          // Save trip and sync to API
                          tripStorage.saveTrip(trip);
                          if (tripStorage.isApiSyncEnabled()) {
                              try {
                                  CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                  cloudService.backupTrip(trip);
                              } catch (Exception e) {
                                  Log.e(TAG, "API backup failed: " + e.getMessage());
                              }
                          }
                          
                          Toast.makeText(this, "âœ… All trip details updated successfully!", Toast.LENGTH_SHORT).show();
                          if ("home".equals(currentTab)) {
                              updateRecentTrips();
                          } else {
                              updateAllTrips();
                          }
                          updateStats();
                          
                          Log.d(TAG, "Trip fully updated: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                                " on " + dateFormat.format(new Date(trip.getStartTime())));
                          
                      } catch (NumberFormatException e) {
                          Toast.makeText(this, "Please enter valid numbers for distance and duration", Toast.LENGTH_SHORT).show();
                      } catch (Exception e) {
                          Log.e(TAG, "Error updating trip: " + e.getMessage(), e);
                          Toast.makeText(this, "Error updating trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("âŒ Cancel", null);
                  
                  AlertDialog editDialog = builder.create();
                  editDialog.show();
              }

              private void showDeleteConfirmationDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("ðŸ—‘ï¸ Delete Trip - Permanent Action");
                  
                  String message = String.format(
                      "âš ï¸ Delete this trip?\n\n" +
                      "ðŸ“ From: %s\n" +
                      "ðŸ“ To: %s\n" +
                      "ðŸ“ Distance: %.1f miles\n" +
                      "ðŸ“… Date: %s\n" +
                      "ðŸ¢ Client: %s\n" +
                      "ðŸ“ Purpose: %s\n\n" +
                      "â— This action cannot be undone.\n" +
                      "ðŸ’¾ Trip will be permanently deleted from both local storage and cloud backup.",
                      trip.getStartAddress(),
                      trip.getEndAddress(),
                      trip.getDistance(),
                      trip.getFormattedDateTime(),
                      trip.getClientName() != null ? trip.getClientName() : "Personal",
                      trip.getNotes() != null ? trip.getNotes() : "Not specified"
                  );
                  
                  builder.setMessage(message);
                  
                  builder.setPositiveButton("ðŸ—‘ï¸ DELETE PERMANENTLY", (dialog, which) -> {
                      try {
                          // Delete trip using TripStorage's delete method
                          tripStorage.deleteTrip(trip.getId());
                          
                          // Refresh display
                          updateRecentTrips();
                          updateAllTrips();
                          updateStats();
                          
                          Toast.makeText(this, "ðŸ—‘ï¸ Trip deleted successfully", Toast.LENGTH_SHORT).show();
                      } catch (Exception e) {
                          Log.e(TAG, "Error deleting trip: " + e.getMessage(), e);
                          Toast.makeText(this, "âŒ Error deleting trip", Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("âŒ Cancel", null);
                  
                  AlertDialog deleteDialog = builder.create();
                  deleteDialog.show();
              }

              // Export functionality with date range picker
              private void showExportDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("ðŸ“¤ Export Trips");
                  
                  ScrollView scrollView = new ScrollView(this);
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(40, 20, 40, 20);
                  
                  // Category filter selection
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("ðŸ·ï¸ Filter by Category:");
                  categoryLabel.setTextSize(16);
                  categoryLabel.setTextColor(0xFF495057);
                  categoryLabel.setPadding(0, 10, 0, 10);
                  layout.addView(categoryLabel);
                  
                  Spinner categorySpinner = new Spinner(this);
                  List<String> categoryOptionsList = new ArrayList<>();
                  categoryOptionsList.add("All Categories");
                  categoryOptionsList.addAll(tripStorage.getAllCategories());
                  String[] categoryOptions = categoryOptionsList.toArray(new String[0]);
                  ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categoryOptions);
                  categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categorySpinner.setAdapter(categoryAdapter);
                  categorySpinner.setPadding(20, 10, 20, 20);
                  layout.addView(categorySpinner);
                  
                  // Date range selection
                  TextView dateRangeLabel = new TextView(this);
                  dateRangeLabel.setText("ðŸ“… Select Date Range:");
                  dateRangeLabel.setTextSize(16);
                  dateRangeLabel.setTextColor(0xFF495057);
                  dateRangeLabel.setPadding(0, 10, 0, 10);
                  layout.addView(dateRangeLabel);
                  
                  // Start date picker
                  Button startDateButton = new Button(this);
                  startDateButton.setText("ðŸ“… Start Date: Tap to select");
                  startDateButton.setBackgroundColor(0xFF007bff);
                  startDateButton.setTextColor(0xFFFFFFFF);
                  startDateButton.setPadding(20, 15, 20, 15);
                  layout.addView(startDateButton);
                  
                  // End date picker  
                  Button endDateButton = new Button(this);
                  endDateButton.setText("ðŸ“… End Date: Tap to select");
                  endDateButton.setBackgroundColor(0xFF007bff);
                  endDateButton.setTextColor(0xFFFFFFFF);
                  endDateButton.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams endDateParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  endDateParams.setMargins(0, 10, 0, 20);
                  endDateButton.setLayoutParams(endDateParams);
                  layout.addView(endDateButton);
                  
                  // Export format selection
                  TextView formatLabel = new TextView(this);
                  formatLabel.setText("ðŸ“„ Export Format:");
                  formatLabel.setTextSize(16);
                  formatLabel.setTextColor(0xFF495057);
                  formatLabel.setPadding(0, 20, 0, 10);
                  layout.addView(formatLabel);
                  
                  Spinner formatSpinner = new Spinner(this);
                  String[] formatOptions = {"CSV Spreadsheet (.csv)", "Text File (.txt)", "PDF Report (.pdf)"};
                  ArrayAdapter<String> formatAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, formatOptions);
                  formatAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  formatSpinner.setAdapter(formatAdapter);
                  formatSpinner.setPadding(20, 10, 20, 20);
                  layout.addView(formatSpinner);
                  
                  // Export method selection
                  TextView methodLabel = new TextView(this);
                  methodLabel.setText("ðŸ“¤ Export Method:");
                  methodLabel.setTextSize(16);
                  methodLabel.setTextColor(0xFF495057);
                  methodLabel.setPadding(0, 20, 0, 10);
                  layout.addView(methodLabel);
                  
                  // Email button
                  Button emailButton = new Button(this);
                  emailButton.setText("ðŸ“§ Send via Email");
                  emailButton.setBackgroundColor(0xFF6f42c1);
                  emailButton.setTextColor(0xFFFFFFFF);
                  emailButton.setPadding(20, 15, 20, 15);
                  layout.addView(emailButton);
                  
                  // Cloud storage button
                  Button cloudButton = new Button(this);
                  cloudButton.setText("â˜ï¸ Share to Cloud (Drive, Dropbox, OneDrive)");
                  cloudButton.setBackgroundColor(0xFF17a2b8);
                  cloudButton.setTextColor(0xFFFFFFFF);
                  cloudButton.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams cloudParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  cloudParams.setMargins(0, 10, 0, 0);
                  cloudButton.setLayoutParams(cloudParams);
                  layout.addView(cloudButton);
                  
                  scrollView.addView(layout);
                  builder.setView(scrollView);
                  
                  // Date picker state
                  final Calendar startCal = Calendar.getInstance();
                  final Calendar endCal = Calendar.getInstance();
                  final boolean[] startDateSet = {false};
                  final boolean[] endDateSet = {false};
                  
                  // Start date picker click handler
                  startDateButton.setOnClickListener(v -> {
                      new DatePickerDialog(this, (view, year, month, dayOfMonth) -> {
                          startCal.set(year, month, dayOfMonth);
                          startDateButton.setText("ðŸ“… Start: " + (month + 1) + "/" + dayOfMonth + "/" + year);
                          startDateSet[0] = true;
                      }, startCal.get(Calendar.YEAR), startCal.get(Calendar.MONTH), startCal.get(Calendar.DAY_OF_MONTH)).show();
                  });
                  
                  // End date picker click handler
                  endDateButton.setOnClickListener(v -> {
                      new DatePickerDialog(this, (view, year, month, dayOfMonth) -> {
                          endCal.set(year, month, dayOfMonth);
                          endDateButton.setText("ðŸ“… End: " + (month + 1) + "/" + dayOfMonth + "/" + year);
                          endDateSet[0] = true;
                      }, endCal.get(Calendar.YEAR), endCal.get(Calendar.MONTH), endCal.get(Calendar.DAY_OF_MONTH)).show();
                  });
                  
                  // Export handlers
                  emailButton.setOnClickListener(v -> {
                      if (!startDateSet[0] || !endDateSet[0]) {
                          Toast.makeText(this, "âŒ Please select both start and end dates", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      String selectedCategory = categorySpinner.getSelectedItem().toString();
                      int formatIndex = formatSpinner.getSelectedItemPosition(); // 0=CSV, 1=TXT, 2=PDF
                      exportAndEmail(startCal.getTime(), endCal.getTime(), selectedCategory, formatIndex);
                  });
                  
                  cloudButton.setOnClickListener(v -> {
                      if (!startDateSet[0] || !endDateSet[0]) {
                          Toast.makeText(this, "âŒ Please select both start and end dates", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      String selectedCategory = categorySpinner.getSelectedItem().toString();
                      int formatIndex = formatSpinner.getSelectedItemPosition(); // 0=CSV, 1=TXT, 2=PDF
                      exportToCloud(startCal.getTime(), endCal.getTime(), selectedCategory, formatIndex);
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.create().show();
              }
              
              private void exportAndEmail(Date startDate, Date endDate, String category, int formatIndex) {
                  try {
                      List<Trip> tripsInRange = getTripsInDateRange(startDate, endDate, category);
                      if (tripsInRange.isEmpty()) {
                          String categoryText = category.equals("All Categories") ? "selected date range" : category + " trips in selected date range";
                          Toast.makeText(this, "âŒ No " + categoryText + " found", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      
                      String exportContent = null;
                      byte[] binaryContent = null;
                      String fileExtension;
                      String mimeType;
                      boolean isBinaryFile = false;
                      
                      switch (formatIndex) {
                          case 0: // CSV
                              exportContent = generateCSV(tripsInRange, startDate, endDate, category);
                              fileExtension = ".csv";
                              mimeType = "text/csv";
                              break;
                          case 1: // TXT
                              exportContent = generateTXT(tripsInRange, startDate, endDate, category);
                              fileExtension = ".txt";
                              mimeType = "text/plain";
                              break;
                          case 2: // PDF
                              binaryContent = generatePDF(tripsInRange, startDate, endDate, category);
                              fileExtension = ".pdf";
                              mimeType = "application/pdf";
                              isBinaryFile = true;
                              break;
                          default:
                              exportContent = generateCSV(tripsInRange, startDate, endDate, category);
                              fileExtension = ".csv";
                              mimeType = "text/csv";
                              break;
                      }
                      
                      // Create temporary file
                      SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
                      String fileName = "MileTracker_Export_" + dateFormat.format(startDate) + "_to_" + dateFormat.format(endDate);
                      if (!category.equals("All Categories")) {
                          fileName += "_" + category.replace(" ", "_");
                      }
                      fileName += fileExtension;
                      
                      try {
                          // Create file in external cache directory
                          File exportFile = new File(getExternalCacheDir(), fileName);
                          
                          if (isBinaryFile) {
                              // For PDF files, write binary data
                              // Use binaryContent instead of generating PDF again
                              FileOutputStream fos = new FileOutputStream(exportFile);
                              fos.write(binaryContent);
                              fos.close();
                          } else {
                              // For text files (CSV, TXT), write as text
                              FileWriter writer = new FileWriter(exportFile);
                              writer.write(exportContent);
                              writer.close();
                          }
                          
                          // Create URI for the file
                          Uri fileUri = FileProvider.getUriForFile(this, getPackageName() + ".fileprovider", exportFile);
                          
                          String categoryFilter = category.equals("All Categories") ? "" : " (" + category + ")";
                          
                          Intent emailIntent = new Intent(Intent.ACTION_SEND);
                          emailIntent.setType("message/rfc822"); // Force email apps instead of text apps
                          emailIntent.putExtra(Intent.EXTRA_SUBJECT, "MileTracker Pro - Trip Export" + categoryFilter + " " + 
                              new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(startDate) + " to " +
                              new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(endDate));
                          String formatDescription = "";
                          String openingInfo = "";
                          switch (formatIndex) {
                              case 0: // CSV
                                  formatDescription = "CSV Spreadsheet";
                                  openingInfo = "This file can be opened in Excel, Google Sheets, or any spreadsheet application.";
                                  break;
                              case 1: // TXT
                                  formatDescription = "Text Document";
                                  openingInfo = "This file can be opened in any text editor or word processor.";
                                  break;
                              case 2: // PDF
                                  formatDescription = "PDF Report";
                                  openingInfo = "This file can be opened in any PDF reader, printed, or shared professionally.";
                                  break;
                              default:
                                  formatDescription = "CSV Spreadsheet";
                                  openingInfo = "This file can be opened in Excel, Google Sheets, or any spreadsheet application.";
                                  break;
                          }
                          
                          emailIntent.putExtra(Intent.EXTRA_TEXT, "Please find your MileTracker Pro trip data attached as " + fileName + ".\n\n" +
                              "Export Summary:\n" +
                              "Date Range: " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(startDate) + " to " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(endDate) + "\n" +
                              "Category: " + category + "\n" +
                              "Total Trips: " + tripsInRange.size() + "\n" +
                              "File Format: " + formatDescription + "\n\n" +
                              openingInfo + "\n\n" +
                              "Generated by MileTracker Pro");
                          emailIntent.putExtra(Intent.EXTRA_STREAM, fileUri);
                          emailIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                          
                          // Try email-specific apps first, fallback to general sharing
                          try {
                              emailIntent.setPackage("com.google.android.gm"); // Try Gmail first
                              if (emailIntent.resolveActivity(getPackageManager()) != null) {
                                  startActivity(emailIntent);
                                  Toast.makeText(this, "âœ… Opening Gmail with " + tripsInRange.size() + " trips attached as " + fileName, Toast.LENGTH_LONG).show();
                              } else {
                                  // Try Outlook
                                  emailIntent.setPackage("com.microsoft.office.outlook");
                                  if (emailIntent.resolveActivity(getPackageManager()) != null) {
                                      startActivity(emailIntent);
                                      Toast.makeText(this, "âœ… Opening Outlook with " + tripsInRange.size() + " trips attached as " + fileName, Toast.LENGTH_LONG).show();
                                  } else {
                                      // Fallback to any email app
                                      emailIntent.setPackage(null);
                                      emailIntent.setType("message/rfc822");
                                      if (emailIntent.resolveActivity(getPackageManager()) != null) {
                                          startActivity(Intent.createChooser(emailIntent, "Send via email..."));
                                          Toast.makeText(this, "âœ… Email created with " + tripsInRange.size() + " trips attached as " + fileName, Toast.LENGTH_LONG).show();
                                      } else {
                                          Toast.makeText(this, "âŒ No email app available", Toast.LENGTH_SHORT).show();
                                      }
                                  }
                              }
                          } catch (Exception e) {
                              Log.e(TAG, "Error launching email: " + e.getMessage(), e);
                              Toast.makeText(this, "âŒ Failed to open email app", Toast.LENGTH_SHORT).show();
                          }
                      } catch (IOException e) {
                          Log.e(TAG, "Error creating export file: " + e.getMessage(), e);
                          Toast.makeText(this, "âŒ Failed to create export file: " + e.getMessage(), Toast.LENGTH_LONG).show();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error exporting to email: " + e.getMessage(), e);
                      Toast.makeText(this, "âŒ Export failed: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
              
              private void exportToCloud(Date startDate, Date endDate, String category, int formatIndex) {
                  try {
                      List<Trip> tripsInRange = getTripsInDateRange(startDate, endDate, category);
                      if (tripsInRange.isEmpty()) {
                          String categoryText = category.equals("All Categories") ? "selected date range" : category + " trips in selected date range";
                          Toast.makeText(this, "âŒ No " + categoryText + " found", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      
                      String exportContent = null;
                      byte[] binaryContent = null;
                      String fileExtension;
                      String mimeType;
                      boolean isBinaryFile = false;
                      
                      switch (formatIndex) {
                          case 0: // CSV
                              exportContent = generateCSV(tripsInRange, startDate, endDate, category);
                              fileExtension = ".csv";
                              mimeType = "text/csv";
                              break;
                          case 1: // TXT
                              exportContent = generateTXT(tripsInRange, startDate, endDate, category);
                              fileExtension = ".txt";
                              mimeType = "text/plain";
                              break;
                          case 2: // PDF
                              binaryContent = generatePDF(tripsInRange, startDate, endDate, category);
                              fileExtension = ".pdf";
                              mimeType = "application/pdf";
                              isBinaryFile = true;
                              break;
                          default:
                              exportContent = generateCSV(tripsInRange, startDate, endDate, category);
                              fileExtension = ".csv";
                              mimeType = "text/csv";
                              break;
                      }
                      
                      // Create temporary file
                      SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
                      String fileName = "MileTracker_Export_" + dateFormat.format(startDate) + "_to_" + dateFormat.format(endDate);
                      if (!category.equals("All Categories")) {
                          fileName += "_" + category.replace(" ", "_");
                      }
                      fileName += fileExtension;
                      
                      try {
                          // Create file in external cache directory
                          File exportFile = new File(getExternalCacheDir(), fileName);
                          
                          if (isBinaryFile) {
                              // For PDF files, write binary data
                              // Use binaryContent instead of generating PDF again
                              FileOutputStream fos = new FileOutputStream(exportFile);
                              fos.write(binaryContent);
                              fos.close();
                          } else {
                              // For text files (CSV, TXT), write as text
                              FileWriter writer = new FileWriter(exportFile);
                              writer.write(exportContent);
                              writer.close();
                          }
                          
                          // Create URI for the file
                          Uri fileUri = FileProvider.getUriForFile(this, getPackageName() + ".fileprovider", exportFile);
                          
                          String categoryFilter = category.equals("All Categories") ? "" : " (" + category + ")";
                          
                          Intent shareIntent = new Intent(Intent.ACTION_SEND);
                          shareIntent.setType(mimeType);
                          shareIntent.putExtra(Intent.EXTRA_SUBJECT, "MileTracker Pro - Trip Export" + categoryFilter);
                          shareIntent.putExtra(Intent.EXTRA_TEXT, "MileTracker Pro trip data export file attached.\n\n" +
                              "File: " + fileName + "\n" +
                              "Date Range: " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(startDate) + " to " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(endDate) + "\n" +
                              "Category: " + category + "\n" +
                              "Total Trips: " + tripsInRange.size());
                          shareIntent.putExtra(Intent.EXTRA_STREAM, fileUri);
                          shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                      
                          if (shareIntent.resolveActivity(getPackageManager()) != null) {
                              startActivity(Intent.createChooser(shareIntent, "Share to cloud storage..."));
                              String formatName = "";
                              switch (formatIndex) {
                                  case 0: formatName = "CSV"; break;
                                  case 1: formatName = "TXT"; break;
                                  case 2: formatName = "PDF"; break;
                                  default: formatName = "CSV"; break;
                              }
                              Toast.makeText(this, "âœ… Sharing " + tripsInRange.size() + " trips (" + formatName + ") to cloud", Toast.LENGTH_SHORT).show();
                          } else {
                              Toast.makeText(this, "âŒ No sharing apps available", Toast.LENGTH_SHORT).show();
                          }
                      } catch (IOException e) {
                          Log.e(TAG, "Error creating export file: " + e.getMessage(), e);
                          Toast.makeText(this, "âŒ Failed to create export file: " + e.getMessage(), Toast.LENGTH_LONG).show();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error exporting to cloud: " + e.getMessage(), e);
                      Toast.makeText(this, "âŒ Export failed: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
              
              private List<Trip> getTripsInDateRange(Date startDate, Date endDate, String category) {
                  List<Trip> allTrips = tripStorage.getAllTrips();
                  List<Trip> filteredTrips = new ArrayList<>();
                  
                  for (Trip trip : allTrips) {
                      Date tripDate = new Date(trip.getStartTime());
                      if (!tripDate.before(startDate) && !tripDate.after(endDate)) {
                          // Apply category filter
                          if (category.equals("All Categories") || trip.getCategory().equals(category)) {
                              filteredTrips.add(trip);
                          }
                      }
                  }
                  
                  return filteredTrips;
              }
              
              private String generateCSV(List<Trip> trips, Date startDate, Date endDate, String category) {
                  StringBuilder csv = new StringBuilder();
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
                  SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
                  
                  // Header
                  csv.append("MileTracker Pro - Trip Export\n");
                  csv.append("Export Date Range: ").append(dateFormat.format(startDate))
                     .append(" to ").append(dateFormat.format(endDate)).append("\n");
                  csv.append("Category Filter: ").append(category).append("\n");
                  csv.append("Generated: ").append(dateFormat.format(new Date())).append("\n\n");
                  
                  // CSV Headers
                  csv.append("Date,Start Time,End Time,Start Location,End Location,Distance (mi),Duration,Category,Client,Notes,Type\n");
                  
                  // Data rows
                  double totalMiles = 0;
                  for (Trip trip : trips) {
                      Date tripDate = new Date(trip.getStartTime());
                      Date endTime = new Date(trip.getEndTime());
                      
                      csv.append("\"").append(dateFormat.format(tripDate)).append("\",");
                      csv.append("\"").append(timeFormat.format(tripDate)).append("\",");
                      csv.append("\"").append(timeFormat.format(endTime)).append("\",");
                      csv.append("\"").append(trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown").append("\",");
                      csv.append("\"").append(trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown").append("\",");
                      csv.append(String.format("%.2f", trip.getDistance())).append(",");
                      csv.append("\"").append(trip.getFormattedDuration()).append("\",");
                      csv.append("\"").append(trip.getCategory()).append("\",");
                      csv.append("\"").append(trip.getClientName() != null ? trip.getClientName() : "").append("\",");
                      csv.append("\"").append(trip.getNotes() != null ? trip.getNotes() : "").append("\",");
                      csv.append("\"").append(trip.isAutoDetected() ? "Auto" : "Manual").append("\"\n");
                      
                      totalMiles += trip.getDistance();
                  }
                  
                  // Summary
                  csv.append("\nSUMMARY\n");
                  csv.append("Total Trips,").append(trips.size()).append("\n");
                  csv.append("Total Miles,").append(String.format("%.2f", totalMiles)).append("\n");
                  csv.append("Business Deduction (IRS $").append(String.format("%.2f", getIrsBusinessRate())).append("/mi),\"$").append(String.format("%.2f", totalMiles * getIrsBusinessRate())).append("\"\n");
                  
                  return csv.toString();
              }
              
              private String generateTXT(List<Trip> trips, Date startDate, Date endDate, String category) {
                  StringBuilder txt = new StringBuilder();
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
                  SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
                  
                  // Header
                  txt.append("MileTracker Pro - Trip Export\n");
                  txt.append("================================\n\n");
                  txt.append("Export Date Range: ").append(dateFormat.format(startDate))
                     .append(" to ").append(dateFormat.format(endDate)).append("\n");
                  txt.append("Category Filter: ").append(category).append("\n");
                  txt.append("Generated: ").append(dateFormat.format(new Date())).append("\n\n");
                  
                  // Trip details
                  double totalMiles = 0;
                  int tripNumber = 1;
                  
                  for (Trip trip : trips) {
                      Date tripDate = new Date(trip.getStartTime());
                      Date endTime = new Date(trip.getEndTime());
                      
                      txt.append("TRIP #").append(tripNumber++).append("\n");
                      txt.append("--------\n");
                      txt.append("Date: ").append(dateFormat.format(tripDate)).append("\n");
                      txt.append("Time: ").append(timeFormat.format(tripDate))
                         .append(" - ").append(timeFormat.format(endTime)).append("\n");
                      txt.append("From: ").append(trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown").append("\n");
                      txt.append("To: ").append(trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown").append("\n");
                      txt.append("Distance: ").append(String.format("%.2f", trip.getDistance())).append(" miles\n");
                      txt.append("Duration: ").append(trip.getFormattedDuration()).append("\n");
                      txt.append("Category: ").append(trip.getCategory()).append("\n");
                      if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                          txt.append("Client: ").append(trip.getClientName()).append("\n");
                      }
                      if (trip.getNotes() != null && !trip.getNotes().isEmpty()) {
                          txt.append("Notes: ").append(trip.getNotes()).append("\n");
                      }
                      txt.append("Type: ").append(trip.isAutoDetected() ? "Auto-detected" : "Manual entry").append("\n\n");
                      
                      totalMiles += trip.getDistance();
                  }
                  
                  // Summary
                  txt.append("SUMMARY\n");
                  txt.append("=======\n");
                  txt.append("Total Trips: ").append(trips.size()).append("\n");
                  txt.append("Total Miles: ").append(String.format("%.2f", totalMiles)).append("\n");
                  txt.append("Business Deduction (IRS $").append(String.format("%.2f", getIrsBusinessRate())).append("/mi): $").append(String.format("%.2f", totalMiles * getIrsBusinessRate())).append("\n");
                  
                  return txt.toString();
              }
              
              private byte[] generatePDF(List<Trip> trips, Date startDate, Date endDate, String category) {
                  try {
                      // Create PDF document
                      android.graphics.pdf.PdfDocument document = new android.graphics.pdf.PdfDocument();
                      android.graphics.pdf.PdfDocument.PageInfo pageInfo = new android.graphics.pdf.PdfDocument.PageInfo.Builder(595, 842, 1).create(); // A4 size
                      android.graphics.pdf.PdfDocument.Page page = document.startPage(pageInfo);
                      
                      Canvas canvas = page.getCanvas();
                      Paint paint = new Paint();
                      paint.setAntiAlias(true);
                      
                      // Set up text formatting
                      paint.setTextSize(16);
                      paint.setColor(Color.BLACK);
                      paint.setTypeface(Typeface.DEFAULT_BOLD);
                      
                      SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
                      SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
                      
                      // Title
                      canvas.drawText("MileTracker Pro - Professional Mileage Report", 50, 50, paint);
                      
                      // Header info
                      paint.setTextSize(12);
                      paint.setTypeface(Typeface.DEFAULT);
                      canvas.drawText("Export Date Range: " + dateFormat.format(startDate) + " to " + dateFormat.format(endDate), 50, 80, paint);
                      canvas.drawText("Category Filter: " + category, 50, 100, paint);
                      canvas.drawText("Generated: " + dateFormat.format(new Date()), 50, 120, paint);
                      
                      // Table headers
                      paint.setTypeface(Typeface.DEFAULT_BOLD);
                      paint.setTextSize(10);
                      int yPosition = 160;
                      canvas.drawText("Date", 40, yPosition, paint);
                      canvas.drawText("Time", 100, yPosition, paint);
                      canvas.drawText("From", 140, yPosition, paint);
                      canvas.drawText("To", 280, yPosition, paint);
                      canvas.drawText("Dist", 420, yPosition, paint);
                      canvas.drawText("Cat", 460, yPosition, paint);
                      
                      // Draw line under headers
                      paint.setStrokeWidth(1);
                      canvas.drawLine(40, yPosition + 5, 520, yPosition + 5, paint);
                      
                      // Trip data
                      paint.setTypeface(Typeface.DEFAULT);
                      paint.setTextSize(9);
                      yPosition += 20;
                      double totalMiles = 0;
                      
                      for (Trip trip : trips) {
                          if (yPosition > 800) { // Start new page if needed
                              document.finishPage(page);
                              page = document.startPage(pageInfo);
                              canvas = page.getCanvas();
                              yPosition = 50;
                          }
                          
                          Date tripDate = new Date(trip.getStartTime());
                          Date endTime = new Date(trip.getEndTime());
                          
                          canvas.drawText(dateFormat.format(tripDate), 40, yPosition, paint);
                          canvas.drawText(timeFormat.format(tripDate), 100, yPosition, paint);
                          
                          // Draw wrapped text for addresses
                          int fromLines = drawWrappedText(canvas, paint, trip.getStartAddress(), 140, yPosition, 135);
                          int toLines = drawWrappedText(canvas, paint, trip.getEndAddress(), 280, yPosition, 135);
                          
                          canvas.drawText(String.format("%.2f", trip.getDistance()), 420, yPosition, paint);
                          canvas.drawText(trip.getCategory(), 460, yPosition, paint);
                          
                          totalMiles += trip.getDistance();
                          
                          // Adjust row height based on maximum lines used
                          int maxLines = Math.max(fromLines, toLines);
                          yPosition += (maxLines * 12) + 3; // Line height + small padding
                      }
                      
                      // Summary section
                      yPosition += 20;
                      paint.setTypeface(Typeface.DEFAULT_BOLD);
                      paint.setTextSize(12);
                      canvas.drawText("SUMMARY", 50, yPosition, paint);
                      
                      paint.setTypeface(Typeface.DEFAULT);
                      paint.setTextSize(10);
                      yPosition += 20;
                      canvas.drawText("Total Trips: " + trips.size(), 50, yPosition, paint);
                      yPosition += 15;
                      canvas.drawText("Total Miles: " + String.format("%.2f", totalMiles), 50, yPosition, paint);
                      yPosition += 15;
                      canvas.drawText("Business Deduction (IRS $" + String.format("%.2f", getIrsBusinessRate()) + "/mi): $" + String.format("%.2f", totalMiles * getIrsBusinessRate()), 50, yPosition, paint);
                      
                      document.finishPage(page);
                      
                      // Write PDF to byte array
                      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                      document.writeTo(outputStream);
                      document.close();
                      
                      return outputStream.toByteArray();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error generating PDF", e);
                      return null;
                  }
              }
              
              private String truncateText(String text, int maxLength) {
                  if (text == null || text.length() <= maxLength) {
                      return text;
                  }
                  return text.substring(0, maxLength - 3) + "...";
              }
              
              private int drawWrappedText(Canvas canvas, Paint paint, String text, float x, float y, float maxWidth) {
                  if (text == null || text.isEmpty()) {
                      canvas.drawText("Unknown", x, y, paint);
                      return 1; // Return number of lines drawn
                  }
                  
                  String[] words = text.split(" ");
                  StringBuilder line = new StringBuilder();
                  float currentY = y;
                  int linesDrawn = 0;
                  
                  for (String word : words) {
                      String testLine = line.length() == 0 ? word : line + " " + word;
                      float textWidth = paint.measureText(testLine);
                      
                      if (textWidth > maxWidth && line.length() > 0) {
                          canvas.drawText(line.toString(), x, currentY, paint);
                          line = new StringBuilder(word);
                          currentY += 12; // Line height
                          linesDrawn++;
                      } else {
                          line = new StringBuilder(testLine);
                      }
                  }
                  
                  if (line.length() > 0) {
                      canvas.drawText(line.toString(), x, currentY, paint);
                      linesDrawn++;
                  }
                  
                  return linesDrawn;
              }

              private void showSplitTripDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("âœ‚ï¸ Split Trip");
                  
                  // Create scrollable layout with proper sizing
                  ScrollView scrollView = new ScrollView(this);
                  scrollView.setLayoutParams(new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      700 // Increased height for better button visibility
                  ));
                  scrollView.setPadding(0, 0, 0, 50); // Bottom padding for buttons
                  
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(30, 20, 30, 20);
                  
                  // Trip info header
                  TextView tripInfo = new TextView(this);
                  tripInfo.setText(String.format("Split Trip: %.1f miles\n%s â†’ %s", 
                      trip.getDistance(), trip.getStartAddress(), trip.getEndAddress()));
                  tripInfo.setTextSize(14);
                  tripInfo.setTextColor(0xFF495057);
                  tripInfo.setPadding(0, 0, 0, 20);
                  layout.addView(tripInfo);
                  
                  // Split method toggle
                  TextView splitMethodLabel = new TextView(this);
                  splitMethodLabel.setText("Split Method:");
                  splitMethodLabel.setTextSize(14);
                  splitMethodLabel.setTypeface(null, android.graphics.Typeface.BOLD);
                  layout.addView(splitMethodLabel);
                  
                  // Radio button group for split method
                  LinearLayout radioGroup = new LinearLayout(this);
                  radioGroup.setOrientation(LinearLayout.HORIZONTAL);
                  radioGroup.setPadding(0, 5, 0, 15);
                  
                  CheckBox percentageRadio = new CheckBox(this);
                  percentageRadio.setText("Percentage");
                  percentageRadio.setChecked(false);
                  percentageRadio.setPadding(0, 0, 20, 0);
                  
                  CheckBox exactMilesRadio = new CheckBox(this);
                  exactMilesRadio.setText("Exact Miles");
                  exactMilesRadio.setChecked(true); // Default to exact miles
                  
                  radioGroup.addView(percentageRadio);
                  radioGroup.addView(exactMilesRadio);
                  layout.addView(radioGroup);
                  
                  // Percentage split section
                  LinearLayout percentageSection = new LinearLayout(this);
                  percentageSection.setOrientation(LinearLayout.VERTICAL);
                  percentageSection.setVisibility(View.GONE); // Hidden by default
                  
                  SeekBar splitSlider = new SeekBar(this);
                  splitSlider.setMax(80); // 20% to 100%
                  splitSlider.setProgress(30); // Default 50%
                  splitSlider.setPadding(0, 10, 0, 10);
                  
                  TextView splitPercentage = new TextView(this);
                  splitPercentage.setText("50% split");
                  splitPercentage.setTextSize(12);
                  splitPercentage.setTextColor(0xFF6C757D);
                  
                  percentageSection.addView(splitSlider);
                  percentageSection.addView(splitPercentage);
                  layout.addView(percentageSection);
                  
                  // Exact miles section
                  LinearLayout exactMilesSection = new LinearLayout(this);
                  exactMilesSection.setOrientation(LinearLayout.VERTICAL);
                  
                  TextView firstMilesLabel = new TextView(this);
                  firstMilesLabel.setText("First Trip Distance (miles):");
                  firstMilesLabel.setTextSize(12);
                  exactMilesSection.addView(firstMilesLabel);
                  
                  EditText firstMilesInput = new EditText(this);
                  firstMilesInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  firstMilesInput.setHint("e.g., 25.5");
                  firstMilesInput.setText(String.format("%.1f", trip.getDistance() / 2.0)); // Default to half
                  exactMilesSection.addView(firstMilesInput);
                  
                  TextView secondMilesLabel = new TextView(this);
                  secondMilesLabel.setText("Second Trip Distance (miles):");
                  secondMilesLabel.setTextSize(12);
                  secondMilesLabel.setPadding(0, 10, 0, 0);
                  exactMilesSection.addView(secondMilesLabel);
                  
                  EditText secondMilesInput = new EditText(this);
                  secondMilesInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  secondMilesInput.setHint("e.g., 75.0");
                  secondMilesInput.setText(String.format("%.1f", trip.getDistance() / 2.0)); // Default to half
                  exactMilesSection.addView(secondMilesInput);
                  
                  TextView totalCheck = new TextView(this);
                  totalCheck.setText(String.format("Total should equal: %.1f miles", trip.getDistance()));
                  totalCheck.setTextSize(11);
                  totalCheck.setTextColor(0xFF6C757D);
                  totalCheck.setPadding(0, 5, 0, 0);
                  exactMilesSection.addView(totalCheck);
                  
                  layout.addView(exactMilesSection);
                  
                  // Radio button toggle logic
                  percentageRadio.setOnClickListener(v -> {
                      if (percentageRadio.isChecked()) {
                          exactMilesRadio.setChecked(false);
                          percentageSection.setVisibility(View.VISIBLE);
                          exactMilesSection.setVisibility(View.GONE);
                      }
                  });
                  
                  exactMilesRadio.setOnClickListener(v -> {
                      if (exactMilesRadio.isChecked()) {
                          percentageRadio.setChecked(false);
                          percentageSection.setVisibility(View.GONE);
                          exactMilesSection.setVisibility(View.VISIBLE);
                      }
                  });
                  
                  // Update percentage display
                  splitSlider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
                      @Override
                      public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                          int percentage = progress + 20; // 20% to 100%
                          splitPercentage.setText(percentage + "% split");
                      }
                      
                      @Override
                      public void onStartTrackingTouch(SeekBar seekBar) {}
                      
                      @Override
                      public void onStopTrackingTouch(SeekBar seekBar) {}
                  });
                  
                  // Intermediate location
                  TextView intermediateLabelx = new TextView(this);
                  intermediateLabelx.setText("Intermediate Stop Location:");
                  intermediateLabelx.setTextSize(14);
                  intermediateLabelx.setTypeface(null, android.graphics.Typeface.BOLD);
                  intermediateLabelx.setPadding(0, 20, 0, 5);
                  layout.addView(intermediateLabelx);
                  
                  EditText intermediateLocation = new EditText(this);
                  intermediateLocation.setHint("Gas station, restaurant, etc.");
                  intermediateLocation.setText("Intermediate Stop");
                  layout.addView(intermediateLocation);
                  
                  // Categories for each trip part
                  TextView categoriesLabel = new TextView(this);
                  categoriesLabel.setText("Categories for Split Trips:");
                  categoriesLabel.setTextSize(14);
                  categoriesLabel.setTypeface(null, android.graphics.Typeface.BOLD);
                  categoriesLabel.setPadding(0, 20, 0, 10);
                  layout.addView(categoriesLabel);
                  
                  // First trip category
                  TextView firstLabel = new TextView(this);
                  firstLabel.setText("First Trip Category:");
                  firstLabel.setTextSize(12);
                  layout.addView(firstLabel);
                  
                  Spinner firstCategorySpinner = new Spinner(this);
                  List<String> allCategories = new ArrayList<>();
                  allCategories.add("Uncategorized");
                  allCategories.addAll(tripStorage.getAllCategories());
                  String[] categories = allCategories.toArray(new String[0]);
                  ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                  categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  firstCategorySpinner.setAdapter(categoryAdapter);
                  
                  // Set current category as default
                  String currentCategory = trip.getCategory();
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(currentCategory)) {
                          firstCategorySpinner.setSelection(i);
                          break;
                      }
                  }
                  layout.addView(firstCategorySpinner);
                  
                  // Second trip category
                  TextView secondLabel = new TextView(this);
                  secondLabel.setText("Second Trip Category:");
                  secondLabel.setTextSize(12);
                  secondLabel.setPadding(0, 10, 0, 0);
                  layout.addView(secondLabel);
                  
                  Spinner secondCategorySpinner = new Spinner(this);
                  secondCategorySpinner.setAdapter(categoryAdapter);
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(currentCategory)) {
                          secondCategorySpinner.setSelection(i);
                          break;
                      }
                  }
                  layout.addView(secondCategorySpinner);
                  
                  scrollView.addView(layout);
                  builder.setView(scrollView);
                  
                  builder.setPositiveButton("âœ‚ï¸ Split Trip", (dialog, which) -> {
                      try {
                          double firstDistance, secondDistance;
                          long firstDuration, secondDuration;
                          
                          if (exactMilesRadio.isChecked()) {
                              // Use exact miles input
                              try {
                                  firstDistance = Double.parseDouble(firstMilesInput.getText().toString());
                                  secondDistance = Double.parseDouble(secondMilesInput.getText().toString());
                                  
                                  // Validate totals match approximately
                                  double totalInput = firstDistance + secondDistance;
                                  if (Math.abs(totalInput - trip.getDistance()) > 0.1) {
                                      Toast.makeText(this, "âš ï¸ Split distances don't match total: " + 
                                          String.format("%.1f + %.1f = %.1f (should be %.1f)", 
                                          firstDistance, secondDistance, totalInput, trip.getDistance()), 
                                          Toast.LENGTH_LONG).show();
                                      return;
                                  }
                                  
                                  // Calculate proportional durations
                                  double firstPercent = firstDistance / trip.getDistance();
                                  firstDuration = (long)(trip.getDuration() * firstPercent);
                                  secondDuration = trip.getDuration() - firstDuration;
                                  
                              } catch (NumberFormatException e) {
                                  Toast.makeText(this, "âš ï¸ Please enter valid numbers for distances", Toast.LENGTH_SHORT).show();
                                  return;
                              }
                          } else {
                              // Use percentage slider
                              int splitPercent = splitSlider.getProgress() + 20;
                              firstDistance = (trip.getDistance() * splitPercent) / 100.0;
                              secondDistance = trip.getDistance() - firstDistance;
                              
                              firstDuration = (trip.getDuration() * splitPercent) / 100;
                              secondDuration = trip.getDuration() - firstDuration;
                          }
                          
                          String intermediateStop = intermediateLocation.getText().toString().trim();
                          if (intermediateStop.isEmpty()) {
                              intermediateStop = "Intermediate Stop";
                          }
                          
                          // Create first trip
                          Trip firstTrip = new Trip();
                          firstTrip.setId(System.currentTimeMillis());
                          firstTrip.setStartAddress(trip.getStartAddress());
                          firstTrip.setEndAddress(intermediateStop);
                          firstTrip.setStartLatitude(trip.getStartLatitude());
                          firstTrip.setStartLongitude(trip.getStartLongitude());
                          firstTrip.setEndLatitude(trip.getEndLatitude()); // Will be updated with intermediate coords
                          firstTrip.setEndLongitude(trip.getEndLongitude());
                          firstTrip.setDistance(firstDistance);
                          firstTrip.setDuration(firstDuration);
                          firstTrip.setStartTime(trip.getStartTime());
                          firstTrip.setEndTime(trip.getStartTime() + firstDuration);
                          firstTrip.setCategory(firstCategorySpinner.getSelectedItem().toString());
                          firstTrip.setAutoDetected(false);
                          firstTrip.setClientName(trip.getClientName());
                          firstTrip.setNotes("Split from original trip - First part");
                          
                          // Create second trip  
                          Trip secondTrip = new Trip();
                          secondTrip.setId(System.currentTimeMillis() + 1);
                          secondTrip.setStartAddress(intermediateStop);
                          secondTrip.setEndAddress(trip.getEndAddress());
                          secondTrip.setStartLatitude(trip.getEndLatitude()); // Will be updated with intermediate coords
                          secondTrip.setStartLongitude(trip.getEndLongitude());
                          secondTrip.setEndLatitude(trip.getEndLatitude());
                          secondTrip.setEndLongitude(trip.getEndLongitude());
                          secondTrip.setDistance(secondDistance);
                          secondTrip.setDuration(secondDuration);
                          secondTrip.setStartTime(trip.getStartTime() + firstDuration);
                          secondTrip.setEndTime(trip.getEndTime());
                          secondTrip.setCategory(secondCategorySpinner.getSelectedItem().toString());
                          secondTrip.setAutoDetected(false);
                          secondTrip.setClientName(trip.getClientName());
                          secondTrip.setNotes("Split from original trip - Second part");
                          
                          // Delete original trip and save new ones
                          tripStorage.deleteTrip(trip.getId());
                          tripStorage.saveTrip(firstTrip);
                          tripStorage.saveTrip(secondTrip);
                          
                          // Backup to API if enabled
                          if (tripStorage.isApiSyncEnabled()) {
                              try {
                                  CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                  cloudService.backupTrip(firstTrip);
                                  cloudService.backupTrip(secondTrip);
                              } catch (Exception e) {
                                  Log.e(TAG, "API backup failed for split trips: " + e.getMessage());
                              }
                          }
                          
                          // Refresh display
                          updateRecentTrips();
                          updateAllTrips();
                          updateStats();
                          
                          Toast.makeText(this, "âœ‚ï¸ Trip split successfully into 2 trips", Toast.LENGTH_SHORT).show();
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error splitting trip: " + e.getMessage(), e);
                          Toast.makeText(this, "âŒ Error splitting trip", Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("âŒ Cancel", null);
                  
                  AlertDialog splitDialog = builder.create();
                  splitDialog.show();
              }

              // Initialize gesture detector for swipe classification
              private void initializeGestureDetector() {
                  gestureDetector = new GestureDetector(this, new GestureDetector.SimpleOnGestureListener() {
                      @Override
                      public boolean onDown(MotionEvent e) {
                          Log.d(TAG, "Gesture detector onDown called");
                          return true;
                      }
                      
                      @Override
                      public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                          Log.d(TAG, "Gesture detector onFling called");
                          try {
                              if (currentSwipeTrip == null || currentSwipeView == null) {
                                  Log.d(TAG, "Swipe ignored - no current trip or view");
                                  return false;
                              }
                              
                              if (swipeInProgress) {
                                  Log.d(TAG, "Swipe ignored - already in progress");
                                  return false;
                              }
                              
                              float deltaX = e2.getX() - e1.getX();
                              float deltaY = e2.getY() - e1.getY();
                              
                              Log.d(TAG, "Swipe detected - deltaX: " + deltaX + ", deltaY: " + deltaY + ", velocityX: " + velocityX);
                              
                              // ULTRA-SENSITIVE swipe detection - minimal thresholds, no velocity requirement
                              if (Math.abs(deltaX) > 3 && Math.abs(deltaX) > Math.abs(deltaY) * 0.1) {
                                  swipeInProgress = true;
                                  
                                  if (deltaX > 0) {
                                      // Right swipe - Business
                                      Log.d(TAG, "Right swipe detected - Business");
                                      performSwipeClassification(currentSwipeTrip, "Business", 0xFF28A745);
                                  } else {
                                      // Left swipe - Personal
                                      Log.d(TAG, "Left swipe detected - Personal");
                                      performSwipeClassification(currentSwipeTrip, "Personal", 0xFF0044FF);
                                  }
                                  
                                  return true;
                              } else {
                                  Log.d(TAG, "Swipe requirements not met - deltaX: " + deltaX + ", deltaY: " + deltaY);
                              }
                          } catch (Exception e) {
                              Log.e(TAG, "Error handling swipe gesture: " + e.getMessage());
                          }
                          return false;
                      }
                  });
                  Log.d(TAG, "Gesture detector initialized successfully");
              }

              // Perform swipe classification with enhanced off-screen animation
              private void performSwipeClassification(Trip trip, String newCategory, int color) {
                  try {
                      Log.d(TAG, "Performing enhanced swipe classification to: " + newCategory);
                      
                      // Flash the new category color first on the container's background
                      GradientDrawable flashBorder = new GradientDrawable();
                      flashBorder.setColor(color);
                      flashBorder.setStroke(2, 0xFFd0d0d0);
                      flashBorder.setCornerRadius(8);
                      currentSwipeView.setBackground(flashBorder);
                      Log.d(TAG, "Container background flashed to: " + Integer.toHexString(color));
                      
                      // ENHANCED ANIMATION: Move item off-screen like typical swipe-to-dismiss
                      float screenWidth = getResources().getDisplayMetrics().widthPixels;
                      float targetX = newCategory.equals("Business") ? screenWidth : -screenWidth;
                      
                      // Create pronounced slide-out animation with proper container cleanup
                      currentSwipeView.animate()
                          .translationX(targetX)
                          .alpha(0.1f)
                          .setDuration(400)
                          .setListener(new android.animation.AnimatorListenerAdapter() {
                              @Override
                              public void onAnimationEnd(android.animation.Animator animation) {
                                  try {
                                      // IMMEDIATE CONTAINER CLEANUP - Hide the view completely
                                      currentSwipeView.setVisibility(android.view.View.GONE);
                                      
                                      // Update trip category
                                      String oldCategory = trip.getCategory();
                                      trip.setCategory(newCategory);
                                      tripStorage.saveTrip(trip);
                                      Log.d(TAG, "Trip category updated from " + oldCategory + " to " + newCategory);
                                      
                                      // Auto-classification learning - apply to similar uncategorized trips
                                      performLocationBasedLearning(trip, newCategory);
                                      
                                      // Backup to API if enabled
                                      if (tripStorage.isApiSyncEnabled()) {
                                          CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                          cloudService.backupTrip(trip);
                                          Log.d(TAG, "Trip backed up to API");
                                      }
                                      
                                      // Show success message indicating movement to Filed Trips
                                      String message = String.format("âœ“ Moved to %s â†’ Filed Trips", newCategory);
                                      Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show();
                                      Log.d(TAG, "Success toast shown: " + message);
                                      
                                      // Clear swipe state
                                      swipeInProgress = false;
                                      currentSwipeTrip = null;
                                      currentSwipeView = null;
                                      
                                      // Refresh display to completely remove the swiped item and clean up containers
                                      if ("classify".equals(currentTab)) {
                                          updateClassifyTrips();
                                      } else {
                                          updateAllTrips();
                                      }
                                      updateStats();
                                      Log.d(TAG, "Enhanced swipe classification completed with complete container cleanup");
                                  } catch (Exception e) {
                                      Log.e(TAG, "Error in swipe animation completion: " + e.getMessage());
                                  }
                              }
                          })
                          .start();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error performing enhanced swipe classification: " + e.getMessage());
                      Toast.makeText(this, "Error updating trip category", Toast.LENGTH_SHORT).show();
                      swipeInProgress = false;
                  }
              }

              // Get persistent background color for category
              private int getPersistentCategoryColor(String category) {
                  switch (category.toLowerCase()) {
                      case "business":
                          return 0xFFE8F5E8; // Light green background
                      case "personal":
                          return 0xFFE3F2FD; // Light blue background
                      case "medical":
                          return 0xFFFFF3E0; // Light yellow background
                      case "charity":
                          return 0xFFFFEBEE; // Light red background
                      case "uncategorized":
                          return 0xFFF8F9FA; // Light gray background for uncategorized
                      default:
                          return 0xFFFFFFFF; // White background
                  }
              }

              // LEARNING SYSTEM: Auto-classify similar uncategorized trips after user establishes patterns
              private void performLocationBasedLearning(Trip trip, String category) {
                  try {
                      // Get all uncategorized trips to check for similar locations
                      List<Trip> uncategorizedTrips = tripStorage.getAllTrips();
                      List<Trip> similarTrips = new ArrayList<>();
                      
                      String startLocationKey = normalizeLocationForClassification(trip.getStartAddress());
                      String endLocationKey = normalizeLocationForClassification(trip.getEndAddress());
                      
                      for (Trip uncategorizedTrip : uncategorizedTrips) {
                          if (uncategorizedTrip.getId() == trip.getId()) continue; // Skip current trip
                          if (!"Uncategorized".equals(uncategorizedTrip.getCategory())) continue; // Only process uncategorized trips
                          
                          String uncategorizedStartKey = normalizeLocationForClassification(uncategorizedTrip.getStartAddress());
                          String uncategorizedEndKey = normalizeLocationForClassification(uncategorizedTrip.getEndAddress());
                          
                          // Check if this uncategorized trip matches the location pattern
                          if (startLocationKey.equals(uncategorizedStartKey) || endLocationKey.equals(uncategorizedEndKey)) {
                              similarTrips.add(uncategorizedTrip);
                          }
                      }
                      
                      // Auto-classify similar trips
                      if (!similarTrips.isEmpty()) {
                          for (Trip similarTrip : similarTrips) {
                              similarTrip.setCategory(category);
                              tripStorage.saveTrip(similarTrip);
                          }
                          
                          // Notify user about auto-classifications
                          String message = "ðŸ¤– Auto-classified " + similarTrips.size() + " similar trip" + (similarTrips.size() == 1 ? "" : "s") + " as " + category;
                          Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                          
                          Log.d(TAG, "Auto-classified " + similarTrips.size() + " similar trips as " + category);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in location-based learning: " + e.getMessage(), e);
                  }
              }
              
              // Normalize location strings for consistent matching
              private String normalizeLocationForClassification(String location) {
                  if (location == null || location.trim().isEmpty()) return "";
                  
                  // Normalize location string for consistent matching
                  String normalized = location.toLowerCase().trim();
                  
                  // Remove common prefixes/suffixes that vary
                  normalized = normalized.replaceAll("^\\d+\\s*", ""); // Remove leading numbers
                  normalized = normalized.replaceAll("\\s*,.*$", ""); // Remove everything after first comma
                  normalized = normalized.replaceAll("\\s+", " "); // Normalize whitespace
                  
                  // Handle common location patterns
                  if (normalized.contains("home") || normalized.contains("house") || normalized.contains("residence")) {
                      return "home";
                  }
                  
                  // Business location keywords
                  if (normalized.contains("office") || normalized.contains("corp") || normalized.contains("company") || 
                      normalized.contains("business") || normalized.contains("workplace") || normalized.contains("work")) {
                      return "business_location";
                  }
                  
                  // Medical location keywords
                  if (normalized.contains("hospital") || normalized.contains("clinic") || normalized.contains("medical") || 
                      normalized.contains("doctor") || normalized.contains("dentist") || normalized.contains("pharmacy")) {
                      return "medical_location";
                  }
                  
                  // Return first meaningful part of address for matching
                  String[] parts = normalized.split(" ");
                  return parts.length > 0 ? parts[0] : normalized;
              }

              // Simplify address for classification matching
              private String simplifyAddress(String address) {
                  if (address == null) return "";
                  
                  // Extract key location identifiers
                  String simplified = address.toLowerCase()
                      .replaceAll("\\d+", "") // Remove numbers
                      .replaceAll("[^a-z\\s]", "") // Remove special characters
                      .replaceAll("\\s+", " ") // Normalize spaces
                      .trim();
                  
                  // Take first 3 words for location matching
                  String[] words = simplified.split("\\s+");
                  StringBuilder result = new StringBuilder();
                  for (int i = 0; i < Math.min(3, words.length); i++) {
                      if (i > 0) result.append(" ");
                      result.append(words[i]);
                  }
                  
                  return result.toString();
              }

              // Get auto-classification suggestion for a location
              private String getAutoClassificationSuggestion(String address) {
                  try {
                      if (address == null || address.isEmpty()) return null;
                      
                      String key = "location_" + simplifyAddress(address);
                      int count = locationPrefs.getInt(key + "_count", 0);
                      
                      // Only suggest if location has been visited 2+ times
                      if (count >= 2) {
                          return locationPrefs.getString(key + "_category", null);
                      }
                      
                      // Check for common business indicators
                      String lowerAddress = address.toLowerCase();
                      if (lowerAddress.contains("office") || lowerAddress.contains("corp") ||
                          lowerAddress.contains("company") || lowerAddress.contains("business") ||
                          lowerAddress.contains("suite") || lowerAddress.contains("building")) {
                          return "Business";
                      }
                      
                      // Check for medical indicators
                      if (lowerAddress.contains("hospital") || lowerAddress.contains("clinic") ||
                          lowerAddress.contains("medical") || lowerAddress.contains("doctor") ||
                          lowerAddress.contains("pharmacy")) {
                          return "Medical";
                      }
                      
                      return null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting auto-classification: " + e.getMessage());
                      return null;
                  }
              }
              
              // Reset all trips to Uncategorized
              private void resetAllTripsToUncategorized() {
                  try {
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      int resetCount = 0;
                      
                      for (Trip trip : allTrips) {
                          if (!"Uncategorized".equals(trip.getCategory())) {
                              trip.setCategory("Uncategorized");
                              tripStorage.saveTrip(trip);
                              resetCount++;
                          }
                      }
                      
                      // Sync to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudService = new CloudBackupService(this);
                          for (Trip trip : allTrips) {
                              cloudService.backupTrip(trip);
                          }
                      }
                      
                      Toast.makeText(this, "âœ… Reset " + resetCount + " trips to Uncategorized", Toast.LENGTH_LONG).show();
                      Log.d(TAG, "Reset " + resetCount + " trips to Uncategorized");
                      
                      // Refresh display
                      updateAllTrips();
                      updateStats();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error resetting trips: " + e.getMessage(), e);
                      Toast.makeText(this, "âŒ Error resetting trips", Toast.LENGTH_SHORT).show();
                  }
              }


          }
          EOF

      - name: Copy AddressLookup and services exactly from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder addressText = new StringBuilder();

                  if (address.getSubThoroughfare() != null) {
                      addressText.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      addressText.append(address.getThoroughfare()).append(", ");
                  }
                  if (address.getLocality() != null) {
                      addressText.append(address.getLocality()).append(", ");
                  }
                  if (address.getAdminArea() != null) {
                      addressText.append(address.getAdminArea());
                  }

                  String result = addressText.toString().trim();
                  if (result.endsWith(",")) {
                      result = result.substring(0, result.length() - 1);
                  }

                  return result.isEmpty() ? "Unknown Location" : result;
              }
          }
          EOF

          # Services (exact copy from working)
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              private static final int NOTIFICATION_ID = 1001;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private boolean isTracking = false;
              private Trip currentTrip = null;
              private Location lastLocation = null;
              private int stationaryCount = 0;
              private int movingCount = 0;
              private long lastMovementTime = 0;
              private List<Location> pathPoints = new ArrayList<>();
              private double cumulativeDistance = 0.0;

              private static final double SPEED_THRESHOLD_START = 4.6;
              private static final double SPEED_THRESHOLD_STOP = 3.0;
              private static final int START_CONFIRMATIONS = 3;
              private static final int STOP_CONFIRMATIONS = 4;
              private static final long MAX_STATIONARY_TIME = 120000;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();

                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          startAutoDetection();
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopAutoDetection();
                      }
                  }
                  return START_STICKY;
              }

              private void startAutoDetection() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      isTracking = true;
                      tripStorage.setAutoDetectionEnabled(true);

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          10000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (!isTracking || location == null) return;

                  try {
                      float speed = location.getSpeed() * 2.237f;
                      long currentTime = System.currentTimeMillis();

                      if (currentTrip == null) {
                          // RETURN TRIP FIX: More aggressive detection after first trip
                          if (speed >= SPEED_THRESHOLD_START) {
                              movingCount++;
                              stationaryCount = 0;
                              
                              Log.d(TAG, String.format("Return trip detection: Speed %.1f mph, Moving count: %d", 
                                  speed, movingCount));

                              if (movingCount >= START_CONFIRMATIONS) {
                                  Log.d(TAG, "Return trip detected - starting new trip");
                                  startNewTrip(location, currentTime);
                              }
                          } else {
                              // Reset moving count only if speed is really low
                              if (speed < 2.0) {
                                  movingCount = 0;
                              }
                              // Keep some moving count for gradual acceleration
                              Log.d(TAG, String.format("Waiting for return trip: Speed %.1f mph, Moving count: %d", 
                                  speed, movingCount));
                          }
                      } else {
                          // We're in an active trip - add path point
                          addPathPoint(location);
                          
                          if (speed <= SPEED_THRESHOLD_STOP) {
                              stationaryCount++;
                              movingCount = 0;

                              long timeSinceLastMovement = currentTime - lastMovementTime;

                              if (stationaryCount >= STOP_CONFIRMATIONS || 
                                  timeSinceLastMovement > MAX_STATIONARY_TIME) {
                                  endCurrentTrip();
                              }
                          } else {
                              stationaryCount = 0;
                              lastMovementTime = currentTime;
                          }
                      }

                      lastLocation = location;
                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location update", e);
                  }
              }

              private void startNewTrip(Location location, long currentTime) {
                  try {
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(true);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());
                      
                      // Initialize path tracking
                      pathPoints.clear();
                      pathPoints.add(location);
                      cumulativeDistance = 0.0;

                      // IMPROVED START LOCATION - Use home area detection for better accuracy
                      getHomeAreaAddress(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setStartAddress(address);
                              tripStorage.saveCurrentTrip(currentTrip);
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setStartAddress("Unknown Location");
                              tripStorage.saveCurrentTrip(currentTrip);
                          }
                      });

                      movingCount = 0;
                      lastMovementTime = currentTime;

                      Notification notification = createNotification("Trip in progress", "Recording your trip");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting trip", e);
                  }
              }

              private void endCurrentTrip() {
                  if (currentTrip == null) return;

                  try {
                      long currentTime = System.currentTimeMillis();
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      // Add final path point if needed
                      addPathPoint(lastLocation);
                      
                      // Use cumulative distance from path tracking instead of straight-line
                      currentTrip.setDistance(cumulativeDistance);

                      if (cumulativeDistance >= 0.5) {
                          // ENHANCED END LOCATION - Use area detection for better addresses
                          getEnhancedEndAddress(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  saveCompletedTrip();
                                  
                                  // CRITICAL FIX: Reset detection state for next trip
                                  resetDetectionState();
                              }

                              @Override
                              public void onAddressError(String error) {
                                  // FALLBACK: Use coordinates with city info as last resort
                                  String fallbackAddress = String.format("%.4f, %.4f", 
                                      lastLocation.getLatitude(), lastLocation.getLongitude());
                                  currentTrip.setEndAddress(fallbackAddress);
                                  saveCompletedTrip();
                                  
                                  // CRITICAL FIX: Reset detection state for next trip
                                  resetDetectionState();
                              }
                          });
                      } else {
                          // CRITICAL FIX: Trip too short, reset properly
                          Log.d(TAG, "Trip too short (" + cumulativeDistance + " mi), not saving");
                          tripStorage.saveCurrentTrip(null);
                          resetDetectionState();
                      }

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip: " + e.getMessage(), e);
                  }
              }
              
              // CRITICAL FIX: Ensure clean state for return trip detection
              private void resetDetectionState() {
                  try {
                      Log.d(TAG, "Resetting detection state for next trip");
                      
                      // Clear trip reference
                      currentTrip = null;
                      
                      // Reset all counters
                      stationaryCount = 0;
                      movingCount = 0;
                      lastMovementTime = 0;
                      
                      // Clear path tracking
                      pathPoints.clear();
                      cumulativeDistance = 0.0;
                      
                      // Clear trip storage
                      tripStorage.saveCurrentTrip(null);
                      
                      Log.d(TAG, "Detection state reset complete - ready for return trip");
                  } catch (Exception e) {
                      Log.e(TAG, "Error resetting detection state: " + e.getMessage(), e);
                  }
              }

              private void saveCompletedTrip() {
                  try {
                      Log.d(TAG, String.format("Saving completed trip: %.2f mi, %d minutes", 
                          currentTrip.getDistance(), currentTrip.getDuration() / 60000));
                          
                      tripStorage.saveTrip(currentTrip);
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }
                      
                      // Clear current trip from storage
                      tripStorage.saveCurrentTrip(null);
                      
                      Log.d(TAG, "Trip saved successfully, ready for next detection");
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving completed trip: " + e.getMessage(), e);
                  }
              }

              private void addPathPoint(Location location) {
                  try {
                      if (pathPoints.isEmpty()) {
                          pathPoints.add(location);
                          return;
                      }

                      Location lastPoint = pathPoints.get(pathPoints.size() - 1);
                      double segmentDistance = calculateDistance(
                          lastPoint.getLatitude(), lastPoint.getLongitude(),
                          location.getLatitude(), location.getLongitude()
                      );

                      // Only add point if we've moved a significant distance (about 50 feet)
                      if (segmentDistance >= 0.01) {
                          pathPoints.add(location);
                          cumulativeDistance += segmentDistance;
                          
                          Log.d(TAG, String.format("Path point added. Segment: %.3f mi, Total: %.3f mi", 
                              segmentDistance, cumulativeDistance));
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding path point", e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              // PRECISION HOME AREA DETECTION - Finds closest address to actual GPS location
              private void getHomeAreaAddress(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  try {
                      // DISTANCE-AWARE HOME DETECTION - Find the closest valid address
                      List<LocationCandidate> candidates = new ArrayList<>();
                      
                      // Test multiple precise locations around GPS coordinates
                      double[] offsets = {0.0, 0.0002, -0.0002, 0.0004, -0.0004, 0.0006, -0.0006}; // 0-70 meters
                      
                      findBestHomeAddress(latitude, longitude, offsets, 0, candidates, callback);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in precision home area detection: " + e.getMessage());
                      callback.onAddressError("Precision home area detection failed");
                  }
              }
              
              private void findBestHomeAddress(double baseLat, double baseLon, double[] offsets, int index, 
                                             List<LocationCandidate> candidates, AddressLookup.AddressCallback callback) {
                  if (index >= offsets.length) {
                      // All searches complete - find best candidate
                      processBestHomeCandidate(baseLat, baseLon, candidates, callback);
                      return;
                  }
                  
                  // Try latitude offset
                  double testLat = baseLat + offsets[index];
                  addressLookup.getAddressFromLocation(testLat, baseLon, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          if (isValidHomeAddress(address)) {
                              double distance = calculateDistance(baseLat, baseLon, testLat, baseLon);
                              candidates.add(new LocationCandidate(address, distance, testLat, baseLon));
                              Log.d(TAG, "Home candidate: " + address + " (distance: " + String.format("%.3f", distance) + " mi)");
                          }
                          
                          // Try longitude offset for same index
                          double testLon = baseLon + offsets[index];
                          addressLookup.getAddressFromLocation(baseLat, testLon, new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address2) {
                                  if (isValidHomeAddress(address2)) {
                                      double distance2 = calculateDistance(baseLat, baseLon, baseLat, testLon);
                                      candidates.add(new LocationCandidate(address2, distance2, baseLat, testLon));
                                      Log.d(TAG, "Home candidate: " + address2 + " (distance: " + String.format("%.3f", distance2) + " mi)");
                                  }
                                  
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }

                              @Override
                              public void onAddressError(String error2) {
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }
                          });
                      }

                      @Override
                      public void onAddressError(String error) {
                          // Try longitude offset for same index
                          double testLon = baseLon + offsets[index];
                          addressLookup.getAddressFromLocation(baseLat, testLon, new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address2) {
                                  if (isValidHomeAddress(address2)) {
                                      double distance2 = calculateDistance(baseLat, baseLon, baseLat, testLon);
                                      candidates.add(new LocationCandidate(address2, distance2, baseLat, testLon));
                                      Log.d(TAG, "Home candidate: " + address2 + " (distance: " + String.format("%.3f", distance2) + " mi)");
                                  }
                                  
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }

                              @Override
                              public void onAddressError(String error2) {
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }
                          });
                      }
                  });
              }
              
              private void processBestHomeCandidate(double baseLat, double baseLon, List<LocationCandidate> candidates, 
                                                  AddressLookup.AddressCallback callback) {
                  if (candidates.isEmpty()) {
                      Log.d(TAG, "No valid home candidates found, using fallback");
                      callback.onAddressError("No valid home address found");
                      return;
                  }
                  
                  // Sort by distance to find closest address
                  Collections.sort(candidates, (a, b) -> Double.compare(a.distance, b.distance));
                  
                  LocationCandidate best = candidates.get(0);
                  Log.d(TAG, "Best home address selected: " + best.address + " (distance: " + String.format("%.3f", best.distance) + " mi)");
                  
                  // If closest address is more than 1/8 mile away, something is wrong
                  if (best.distance > 0.125) {
                      Log.w(TAG, "Closest address is " + String.format("%.3f", best.distance) + " miles away - GPS accuracy issue?");
                  }
                  
                  callback.onAddressFound(best.address);
              }
              
              private boolean isValidHomeAddress(String address) {
                  if (address == null || address.isEmpty()) return false;
                  
                  String lower = address.toLowerCase();
                  
                  // Reject obviously bad addresses
                  if (lower.contains("unnamed") || lower.contains("unknown") || lower.contains("null")) {
                      return false;
                  }
                  
                  // Home addresses should have house numbers
                  if (!address.matches(".*\\d+.*")) {
                      return false;
                  }
                  
                  // Should be a residential street (not highway/interstate)
                  if (lower.contains("interstate") || lower.contains("highway") || lower.contains("i-")) {
                      return false;
                  }
                  
                  return true;
              }
              
              // Helper class for distance-aware address selection
              private static class LocationCandidate {
                  public String address;
                  public double distance;
                  public double lat;
                  public double lon;
                  
                  public LocationCandidate(String address, double distance, double lat, double lon) {
                      this.address = address;
                      this.distance = distance;
                      this.lat = lat;
                      this.lon = lon;
                  }
              }
              


              // ENHANCED END LOCATION DETECTION - Better destination address accuracy
              private void getEnhancedEndAddress(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  try {
                      // First try: Primary location with retries
                      tryAddressLookupWithRetries(latitude, longitude, 3, new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              if (isValidAddress(address)) {
                                  Log.d(TAG, "Found good end address: " + address);
                                  callback.onAddressFound(address);
                              } else {
                                  // Try nearby locations for better accuracy
                                  tryNearbyEndLocations(latitude, longitude, callback);
                              }
                          }

                          @Override
                          public void onAddressError(String error) {
                              // Try nearby locations if primary fails
                              tryNearbyEndLocations(latitude, longitude, callback);
                          }
                      });
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in enhanced end address detection: " + e.getMessage());
                      callback.onAddressError("Enhanced end address detection failed");
                  }
              }
              
              private void tryNearbyEndLocations(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  // Try a wider search area for end locations (businesses, destinations)
                  double[] offsets = {0.0, 0.0009, -0.0009, 0.0018, -0.0018}; // 0, 100m, 200m radius
                  
                  tryEndLocationWithOffsets(latitude, longitude, offsets, 0, callback);
              }
              
              private void tryEndLocationWithOffsets(double baseLat, double baseLon, double[] offsets, int index, AddressLookup.AddressCallback callback) {
                  if (index >= offsets.length) {
                      // All nearby locations failed, use coordinates with city lookup
                      getCityForCoordinates(baseLat, baseLon, callback);
                      return;
                  }
                  
                  double lat = baseLat + offsets[index];
                  double lon = baseLon + offsets[index];
                  
                  addressLookup.getAddressFromLocation(lat, lon, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          if (isValidAddress(address)) {
                              Log.d(TAG, "Found better end address at offset " + index + ": " + address);
                              callback.onAddressFound(address);
                          } else {
                              // Try next offset
                              tryEndLocationWithOffsets(baseLat, baseLon, offsets, index + 1, callback);
                          }
                      }

                      @Override
                      public void onAddressError(String error) {
                          // Try next offset
                          tryEndLocationWithOffsets(baseLat, baseLon, offsets, index + 1, callback);
                      }
                  });
              }
              
              private void getCityForCoordinates(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  try {
                      // Try to get at least city/state info for coordinates
                      addressLookup.getAddressFromLocation(latitude, longitude, new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              // Extract city/state from any address we get
                              String cityInfo = extractCityFromAddress(address);
                              if (cityInfo != null && !cityInfo.isEmpty()) {
                                  String formattedAddress = String.format("%.4f, %.4f (%s)", 
                                      latitude, longitude, cityInfo);
                                  callback.onAddressFound(formattedAddress);
                              } else {
                                  // Just coordinates if no city info
                                  callback.onAddressFound(String.format("%.4f, %.4f", latitude, longitude));
                              }
                          }

                          @Override
                          public void onAddressError(String error) {
                              // Last resort: just coordinates
                              callback.onAddressFound(String.format("%.4f, %.4f", latitude, longitude));
                          }
                      });
                  } catch (Exception e) {
                      callback.onAddressFound(String.format("%.4f, %.4f", latitude, longitude));
                  }
              }
              
              private String extractCityFromAddress(String address) {
                  try {
                      if (address == null || address.isEmpty()) return null;
                      
                      // Look for city, state pattern (e.g., "High Point, North Carolina")
                      String[] parts = address.split(",");
                      if (parts.length >= 2) {
                          String city = parts[parts.length - 2].trim();
                          String state = parts[parts.length - 1].trim();
                          return city + ", " + state;
                      }
                      
                      return null;
                  } catch (Exception e) {
                      return null;
                  }
              }
              
              private boolean isValidAddress(String address) {
                  if (address == null || address.isEmpty()) return false;
                  
                  // Valid addresses should have:
                  // - Street numbers OR business names
                  // - Not contain "unnamed" or "unknown"
                  // - Not be just coordinates
                  
                  String lower = address.toLowerCase();
                  if (lower.contains("unnamed") || lower.contains("unknown") || lower.contains("null")) {
                      return false;
                  }
                  
                  // Check if it's just coordinates (pattern like "35.1234, -80.1234")
                  if (address.matches("^-?\\d+\\.\\d+,\\s*-?\\d+\\.\\d+$")) {
                      return false;
                  }
                  
                  // Good address should have either numbers or common business words
                  return address.matches(".*\\d+.*") || 
                         lower.contains("street") || lower.contains("road") || lower.contains("avenue") ||
                         lower.contains("drive") || lower.contains("lane") || lower.contains("court") ||
                         lower.contains("center") || lower.contains("plaza") || lower.contains("mall");
              }
              
              private void tryAddressLookupWithRetries(double latitude, double longitude, int maxRetries, AddressLookup.AddressCallback callback) {
                  tryAddressLookupWithRetries(latitude, longitude, maxRetries, 0, callback);
              }
              
              private void tryAddressLookupWithRetries(double latitude, double longitude, int maxRetries, int currentTry, AddressLookup.AddressCallback callback) {
                  if (currentTry >= maxRetries) {
                      callback.onAddressError("Max retries exceeded");
                      return;
                  }
                  
                  addressLookup.getAddressFromLocation(latitude, longitude, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          callback.onAddressFound(address);
                      }

                      @Override
                      public void onAddressError(String error) {
                          // Retry with small delay
                          try {
                              Thread.sleep(500);
                          } catch (InterruptedException e) {
                              Thread.currentThread().interrupt();
                          }
                          tryAddressLookupWithRetries(latitude, longitude, maxRetries, currentTry + 1, callback);
                      }
                  });
              }

              private void stopAutoDetection() {
                  try {
                      isTracking = false;
                      tripStorage.setAutoDetectionEnabled(false);

                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && lastLocation != null) {
                          endCurrentTrip();
                      }

                      stopForeground(true);
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto detection", e);
                  }
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.widget.Toast;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import com.miletrackerpro.app.services.BluetoothVehicleService;
          import android.os.Handler;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "MANUAL_TRIP_CHANNEL";
              private static final int NOTIFICATION_ID = 1002;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private Trip currentTrip = null;
              private Location startLocation = null;
              private Location lastLocation = null;
              
              // Bluetooth variables
              private BluetoothVehicleService bluetoothVehicleService;
              private boolean autoDetectionEnabled = false;
              private boolean isCurrentlyTracking = false;
              private Handler speedHandler;
              private Handler blinkHandler;
              private Runnable speedRunnable;
              private Runnable blinkRunnable;

              @Override
              public void onCreate() {
                  super.onCreate();

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();
                  
                  // Initialize Bluetooth service
                  try {
                      bluetoothVehicleService = new BluetoothVehicleService(this);
                      bluetoothVehicleService.setCallbacks(new BluetoothVehicleService.VehicleConnectionCallback() {
                          @Override
                          public void onVehicleConnected(BluetoothVehicleService.VehicleInfo vehicle) {
                              // Handle vehicle connection
                              if (autoDetectionEnabled && !isCurrentlyTracking) {
                                  startAutoTrip();
                              }
                          }

                          @Override
                          public void onVehicleDisconnected(BluetoothVehicleService.VehicleInfo vehicle) {
                              // Handle vehicle disconnection
                              if (isCurrentlyTracking) {
                                  endAutoTrip();
                              }
                          }
                          
                          @Override
                          public void onNewVehicleDetected(String deviceName, String macAddress) {
                              // Handle new vehicle detection
                          }
                      }, null);
                      bluetoothVehicleService.setAutoDetectionEnabled(autoDetectionEnabled);
                  } catch (Exception e) {
                      Log.e(TAG, "Error initializing bluetooth service", e);
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      long currentTime = System.currentTimeMillis();

                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setEndAddress(address);
                              saveTrip();
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setEndAddress("Unknown Location");
                              saveTrip();
                          }
                      });
                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private void saveTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }

                      sendBroadcast("completed", currentTrip.getDistance(), currentTrip.getDuration());
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                  }
              }



              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip == null) return;

                      if (startLocation == null) {
                          startLocation = location;
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());

                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                              }
                          });
                      }

                      lastLocation = location;

                      if (startLocation != null) {
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  try {
                      Intent intent = new Intent("MANUAL_TRIP_UPDATE");
                      intent.putExtra("status", status);
                      intent.putExtra("distance", distance);
                      intent.putExtra("duration", duration);
                      sendBroadcast(intent);
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending broadcast: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }



              // Bluetooth methods
              private void startAutoTrip() {
                  if (!isCurrentlyTracking) {
                      isCurrentlyTracking = true;
                      startManualTrip();
                  }
              }
              
              private void endAutoTrip() {
                  if (isCurrentlyTracking) {
                      isCurrentlyTracking = false;
                      stopManualTrip();
                  }
              }
              
              public void onDestroy() {
                  super.onDestroy();
                  
                  if (bluetoothVehicleService != null) {
                      bluetoothVehicleService.destroy();
                  }
                  
                  if (speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
                  
                  if (blinkRunnable != null) {
                      blinkHandler.removeCallbacks(blinkRunnable);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: BUTTONS_FIXED_IN_CATEGORIZED_TAB_2025-01-10_10-55pm-EST with STABLE DEVICE ID + USER LINKING
        run: |
          cd android
          echo "BUILDING v4.9.140 - TWO-TAB INTERFACE SIMPLIFIED"
          echo "âœ… SIMPLIFIED: Removed Sort Trips tab for cleaner two-tab interface"
          echo "âœ… RENAMED: Filed Trips tab renamed to simply Trips"
          echo "âœ… ENHANCED: Cleaner navigation with Home and Trips tabs only"
          echo "âœ… PRESERVED: All uncategorized filter functionality maintained"
          echo "âœ… PRESERVED: Complete round-trip detection system and all working features"
          echo "âœ… PRESERVED: Advanced multi-level clustering algorithm for business travel"
          echo "âœ… PRESERVED: Complete authentication system and PostgreSQL sync"
          ./gradlew clean assembleRelease --no-daemon --stacktrace

      - name: Upload APK - Enhanced API Sync + All Editable Fields
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.96-Real-Time-Distance-Tracking
          path: android/app/build/outputs/apk/release/*.apk
