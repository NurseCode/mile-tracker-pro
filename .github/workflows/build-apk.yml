name: Phase 4 Fixed - Auto Detection + Manual Controls
on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh
          
          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`
          
          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"
          
          die () {
              echo
              echo "$*"
              echo
              exit 1
          }
          
          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi
          
          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null
          
          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
          
          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF
          
          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }
          
          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }
          
          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34
              
              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 17
                  versionName "4.1-auto-plus-manual-fixed"
              }
              
              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.debug
                  }
              }
              
              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }
              
              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }
          
          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }
          
          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              
              // Force specific Kotlin version to avoid conflicts
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              
              <!-- Location permissions -->
              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              
              <!-- Background service permissions -->
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              
              <!-- Network access for address lookup -->
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              
              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme">
                  
                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:launchMode="singleTop">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>
                  
                  <!-- Auto Detection Service -->
                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />
                  
              </application>
          </manifest>
          EOF

      - name: Create AddressLookup utility
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;
          
          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.os.Handler;
          import android.os.Looper;
          import java.io.IOException;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          
          public class AddressLookup {
              private static final ExecutorService executor = Executors.newFixedThreadPool(2);
              private static final Handler mainHandler = new Handler(Looper.getMainLooper());
              
              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressNotFound();
              }
              
              public static void getAddressFromLocation(Context context, double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      String address = lookupAddress(context, latitude, longitude);
                      
                      mainHandler.post(() -> {
                          if (address != null && !address.isEmpty()) {
                              callback.onAddressFound(address);
                          } else {
                              callback.onAddressNotFound();
                          }
                      });
                  });
              }
              
              private static String lookupAddress(Context context, double latitude, double longitude) {
                  try {
                      Geocoder geocoder = new Geocoder(context, Locale.getDefault());
                      
                      if (!geocoder.isPresent()) {
                          return null;
                      }
                      
                      List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                      
                      if (addresses != null && !addresses.isEmpty()) {
                          Address address = addresses.get(0);
                          return formatAddress(address);
                      }
                      
                  } catch (IOException e) {
                      return null;
                  } catch (Exception e) {
                      return null;
                  }
                  
                  return null;
              }
              
              private static String formatAddress(Address address) {
                  StringBuilder sb = new StringBuilder();
                  
                  if (address.getSubThoroughfare() != null) {
                      sb.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      sb.append(address.getThoroughfare());
                  }
                  
                  if (address.getLocality() != null) {
                      if (sb.length() > 0) sb.append(", ");
                      sb.append(address.getLocality());
                  }
                  
                  if (address.getAdminArea() != null) {
                      if (sb.length() > 0) sb.append(", ");
                      sb.append(address.getAdminArea());
                  }
                  
                  if (sb.length() == 0) {
                      if (address.getFeatureName() != null) {
                          sb.append(address.getFeatureName());
                      } else if (address.getSubLocality() != null) {
                          sb.append(address.getSubLocality());
                      }
                  }
                  
                  if (sb.length() == 0) {
                      return String.format("%.4f, %.4f", address.getLatitude(), address.getLongitude());
                  }
                  
                  return sb.toString().trim();
              }
          }
          EOF

      - name: Create Trip data model
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;
          
          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;
          
          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long duration;
              private long startTime;
              private long endTime;
              private boolean isAutoDetected;
              private boolean isManual;
              
              public Trip() {
                  this.id = System.currentTimeMillis();
                  this.startTime = System.currentTimeMillis();
                  this.startAddress = "Looking up address...";
                  this.endAddress = "Looking up address...";
              }
              
              public Trip(double distance, long duration, boolean isAutoDetected) {
                  this();
                  this.distance = distance;
                  this.duration = duration;
                  this.endTime = this.startTime + duration;
                  this.isAutoDetected = isAutoDetected;
                  this.isManual = !isAutoDetected;
              }
              
              public Trip(double startLat, double startLng, double endLat, double endLng, double distance, long duration, boolean isAutoDetected) {
                  this(distance, duration, isAutoDetected);
                  this.startLatitude = startLat;
                  this.startLongitude = startLng;
                  this.endLatitude = endLat;
                  this.endLongitude = endLng;
              }
              
              // Getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }
              
              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }
              
              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }
              
              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }
              
              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }
              
              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }
              
              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }
              
              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }
              
              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }
              
              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }
              
              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }
              
              public boolean isAutoDetected() { return isAutoDetected; }
              public void setAutoDetected(boolean autoDetected) { 
                  this.isAutoDetected = autoDetected; 
                  this.isManual = !autoDetected;
              }
              
              public boolean isManual() { return isManual; }
              public void setManual(boolean manual) { 
                  this.isManual = manual; 
                  this.isAutoDetected = !manual;
              }
              
              public String getFormattedDate() {
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy 'at' h:mm a", Locale.getDefault());
                  return dateFormat.format(new Date(startTime));
              }
              
              public String getFormattedDuration() {
                  long seconds = duration / 1000;
                  long minutes = seconds / 60;
                  long hours = minutes / 60;
                  
                  if (hours > 0) {
                      return String.format("%dh %dm", hours, minutes % 60);
                  } else {
                      return String.format("%dm", minutes);
                  }
              }
              
              public String getTrackingMethod() {
                  return isAutoDetected ? "Auto Detected" : "Manual Trip";
              }
          }
          EOF

      - name: Create TripStorage
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;
          
          import android.content.Context;
          import android.content.SharedPreferences;
          import java.util.ArrayList;
          import java.util.HashSet;
          import java.util.List;
          import java.util.Set;
          
          public class TripStorage {
              private static final String PREFS_NAME = "MileTrackerTrips";
              private static final String KEY_TRIP_COUNT = "trip_count";
              private static final String KEY_TRIP_PREFIX = "trip_";
              private static final String KEY_AUTO_DETECTION_ENABLED = "auto_detection_enabled";
              private static final String KEY_TRACKING_MODE = "tracking_mode";
              
              private SharedPreferences prefs;
              
              public TripStorage(Context context) {
                  prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }
              
              public void saveTrip(Trip trip) {
                  int tripCount = prefs.getInt(KEY_TRIP_COUNT, 0);
                  tripCount++;
                  
                  SharedPreferences.Editor editor = prefs.edit();
                  
                  String tripKey = KEY_TRIP_PREFIX + trip.getId();
                  editor.putString(tripKey + "_start_addr", trip.getStartAddress());
                  editor.putString(tripKey + "_end_addr", trip.getEndAddress());
                  editor.putFloat(tripKey + "_start_lat", (float) trip.getStartLatitude());
                  editor.putFloat(tripKey + "_start_lng", (float) trip.getStartLongitude());
                  editor.putFloat(tripKey + "_end_lat", (float) trip.getEndLatitude());
                  editor.putFloat(tripKey + "_end_lng", (float) trip.getEndLongitude());
                  editor.putFloat(tripKey + "_distance", (float) trip.getDistance());
                  editor.putLong(tripKey + "_duration", trip.getDuration());
                  editor.putLong(tripKey + "_start_time", trip.getStartTime());
                  editor.putLong(tripKey + "_end_time", trip.getEndTime());
                  editor.putBoolean(tripKey + "_auto", trip.isAutoDetected());
                  editor.putBoolean(tripKey + "_manual", trip.isManual());
                  
                  editor.putInt(KEY_TRIP_COUNT, tripCount);
                  
                  Set<String> tripIds = prefs.getStringSet("trip_ids", new HashSet<>());
                  tripIds = new HashSet<>(tripIds);
                  tripIds.add(String.valueOf(trip.getId()));
                  editor.putStringSet("trip_ids", tripIds);
                  
                  editor.apply();
              }
              
              public void updateTripAddresses(long tripId, String startAddress, String endAddress) {
                  SharedPreferences.Editor editor = prefs.edit();
                  String tripKey = KEY_TRIP_PREFIX + tripId;
                  
                  if (startAddress != null) {
                      editor.putString(tripKey + "_start_addr", startAddress);
                  }
                  if (endAddress != null) {
                      editor.putString(tripKey + "_end_addr", endAddress);
                  }
                  
                  editor.apply();
              }
              
              public boolean isAutoDetectionEnabled() {
                  return prefs.getBoolean(KEY_AUTO_DETECTION_ENABLED, false);
              }
              
              public void setAutoDetectionEnabled(boolean enabled) {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.putBoolean(KEY_AUTO_DETECTION_ENABLED, enabled);
                  editor.apply();
              }
              
              public String getTrackingMode() {
                  return prefs.getString(KEY_TRACKING_MODE, "auto");
              }
              
              public void setTrackingMode(String mode) {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.putString(KEY_TRACKING_MODE, mode);
                  editor.apply();
              }
              
              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  Set<String> tripIds = prefs.getStringSet("trip_ids", new HashSet<>());
                  
                  for (String tripIdStr : tripIds) {
                      try {
                          long tripId = Long.parseLong(tripIdStr);
                          Trip trip = loadTrip(tripId);
                          if (trip != null) {
                              trips.add(trip);
                          }
                      } catch (NumberFormatException e) {
                          // Skip invalid trip IDs
                      }
                  }
                  
                  trips.sort((t1, t2) -> Long.compare(t2.getStartTime(), t1.getStartTime()));
                  
                  return trips;
              }
              
              private Trip loadTrip(long tripId) {
                  String tripKey = KEY_TRIP_PREFIX + tripId;
                  
                  if (!prefs.contains(tripKey + "_distance")) {
                      return null;
                  }
                  
                  Trip trip = new Trip();
                  trip.setId(tripId);
                  trip.setStartAddress(prefs.getString(tripKey + "_start_addr", "Unknown Location"));
                  trip.setEndAddress(prefs.getString(tripKey + "_end_addr", "Unknown Location"));
                  trip.setStartLatitude(prefs.getFloat(tripKey + "_start_lat", 0.0f));
                  trip.setStartLongitude(prefs.getFloat(tripKey + "_start_lng", 0.0f));
                  trip.setEndLatitude(prefs.getFloat(tripKey + "_end_lat", 0.0f));
                  trip.setEndLongitude(prefs.getFloat(tripKey + "_end_lng", 0.0f));
                  trip.setDistance(prefs.getFloat(tripKey + "_distance", 0.0f));
                  trip.setDuration(prefs.getLong(tripKey + "_duration", 0));
                  trip.setStartTime(prefs.getLong(tripKey + "_start_time", 0));
                  trip.setEndTime(prefs.getLong(tripKey + "_end_time", 0));
                  trip.setAutoDetected(prefs.getBoolean(tripKey + "_auto", false));
                  trip.setManual(prefs.getBoolean(tripKey + "_manual", false));
                  
                  return trip;
              }
              
              public int getTripCount() {
                  return prefs.getInt(KEY_TRIP_COUNT, 0);
              }
              
              public double getTotalMiles() {
                  double total = 0.0;
                  List<Trip> trips = getAllTrips();
                  for (Trip trip : trips) {
                      total += trip.getDistance();
                  }
                  return total;
              }
              
              public void clearAllTrips() {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.clear();
                  editor.apply();
              }
          }
          EOF

      - name: Create SmartAutoDetectionService
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;
          
          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.os.PowerManager;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import java.util.ArrayList;
          import java.util.List;
          
          public class AutoDetectionService extends Service implements LocationListener {
              private static final int NOTIFICATION_ID = 2001;
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              
              // Smart detection thresholds
              private static final float DRIVING_SPEED_THRESHOLD = 8.0f; // mph
              private static final float STOPPED_SPEED_THRESHOLD = 3.0f; // mph
              private static final int READINGS_TO_START = 3; // consecutive readings
              private static final int READINGS_TO_STOP = 8; // increased from 4 to reduce stoplight splits
              private static final double MIN_TRIP_DISTANCE = 0.3; // increased from 0.1 to avoid short segments
              private static final long MIN_TRIP_DURATION = 120000; // 2 minutes minimum trip duration
              private static final long STOPLIGHT_GRACE_PERIOD = 180000; // 3 minutes grace for stoplights
              
              private LocationManager locationManager;
              private PowerManager.WakeLock wakeLock;
              private NotificationManager notificationManager;
              private TripStorage tripStorage;
              
              private Location lastLocation;
              private Location tripStartLocation;
              private List<Float> recentSpeeds = new ArrayList<>();
              private boolean isInTrip = false;
              private float totalDistance = 0.0f;
              private long tripStartTime = 0;
              private long lastMovementTime = 0;
              private long currentTripId = 0;
              private int drivingReadings = 0;
              private int stoppedReadings = 0;
              
              @Override
              public void onCreate() {
                  super.onCreate();
                  
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                  notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
                  tripStorage = new TripStorage(this);
                  
                  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);
                  wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MileTracker:AutoDetection");
                  
                  createNotificationChannel();
                  startMonitoring();
              }
              
              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  return START_STICKY;
              }
              
              private void startMonitoring() {
                  if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                      == PackageManager.PERMISSION_GRANTED) {
                      
                      if (!wakeLock.isHeld()) {
                          wakeLock.acquire();
                      }
                      
                      startForeground(NOTIFICATION_ID, createMonitoringNotification());
                      
                      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 
                          6000, 3, this);
                      
                      locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 
                          10000, 8, this);
                  }
              }
              
              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Trip Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      channel.setDescription("Smart trip detection with stoplight awareness");
                      notificationManager.createNotificationChannel(channel);
                  }
              }
              
              private Notification createMonitoringNotification() {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle("MileTracker Pro")
                      .setContentText("Smart auto-detection active - prevents stoplight splits")
                      .setSmallIcon(android.R.drawable.ic_menu_compass)
                      .setOngoing(true)
                      .setPriority(NotificationCompat.PRIORITY_LOW)
                      .build();
              }
              
              private Notification createTripNotification() {
                  long elapsed = System.currentTimeMillis() - tripStartTime;
                  String timeText = formatTime(elapsed);
                  
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle("MileTracker Pro - Smart Trip Active")
                      .setContentText(String.format("%.2f miles â€¢ %s", totalDistance, timeText))
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .setPriority(NotificationCompat.PRIORITY_LOW)
                      .build();
              }
              
              private void updateNotification() {
                  Notification notification = isInTrip ? createTripNotification() : createMonitoringNotification();
                  notificationManager.notify(NOTIFICATION_ID, notification);
              }
              
              private String formatTime(long milliseconds) {
                  long seconds = milliseconds / 1000;
                  long minutes = seconds / 60;
                  seconds = seconds % 60;
                  return String.format("%02d:%02d", minutes, seconds);
              }
              
              @Override
              public void onLocationChanged(Location location) {
                  float speed = location.getSpeed() * 2.237f; // Convert m/s to mph
                  long currentTime = System.currentTimeMillis();
                  
                  // Update last movement time if moving
                  if (speed > STOPPED_SPEED_THRESHOLD) {
                      lastMovementTime = currentTime;
                  }
                  
                  // Add speed to recent readings
                  recentSpeeds.add(speed);
                  if (recentSpeeds.size() > 15) {
                      recentSpeeds.remove(0);
                  }
                  
                  // Check for trip start/stop conditions
                  if (!isInTrip) {
                      checkTripStart(speed, location, currentTime);
                  } else {
                      updateTripDistance(location);
                      checkTripStop(speed, location, currentTime);
                  }
                  
                  lastLocation = location;
                  updateNotification();
              }
              
              private void checkTripStart(float speed, Location location, long currentTime) {
                  if (speed > DRIVING_SPEED_THRESHOLD) {
                      drivingReadings++;
                      stoppedReadings = 0;
                      
                      if (drivingReadings >= READINGS_TO_START) {
                          startTrip(location, currentTime);
                      }
                  } else {
                      drivingReadings = 0;
                  }
              }
              
              private void checkTripStop(float speed, Location location, long currentTime) {
                  long tripDuration = currentTime - tripStartTime;
                  long timeSinceMovement = currentTime - lastMovementTime;
                  
                  if (speed < STOPPED_SPEED_THRESHOLD) {
                      stoppedReadings++;
                      drivingReadings = 0;
                      
                      boolean longEnoughStop = stoppedReadings >= READINGS_TO_STOP;
                      boolean minimumDuration = tripDuration >= MIN_TRIP_DURATION;
                      boolean gracePeriodElapsed = timeSinceMovement >= STOPLIGHT_GRACE_PERIOD;
                      boolean minimumDistance = totalDistance >= MIN_TRIP_DISTANCE;
                      
                      if (longEnoughStop && (minimumDuration || gracePeriodElapsed) && minimumDistance) {
                          stopTrip(location, currentTime);
                      }
                  } else {
                      stoppedReadings = 0;
                  }
              }
              
              private void startTrip(Location location, long currentTime) {
                  isInTrip = true;
                  tripStartTime = currentTime;
                  lastMovementTime = currentTime;
                  tripStartLocation = location;
                  totalDistance = 0.0f;
                  drivingReadings = 0;
                  stoppedReadings = 0;
                  currentTripId = currentTime;
              }
              
              private void stopTrip(Location endLocation, long currentTime) {
                  if (isInTrip) {
                      long duration = currentTime - tripStartTime;
                      
                      if (totalDistance >= MIN_TRIP_DISTANCE && duration >= MIN_TRIP_DURATION) {
                          Trip trip = new Trip(
                              tripStartLocation.getLatitude(),
                              tripStartLocation.getLongitude(),
                              endLocation.getLatitude(),
                              endLocation.getLongitude(),
                              totalDistance,
                              duration,
                              true
                          );
                          
                          trip.setId(currentTripId);
                          
                          tripStorage.saveTrip(trip);
                          lookupTripAddresses(trip);
                      }
                  }
                  
                  isInTrip = false;
                  totalDistance = 0.0f;
                  drivingReadings = 0;
                  stoppedReadings = 0;
                  tripStartLocation = null;
                  currentTripId = 0;
              }
              
              private void lookupTripAddresses(Trip trip) {
                  AddressLookup.getAddressFromLocation(this, 
                      trip.getStartLatitude(), 
                      trip.getStartLongitude(), 
                      new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              tripStorage.updateTripAddresses(trip.getId(), address, null);
                          }
                          
                          @Override
                          public void onAddressNotFound() {
                              tripStorage.updateTripAddresses(trip.getId(), "Unknown Location", null);
                          }
                      });
                  
                  AddressLookup.getAddressFromLocation(this, 
                      trip.getEndLatitude(), 
                      trip.getEndLongitude(), 
                      new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              tripStorage.updateTripAddresses(trip.getId(), null, address);
                          }
                          
                          @Override
                          public void onAddressNotFound() {
                              tripStorage.updateTripAddresses(trip.getId(), null, "Unknown Location");
                          }
                      });
              }
              
              private void updateTripDistance(Location location) {
                  if (lastLocation != null) {
                      float distance = lastLocation.distanceTo(location) / 1609.34f; // Convert to miles
                      
                      if (distance > 0.002f && distance < 0.3f) {
                          totalDistance += distance;
                      }
                  }
              }
              
              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
              
              @Override
              public void onDestroy() {
                  super.onDestroy();
                  
                  if (wakeLock.isHeld()) {
                      wakeLock.release();
                  }
                  
                  locationManager.removeUpdates(this);
              }
              
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              
              @Override
              public void onProviderEnabled(String provider) {}
              
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Create simplified MainActivity with dual mode
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;
          
          import android.Manifest;
          import android.app.ActivityManager;
          import android.content.Context;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.view.View;
          import android.widget.Button;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.services.AutoDetectionService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import java.util.List;
          
          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final int LOCATION_PERMISSION_REQUEST = 1001;
              private static final int BACKGROUND_LOCATION_PERMISSION_REQUEST = 1002;
              
              private TextView statusText;
              private TextView speedText;
              private TextView statsText;
              private TextView modeText;
              private Button modeToggle;
              private Button actionButton;
              private Button viewTripsButton;
              private LinearLayout tripHistoryLayout;
              private ScrollView tripHistoryScroll;
              
              private LocationManager locationManager;
              private TripStorage tripStorage;
              private String currentMode = "auto"; // "auto" or "manual"
              private boolean autoDetectionEnabled = false;
              private boolean showingTrips = false;
              private Handler speedHandler = new Handler();
              private Runnable speedRunnable;
              
              // Manual trip tracking
              private boolean manualTripActive = false;
              private Location manualTripStart;
              private float manualTripDistance = 0.0f;
              private long manualTripStartTime = 0;
              
              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  tripStorage = new TripStorage(this);
                  currentMode = tripStorage.getTrackingMode();
                  
                  createLayout();
                  initializeGPS();
                  setupSpeedMonitoring();
                  requestPermissions();
                  updateStats();
                  
                  if (currentMode.equals("auto")) {
                      restoreAutoDetectionState();
                  }
                  
                  updateModeDisplay();
              }
              
              private void createLayout() {
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 60, 40, 40);
                  mainLayout.setBackgroundColor(0xFFFFFFFF);
                  
                  // Title
                  TextView title = new TextView(this);
                  title.setText("MileTracker Pro");
                  title.setTextSize(28);
                  title.setTextColor(0xFF667eea);
                  title.setPadding(0, 0, 0, 20);
                  mainLayout.addView(title);
                  
                  // Subtitle
                  TextView subtitle = new TextView(this);
                  subtitle.setText("Auto Detection + Manual Controls");
                  subtitle.setTextSize(16);
                  subtitle.setTextColor(0xFF666666);
                  subtitle.setPadding(0, 0, 0, 20);
                  mainLayout.addView(subtitle);
                  
                  // Stats
                  statsText = new TextView(this);
                  statsText.setTextSize(14);
                  statsText.setTextColor(0xFF666666);
                  statsText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(statsText);
                  
                  // Mode display
                  modeText = new TextView(this);
                  modeText.setTextSize(16);
                  modeText.setTextColor(0xFF333333);
                  modeText.setPadding(0, 0, 0, 15);
                  mainLayout.addView(modeText);
                  
                  // Status
                  statusText = new TextView(this);
                  statusText.setText("Ready for trip tracking");
                  statusText.setTextSize(16);
                  statusText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(statusText);
                  
                  // Speed display
                  speedText = new TextView(this);
                  speedText.setText("Speed: -- mph");
                  speedText.setTextSize(18);
                  speedText.setTextColor(0xFF1976D2);
                  speedText.setPadding(0, 0, 0, 30);
                  mainLayout.addView(speedText);
                  
                  // Mode toggle button
                  modeToggle = new Button(this);
                  modeToggle.setText("SWITCH TO MANUAL MODE");
                  modeToggle.setTextSize(14);
                  modeToggle.setBackgroundColor(0xFF667eea);
                  modeToggle.setTextColor(0xFFFFFFFF);
                  modeToggle.setPadding(15, 15, 15, 15);
                  modeToggle.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          toggleMode();
                      }
                  });
                  mainLayout.addView(modeToggle);
                  
                  // Add spacing
                  TextView spacer1 = new TextView(this);
                  spacer1.setHeight(20);
                  mainLayout.addView(spacer1);
                  
                  // Action button
                  actionButton = new Button(this);
                  actionButton.setTextSize(16);
                  actionButton.setPadding(20, 20, 20, 20);
                  actionButton.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          handleActionButton();
                      }
                  });
                  mainLayout.addView(actionButton);
                  
                  // Add spacing
                  TextView spacer2 = new TextView(this);
                  spacer2.setHeight(30);
                  mainLayout.addView(spacer2);
                  
                  // Explanation
                  TextView explanation = new TextView(this);
                  explanation.setText("Auto Mode: Automatically starts/stops trips based on driving speed. Smart logic prevents splitting trips at stoplights.");
                  explanation.setTextSize(14);
                  explanation.setTextColor(0xFF666666);
                  explanation.setPadding(0, 0, 0, 30);
                  mainLayout.addView(explanation);
                  
                  // View trips button
                  viewTripsButton = new Button(this);
                  viewTripsButton.setText("VIEW TRIP HISTORY");
                  viewTripsButton.setTextSize(16);
                  viewTripsButton.setBackgroundColor(0xFF667eea);
                  viewTripsButton.setTextColor(0xFFFFFFFF);
                  viewTripsButton.setPadding(20, 15, 20, 15);
                  viewTripsButton.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          toggleTripHistory();
                      }
                  });
                  mainLayout.addView(viewTripsButton);
                  
                  // Trip history scroll view
                  tripHistoryScroll = new ScrollView(this);
                  tripHistoryScroll.setVisibility(View.GONE);
                  
                  tripHistoryLayout = new LinearLayout(this);
                  tripHistoryLayout.setOrientation(LinearLayout.VERTICAL);
                  tripHistoryLayout.setPadding(0, 20, 0, 0);
                  
                  tripHistoryScroll.addView(tripHistoryLayout);
                  mainLayout.addView(tripHistoryScroll);
                  
                  setContentView(mainLayout);
              }
              
              private void toggleMode() {
                  if (currentMode.equals("auto")) {
                      currentMode = "manual";
                      if (autoDetectionEnabled) {
                          stopAutoDetectionService();
                          autoDetectionEnabled = false;
                      }
                      stopSpeedMonitoring();
                  } else {
                      currentMode = "auto";
                      if (manualTripActive) {
                          stopManualTrip();
                      }
                  }
                  
                  tripStorage.setTrackingMode(currentMode);
                  updateModeDisplay();
              }
              
              private void updateModeDisplay() {
                  if (currentMode.equals("auto")) {
                      modeText.setText("Auto Mode: Smart trip detection with stoplight awareness");
                      modeToggle.setText("SWITCH TO MANUAL MODE");
                      
                      if (autoDetectionEnabled) {
                          actionButton.setText("AUTO DETECTION: ON");
                          actionButton.setBackgroundColor(0xFF4CAF50);
                          actionButton.setTextColor(0xFFFFFFFF);
                          statusText.setText("Auto-detection active - smart monitoring prevents stoplight splits");
                          startSpeedMonitoring();
                      } else {
                          actionButton.setText("AUTO DETECTION: OFF");
                          actionButton.setBackgroundColor(0xFFE0E0E0);
                          actionButton.setTextColor(0xFF000000);
                          statusText.setText("Auto-detection ready - enable to start monitoring");
                          speedText.setText("Speed: -- mph");
                      }
                      
                  } else {
                      modeText.setText("Manual Mode: Full start/stop control like traditional apps");
                      modeToggle.setText("SWITCH TO AUTO MODE");
                      
                      if (manualTripActive) {
                          actionButton.setText("STOP TRIP");
                          actionButton.setBackgroundColor(0xFFD32F2F);
                          actionButton.setTextColor(0xFFFFFFFF);
                          statusText.setText("Manual trip recording in progress");
                      } else {
                          actionButton.setText("START TRIP NOW");
                          actionButton.setBackgroundColor(0xFF4CAF50);
                          actionButton.setTextColor(0xFFFFFFFF);
                          statusText.setText("Ready to start manual trip");
                      }
                      
                      speedText.setText("Speed: -- mph");
                  }
              }
              
              private void handleActionButton() {
                  if (currentMode.equals("auto")) {
                      toggleAutoDetection();
                  } else {
                      toggleManualTrip();
                  }
              }
              
              private void toggleAutoDetection() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                      if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) 
                          != PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Background location permission required for auto-detection", Toast.LENGTH_LONG).show();
                          requestBackgroundLocationPermission();
                          return;
                      }
                  }
                  
                  autoDetectionEnabled = !autoDetectionEnabled;
                  tripStorage.setAutoDetectionEnabled(autoDetectionEnabled);
                  
                  if (autoDetectionEnabled) {
                      startAutoDetectionService();
                      startSpeedMonitoring();
                  } else {
                      stopAutoDetectionService();
                      stopSpeedMonitoring();
                  }
                  
                  updateModeDisplay();
              }
              
              private void toggleManualTrip() {
                  if (manualTripActive) {
                      stopManualTrip();
                  } else {
                      startManualTrip();
                  }
              }
              
              private void startManualTrip() {
                  manualTripActive = true;
                  manualTripStartTime = System.currentTimeMillis();
                  manualTripDistance = 0.0f;
                  manualTripStart = null;
                  
                  startLocationUpdatesForManual();
                  updateModeDisplay();
                  Toast.makeText(this, "Manual trip started", Toast.LENGTH_SHORT).show();
              }
              
              private void stopManualTrip() {
                  if (manualTripActive && manualTripStart != null) {
                      // Save manual trip
                      long duration = System.currentTimeMillis() - manualTripStartTime;
                      
                      if (manualTripDistance > 0.1) { // Minimum distance
                          Trip trip = new Trip(manualTripDistance, duration, false);
                          trip.setManual(true);
                          trip.setStartLatitude(manualTripStart.getLatitude());
                          trip.setStartLongitude(manualTripStart.getLongitude());
                          
                          // Use current location as end point if available
                          LocationManager lm = (LocationManager) getSystemService(LOCATION_SERVICE);
                          if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                              Location lastKnown = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                              if (lastKnown != null) {
                                  trip.setEndLatitude(lastKnown.getLatitude());
                                  trip.setEndLongitude(lastKnown.getLongitude());
                              }
                          }
                          
                          tripStorage.saveTrip(trip);
                          updateStats();
                          Toast.makeText(this, "Manual trip saved", Toast.LENGTH_SHORT).show();
                      }
                  }
                  
                  manualTripActive = false;
                  stopLocationUpdatesForManual();
                  updateModeDisplay();
              }
              
              private void startLocationUpdatesForManual() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                      == PackageManager.PERMISSION_GRANTED) {
                      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 
                          3000, 2, this);
                  }
              }
              
              private void stopLocationUpdatesForManual() {
                  locationManager.removeUpdates(this);
              }
              
              private void restoreAutoDetectionState() {
                  boolean serviceRunning = isServiceRunning(AutoDetectionService.class);
                  boolean savedState = tripStorage.isAutoDetectionEnabled();
                  
                  autoDetectionEnabled = serviceRunning || savedState;
                  
                  if (autoDetectionEnabled && !serviceRunning) {
                      startAutoDetectionService();
                  }
              }
              
              private boolean isServiceRunning(Class<?> serviceClass) {
                  ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
                  for (ActivityManager.RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) {
                      if (serviceClass.getName().equals(service.service.getClassName())) {
                          return true;
                      }
                  }
                  return false;
              }
              
              private void updateStats() {
                  int tripCount = tripStorage.getTripCount();
                  double totalMiles = tripStorage.getTotalMiles();
                  statsText.setText(String.format("Total: %d trips â€¢ %.2f miles", tripCount, totalMiles));
              }
              
              private void toggleTripHistory() {
                  showingTrips = !showingTrips;
                  
                  if (showingTrips) {
                      viewTripsButton.setText("HIDE TRIP HISTORY");
                      displayTripHistory();
                      tripHistoryScroll.setVisibility(View.VISIBLE);
                  } else {
                      viewTripsButton.setText("VIEW TRIP HISTORY");
                      tripHistoryScroll.setVisibility(View.GONE);
                  }
              }
              
              private void displayTripHistory() {
                  tripHistoryLayout.removeAllViews();
                  
                  List<Trip> trips = tripStorage.getAllTrips();
                  
                  if (trips.isEmpty()) {
                      TextView noTrips = new TextView(this);
                      noTrips.setText("No trips recorded yet. Enable auto-detection or start a manual trip!");
                      noTrips.setTextSize(16);
                      noTrips.setTextColor(0xFF666666);
                      noTrips.setPadding(0, 20, 0, 20);
                      tripHistoryLayout.addView(noTrips);
                      return;
                  }
                  
                  for (Trip trip : trips) {
                      LinearLayout tripCard = new LinearLayout(this);
                      tripCard.setOrientation(LinearLayout.VERTICAL);
                      tripCard.setBackgroundColor(0xFFF5F5F5);
                      tripCard.setPadding(20, 15, 20, 15);
                      
                      LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT,
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      cardParams.setMargins(0, 0, 0, 10);
                      tripCard.setLayoutParams(cardParams);
                      
                      // Trip header
                      TextView tripHeader = new TextView(this);
                      tripHeader.setText(String.format("%.2f miles â€¢ %s", 
                          trip.getDistance(), trip.getFormattedDuration()));
                      tripHeader.setTextSize(18);
                      tripHeader.setTextColor(0xFF2E7D32);
                      tripCard.addView(tripHeader);
                      
                      // Start address
                      TextView startText = new TextView(this);
                      String startAddr = trip.getStartAddress();
                      if (startAddr == null || startAddr.isEmpty()) {
                          startAddr = "Unknown Start";
                      }
                      startText.setText("From: " + startAddr);
                      startText.setTextSize(13);
                      startText.setTextColor(0xFF333333);
                      startText.setPadding(0, 5, 0, 0);
                      tripCard.addView(startText);
                      
                      // End address
                      TextView endText = new TextView(this);
                      String endAddr = trip.getEndAddress();
                      if (endAddr == null || endAddr.isEmpty()) {
                          endAddr = "Unknown End";
                      }
                      endText.setText("To: " + endAddr);
                      endText.setTextSize(13);
                      endText.setTextColor(0xFF333333);
                      endText.setPadding(0, 2, 0, 0);
                      tripCard.addView(endText);
                      
                      // Trip date and time
                      TextView tripDate = new TextView(this);
                      tripDate.setText(trip.getFormattedDate());
                      tripDate.setTextSize(12);
                      tripDate.setTextColor(0xFF666666);
                      tripDate.setPadding(0, 5, 0, 0);
                      tripCard.addView(tripDate);
                      
                      // Trip method
                      TextView tripMethod = new TextView(this);
                      tripMethod.setText(trip.getTrackingMethod());
                      tripMethod.setTextSize(11);
                      tripMethod.setTextColor(trip.isAutoDetected() ? 0xFF4CAF50 : 0xFF1976D2);
                      tripMethod.setPadding(0, 3, 0, 0);
                      tripCard.addView(tripMethod);
                      
                      tripHistoryLayout.addView(tripCard);
                  }
              }
              
              private void requestPermissions() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                      != PackageManager.PERMISSION_GRANTED) {
                      ActivityCompat.requestPermissions(this,
                          new String[]{
                              Manifest.permission.ACCESS_FINE_LOCATION,
                              Manifest.permission.ACCESS_COARSE_LOCATION
                          },
                          LOCATION_PERMISSION_REQUEST);
                  } else {
                      requestBackgroundLocationPermission();
                  }
              }
              
              private void requestBackgroundLocationPermission() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                      if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) 
                          != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this,
                              new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION},
                              BACKGROUND_LOCATION_PERMISSION_REQUEST);
                      }
                  }
              }
              
              private void startAutoDetectionService() {
                  Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                  startForegroundService(serviceIntent);
              }
              
              private void stopAutoDetectionService() {
                  Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                  stopService(serviceIntent);
              }
              
              private void initializeGPS() {
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
              }
              
              private void setupSpeedMonitoring() {
                  speedRunnable = new Runnable() {
                      @Override
                      public void run() {
                          if (currentMode.equals("auto") && autoDetectionEnabled) {
                              speedHandler.postDelayed(this, 2000);
                          }
                      }
                  };
              }
              
              private void startSpeedMonitoring() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                      == PackageManager.PERMISSION_GRANTED) {
                      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 
                          2000, 0, this);
                      speedHandler.post(speedRunnable);
                  }
              }
              
              private void stopSpeedMonitoring() {
                  locationManager.removeUpdates(this);
                  speedHandler.removeCallbacks(speedRunnable);
              }
              
              @Override
              public void onLocationChanged(Location location) {
                  if (currentMode.equals("auto") && autoDetectionEnabled) {
                      float speed = location.getSpeed() * 2.237f;
                      speedText.setText(String.format("Speed: %.1f mph", speed));
                  } else if (currentMode.equals("manual") && manualTripActive) {
                      if (manualTripStart == null) {
                          manualTripStart = location;
                      } else {
                          float distance = manualTripStart.distanceTo(location) / 1609.34f;
                          if (distance > 0.001f && distance < 1.0f) {
                              manualTripDistance += distance;
                          }
                          manualTripStart = location;
                      }
                      
                      long elapsed = System.currentTimeMillis() - manualTripStartTime;
                      statusText.setText(String.format("Recording: %.2f miles â€¢ %s", 
                          manualTripDistance, formatTime(elapsed)));
                  }
              }
              
              private String formatTime(long milliseconds) {
                  long seconds = milliseconds / 1000;
                  long minutes = seconds / 60;
                  seconds = seconds % 60;
                  return String.format("%02d:%02d", minutes, seconds);
              }
              
              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  
                  if (requestCode == LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          requestBackgroundLocationPermission();
                      }
                  }
              }
              
              @Override
              protected void onResume() {
                  super.onResume();
                  updateStats();
                  if (showingTrips) {
                      displayTripHistory();
                  }
                  updateModeDisplay();
              }
              
              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  stopSpeedMonitoring();
                  if (manualTripActive) {
                      stopLocationUpdatesForManual();
                  }
              }
              
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              
              @Override
              public void onProviderEnabled(String provider) {}
              
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Create app theme and resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a67d8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF
          
          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
          </resources>
          EOF

      - name: Create app icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="108dp"
              android:height="108dp"
              android:viewportWidth="108"
              android:viewportHeight="108">
              <path
                  android:fillColor="#667eea"
                  android:pathData="M0,0h108v108h-108z" />
              <path
                  android:fillColor="#ffffff"
                  android:pathData="M30,30h48v48h-48z" />
          </vector>
          EOF

      - name: Build APK
        run: |
          cd android
          ./gradlew clean assembleRelease

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: miletracker-auto-plus-manual-fixed.apk
          path: android/app/build/outputs/apk/release/app-release.apk
