name: Working Baseline User Merge v4.9.68 on
push:
  branches: [ main ]

workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Run npm install
      run: |
        npm install

    - name: Create android directory structure
      run: |
        mkdir -p android-app/src/main/java/com/miletrackerpro/activities
        mkdir -p android-app/src/main/java/com/miletrackerpro/services
        mkdir -p android-app/src/main/java/com/miletrackerpro/storage
        mkdir -p android-app/src/main/java/com/miletrackerpro/utils
        mkdir -p android-app/src/main/java/com/miletrackerpro/models
        mkdir -p android-app/src/main/res/values
        mkdir -p android-app/src/main/res/layout

    - name: Create Android manifest
      run: |
        cat > android-app/src/main/AndroidManifest.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            package="com.miletrackerpro.app">

            <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
            <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
            <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
            <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
            <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
            <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
            <uses-permission android:name="android.permission.WAKE_LOCK" />
            <uses-permission android:name="android.permission.INTERNET" />
            <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
            <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
            <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />

            <application
                android:allowBackup="true"
                android:icon="@android:drawable/ic_menu_mylocation"
                android:label="MileTracker Pro"
                android:requestLegacyExternalStorage="true"
                android:theme="@android:style/Theme.Material.Light">
                
                <activity
                    android:name=".activities.MainActivity"
                    android:exported="true"
                    android:launchMode="singleTop">
                    <intent-filter>
                        <action android:name="android.intent.action.MAIN" />
                        <category android:name="android.intent.category.LAUNCHER" />
                    </intent-filter>
                </activity>

                <service
                    android:name=".services.AutoDetectionService"
                    android:enabled="true"
                    android:exported="false"
                    android:foregroundServiceType="location" />

                <service
                    android:name=".services.ManualTripService"
                    android:enabled="true"
                    android:exported="false"
                    android:foregroundServiceType="location" />

            </application>
        </manifest>
        EOF

    - name: Create MainActivity.java with Service Startup Fix
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/activities/MainActivity.java << 'EOF'
        package com.miletrackerpro.activities;

          import android.Manifest;
          import android.app.Activity;
          import android.app.AlertDialog;
          import android.app.DatePickerDialog;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.DialogInterface;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.graphics.Typeface;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.view.View;
          import android.widget.*;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;

          import com.miletrackerpro.models.Trip;
          import com.miletrackerpro.services.AutoDetectionService;
          import com.miletrackerpro.services.ManualTripService;
          import com.miletrackerpro.storage.TripStorage;
          import com.miletrackerpro.utils.AddressLookup;
          import com.miletrackerpro.utils.CloudBackupService;

          import java.text.SimpleDateFormat;
          import java.util.*;
          import java.util.stream.Collectors;

          public class MainActivity extends Activity {
              private static final String TAG = "MileTracker";
              private static final int PERMISSION_REQUEST_CODE = 1001;

              // UI Elements - Main Controls
              private Button autoToggle, manualToggle;
              private TextView statusText, speedText;
              private LinearLayout mainLayout;

              // UI Elements - Stats
              private TextView monthlyTripsText, monthlyMilesText, monthlyDeductionText;

              // UI Elements - Recent Trips
              private LinearLayout recentTripsLayout;
              private ScrollView recentTripsScroll;

              // UI Elements - Tabs
              private Button dashboardTab, tripsTab;
              private LinearLayout dashboardView, tripsView;

              // UI Elements - All Trips
              private LinearLayout allTripsLayout;
              private ScrollView allTripsScroll;
              
              // UI Elements - User Controls
              private LinearLayout userControlsLayout;
              private CheckBox mergeSelectAllCheckbox;
              private Button mergeExecuteButton, mergeCancelButton;
              private boolean mergeMode = false;
              private Set<Long> selectedTripIds = new HashSet<>();

              // Trips UI Elements
              private LinearLayout allTripsLayout;
              private ScrollView allTripsScroll;

              // Services and storage
              private LocationManager locationManager;
              private TripStorage tripStorage;
              private boolean autoDetectionEnabled = false;
              private boolean manualTripInProgress = false;
              private Handler speedHandler = new Handler();
              private Runnable speedRunnable;

              // Broadcast receiver for service updates
              private BroadcastReceiver serviceReceiver;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  Log.d(TAG, "MainActivity onCreate - MileTracker Pro v4.9.68 Enhanced");

                  // Initialize storage first
                  tripStorage = new TripStorage(this);

                  // Request permissions
                  if (!hasLocationPermissions()) {
                      requestLocationPermissions();
                  }

                  createUI();
                  initializeGPS();
                  
                  // CRITICAL FIX: Restore auto-detection with proper service startup
                  restoreAutoDetectionState();
                  
                  setupServiceReceiver();
                  
                  // Load data
                  loadDashboardData();
                  loadAllTrips();
                  showDashboardView();
              }

              private void createUI() {
                  mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(20, 20, 20, 20);
                  mainLayout.setBackgroundColor(0xFFF8F9FA);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("ðŸš— MileTracker Pro v4.9.68");
                  headerText.setTextSize(24);
                  headerText.setTypeface(null, Typeface.BOLD);
                  headerText.setTextColor(0xFF2563EB);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(headerText);

                  // Tab Layout
                  createTabLayout();

                  // Dashboard View
                  createDashboardView();

                  // Trips View
                  createTripsView();

                  setContentView(mainLayout);
              }

              private void createTabLayout() {
                  LinearLayout tabLayout = new LinearLayout(this);
                  tabLayout.setOrientation(LinearLayout.HORIZONTAL);
                  tabLayout.setGravity(Gravity.CENTER);
                  
                  // Dashboard Tab
                  dashboardTab = new Button(this);
                  dashboardTab.setText("ðŸ  Dashboard");
                  dashboardTab.setBackgroundColor(0xFF2563EB);
                  dashboardTab.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams dashboardParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  dashboardParams.setMargins(0, 0, 5, 0);
                  dashboardTab.setLayoutParams(dashboardParams);
                  dashboardTab.setOnClickListener(v -> showDashboardView());
                  tabLayout.addView(dashboardTab);

                  // Trips Tab
                  tripsTab = new Button(this);
                  tripsTab.setText("ðŸš— Trips");
                  tripsTab.setBackgroundColor(0xFF6B7280);
                  tripsTab.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams tripsParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  tripsParams.setMargins(5, 0, 0, 0);
                  tripsTab.setLayoutParams(tripsParams);
                  tripsTab.setOnClickListener(v -> showTripsView());
                  tabLayout.addView(tripsTab);

                  mainLayout.addView(tabLayout);
              }

              private void createDashboardView() {
                  dashboardView = new LinearLayout(this);
                  dashboardView.setOrientation(LinearLayout.VERTICAL);

                  // Control buttons
                  createControlButtons();

                  // Status display
                  createStatusDisplay();

                  // Monthly stats
                  createMonthlyStats();

                  // Recent trips
                  createRecentTripsView();

                  mainLayout.addView(dashboardView);
              }

              private void createControlButtons() {
                  LinearLayout controlLayout = new LinearLayout(this);
                  controlLayout.setOrientation(LinearLayout.HORIZONTAL);
                  controlLayout.setGravity(Gravity.CENTER);
                  controlLayout.setPadding(0, 10, 0, 20);

                  // Auto Detection Toggle
                  autoToggle = new Button(this);
                  autoToggle.setText("ðŸ”„ Auto OFF");
                  autoToggle.setBackgroundColor(0xFF9CA3AF);
                  autoToggle.setTextColor(0xFFFFFFFF);
                  autoToggle.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams autoParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  autoParams.setMargins(0, 0, 10, 0);
                  autoToggle.setLayoutParams(autoParams);
                  autoToggle.setOnClickListener(v -> toggleAutoDetection());
                  controlLayout.addView(autoToggle);

                  // Manual Toggle
                  manualToggle = new Button(this);
                  manualToggle.setText("ðŸ”„ Manual OFF");
                  manualToggle.setBackgroundColor(0xFF9CA3AF);
                  manualToggle.setTextColor(0xFFFFFFFF);
                  manualToggle.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams manualParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  manualParams.setMargins(10, 0, 0, 0);
                  manualToggle.setLayoutParams(manualParams);
                  manualToggle.setOnClickListener(v -> toggleManualTrip());
                  controlLayout.addView(manualToggle);

                  dashboardView.addView(controlLayout);
              }

              private void createStatusDisplay() {
                  LinearLayout statusLayout = new LinearLayout(this);
                  statusLayout.setOrientation(LinearLayout.VERTICAL);
                  statusLayout.setBackgroundColor(0xFFFFFFFF);
                  statusLayout.setPadding(15, 15, 15, 15);
                  statusLayout.setGravity(Gravity.CENTER);

                  statusText = new TextView(this);
                  statusText.setText("Ready");
                  statusText.setTextSize(16);
                  statusText.setTextColor(0xFF374151);
                  statusText.setGravity(Gravity.CENTER);
                  statusLayout.addView(statusText);

                  speedText = new TextView(this);
                  speedText.setText("Speed: 0.0 mph");
                  speedText.setTextSize(14);
                  speedText.setTextColor(0xFF6B7280);
                  speedText.setGravity(Gravity.CENTER);
                  speedText.setPadding(0, 5, 0, 0);
                  statusLayout.addView(speedText);

                  dashboardView.addView(statusLayout);
              }

              private void createMonthlyStats() {
                  TextView monthlyHeader = new TextView(this);
                  monthlyHeader.setText("ðŸ“Š This Month");
                  monthlyHeader.setTextSize(18);
                  monthlyHeader.setTypeface(null, Typeface.BOLD);
                  monthlyHeader.setTextColor(0xFF2563EB);
                  monthlyHeader.setPadding(0, 20, 0, 10);
                  dashboardView.addView(monthlyHeader);

                  LinearLayout statsLayout = new LinearLayout(this);
                  statsLayout.setOrientation(LinearLayout.HORIZONTAL);
                  statsLayout.setBackgroundColor(0xFFFFFFFF);
                  statsLayout.setPadding(15, 15, 15, 15);

                  // Trips
                  LinearLayout tripsColumn = new LinearLayout(this);
                  tripsColumn.setOrientation(LinearLayout.VERTICAL);
                  tripsColumn.setGravity(Gravity.CENTER);
                  LinearLayout.LayoutParams columnParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  tripsColumn.setLayoutParams(columnParams);

                  TextView tripsLabel = new TextView(this);
                  tripsLabel.setText("Trips");
                  tripsLabel.setTextSize(12);
                  tripsLabel.setTextColor(0xFF6B7280);
                  tripsLabel.setGravity(Gravity.CENTER);
                  tripsColumn.addView(tripsLabel);

                  monthlyTripsText = new TextView(this);
                  monthlyTripsText.setText("0");
                  monthlyTripsText.setTextSize(20);
                  monthlyTripsText.setTypeface(null, Typeface.BOLD);
                  monthlyTripsText.setTextColor(0xFF2563EB);
                  monthlyTripsText.setGravity(Gravity.CENTER);
                  tripsColumn.addView(monthlyTripsText);

                  statsLayout.addView(tripsColumn);

                  // Miles
                  LinearLayout milesColumn = new LinearLayout(this);
                  milesColumn.setOrientation(LinearLayout.VERTICAL);
                  milesColumn.setGravity(Gravity.CENTER);
                  milesColumn.setLayoutParams(columnParams);

                  TextView milesLabel = new TextView(this);
                  milesLabel.setText("Miles");
                  milesLabel.setTextSize(12);
                  milesLabel.setTextColor(0xFF6B7280);
                  milesLabel.setGravity(Gravity.CENTER);
                  milesColumn.addView(milesLabel);

                  monthlyMilesText = new TextView(this);
                  monthlyMilesText.setText("0.0");
                  monthlyMilesText.setTextSize(20);
                  monthlyMilesText.setTypeface(null, Typeface.BOLD);
                  monthlyMilesText.setTextColor(0xFF059669);
                  monthlyMilesText.setGravity(Gravity.CENTER);
                  milesColumn.addView(monthlyMilesText);

                  statsLayout.addView(milesColumn);

                  // Deduction
                  LinearLayout deductionColumn = new LinearLayout(this);
                  deductionColumn.setOrientation(LinearLayout.VERTICAL);
                  deductionColumn.setGravity(Gravity.CENTER);
                  deductionColumn.setLayoutParams(columnParams);

                  TextView deductionLabel = new TextView(this);
                  deductionLabel.setText("IRS Deduction");
                  deductionLabel.setTextSize(12);
                  deductionLabel.setTextColor(0xFF6B7280);
                  deductionLabel.setGravity(Gravity.CENTER);
                  deductionColumn.addView(deductionLabel);

                  monthlyDeductionText = new TextView(this);
                  monthlyDeductionText.setText("$0.00");
                  monthlyDeductionText.setTextSize(20);
                  monthlyDeductionText.setTypeface(null, Typeface.BOLD);
                  monthlyDeductionText.setTextColor(0xFFDC2626);
                  monthlyDeductionText.setGravity(Gravity.CENTER);
                  deductionColumn.addView(monthlyDeductionText);

                  statsLayout.addView(deductionColumn);

                  dashboardView.addView(statsLayout);
              }

              private void createRecentTripsView() {
                  TextView recentHeader = new TextView(this);
                  recentHeader.setText("ðŸš— Recent Trips");
                  recentHeader.setTextSize(18);
                  recentHeader.setTypeface(null, Typeface.BOLD);
                  recentHeader.setTextColor(0xFF2563EB);
                  recentHeader.setPadding(0, 20, 0, 10);
                  dashboardView.addView(recentHeader);

                  recentTripsScroll = new ScrollView(this);
                  LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 300);
                  recentTripsScroll.setLayoutParams(scrollParams);

                  recentTripsLayout = new LinearLayout(this);
                  recentTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  recentTripsScroll.addView(recentTripsLayout);

                  dashboardView.addView(recentTripsScroll);
              }

              private void createTripsView() {
                  tripsView = new LinearLayout(this);
                  tripsView.setOrientation(LinearLayout.VERTICAL);
                  tripsView.setVisibility(View.GONE);

                  TextView tripsHeader = new TextView(this);
                  tripsHeader.setText("ðŸš— All Trips");
                  tripsHeader.setTextSize(20);
                  tripsHeader.setTypeface(null, Typeface.BOLD);
                  tripsHeader.setTextColor(0xFF2563EB);
                  tripsHeader.setPadding(0, 10, 0, 15);
                  tripsView.addView(tripsHeader);

                  // User Controls Layout
                  createUserControlsLayout();

                  allTripsScroll = new ScrollView(this);
                  allTripsLayout = new LinearLayout(this);
                  allTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  allTripsScroll.addView(allTripsLayout);
                  tripsView.addView(allTripsScroll);

                  mainLayout.addView(tripsView);
              }

              private void createUserControlsLayout() {
                  userControlsLayout = new LinearLayout(this);
                  userControlsLayout.setOrientation(LinearLayout.VERTICAL);
                  userControlsLayout.setPadding(0, 0, 0, 15);
                  userControlsLayout.setBackgroundColor(0xFFF3F4F6);

                  // Merge Controls Row
                  LinearLayout mergeControlsRow = new LinearLayout(this);
                  mergeControlsRow.setOrientation(LinearLayout.HORIZONTAL);
                  mergeControlsRow.setPadding(10, 10, 10, 10);

                  Button toggleMergeButton = new Button(this);
                  toggleMergeButton.setText("Merge Trips");
                  toggleMergeButton.setBackgroundColor(0xFF3B82F6);
                  toggleMergeButton.setTextColor(0xFFFFFFFF);
                  toggleMergeButton.setPadding(15, 10, 15, 10);
                  toggleMergeButton.setOnClickListener(v -> toggleMergeMode());
                  mergeControlsRow.addView(toggleMergeButton);

                  Button addTripButton = new Button(this);
                  addTripButton.setText("+ Add Trip");
                  addTripButton.setBackgroundColor(0xFF10B981);
                  addTripButton.setTextColor(0xFFFFFFFF);
                  addTripButton.setPadding(15, 10, 15, 10);
                  LinearLayout.LayoutParams addTripParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  addTripParams.setMargins(10, 0, 0, 0);
                  addTripButton.setLayoutParams(addTripParams);
                  addTripButton.setOnClickListener(v -> showAddTripDialog());
                  mergeControlsRow.addView(addTripButton);

                  userControlsLayout.addView(mergeControlsRow);

                  // Merge Mode Controls (Initially Hidden)
                  LinearLayout mergeRow = new LinearLayout(this);
                  mergeRow.setOrientation(LinearLayout.HORIZONTAL);
                  mergeRow.setPadding(10, 0, 10, 10);
                  mergeRow.setVisibility(View.GONE);

                  mergeSelectAllCheckbox = new CheckBox(this);
                  mergeSelectAllCheckbox.setText("Select All");
                  mergeSelectAllCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                      selectAllTrips(isChecked);
                  });
                  mergeRow.addView(mergeSelectAllCheckbox);

                  mergeExecuteButton = new Button(this);
                  mergeExecuteButton.setText("Execute Merge");
                  mergeExecuteButton.setBackgroundColor(0xFFEF4444);
                  mergeExecuteButton.setTextColor(0xFFFFFFFF);
                  mergeExecuteButton.setPadding(15, 8, 15, 8);
                  LinearLayout.LayoutParams executeParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  executeParams.setMargins(20, 0, 10, 0);
                  mergeExecuteButton.setLayoutParams(executeParams);
                  mergeExecuteButton.setOnClickListener(v -> executeMerge());
                  mergeRow.addView(mergeExecuteButton);

                  mergeCancelButton = new Button(this);
                  mergeCancelButton.setText("Cancel");
                  mergeCancelButton.setBackgroundColor(0xFF6B7280);
                  mergeCancelButton.setTextColor(0xFFFFFFFF);
                  mergeCancelButton.setPadding(15, 8, 15, 8);
                  mergeCancelButton.setOnClickListener(v -> cancelMergeMode());
                  mergeRow.addView(mergeCancelButton);

                  userControlsLayout.addView(mergeRow);

                  // Store reference to merge controls for show/hide
                  userControlsLayout.setTag(mergeRow);

                  tripsView.addView(userControlsLayout);
              }

              private void showDashboardView() {
                  dashboardView.setVisibility(View.VISIBLE);
                  tripsView.setVisibility(View.GONE);
                  
                  dashboardTab.setBackgroundColor(0xFF2563EB);
                  tripsTab.setBackgroundColor(0xFF6B7280);
                  
                  loadDashboardData();
              }

              private void showTripsView() {
                  dashboardView.setVisibility(View.GONE);
                  tripsView.setVisibility(View.VISIBLE);
                  
                  dashboardTab.setBackgroundColor(0xFF6B7280);
                  tripsTab.setBackgroundColor(0xFF2563EB);
                  
                  loadAllTrips();
              }

              private boolean hasLocationPermissions() {
                  return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED &&
                         ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED;
              }

              private void requestLocationPermissions() {
                  String[] permissions = {
                      Manifest.permission.ACCESS_FINE_LOCATION,
                      Manifest.permission.ACCESS_COARSE_LOCATION
                  };
                  
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                      permissions = new String[]{
                          Manifest.permission.ACCESS_FINE_LOCATION,
                          Manifest.permission.ACCESS_COARSE_LOCATION,
                          Manifest.permission.ACCESS_BACKGROUND_LOCATION
                      };
                  }
                  
                  ActivityCompat.requestPermissions(this, permissions, PERMISSION_REQUEST_CODE);
              }

              private void setupServiceReceiver() {
                  serviceReceiver = new BroadcastReceiver() {
                      @Override
                      public void onReceive(Context context, Intent intent) {
                          String action = intent.getAction();
                          if ("com.miletrackerpro.TRIP_UPDATE".equals(action)) {
                              loadDashboardData();
                              loadAllTrips();
                          } else if ("com.miletrackerpro.MANUAL_TRIP_UPDATE".equals(action)) {
                              String status = intent.getStringExtra("status");
                              updateManualTripStatus(status);
                          }
                      }
                  };

                  IntentFilter filter = new IntentFilter();
                  filter.addAction("com.miletrackerpro.TRIP_UPDATE");
                  filter.addAction("com.miletrackerpro.MANUAL_TRIP_UPDATE");
                  
                  try {
                      registerReceiver(serviceReceiver, filter);
                      Log.d(TAG, "Service receiver registered successfully");
                  } catch (Exception e) {
                      Log.e(TAG, "Error registering broadcast receiver: " + e.getMessage(), e);
                  }
              }

              private void restoreAutoDetectionState() {
                  try {
                      // Check user's saved preference
                      autoDetectionEnabled = tripStorage.isAutoDetectionEnabled();
                      
                      if (autoDetectionEnabled) {
                          // User wants auto-detection ON - start service automatically
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }
                          
                          // Update UI to show active state
                          autoToggle.setText("ðŸ¤– Auto ON");
                          autoToggle.setBackgroundColor(0xFF28a745);
                          statusText.setText("Auto detection active - Background monitoring enabled");
                          
                          Log.d(TAG, "AutoDetectionService started automatically based on user preference");
                          
                      } else {
                          // User wants auto-detection OFF - show disabled state
                          autoToggle.setText("ðŸ”„ Auto OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Ready - Tap Auto to start background detection");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error restoring auto detection state: " + e.getMessage(), e);
                      // Default to OFF state on error
                      autoToggle.setText("ðŸ”„ Auto OFF");
                      autoToggle.setBackgroundColor(0xFF9CA3AF);
                      statusText.setText("Ready");
                  }
              }

              private void initializeGPS() {
                  try {
                      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                      if (locationManager != null && ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                          statusText.setText("GPS ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error initializing GPS: " + e.getMessage(), e);
                  }
                  
                  // Start speed monitoring
                  startSpeedMonitoring();
              }

              private void startSpeedMonitoring() {
                  speedRunnable = new Runnable() {
                      @Override
                      public void run() {
                          if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED && locationManager != null) {
                              try {
                                  android.location.Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                                  if (lastKnownLocation != null && speedText != null) {
                                      float speed = lastKnownLocation.getSpeed() * 2.237f; // Convert m/s to mph
                                      speedText.setText(String.format("Speed: %.1f mph", speed));
                                  }
                              } catch (Exception e) {
                                  Log.e(TAG, "Error getting speed: " + e.getMessage());
                              }
                          }
                          speedHandler.postDelayed(this, 2000);
                      }
                  };
                  speedHandler.post(speedRunnable);
              }

              private void toggleAutoDetection() {
                  if (!hasLocationPermissions()) {
                      requestLocationPermissions();
                      return;
                  }

                  // Toggle the state
                  autoDetectionEnabled = !autoDetectionEnabled;
                  
                  // Save user's preference permanently
                  tripStorage.setAutoDetectionEnabled(autoDetectionEnabled);

                  Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                  
                  if (autoDetectionEnabled) {
                      // User turned ON auto-detection
                      serviceIntent.setAction("START_AUTO_DETECTION");
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                          startForegroundService(serviceIntent);
                      } else {
                          startService(serviceIntent);
                      }
                      autoToggle.setText("ðŸ¤– Auto ON");
                      autoToggle.setBackgroundColor(0xFF28a745);
                      statusText.setText("Auto detection active - Background monitoring enabled");
                      
                      Log.d(TAG, "User enabled auto-detection - will remember this preference");
                      
                  } else {
                      // User turned OFF auto-detection
                      serviceIntent.setAction("STOP_AUTO_DETECTION");
                      startService(serviceIntent);
                      autoToggle.setText("ðŸ”„ Auto OFF");
                      autoToggle.setBackgroundColor(0xFF9CA3AF);
                      statusText.setText("Ready - Tap Auto to start background detection");
                      
                      Log.d(TAG, "User disabled auto-detection - will remember this preference");
                  }
              }

              private void toggleManualTrip() {
                  if (!hasLocationPermissions()) {
                      requestLocationPermissions();
                      return;
                  }

                  manualTripInProgress = !manualTripInProgress;

                  Intent serviceIntent = new Intent(this, ManualTripService.class);
                  
                  if (manualTripInProgress) {
                      serviceIntent.setAction("START_MANUAL_TRIP");
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                          startForegroundService(serviceIntent);
                      } else {
                          startService(serviceIntent);
                      }
                      manualToggle.setText("ðŸ”´ Stop Trip");
                      manualToggle.setBackgroundColor(0xFFDC2626);
                      statusText.setText("Manual trip recording...");
                  } else {
                      serviceIntent.setAction("STOP_MANUAL_TRIP");
                      startService(serviceIntent);
                      manualToggle.setText("ðŸ”„ Manual OFF");
                      manualToggle.setBackgroundColor(0xFF9CA3AF);
                      statusText.setText("Ready");
                  }
              }

              private void updateManualTripStatus(String status) {
                  if ("recording".equals(status)) {
                      manualToggle.setText("ðŸ”´ Stop Trip");
                      manualToggle.setBackgroundColor(0xFFDC2626);
                      statusText.setText("Manual trip recording...");
                      manualTripInProgress = true;
                  } else if ("stopped".equals(status)) {
                      manualToggle.setText("ðŸ”„ Manual OFF");
                      manualToggle.setBackgroundColor(0xFF9CA3AF);
                      statusText.setText("Trip saved");
                      manualTripInProgress = false;
                      
                      // Refresh data
                      loadDashboardData();
                      loadAllTrips();
                  }
              }

              private void loadDashboardData() {
                  try {
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      
                      // Filter this month's trips
                      Calendar cal = Calendar.getInstance();
                      int currentMonth = cal.get(Calendar.MONTH);
                      int currentYear = cal.get(Calendar.YEAR);
                      
                      List<Trip> monthlyTrips = new ArrayList<>();
                      double monthlyMiles = 0.0;
                      double monthlyDeduction = 0.0;
                      
                      for (Trip trip : allTrips) {
                          cal.setTimeInMillis(trip.getStartTime());
                          if (cal.get(Calendar.MONTH) == currentMonth && cal.get(Calendar.YEAR) == currentYear) {
                              monthlyTrips.add(trip);
                              monthlyMiles += trip.getDistance();
                              
                              // Calculate deduction based on category
                              double rate = 0.70; // Business default
                              if ("Medical".equals(trip.getCategory())) {
                                  rate = 0.21;
                              } else if ("Charity".equals(trip.getCategory())) {
                                  rate = 0.14;
                              }
                              monthlyDeduction += trip.getDistance() * rate;
                          }
                      }
                      
                      // Update UI
                      monthlyTripsText.setText(String.valueOf(monthlyTrips.size()));
                      monthlyMilesText.setText(String.format("%.1f", monthlyMiles));
                      monthlyDeductionText.setText(String.format("$%.2f", monthlyDeduction));
                      
                      // Load recent trips (last 5)
                      loadRecentTrips(allTrips);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading dashboard data: " + e.getMessage(), e);
                  }
              }

              private void loadRecentTrips(List<Trip> trips) {
                  try {
                      recentTripsLayout.removeAllViews();
                      
                      // Sort by start time descending and take last 5
                      List<Trip> recentTrips = trips.stream()
                          .sorted((t1, t2) -> Long.compare(t2.getStartTime(), t1.getStartTime()))
                          .limit(5)
                          .collect(Collectors.toList());
                      
                      if (recentTrips.isEmpty()) {
                          TextView emptyText = new TextView(this);
                          emptyText.setText("No trips yet. Start driving to track automatically!");
                          emptyText.setTextColor(0xFF6B7280);
                          emptyText.setGravity(Gravity.CENTER);
                          emptyText.setPadding(20, 40, 20, 40);
                          recentTripsLayout.addView(emptyText);
                          return;
                      }
                      
                      for (Trip trip : recentTrips) {
                          createTripCard(trip, recentTripsLayout, false);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading recent trips: " + e.getMessage(), e);
                  }
              }

              private void loadAllTrips() {
                  try {
                      allTripsLayout.removeAllViews();
                      
                      List<Trip> trips = tripStorage.getAllTrips();
                      
                      if (trips.isEmpty()) {
                          TextView emptyText = new TextView(this);
                          emptyText.setText("No trips recorded yet.\n\nTurn on Auto Detection or use Manual controls to start tracking your mileage!");
                          emptyText.setTextColor(0xFF6B7280);
                          emptyText.setGravity(Gravity.CENTER);
                          emptyText.setPadding(20, 60, 20, 60);
                          allTripsLayout.addView(emptyText);
                          return;
                      }
                      
                      // Sort by start time descending
                      trips.sort((t1, t2) -> Long.compare(t2.getStartTime(), t1.getStartTime()));
                      
                      for (Trip trip : trips) {
                          createTripCard(trip, allTripsLayout, true);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading all trips: " + e.getMessage(), e);
                  }
              }

              private void createTripCard(Trip trip, LinearLayout container, boolean showMergeControls) {
                  LinearLayout card = new LinearLayout(this);
                  card.setOrientation(LinearLayout.VERTICAL);
                  card.setBackgroundColor(0xFFFFFFFF);
                  card.setPadding(15, 15, 15, 15);
                  LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  cardParams.setMargins(0, 0, 0, 8);
                  card.setLayoutParams(cardParams);

                  // Header row with merge checkbox if in merge mode
                  LinearLayout headerRow = new LinearLayout(this);
                  headerRow.setOrientation(LinearLayout.HORIZONTAL);
                  headerRow.setGravity(Gravity.CENTER_VERTICAL);

                  // Merge checkbox (only in trips view and merge mode)
                  if (showMergeControls && mergeMode) {
                      CheckBox mergeCheckbox = new CheckBox(this);
                      mergeCheckbox.setChecked(selectedTripIds.contains(trip.getId()));
                      mergeCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                          if (isChecked) {
                              selectedTripIds.add(trip.getId());
                          } else {
                              selectedTripIds.remove(trip.getId());
                          }
                          updateMergeControls();
                      });
                      headerRow.addView(mergeCheckbox);
                  }

                  // Trip info
                  LinearLayout tripInfo = new LinearLayout(this);
                  tripInfo.setOrientation(LinearLayout.VERTICAL);
                  LinearLayout.LayoutParams tripInfoParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  tripInfo.setLayoutParams(tripInfoParams);

                  // Date and detection type
                  TextView dateText = new TextView(this);
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy â€¢ h:mm a", Locale.getDefault());
                  String detectionType = trip.isAutoDetected() ? "ðŸ¤– Auto" : "ðŸ‘¤ Manual";
                  dateText.setText(dateFormat.format(new Date(trip.getStartTime())) + " â€¢ " + detectionType);
                  dateText.setTextSize(12);
                  dateText.setTextColor(0xFF6B7280);
                  tripInfo.addView(dateText);

                  // Distance and category
                  TextView distanceText = new TextView(this);
                  distanceText.setText(String.format("%.2f miles â€¢ %s", trip.getDistance(), trip.getCategory()));
                  distanceText.setTextSize(16);
                  distanceText.setTypeface(null, Typeface.BOLD);
                  distanceText.setTextColor(0xFF374151);
                  distanceText.setPadding(0, 2, 0, 2);
                  tripInfo.addView(distanceText);

                  // Addresses
                  TextView addressText = new TextView(this);
                  String startAddr = trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown";
                  String endAddr = trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown";
                  addressText.setText("From: " + startAddr + "\nTo: " + endAddr);
                  addressText.setTextSize(12);
                  addressText.setTextColor(0xFF6B7280);
                  addressText.setPadding(0, 2, 0, 0);
                  tripInfo.addView(addressText);

                  headerRow.addView(tripInfo);

                  // Action buttons (only if not in merge mode)
                  if (!mergeMode) {
                      LinearLayout buttonLayout = new LinearLayout(this);
                      buttonLayout.setOrientation(LinearLayout.HORIZONTAL);

                      Button editButton = new Button(this);
                      editButton.setText("Edit");
                      editButton.setBackgroundColor(0xFF3B82F6);
                      editButton.setTextColor(0xFFFFFFFF);
                      editButton.setPadding(12, 8, 12, 8);
                      editButton.setTextSize(12);
                      editButton.setOnClickListener(v -> showEditTripDialog(trip));
                      buttonLayout.addView(editButton);

                      Button deleteButton = new Button(this);
                      deleteButton.setText("Delete");
                      deleteButton.setBackgroundColor(0xFFEF4444);
                      deleteButton.setTextColor(0xFFFFFFFF);
                      deleteButton.setPadding(12, 8, 12, 8);
                      deleteButton.setTextSize(12);
                      LinearLayout.LayoutParams deleteParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                      deleteParams.setMargins(8, 0, 0, 0);
                      deleteButton.setLayoutParams(deleteParams);
                      deleteButton.setOnClickListener(v -> showDeleteConfirmation(trip));
                      buttonLayout.addView(deleteButton);

                      headerRow.addView(buttonLayout);
                  }

                  card.addView(headerRow);
                  container.addView(card);
              }

              private void toggleMergeMode() {
                  mergeMode = !mergeMode;
                  selectedTripIds.clear();
                  
                  LinearLayout mergeRow = (LinearLayout) userControlsLayout.getTag();
                  if (mergeMode) {
                      mergeRow.setVisibility(View.VISIBLE);
                      mergeSelectAllCheckbox.setChecked(false);
                  } else {
                      mergeRow.setVisibility(View.GONE);
                  }
                  
                  loadAllTrips(); // Refresh to show/hide checkboxes
                  updateMergeControls();
              }

              private void selectAllTrips(boolean selectAll) {
                  selectedTripIds.clear();
                  if (selectAll) {
                      List<Trip> trips = tripStorage.getAllTrips();
                      for (Trip trip : trips) {
                          selectedTripIds.add(trip.getId());
                      }
                  }
                  loadAllTrips(); // Refresh to update checkboxes
                  updateMergeControls();
              }

              private void updateMergeControls() {
                  mergeExecuteButton.setEnabled(selectedTripIds.size() >= 2);
                  mergeExecuteButton.setText("Execute Merge (" + selectedTripIds.size() + ")");
              }

              private void executeMerge() {
                  if (selectedTripIds.size() < 2) {
                      Toast.makeText(this, "Please select at least 2 trips to merge", Toast.LENGTH_SHORT).show();
                      return;
                  }

                  new AlertDialog.Builder(this)
                      .setTitle("Confirm Merge")
                      .setMessage("Merge " + selectedTripIds.size() + " trips into one? This cannot be undone.")
                      .setPositiveButton("Merge", (dialog, which) -> {
                          performMerge();
                      })
                      .setNegativeButton("Cancel", null)
                      .show();
              }

              private void performMerge() {
                  try {
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      List<Trip> selectedTrips = new ArrayList<>();
                      
                      // Collect selected trips
                      for (Trip trip : allTrips) {
                          if (selectedTripIds.contains(trip.getId())) {
                              selectedTrips.add(trip);
                          }
                      }
                      
                      if (selectedTrips.size() < 2) return;
                      
                      // Sort by start time
                      selectedTrips.sort((t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));
                      
                      // Create merged trip
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(System.currentTimeMillis());
                      mergedTrip.setStartTime(selectedTrips.get(0).getStartTime());
                      mergedTrip.setEndTime(selectedTrips.get(selectedTrips.size() - 1).getEndTime());
                      
                      // Use first trip's start location and last trip's end location
                      mergedTrip.setStartLatitude(selectedTrips.get(0).getStartLatitude());
                      mergedTrip.setStartLongitude(selectedTrips.get(0).getStartLongitude());
                      mergedTrip.setEndLatitude(selectedTrips.get(selectedTrips.size() - 1).getEndLatitude());
                      mergedTrip.setEndLongitude(selectedTrips.get(selectedTrips.size() - 1).getEndLongitude());
                      
                      mergedTrip.setStartAddress(selectedTrips.get(0).getStartAddress());
                      mergedTrip.setEndAddress(selectedTrips.get(selectedTrips.size() - 1).getEndAddress());
                      
                      // Sum distances
                      double totalDistance = 0;
                      for (Trip trip : selectedTrips) {
                          totalDistance += trip.getDistance();
                      }
                      mergedTrip.setDistance(totalDistance);
                      
                      // Use most common category
                      mergedTrip.setCategory(selectedTrips.get(0).getCategory());
                      mergedTrip.setAutoDetected(selectedTrips.get(0).isAutoDetected());
                      
                      // Save merged trip
                      tripStorage.saveTrip(mergedTrip);
                      
                      // Delete original trips
                      for (Trip trip : selectedTrips) {
                          tripStorage.deleteTrip(trip.getId());
                      }
                      
                      // Reset merge mode
                      cancelMergeMode();
                      
                      Toast.makeText(this, "Trips merged successfully", Toast.LENGTH_SHORT).show();
                      
                      // Sync with cloud
                      CloudBackupService cloudService = new CloudBackupService(this);
                      cloudService.syncTripsWithCloud();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                      Toast.makeText(this, "Error merging trips", Toast.LENGTH_SHORT).show();
                  }
              }

              private void cancelMergeMode() {
                  mergeMode = false;
                  selectedTripIds.clear();
                  
                  LinearLayout mergeRow = (LinearLayout) userControlsLayout.getTag();
                  mergeRow.setVisibility(View.GONE);
                  
                  loadAllTrips(); // Refresh to hide checkboxes
              }

              private void showAddTripDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Add Manual Trip");

                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(20, 20, 20, 20);

                  // Date selection
                  TextView dateLabel = new TextView(this);
                  dateLabel.setText("Date:");
                  dateLabel.setTextSize(14);
                  dateLabel.setTypeface(null, Typeface.BOLD);
                  layout.addView(dateLabel);

                  Button dateButton = new Button(this);
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault());
                  dateButton.setText(dateFormat.format(new Date()));
                  dateButton.setBackgroundColor(0xFFE5E7EB);
                  dateButton.setTextColor(0xFF374151);
                  
                  final Calendar selectedDate = Calendar.getInstance();
                  dateButton.setOnClickListener(v -> {
                      DatePickerDialog datePickerDialog = new DatePickerDialog(
                          this,
                          (view, year, month, dayOfMonth) -> {
                              selectedDate.set(year, month, dayOfMonth);
                              dateButton.setText(dateFormat.format(selectedDate.getTime()));
                          },
                          selectedDate.get(Calendar.YEAR),
                          selectedDate.get(Calendar.MONTH),
                          selectedDate.get(Calendar.DAY_OF_MONTH)
                      );
                      datePickerDialog.show();
                  });
                  layout.addView(dateButton);

                  // Start address
                  TextView startLabel = new TextView(this);
                  startLabel.setText("Start Address:");
                  startLabel.setTextSize(14);
                  startLabel.setTypeface(null, Typeface.BOLD);
                  startLabel.setPadding(0, 10, 0, 0);
                  layout.addView(startLabel);

                  EditText startAddressInput = new EditText(this);
                  startAddressInput.setHint("Enter starting location");
                  layout.addView(startAddressInput);

                  // End address
                  TextView endLabel = new TextView(this);
                  endLabel.setText("End Address:");
                  endLabel.setTextSize(14);
                  endLabel.setTypeface(null, Typeface.BOLD);
                  endLabel.setPadding(0, 10, 0, 0);
                  layout.addView(endLabel);

                  EditText endAddressInput = new EditText(this);
                  endAddressInput.setHint("Enter destination");
                  layout.addView(endAddressInput);

                  // Distance
                  TextView distanceLabel = new TextView(this);
                  distanceLabel.setText("Distance (miles):");
                  distanceLabel.setTextSize(14);
                  distanceLabel.setTypeface(null, Typeface.BOLD);
                  distanceLabel.setPadding(0, 10, 0, 0);
                  layout.addView(distanceLabel);

                  EditText distanceInput = new EditText(this);
                  distanceInput.setHint("0.0");
                  distanceInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  layout.addView(distanceInput);

                  // Category
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("Category:");
                  categoryLabel.setTextSize(14);
                  categoryLabel.setTypeface(null, Typeface.BOLD);
                  categoryLabel.setPadding(0, 10, 0, 0);
                  layout.addView(categoryLabel);

                  Spinner categorySpinner = new Spinner(this);
                  String[] categories = {"Business", "Personal", "Medical", "Charity"};
                  ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categorySpinner.setAdapter(adapter);
                  layout.addView(categorySpinner);

                  builder.setView(layout);

                  builder.setPositiveButton("Add Trip", (dialog, which) -> {
                      try {
                          String startAddress = startAddressInput.getText().toString().trim();
                          String endAddress = endAddressInput.getText().toString().trim();
                          String distanceStr = distanceInput.getText().toString().trim();
                          String category = categorySpinner.getSelectedItem().toString();

                          if (startAddress.isEmpty() || endAddress.isEmpty() || distanceStr.isEmpty()) {
                              Toast.makeText(this, "Please fill all fields", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          double distance = Double.parseDouble(distanceStr);
                          if (distance <= 0) {
                              Toast.makeText(this, "Distance must be greater than 0", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          Trip newTrip = new Trip();
                          newTrip.setId(System.currentTimeMillis());
                          newTrip.setStartTime(selectedDate.getTimeInMillis());
                          newTrip.setEndTime(selectedDate.getTimeInMillis() + (30 * 60 * 1000)); // Add 30 minutes
                          newTrip.setStartAddress(startAddress);
                          newTrip.setEndAddress(endAddress);
                          newTrip.setDistance(distance);
                          newTrip.setCategory(category);
                          newTrip.setAutoDetected(false);

                          tripStorage.saveTrip(newTrip);
                          
                          // Sync with cloud
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.syncTripsWithCloud();

                          Toast.makeText(this, "Trip added successfully", Toast.LENGTH_SHORT).show();
                          loadDashboardData();
                          loadAllTrips();

                      } catch (NumberFormatException e) {
                          Toast.makeText(this, "Please enter a valid distance", Toast.LENGTH_SHORT).show();
                      } catch (Exception e) {
                          Log.e(TAG, "Error adding trip: " + e.getMessage(), e);
                          Toast.makeText(this, "Error adding trip", Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              private void showEditTripDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Edit Trip");

                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(20, 20, 20, 20);

                  // Start address
                  TextView startLabel = new TextView(this);
                  startLabel.setText("Start Address:");
                  startLabel.setTextSize(14);
                  startLabel.setTypeface(null, Typeface.BOLD);
                  layout.addView(startLabel);

                  EditText startAddressInput = new EditText(this);
                  startAddressInput.setText(trip.getStartAddress() != null ? trip.getStartAddress() : "");
                  layout.addView(startAddressInput);

                  // End address
                  TextView endLabel = new TextView(this);
                  endLabel.setText("End Address:");
                  endLabel.setTextSize(14);
                  endLabel.setTypeface(null, Typeface.BOLD);
                  endLabel.setPadding(0, 10, 0, 0);
                  layout.addView(endLabel);

                  EditText endAddressInput = new EditText(this);
                  endAddressInput.setText(trip.getEndAddress() != null ? trip.getEndAddress() : "");
                  layout.addView(endAddressInput);

                  // Distance
                  TextView distanceLabel = new TextView(this);
                  distanceLabel.setText("Distance (miles):");
                  distanceLabel.setTextSize(14);
                  distanceLabel.setTypeface(null, Typeface.BOLD);
                  distanceLabel.setPadding(0, 10, 0, 0);
                  layout.addView(distanceLabel);

                  EditText distanceInput = new EditText(this);
                  distanceInput.setText(String.format("%.2f", trip.getDistance()));
                  distanceInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  layout.addView(distanceInput);

                  // Category
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("Category:");
                  categoryLabel.setTextSize(14);
                  categoryLabel.setTypeface(null, Typeface.BOLD);
                  categoryLabel.setPadding(0, 10, 0, 0);
                  layout.addView(categoryLabel);

                  Spinner categorySpinner = new Spinner(this);
                  String[] categories = {"Business", "Personal", "Medical", "Charity"};
                  ArrayAdapter<String> adapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categorySpinner.setAdapter(adapter);
                  
                  // Set current category
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(trip.getCategory())) {
                          categorySpinner.setSelection(i);
                          break;
                      }
                  }
                  layout.addView(categorySpinner);

                  builder.setView(layout);

                  builder.setPositiveButton("Save", (dialog, which) -> {
                      try {
                          String startAddress = startAddressInput.getText().toString().trim();
                          String endAddress = endAddressInput.getText().toString().trim();
                          String distanceStr = distanceInput.getText().toString().trim();
                          String category = categorySpinner.getSelectedItem().toString();

                          if (startAddress.isEmpty() || endAddress.isEmpty() || distanceStr.isEmpty()) {
                              Toast.makeText(this, "Please fill all fields", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          double distance = Double.parseDouble(distanceStr);
                          if (distance <= 0) {
                              Toast.makeText(this, "Distance must be greater than 0", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          trip.setStartAddress(startAddress);
                          trip.setEndAddress(endAddress);
                          trip.setDistance(distance);
                          trip.setCategory(category);

                          tripStorage.saveTrip(trip);
                          
                          // Sync with cloud
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.syncTripsWithCloud();

                          Toast.makeText(this, "Trip updated successfully", Toast.LENGTH_SHORT).show();
                          loadDashboardData();
                          loadAllTrips();

                      } catch (NumberFormatException e) {
                          Toast.makeText(this, "Please enter a valid distance", Toast.LENGTH_SHORT).show();
                      } catch (Exception e) {
                          Log.e(TAG, "Error updating trip: " + e.getMessage(), e);
                          Toast.makeText(this, "Error updating trip", Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              private void showDeleteConfirmation(Trip trip) {
                  new AlertDialog.Builder(this)
                      .setTitle("Delete Trip")
                      .setMessage("Are you sure you want to delete this trip?")
                      .setPositiveButton("Delete", (dialog, which) -> {
                          tripStorage.deleteTrip(trip.getId());
                          
                          // Sync with cloud
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.syncTripsWithCloud();
                          
                          Toast.makeText(this, "Trip deleted", Toast.LENGTH_SHORT).show();
                          loadDashboardData();
                          loadAllTrips();
                      })
                      .setNegativeButton("Cancel", null)
                      .show();
              }

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  if (serviceReceiver != null) {
                      try {
                          unregisterReceiver(serviceReceiver);
                      } catch (Exception e) {
                          Log.e(TAG, "Error unregistering receiver: " + e.getMessage());
                      }
                  }
                  if (speedHandler != null && speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
              }

              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  if (requestCode == PERMISSION_REQUEST_CODE) {
                      boolean allGranted = true;
                      for (int result : grantResults) {
                          if (result != PackageManager.PERMISSION_GRANTED) {
                              allGranted = false;
                              break;
                          }
                      }
                      
                      if (allGranted) {
                          statusText.setText("GPS ready");
                      } else {
                          statusText.setText("Location permissions required");
                      }
                  }
              }
          }
        EOF

    - name: Create AutoDetectionService.java with Path Tracking
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/services/AutoDetectionService.java << 'EOF'
        package com.miletrackerpro.services;

          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.PendingIntent;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;

          import com.miletrackerpro.activities.MainActivity;
          import com.miletrackerpro.models.Trip;
          import com.miletrackerpro.storage.TripStorage;
          import com.miletrackerpro.utils.AddressLookup;
          import com.miletrackerpro.utils.CloudBackupService;

          import java.util.ArrayList;
          import java.util.List;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              private static final int NOTIFICATION_ID = 1001;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private boolean isTracking = false;
              private Trip currentTrip = null;
              private Location lastLocation = null;
              
              // Auto-detection variables
              private int stationaryCount = 0;
              private int movingCount = 0;
              private long lastMovementTime = 0;
              private List<Location> pathPoints = new ArrayList<>();
              private double cumulativeDistance = 0.0;

              private static final double SPEED_THRESHOLD_START = 8.0;
              private static final double SPEED_THRESHOLD_STOP = 3.0;
              private static final int START_CONFIRMATIONS = 3;
              private static final int STOP_CONFIRMATIONS = 4;
              private static final long MAX_STATIONARY_TIME = 120000;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();

                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          startAutoDetection();
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopAutoDetection();
                      }
                  }
                  return START_STICKY;
              }

              private void startAutoDetection() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      isTracking = true;
                      tripStorage.setAutoDetectionEnabled(true);

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          10000,
                          5,
                          this
                      );

                      startForeground(NOTIFICATION_ID, createNotification("Auto trip detection active", "Monitoring for movement..."));
                      Log.d(TAG, "Auto detection started with background GPS monitoring");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (!isTracking || location == null) return;

                  try {
                      float speed = location.getSpeed() * 2.237f;
                      long currentTime = System.currentTimeMillis();

                      if (currentTrip == null) {
                          if (speed >= SPEED_THRESHOLD_START) {
                              movingCount++;
                              stationaryCount = 0;

                              if (movingCount >= START_CONFIRMATIONS) {
                                  startNewTrip(location, currentTime);
                              }
                          } else {
                              movingCount = 0;
                          }
                      } else {
                          // We're in an active trip - add path point
                          addPathPoint(location);
                          
                          if (speed <= SPEED_THRESHOLD_STOP) {
                              stationaryCount++;
                              movingCount = 0;

                              long timeSinceLastMovement = currentTime - lastMovementTime;

                              if (stationaryCount >= STOP_CONFIRMATIONS || 
                                  timeSinceLastMovement > MAX_STATIONARY_TIME) {
                                  endCurrentTrip();
                              }
                          } else {
                              stationaryCount = 0;
                              lastMovementTime = currentTime;
                          }
                      }

                      lastLocation = location;
                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location update", e);
                  }
              }

              private void startNewTrip(Location location, long currentTime) {
                  try {
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(true);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());
                      
                      // Initialize path tracking
                      pathPoints.clear();
                      pathPoints.add(location);
                      cumulativeDistance = 0.0;

                      addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setStartAddress(address);
                              tripStorage.saveCurrentTrip(currentTrip);
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setStartAddress("Unknown Location");
                              tripStorage.saveCurrentTrip(currentTrip);
                          }
                      });

                      movingCount = 0;
                      lastMovementTime = currentTime;

                      updateNotification("Trip started", "Recording your journey...");
                      sendBroadcast("trip_started");
                      
                      Log.d(TAG, "New auto-detected trip started with path tracking");

                  } catch (Exception e) {
                      Log.e(TAG, "Error starting new trip", e);
                  }
              }

              private void endCurrentTrip() {
                  if (currentTrip == null || lastLocation == null) return;

                  try {
                      // Add final path point
                      addPathPoint(lastLocation);
                      
                      // Use cumulative distance from path tracking instead of straight-line
                      currentTrip.setDistance(cumulativeDistance);

                      if (cumulativeDistance >= 0.5) {
                          addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  saveCompletedTrip();
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setEndAddress("Unknown Location");
                                  saveCompletedTrip();
                              }
                          });
                      } else {
                          Log.d(TAG, "Trip too short (" + String.format("%.2f", cumulativeDistance) + " miles), discarding");
                          currentTrip = null;
                          tripStorage.clearCurrentTrip();
                          
                          updateNotification("Auto trip detection active", "Monitoring for movement...");
                          sendBroadcast("monitoring");
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip", e);
                  }
              }

              private void addPathPoint(Location location) {
                  try {
                      if (pathPoints.isEmpty()) {
                          pathPoints.add(location);
                          return;
                      }

                      Location lastPoint = pathPoints.get(pathPoints.size() - 1);
                      double segmentDistance = calculateDistance(
                          lastPoint.getLatitude(), lastPoint.getLongitude(),
                          location.getLatitude(), location.getLongitude()
                      );

                      // Only add point if we've moved a significant distance (about 50 feet)
                      if (segmentDistance >= 0.01) {
                          pathPoints.add(location);
                          cumulativeDistance += segmentDistance;
                          
                          Log.d(TAG, String.format("Path point added. Segment: %.3f mi, Total: %.3f mi", 
                              segmentDistance, cumulativeDistance));
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding path point", e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void stopAutoDetection() {
                  try {
                      isTracking = false;
                      tripStorage.setAutoDetectionEnabled(false);

                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      stopForeground(true);
                      stopSelf();
                      
                      Log.d(TAG, "Auto detection stopped");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto detection", e);
                  }
              }

              private void saveCompletedTrip() {
                  try {
                      currentTrip.setEndTime(System.currentTimeMillis());
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setCategory("Personal");

                      tripStorage.saveTrip(currentTrip);
                      tripStorage.clearCurrentTrip();
                      
                      // Cloud sync
                      cloudBackupService.syncTripsWithCloud();

                      Log.d(TAG, String.format("Auto-detected trip completed: %.2f miles via path tracking", 
                          currentTrip.getDistance()));

                      currentTrip = null;
                      pathPoints.clear();
                      cumulativeDistance = 0.0;
                      stationaryCount = 0;

                      updateNotification("Auto trip detection active", "Trip saved â€¢ Monitoring for movement...");
                      sendBroadcast("trip_saved");

                  } catch (Exception e) {
                      Log.e(TAG, "Error saving completed trip", e);
                  }
              }

              private void sendBroadcast(String status) {
                  Intent intent = new Intent("com.miletrackerpro.TRIP_UPDATE");
                  intent.putExtra("status", status);
                  sendBroadcast(intent);
              }

              private void updateNotification(String title, String content) {
                  try {
                      NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
                      if (notificationManager != null) {
                          notificationManager.notify(NOTIFICATION_ID, createNotification(title, content));
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating notification", e);
                  }
              }

              private Notification createNotification(String title, String content) {
                  Intent notificationIntent = new Intent(this, MainActivity.class);
                  PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 
                      PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setContentIntent(pendingIntent)
                      .setOngoing(true)
                      .setPriority(NotificationCompat.PRIORITY_LOW)
                      .build();
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Trip Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      channel.setDescription("Background location tracking for automatic trip detection");
                      channel.setShowBadge(false);

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      if (notificationManager != null) {
                          notificationManager.createNotificationChannel(channel);
                      }
                  }
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
          }
        EOF

    - name: Create ManualTripService.java with Path Tracking
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/services/ManualTripService.java << 'EOF'
        package com.miletrackerpro.services;

          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.PendingIntent;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.widget.Toast;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;

          import com.miletrackerpro.activities.MainActivity;
          import com.miletrackerpro.models.Trip;
          import com.miletrackerpro.storage.TripStorage;
          import com.miletrackerpro.utils.AddressLookup;
          import com.miletrackerpro.utils.CloudBackupService;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "MANUAL_TRIP_CHANNEL";
              private static final int NOTIFICATION_ID = 1002;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private Trip currentTrip = null;
              private Location startLocation = null;
              private Location lastLocation = null;

              @Override
              public void onCreate() {
                  super.onCreate();

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      startForeground(NOTIFICATION_ID, createNotification("Manual trip recording", "Tap to return to app"));
                      sendBroadcast("recording", 0, 0);
                      
                      Toast.makeText(this, "Manual trip started", Toast.LENGTH_SHORT).show();

                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip", e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          currentTrip.setEndTime(System.currentTimeMillis());
                          currentTrip.setEndLatitude(lastLocation.getLatitude());
                          currentTrip.setEndLongitude(lastLocation.getLongitude());

                          double distance = calculateDistance(
                              currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                              currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                          );
                          currentTrip.setDistance(distance);

                          addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  saveTrip();
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setEndAddress("Unknown Location");
                                  saveTrip();
                              }
                          });
                      }

                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      stopForeground(true);
                      stopSelf();

                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip != null) {
                          if (startLocation == null) {
                              startLocation = location;
                              currentTrip.setStartLatitude(location.getLatitude());
                              currentTrip.setStartLongitude(location.getLongitude());

                              addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                                  @Override
                                  public void onAddressFound(String address) {
                                      currentTrip.setStartAddress(address);
                                  }

                                  @Override
                                  public void onAddressError(String error) {
                                      currentTrip.setStartAddress("Unknown Location");
                                  }
                              });
                          }

                          lastLocation = location;
                          
                          // Calculate current distance for real-time updates
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  Intent intent = new Intent("com.miletrackerpro.MANUAL_TRIP_UPDATE");
                  intent.putExtra("status", status);
                  intent.putExtra("distance", distance);
                  intent.putExtra("duration", duration);
                  sendBroadcast(intent);
              }

              private void saveTrip() {
                  tripStorage.saveTrip(currentTrip);
                  cloudBackupService.syncTripsWithCloud();
                  sendBroadcast("stopped");
                  
                  Toast.makeText(this, "Manual trip saved", Toast.LENGTH_SHORT).show();
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      channel.setDescription("Manual trip recording notifications");

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  Intent notificationIntent = new Intent(this, MainActivity.class);
                  PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 
                      PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setContentIntent(pendingIntent)
                      .setOngoing(true)
                      .setPriority(NotificationCompat.PRIORITY_LOW)
                      .build();
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
          }
        EOF

    - name: Create Trip.java model
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/models/Trip.java << 'EOF'
        package com.miletrackerpro.models;

        public class Trip {
            private long id;
            private long startTime;
            private long endTime;
            private double startLatitude;
            private double startLongitude;
            private double endLatitude;
            private double endLongitude;
            private String startAddress;
            private String endAddress;
            private double distance;
            private String category;
            private boolean autoDetected;
            private String client;
            private String notes;

            public Trip() {
                this.category = "Personal";
                this.autoDetected = false;
            }

            // Getters and setters
            public long getId() { return id; }
            public void setId(long id) { this.id = id; }

            public long getStartTime() { return startTime; }
            public void setStartTime(long startTime) { this.startTime = startTime; }

            public long getEndTime() { return endTime; }
            public void setEndTime(long endTime) { this.endTime = endTime; }

            public double getStartLatitude() { return startLatitude; }
            public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

            public double getStartLongitude() { return startLongitude; }
            public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

            public double getEndLatitude() { return endLatitude; }
            public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

            public double getEndLongitude() { return endLongitude; }
            public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

            public String getStartAddress() { return startAddress; }
            public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

            public String getEndAddress() { return endAddress; }
            public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

            public double getDistance() { return distance; }
            public void setDistance(double distance) { this.distance = distance; }

            public String getCategory() { return category; }
            public void setCategory(String category) { this.category = category; }

            public boolean isAutoDetected() { return autoDetected; }
            public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

            public String getClient() { return client; }
            public void setClient(String client) { this.client = client; }

            public String getNotes() { return notes; }
            public void setNotes(String notes) { this.notes = notes; }
        }
        EOF

    - name: Create TripStorage.java
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/storage/TripStorage.java << 'EOF'
        package com.miletrackerpro.storage;

        import android.content.Context;
        import android.content.SharedPreferences;
        import android.util.Log;
        import com.miletrackerpro.models.Trip;
        import org.json.JSONArray;
        import org.json.JSONObject;

        import java.util.ArrayList;
        import java.util.List;

        public class TripStorage {
            private static final String TAG = "TripStorage";
            private static final String PREFS_NAME = "MileTrackerProPrefs";
            private static final String KEY_TRIPS = "trips";
            private static final String KEY_CURRENT_TRIP = "current_trip";
            private static final String KEY_AUTO_DETECTION = "auto_detection_enabled";
            
            private SharedPreferences prefs;

            public TripStorage(Context context) {
                prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
            }

            public void saveTrip(Trip trip) {
                try {
                    List<Trip> trips = getAllTrips();
                    
                    // Remove existing trip with same ID
                    trips.removeIf(t -> t.getId() == trip.getId());
                    
                    // Add the trip
                    trips.add(trip);
                    saveAllTrips(trips);
                    
                    Log.d(TAG, "Trip saved: " + trip.getId());
                } catch (Exception e) {
                    Log.e(TAG, "Error saving trip", e);
                }
            }

            public List<Trip> getAllTrips() {
                try {
                    String tripsJson = prefs.getString(KEY_TRIPS, "[]");
                    JSONArray jsonArray = new JSONArray(tripsJson);
                    List<Trip> trips = new ArrayList<>();

                    for (int i = 0; i < jsonArray.length(); i++) {
                        JSONObject obj = jsonArray.getJSONObject(i);
                        Trip trip = jsonToTrip(obj);
                        trips.add(trip);
                    }

                    return trips;
                } catch (Exception e) {
                    Log.e(TAG, "Error loading trips", e);
                    return new ArrayList<>();
                }
            }

            public void deleteTrip(long tripId) {
                try {
                    List<Trip> trips = getAllTrips();
                    trips.removeIf(trip -> trip.getId() == tripId);
                    saveAllTrips(trips);
                    Log.d(TAG, "Trip deleted: " + tripId);
                } catch (Exception e) {
                    Log.e(TAG, "Error deleting trip", e);
                }
            }

            public void saveCurrentTrip(Trip trip) {
                try {
                    JSONObject obj = tripToJson(trip);
                    prefs.edit().putString(KEY_CURRENT_TRIP, obj.toString()).apply();
                } catch (Exception e) {
                    Log.e(TAG, "Error saving current trip", e);
                }
            }

            public Trip getCurrentTrip() {
                try {
                    String tripJson = prefs.getString(KEY_CURRENT_TRIP, null);
                    if (tripJson != null) {
                        JSONObject obj = new JSONObject(tripJson);
                        return jsonToTrip(obj);
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error loading current trip", e);
                }
                return null;
            }

            public void clearCurrentTrip() {
                prefs.edit().remove(KEY_CURRENT_TRIP).apply();
            }

            public void setAutoDetectionEnabled(boolean enabled) {
                prefs.edit().putBoolean(KEY_AUTO_DETECTION, enabled).apply();
            }

            public boolean isAutoDetectionEnabled() {
                return prefs.getBoolean(KEY_AUTO_DETECTION, false);
            }

            private void saveAllTrips(List<Trip> trips) {
                try {
                    JSONArray jsonArray = new JSONArray();
                    for (Trip trip : trips) {
                        jsonArray.put(tripToJson(trip));
                    }
                    prefs.edit().putString(KEY_TRIPS, jsonArray.toString()).apply();
                } catch (Exception e) {
                    Log.e(TAG, "Error saving all trips", e);
                }
            }

            private JSONObject tripToJson(Trip trip) throws Exception {
                JSONObject obj = new JSONObject();
                obj.put("id", trip.getId());
                obj.put("startTime", trip.getStartTime());
                obj.put("endTime", trip.getEndTime());
                obj.put("startLatitude", trip.getStartLatitude());
                obj.put("startLongitude", trip.getStartLongitude());
                obj.put("endLatitude", trip.getEndLatitude());
                obj.put("endLongitude", trip.getEndLongitude());
                obj.put("startAddress", trip.getStartAddress());
                obj.put("endAddress", trip.getEndAddress());
                obj.put("distance", trip.getDistance());
                obj.put("category", trip.getCategory());
                obj.put("autoDetected", trip.isAutoDetected());
                obj.put("client", trip.getClient());
                obj.put("notes", trip.getNotes());
                return obj;
            }

            private Trip jsonToTrip(JSONObject obj) throws Exception {
                Trip trip = new Trip();
                trip.setId(obj.getLong("id"));
                trip.setStartTime(obj.getLong("startTime"));
                trip.setEndTime(obj.optLong("endTime", 0));
                trip.setStartLatitude(obj.optDouble("startLatitude", 0));
                trip.setStartLongitude(obj.optDouble("startLongitude", 0));
                trip.setEndLatitude(obj.optDouble("endLatitude", 0));
                trip.setEndLongitude(obj.optDouble("endLongitude", 0));
                trip.setStartAddress(obj.optString("startAddress", ""));
                trip.setEndAddress(obj.optString("endAddress", ""));
                trip.setDistance(obj.optDouble("distance", 0));
                trip.setCategory(obj.optString("category", "Personal"));
                trip.setAutoDetected(obj.optBoolean("autoDetected", false));
                trip.setClient(obj.optString("client", ""));
                trip.setNotes(obj.optString("notes", ""));
                return trip;
            }
        }
        EOF

    - name: Create AddressLookup.java
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/utils/AddressLookup.java << 'EOF'
        package com.miletrackerpro.utils;

        import android.content.Context;
        import android.location.Address;
        import android.location.Geocoder;
        import android.os.AsyncTask;
        import android.util.Log;

        import java.util.List;
        import java.util.Locale;

        public class AddressLookup {
            private static final String TAG = "AddressLookup";
            private Geocoder geocoder;

            public interface AddressCallback {
                void onAddressFound(String address);
                void onAddressError(String error);
            }

            public AddressLookup(Context context) {
                if (Geocoder.isPresent()) {
                    geocoder = new Geocoder(context, Locale.getDefault());
                }
            }

            public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                if (geocoder == null) {
                    callback.onAddressError("Geocoder not available");
                    return;
                }

                new AsyncTask<Void, Void, String>() {
                    @Override
                    protected String doInBackground(Void... voids) {
                        try {
                            List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                            if (addresses != null && !addresses.isEmpty()) {
                                Address address = addresses.get(0);
                                StringBuilder sb = new StringBuilder();
                                
                                if (address.getSubThoroughfare() != null) {
                                    sb.append(address.getSubThoroughfare()).append(" ");
                                }
                                if (address.getThoroughfare() != null) {
                                    sb.append(address.getThoroughfare()).append(", ");
                                }
                                if (address.getLocality() != null) {
                                    sb.append(address.getLocality()).append(", ");
                                }
                                if (address.getAdminArea() != null) {
                                    sb.append(address.getAdminArea());
                                }
                                
                                return sb.toString().trim();
                            }
                        } catch (Exception e) {
                            Log.e(TAG, "Error getting address", e);
                        }
                        return null;
                    }

                    @Override
                    protected void onPostExecute(String result) {
                        if (result != null && !result.isEmpty()) {
                            callback.onAddressFound(result);
                        } else {
                            callback.onAddressError("Address not found");
                        }
                    }
                }.execute();
            }
        }
        EOF

    - name: Create CloudBackupService.java
      run: |
        cat > android-app/src/main/java/com/miletrackerpro/utils/CloudBackupService.java << 'EOF'
        package com.miletrackerpro.utils;

        import android.content.Context;
        import android.os.AsyncTask;
        import android.util.Log;
        import com.miletrackerpro.models.Trip;
        import com.miletrackerpro.storage.TripStorage;
        import org.json.JSONArray;
        import org.json.JSONObject;

        import java.io.BufferedReader;
        import java.io.InputStreamReader;
        import java.io.OutputStream;
        import java.net.HttpURLConnection;
        import java.net.URL;
        import java.util.List;

        public class CloudBackupService {
            private static final String TAG = "CloudBackupService";
            private static final String API_BASE_URL = "https://workspace-codenurse.replit.app/api";
            private Context context;
            private TripStorage tripStorage;

            public CloudBackupService(Context context) {
                this.context = context;
                this.tripStorage = new TripStorage(context);
            }

            public void syncTripsWithCloud() {
                new SyncTask().execute();
            }

            private class SyncTask extends AsyncTask<Void, Void, Boolean> {
                @Override
                protected Boolean doInBackground(Void... voids) {
                    try {
                        List<Trip> localTrips = tripStorage.getAllTrips();
                        
                        for (Trip trip : localTrips) {
                            syncTripToCloud(trip);
                        }
                        
                        return true;
                    } catch (Exception e) {
                        Log.e(TAG, "Error syncing trips to cloud", e);
                        return false;
                    }
                }

                @Override
                protected void onPostExecute(Boolean success) {
                    if (success) {
                        Log.d(TAG, "Cloud sync completed successfully");
                    } else {
                        Log.e(TAG, "Cloud sync failed");
                    }
                }
            }

            private void syncTripToCloud(Trip trip) {
                try {
                    URL url = new URL(API_BASE_URL + "/trips");
                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("POST");
                    connection.setRequestProperty("Content-Type", "application/json");
                    connection.setDoOutput(true);

                    JSONObject tripJson = new JSONObject();
                    tripJson.put("id", trip.getId());
                    tripJson.put("startTime", trip.getStartTime());
                    tripJson.put("endTime", trip.getEndTime());
                    tripJson.put("startLatitude", trip.getStartLatitude());
                    tripJson.put("startLongitude", trip.getStartLongitude());
                    tripJson.put("endLatitude", trip.getEndLatitude());
                    tripJson.put("endLongitude", trip.getEndLongitude());
                    tripJson.put("startAddress", trip.getStartAddress());
                    tripJson.put("endAddress", trip.getEndAddress());
                    tripJson.put("distance", trip.getDistance());
                    tripJson.put("category", trip.getCategory());
                    tripJson.put("autoDetected", trip.isAutoDetected());
                    tripJson.put("deviceId", "android-device");

                    OutputStream os = connection.getOutputStream();
                    os.write(tripJson.toString().getBytes("utf-8"));
                    os.close();

                    int responseCode = connection.getResponseCode();
                    if (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_CREATED) {
                        Log.d(TAG, "Trip synced to cloud: " + trip.getId());
                    } else {
                        Log.w(TAG, "Failed to sync trip: " + responseCode);
                    }

                    connection.disconnect();

                } catch (Exception e) {
                    Log.e(TAG, "Error syncing trip to cloud: " + trip.getId(), e);
                }
            }
        }
        EOF

    - name: Create build.gradle files
      run: |
        # Root build.gradle
        cat > android-app/build.gradle << 'EOF'
        buildscript {
            ext.kotlin_version = '1.9.24'
            repositories {
                google()
                mavenCentral()
            }
            dependencies {
                classpath 'com.android.tools.build:gradle:8.1.0'
                classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
            }
        }

        allprojects {
            repositories {
                google()
                mavenCentral()
            }
        }
        EOF

        # App build.gradle
        cat > android-app/app/build.gradle << 'EOF'
        plugins {
            id 'com.android.application'
        }

        android {
            namespace 'com.miletrackerpro.app'
            compileSdk 35

            defaultConfig {
                applicationId "com.miletrackerpro.app"
                minSdk 24
                targetSdk 35
                versionCode 1
                versionName "4.9.68"
            }

            buildTypes {
                release {
                    minifyEnabled false
                    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                }
            }

            compileOptions {
                sourceCompatibility JavaVersion.VERSION_1_8
                targetCompatibility JavaVersion.VERSION_1_8
            }
        }

        dependencies {
            implementation 'androidx.appcompat:appcompat:1.6.1'
            implementation 'androidx.core:core:1.12.0'
            implementation 'com.google.android.material:material:1.11.0'
        }
        EOF

        # Create gradle wrapper
        mkdir -p android-app/gradle/wrapper
        cat > android-app/gradle/wrapper/gradle-wrapper.properties << 'EOF'
        distributionBase=GRADLE_USER_HOME
        distributionPath=wrapper/dists
        distributionUrl=https://services.gradle.org/distributions/gradle-8.0-bin.zip
        zipStoreBase=GRADLE_USER_HOME
        zipStorePath=wrapper/dists
        EOF

        # Create settings.gradle
        cat > android-app/settings.gradle << 'EOF'
        rootProject.name = "MileTrackerPro"
        include ':app'
        EOF

        # Create gradle.properties
        cat > android-app/gradle.properties << 'EOF'
        org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
        android.useAndroidX=true
        android.enableJetifier=true
        EOF

        # Create proguard file
        mkdir -p android-app/app
        touch android-app/app/proguard-rules.pro

    - name: Create directory structure for gradle
      run: |
        mkdir -p android-app/app/src/main/java/com/miletrackerpro/app
        
        # Move MainActivity to correct package
        mv android-app/src/main/java/com/miletrackerpro/activities/MainActivity.java android-app/app/src/main/java/com/miletrackerpro/app/MainActivity.java
        
        # Move other classes to app module
        mkdir -p android-app/app/src/main/java/com/miletrackerpro/services
        mkdir -p android-app/app/src/main/java/com/miletrackerpro/models
        mkdir -p android-app/app/src/main/java/com/miletrackerpro/storage
        mkdir -p android-app/app/src/main/java/com/miletrackerpro/utils
        
        mv android-app/src/main/java/com/miletrackerpro/services/* android-app/app/src/main/java/com/miletrackerpro/services/
        mv android-app/src/main/java/com/miletrackerpro/models/* android-app/app/src/main/java/com/miletrackerpro/models/
        mv android-app/src/main/java/com/miletrackerpro/storage/* android-app/app/src/main/java/com/miletrackerpro/storage/
        mv android-app/src/main/java/com/miletrackerpro/utils/* android-app/app/src/main/java/com/miletrackerpro/utils/
        
        # Move manifest
        mv android-app/src/main/AndroidManifest.xml android-app/app/src/main/AndroidManifest.xml
        
        # Update MainActivity package
        sed -i 's/package com.miletrackerpro.activities;/package com.miletrackerpro.app;/' android-app/app/src/main/java/com/miletrackerpro/app/MainActivity.java

    - name: Build APK with Gradle
      run: |
        cd android-app
        chmod +x gradlew || ./gradlew wrapper || echo "Gradlew wrapper setup"
        ./gradlew clean assembleRelease --stacktrace --info

    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: app-release
        path: android-app/app/build/outputs/apk/release/app-release-unsigned.apk
