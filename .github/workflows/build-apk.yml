name: HOME ADDRESS CONFIGURATION - v4.9.150

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create consistent signing keystore
        run: |
          cd android/app
          # Remove existing keystore if it exists
          rm -f miletracker.keystore
          # Create new keystore with consistent credentials and date
          keytool -genkey -v -keystore miletracker.keystore -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker Pro LLC, L=Charlotte, S=NC, C=US"

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 49150
                  versionName "4.9.150"
              }

              signingConfigs {
                  release {
                      storeFile file("miletracker.keystore")
                      storePassword "miletracker123"
                      keyAlias "miletracker"
                      keyPassword "miletracker123"
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.release
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              implementation 'org.json:json:20231013'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
              implementation 'com.itextpdf:itext7-core:7.2.5'
              implementation 'androidx.work:work-runtime:2.8.1'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />
              
              <!-- Legacy Bluetooth permissions for Android 11 and below -->
              <uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
              
              <!-- New Android 12+ Bluetooth permissions -->
              <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
              <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
              <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES" android:usesPermissionFlags="neverForLocation" />
              
              <!-- Bluetooth hardware feature requirements -->
              <uses-feature android:name="android.hardware.bluetooth" android:required="false"/>
              <uses-feature android:name="android.hardware.bluetooth_le" android:required="false"/>

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name=".MainActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>



                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="${applicationId}.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

                  <!-- Bluetooth Discovery BroadcastReceiver -->
                  <receiver android:name=".BluetoothDiscoveryReceiver" android:exported="false">
                      <intent-filter>
                          <action android:name="android.bluetooth.device.action.FOUND" />
                          <action android:name="android.bluetooth.adapter.action.DISCOVERY_STARTED" />
                          <action android:name="android.bluetooth.adapter.action.DISCOVERY_FINISHED" />
                      </intent-filter>
                  </receiver>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">mileage-tracker-codenurse.replit.app</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <files-path name="files" path="." />
              <cache-path name="cache" path="." />
              <external-files-path name="external_files" path="." />
              <external-cache-path name="external_cache" path="." />
          </paths>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#667eea</color>
              <color name="primary_dark">#5a6fd8</color>
              <color name="accent">#667eea</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
              <color name="success">#28a745</color>
              <color name="danger">#dc3545</color>
              <color name="warning">#ffc107</color>
              <color name="tab_active">#667eea</color>
              <color name="tab_inactive">#9CA3AF</color>
              <color name="background">#f5f5f5</color>
              <color name="card_background">#ffffff</color>
              <color name="text_primary">#495057</color>
              <color name="text_secondary">#6C757D</color>
          </resources>
          EOF

      - name: Create BluetoothVehicleService as Android Background Service
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BluetoothVehicleService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.PendingIntent;
          import android.app.Service;
          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothClass;
          import android.bluetooth.BluetoothDevice;
          import android.bluetooth.BluetoothManager;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.os.Handler;
          import android.os.IBinder;
          import android.os.Looper;
          import android.util.Log;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.MainActivity;
          import org.json.JSONException;
          import org.json.JSONObject;
          import java.util.HashMap;
          import java.util.Iterator;
          import java.util.Map;
          import java.util.Set;

          public class BluetoothVehicleService extends Service {
              private static final String TAG = "BluetoothVehicleService";
              private static final String PREFS_NAME = "BluetoothVehiclePrefs";
              private static final String VEHICLE_REGISTRY_KEY = "vehicle_registry";
              private static final String CHANNEL_ID = "BluetoothVehicleService";
              private static final int NOTIFICATION_ID = 1001;
              
              private BluetoothAdapter bluetoothAdapter;
              private SharedPreferences prefs;
              private Handler handler;
              private Map<String, VehicleInfo> vehicleRegistry = new HashMap<>();
              private VehicleInfo currentVehicle;
              private boolean isScanning = false;
              private boolean autoDetectionEnabled = false;
              private BroadcastReceiver bluetoothReceiver;
              
              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
              
              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "BluetoothVehicleService onCreate");
                  
                  // Debug: Service created
                  Intent createIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  createIntent.putExtra("message", "üîµ BluetoothVehicleService created");
                  sendBroadcast(createIntent);
                  
                  handler = new Handler(Looper.getMainLooper());
                  prefs = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);
                  loadVehicleRegistry();
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
                  if (bluetoothManager != null) {
                      bluetoothAdapter = bluetoothManager.getAdapter();
                  }
                  
                  createNotificationChannel();
                  registerBluetoothReceiver();
              }
              
              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  Log.d(TAG, "BluetoothVehicleService onStartCommand");
                  
                  // Debug: Service command received
                  Intent cmdIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  cmdIntent.putExtra("message", "üîµ BluetoothVehicleService onStartCommand received");
                  sendBroadcast(cmdIntent);
                  
                  if (intent != null) {
                      String action = intent.getAction();
                      
                      // Debug: Action received
                      Intent actionIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                      actionIntent.putExtra("message", "üîµ Action received: " + action);
                      sendBroadcast(actionIntent);
                      
                      if ("START_BLUETOOTH_MONITORING".equals(action)) {
                          startForeground(NOTIFICATION_ID, createNotification("Monitoring for vehicle connections..."));
                          startBluetoothMonitoring();
                      } else if ("STOP_BLUETOOTH_MONITORING".equals(action)) {
                          stopBluetoothMonitoring();
                          stopForeground(true);
                          stopSelf();
                      } else if ("REGISTER_VEHICLE".equals(action)) {
                          String deviceName = intent.getStringExtra("deviceName");
                          String macAddress = intent.getStringExtra("macAddress");
                          String vehicleType = intent.getStringExtra("vehicleType");
                          registerVehicle(deviceName, macAddress, vehicleType);
                      }
                  }
                  
                  return START_STICKY;
              }
              
              @Override
              public void onDestroy() {
                  Log.d(TAG, "BluetoothVehicleService onDestroy");
                  stopBluetoothMonitoring();
                  unregisterBluetoothReceiver();
                  super.onDestroy();
              }
              
              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel serviceChannel = new NotificationChannel(
                          CHANNEL_ID, "Bluetooth Vehicle Service", NotificationManager.IMPORTANCE_LOW);
                      serviceChannel.setDescription("Monitors Bluetooth connections for automatic trip detection");
                      
                      NotificationManager manager = getSystemService(NotificationManager.class);
                      if (manager != null) {
                          manager.createNotificationChannel(serviceChannel);
                      }
                  }
              }
              
              private Notification createNotification(String contentText) {
                  Intent notificationIntent = new Intent(this, MainActivity.class);
                  PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent,
                      PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
                  
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle("MileTracker Pro - Vehicle Monitor")
                      .setContentText(contentText)
                      .setSmallIcon(android.R.drawable.ic_dialog_info)
                      .setContentIntent(pendingIntent)
                      .setOngoing(true)
                      .build();
              }
              
              private void startBluetoothMonitoring() {
                  Log.d(TAG, "Starting Bluetooth monitoring");
                  
                  // Send debug toast to MainActivity
                  Intent debugIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  debugIntent.putExtra("message", "üîµ Bluetooth Discovery: Starting...");
                  sendBroadcast(debugIntent);
                  
                  if (bluetoothAdapter == null) {
                      Log.w(TAG, "Bluetooth adapter is null");
                      Intent errorIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                      errorIntent.putExtra("message", "üî¥ Bluetooth adapter is null");
                      sendBroadcast(errorIntent);
                      return;
                  }
                  
                  if (!bluetoothAdapter.isEnabled()) {
                      Log.w(TAG, "Bluetooth is disabled");
                      Intent errorIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                      errorIntent.putExtra("message", "üî¥ Bluetooth is disabled");
                      sendBroadcast(errorIntent);
                      return;
                  }
                  
                  autoDetectionEnabled = true;
                  
                  // Confirm successful start
                  Log.d(TAG, "Bluetooth monitoring started successfully");
                  Intent successIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  successIntent.putExtra("message", "üü¢ Bluetooth Discovery: Started successfully");
                  sendBroadcast(successIntent);
                  
                  startPeriodicScanning();
              }
              
              private void stopBluetoothMonitoring() {
                  Log.d(TAG, "Stopping Bluetooth monitoring");
                  autoDetectionEnabled = false;
                  isScanning = false;
                  
                  if (handler != null) {
                      handler.removeCallbacksAndMessages(null);
                  }
              }
              
              private void startPeriodicScanning() {
                  if (!autoDetectionEnabled || isScanning) return;
                  
                  isScanning = true;
                  Log.d(TAG, "Starting periodic Bluetooth scanning");
                  
                  // Debug: Confirm scanning started
                  Intent scanIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  scanIntent.putExtra("message", "üîç Bluetooth scanning started");
                  sendBroadcast(scanIntent);
                  
                  handler.postDelayed(() -> {
                      if (autoDetectionEnabled) {
                          Intent checkIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                          checkIntent.putExtra("message", "üîç Checking Bluetooth connections...");
                          sendBroadcast(checkIntent);
                          
                          checkBluetoothConnections();
                          isScanning = false;
                          startPeriodicScanning();
                      }
                  }, 30 * 1000); // 30 seconds for more frequent checking
              }
              
              private void registerBluetoothReceiver() {
                  bluetoothReceiver = new BroadcastReceiver() {
                      @Override
                      public void onReceive(Context context, Intent intent) {
                          String action = intent.getAction();
                          Log.d(TAG, "Bluetooth broadcast received: " + action);
                          
                          if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
                              BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                              if (device != null) {
                                  onDeviceConnected(device);
                              }
                          } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                              BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                              if (device != null) {
                                  onDeviceDisconnected(device);
                              }
                          }
                      }
                  };
                  
                  IntentFilter filter = new IntentFilter();
                  filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
                  filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
                  registerReceiver(bluetoothReceiver, filter);
              }
              
              private void unregisterBluetoothReceiver() {
                  if (bluetoothReceiver != null) {
                      try {
                          unregisterReceiver(bluetoothReceiver);
                      } catch (IllegalArgumentException e) {
                          Log.d(TAG, "Bluetooth receiver already unregistered");
                      }
                  }
              }
              
              private void checkBluetoothConnections() {
                  Log.d(TAG, "Checking Bluetooth connections");
                  
                  if (bluetoothAdapter == null || !bluetoothAdapter.isEnabled()) {
                      Log.d(TAG, "Bluetooth not available or disabled");
                      return;
                  }
                  
                  Set<BluetoothDevice> bondedDevices = bluetoothAdapter.getBondedDevices();
                  Log.d(TAG, "Found " + bondedDevices.size() + " bonded devices");
                  
                  for (BluetoothDevice device : bondedDevices) {
                      String deviceName = device.getName();
                      String macAddress = device.getAddress();
                      
                      Log.d(TAG, "Checking device: " + deviceName + " (" + macAddress + ")");
                      
                      // UConnect debug logging
                      if (deviceName != null && deviceName.toLowerCase().contains("uconnect")) {
                          Log.d(TAG, "üöó UCONNECT DEVICE FOUND: " + deviceName + " (" + macAddress + ")");
                      }
                      
                      if (vehicleRegistry.containsKey(device.getAddress())) {
                          // Handle registered vehicles
                          try {
                              boolean isConnected = (boolean) device.getClass().getMethod("isConnected").invoke(device);
                              Log.d(TAG, "Registered vehicle " + deviceName + " connected: " + isConnected);
                              if (isConnected && currentVehicle == null) {
                                  onDeviceConnected(device);
                              }
                          } catch (Exception e) {
                              Log.d(TAG, "Could not check connection status for registered vehicle");
                          }
                      } else {
                          // Handle potential new vehicles
                          if (deviceName != null && isLikelyVehicleDevice(device)) {
                              Log.d(TAG, "Found potential new vehicle: " + deviceName);
                              try {
                                  boolean isConnected = (boolean) device.getClass().getMethod("isConnected").invoke(device);
                                  Log.d(TAG, "New vehicle " + deviceName + " connected: " + isConnected);
                                  
                                  if (isConnected) {
                                      Log.d(TAG, "New vehicle device connected and bonded: " + deviceName);
                                      
                                      // Send broadcast intent to trigger registration dialog
                                      Log.d(TAG, "Sending NEW_VEHICLE_DETECTED broadcast for: " + deviceName);
                                      Intent broadcastIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                                      broadcastIntent.putExtra("deviceName", deviceName);
                                      broadcastIntent.putExtra("macAddress", macAddress);
                                      sendBroadcast(broadcastIntent);
                                      Log.d(TAG, "NEW_VEHICLE_DETECTED broadcast sent for: " + deviceName);
                                  }
                              } catch (Exception e) {
                                  Log.d(TAG, "Could not check connection status for new vehicle, treating as connected");
                                  // If we can't check connection status, assume it's connected since it's bonded
                                  Log.d(TAG, "New vehicle device assumed connected: " + deviceName);
                                  
                                  Log.d(TAG, "Sending NEW_VEHICLE_DETECTED broadcast for: " + deviceName);
                                  Intent broadcastIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                                  broadcastIntent.putExtra("deviceName", deviceName);
                                  broadcastIntent.putExtra("macAddress", macAddress);
                                  sendBroadcast(broadcastIntent);
                                  Log.d(TAG, "NEW_VEHICLE_DETECTED broadcast sent for: " + deviceName);
                              }
                          } else {
                              Log.d(TAG, "Non-vehicle device ignored: " + deviceName);
                          }
                      }
                  }
              }
              
              private void onDeviceConnected(BluetoothDevice device) {
                  Log.d(TAG, "Device connected: " + device.getName());
                  
                  if (vehicleRegistry.containsKey(device.getAddress())) {
                      VehicleInfo vehicle = vehicleRegistry.get(device.getAddress());
                      currentVehicle = vehicle;
                      
                      updateNotification("Connected to " + vehicle.deviceName);
                      
                      Intent intent = new Intent("com.miletrackerpro.VEHICLE_CONNECTED");
                      intent.putExtra("deviceName", vehicle.deviceName);
                      intent.putExtra("vehicleType", vehicle.vehicleType);
                      sendBroadcast(intent);
                      
                      startAutoDetectionService(vehicle);
                  } else {
                      // Check for new vehicle devices when bonded/paired
                      String deviceName = device.getName();
                      String macAddress = device.getAddress();
                      
                      if (deviceName != null && isLikelyVehicleDevice(device)) {
                          // For new vehicles, check if device is bonded/paired
                          if (device.getBondState() == BluetoothDevice.BOND_BONDED) {
                              Log.d(TAG, "New vehicle device detected: " + deviceName);
                              
                              // Send broadcast intent to trigger registration dialog
                              Log.d(TAG, "Sending NEW_VEHICLE_DETECTED broadcast for: " + deviceName);
                              Intent broadcastIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                              broadcastIntent.putExtra("deviceName", deviceName);
                              broadcastIntent.putExtra("macAddress", macAddress);
                              sendBroadcast(broadcastIntent);
                              Log.d(TAG, "NEW_VEHICLE_DETECTED broadcast sent for: " + deviceName);
                          } else {
                              Log.d(TAG, "New vehicle device not bonded, skipping registration: " + deviceName);
                          }
                      } else {
                          Log.d(TAG, "Non-vehicle device connected: " + deviceName);
                      }
                  }
              }
              
              private void onDeviceDisconnected(BluetoothDevice device) {
                  Log.d(TAG, "Device disconnected: " + device.getName());
                  
                  if (currentVehicle != null && device.getAddress().equals(currentVehicle.macAddress)) {
                      updateNotification("Monitoring for vehicle connections...");
                      
                      Intent intent = new Intent("com.miletrackerpro.VEHICLE_DISCONNECTED");
                      intent.putExtra("deviceName", currentVehicle.deviceName);
                      sendBroadcast(intent);
                      
                      stopAutoDetectionService(currentVehicle);
                      currentVehicle = null;
                  }
              }
              
              private void startAutoDetectionService(VehicleInfo vehicle) {
                  // Send broadcast to MainActivity to start auto-detection
                  Intent intent = new Intent("com.miletrackerpro.START_AUTO_DETECTION");
                  intent.putExtra("trigger_source", "bluetooth_vehicle");
                  intent.putExtra("vehicle_name", vehicle.deviceName);
                  intent.putExtra("bluetooth_triggered", true);
                  sendBroadcast(intent);
              }
              
              private void stopAutoDetectionService(VehicleInfo vehicle) {
                  // Send broadcast to MainActivity to stop auto-detection
                  Intent intent = new Intent("com.miletrackerpro.STOP_AUTO_DETECTION");
                  intent.putExtra("trigger_source", "bluetooth_vehicle");
                  sendBroadcast(intent);
              }
              
              private void updateNotification(String text) {
                  NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
                  if (manager != null) {
                      manager.notify(NOTIFICATION_ID, createNotification(text));
                  }
              }
              
              private void registerVehicle(String deviceName, String macAddress, String vehicleType) {
                  Log.d(TAG, "Registering vehicle: " + deviceName + " (" + vehicleType + ")");
                  
                  VehicleInfo vehicle = new VehicleInfo();
                  vehicle.macAddress = macAddress;
                  vehicle.deviceName = deviceName;
                  vehicle.vehicleType = vehicleType;
                  vehicle.registrationTime = System.currentTimeMillis();
                  
                  vehicleRegistry.put(macAddress, vehicle);
                  saveVehicleRegistry();
                  
                  Intent intent = new Intent("com.miletrackerpro.VEHICLE_REGISTERED");
                  intent.putExtra("deviceName", deviceName);
                  intent.putExtra("macAddress", macAddress);
                  intent.putExtra("vehicleType", vehicleType);
                  sendBroadcast(intent);
                  
                  Log.d(TAG, "Vehicle registered successfully: " + deviceName);
              }
              
              private void loadVehicleRegistry() {
                  try {
                      String registryJson = prefs.getString(VEHICLE_REGISTRY_KEY, "{}");
                      JSONObject registry = new JSONObject(registryJson);
                      
                      Iterator<String> keys = registry.keys();
                      while (keys.hasNext()) {
                          String macAddress = keys.next();
                          JSONObject vehicleJson = registry.getJSONObject(macAddress);
                          VehicleInfo vehicle = new VehicleInfo();
                          vehicle.macAddress = macAddress;
                          vehicle.deviceName = vehicleJson.optString("deviceName", "Unknown");
                          vehicle.vehicleType = vehicleJson.optString("vehicleType", "Personal");
                          vehicle.registrationTime = vehicleJson.optLong("registrationTime", System.currentTimeMillis());
                          
                          vehicleRegistry.put(macAddress, vehicle);
                      }
                      
                      Log.d(TAG, "Vehicle registry loaded: " + vehicleRegistry.size() + " vehicles");
                  } catch (JSONException e) {
                      Log.e(TAG, "Error loading vehicle registry", e);
                  }
              }
              
              private void saveVehicleRegistry() {
                  try {
                      JSONObject registry = new JSONObject();
                      
                      for (Map.Entry<String, VehicleInfo> entry : vehicleRegistry.entrySet()) {
                          VehicleInfo vehicle = entry.getValue();
                          JSONObject vehicleJson = new JSONObject();
                          vehicleJson.put("deviceName", vehicle.deviceName);
                          vehicleJson.put("vehicleType", vehicle.vehicleType);
                          vehicleJson.put("registrationTime", vehicle.registrationTime);
                          
                          registry.put(entry.getKey(), vehicleJson);
                      }
                      
                      prefs.edit().putString(VEHICLE_REGISTRY_KEY, registry.toString()).apply();
                      Log.d(TAG, "Vehicle registry saved: " + vehicleRegistry.size() + " vehicles");
                  } catch (JSONException e) {
                      Log.e(TAG, "Error saving vehicle registry", e);
                  }
              }
              
              private boolean isLikelyVehicleDevice(BluetoothDevice device) {
                  if (device == null) return false;
                  
                  // PRIMARY METHOD: Check Bluetooth device class for car audio
                  if (device.getBluetoothClass() != null) {
                      int deviceClass = device.getBluetoothClass().getDeviceClass();
                      Log.d(TAG, "Device class for " + device.getName() + ": " + deviceClass);
                      
                      // Check for car audio device class (from Stack Overflow article)
                      if (deviceClass == BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO) {
                          Log.d(TAG, "Device " + device.getName() + " identified as car audio via device class");
                          return true;
                      }
                  }
                  
                  // FALLBACK METHOD: Check device name patterns
                  String deviceName = device.getName();
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  
                  // Vehicle infotainment systems
                  if (name.contains("uconnect") || name.contains("sync") || 
                      name.contains("carplay") || name.contains("android auto") ||
                      name.contains("infotainment") || name.contains("multimedia")) {
                      Log.d(TAG, "Device " + deviceName + " identified as vehicle via name pattern");
                      return true;
                  }
                  
                  // Car brand specific systems
                  if (name.contains("bmw") || name.contains("mercedes") || name.contains("audi") ||
                      name.contains("toyota") || name.contains("honda") || name.contains("nissan") ||
                      name.contains("ford") || name.contains("chevy") || name.contains("gm") ||
                      name.contains("volkswagen") || name.contains("hyundai") || name.contains("kia") ||
                      name.contains("lexus") || name.contains("acura") || name.contains("infiniti") ||
                      name.contains("cadillac") || name.contains("buick") || name.contains("lincoln") ||
                      name.contains("mazda") || name.contains("subaru") || name.contains("volvo") ||
                      name.contains("tesla") || name.contains("jeep") || name.contains("dodge") ||
                      name.contains("ram") || name.contains("chrysler")) {
                      Log.d(TAG, "Device " + deviceName + " identified as vehicle via brand name");
                      return true;
                  }
                  
                  // Generic vehicle terms
                  if (name.contains("car") || name.contains("vehicle") || name.contains("auto") ||
                      name.contains("stereo") || name.contains("radio") || name.contains("nav") ||
                      name.contains("navigation") || name.contains("dash") || name.contains("display")) {
                      Log.d(TAG, "Device " + deviceName + " identified as vehicle via generic term");
                      return true;
                  }
                  
                  // Filter out obvious non-vehicle devices
                  if (name.contains("phone") || name.contains("headset") || name.contains("speaker") ||
                      name.contains("buds") || name.contains("airpods") || name.contains("beats") ||
                      name.contains("mouse") || name.contains("keyboard") || name.contains("laptop") ||
                      name.contains("tablet") || name.contains("watch") || name.contains("tv")) {
                      Log.d(TAG, "Device " + deviceName + " excluded as non-vehicle device");
                      return false;
                  }
                  
                  Log.d(TAG, "Device " + deviceName + " does not match vehicle patterns");
                  return false;
              }
              
              public static class VehicleInfo {
                  public String macAddress;
                  public String deviceName;
                  public String vehicleType;
                  public long registrationTime;
                  
                  public boolean isExpired() {
                      if ("Rental".equals(vehicleType)) {
                          return (System.currentTimeMillis() - registrationTime) > (7 * 24 * 60 * 60 * 1000);
                      } else if ("Borrowed".equals(vehicleType)) {
                          return (System.currentTimeMillis() - registrationTime) > (3 * 24 * 60 * 60 * 1000);
                      }
                      return false;
                  }
              }
          }
          EOF

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "BluetoothVehicleService";
              private static final String PREFS_NAME = "bluetooth_vehicle_prefs";

              private Context context;
              private BluetoothAdapter bluetoothAdapter;
              private Map<String, VehicleInfo> vehicleRegistry;
              private VehicleInfo currentVehicle;

              public interface VehicleConnectionListener {
                  void onVehicleConnected(VehicleInfo vehicle);
                  void onVehicleDisconnected(VehicleInfo vehicle);
              }

              private VehicleConnectionListener connectionListener;

              public BluetoothVehicleService(Context context) {
                  this.context = context;
                  this.vehicleRegistry = new HashMap<>();
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
                  this.bluetoothAdapter = bluetoothManager.getAdapter();
                  
                  registerBluetoothReceiver();
              }

              public void setConnectionListener(VehicleConnectionListener listener) {
                  this.connectionListener = listener;
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              private void registerBluetoothReceiver() {
                  IntentFilter filter = new IntentFilter();
                  filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
                  filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
                  context.registerReceiver(bluetoothReceiver, filter);
              }

              private final BroadcastReceiver bluetoothReceiver = new BroadcastReceiver() {
                  @Override
                  public void onReceive(Context context, Intent intent) {
                      String action = intent.getAction();
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      
                      if (device != null && vehicleRegistry.containsKey(device.getAddress())) {
                          VehicleInfo vehicle = vehicleRegistry.get(device.getAddress());
                          
                          if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
                              handleVehicleConnected(vehicle);
                          } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                              handleVehicleDisconnected(vehicle);
                          }
                      }
                  }
              };

              private void handleVehicleConnected(VehicleInfo vehicle) {
                  currentVehicle = vehicle;
                  Log.d(TAG, "Vehicle connected: " + vehicle.deviceName);
                  
                  if (connectionListener != null) {
                      connectionListener.onVehicleConnected(vehicle);
                  }
              }

              private void handleVehicleDisconnected(VehicleInfo vehicle) {
                  if (currentVehicle != null && currentVehicle.macAddress.equals(vehicle.macAddress)) {
                      currentVehicle = null;
                      Log.d(TAG, "Vehicle disconnected: " + vehicle.deviceName);
                      
                      if (connectionListener != null) {
                          connectionListener.onVehicleDisconnected(vehicle);
                      }
                  }
              }

              public void registerVehicle(String macAddress, String deviceName, String vehicleType) {
                  VehicleInfo vehicle = new VehicleInfo(macAddress, deviceName, vehicleType);
                  vehicleRegistry.put(macAddress, vehicle);
                  Log.d(TAG, "Vehicle registered: " + deviceName);
              }

              public void unregisterVehicle(String macAddress) {
                  VehicleInfo vehicle = vehicleRegistry.remove(macAddress);
                  if (vehicle != null) {
                      Log.d(TAG, "Vehicle unregistered: " + vehicle.deviceName);
                  }
              }

              public Map<String, VehicleInfo> getRegisteredVehicles() {
                  return new HashMap<>(vehicleRegistry);
              }

              public VehicleInfo getCurrentVehicle() {
                  return currentVehicle;
              }

              public void destroy() {
                  try {
                      context.unregisterReceiver(bluetoothReceiver);
                  } catch (IllegalArgumentException e) {
                      Log.w(TAG, "Bluetooth receiver already unregistered");
                  }
              }

              public static class VehicleInfo {
                  public String macAddress;
                  public String deviceName;
                  public String vehicleType;
                  public String suggestedCategory;

                  public VehicleInfo(String macAddress, String deviceName, String vehicleType) {
                      this.macAddress = macAddress;
                      this.deviceName = deviceName;
                      this.vehicleType = vehicleType;
                      this.suggestedCategory = "Business".equals(vehicleType) ? "Business" : "Personal";
                  }
              }
          }
          EOF

      - name: Create red car icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24.0"
              android:viewportHeight="24.0">
              <path
                  android:fillColor="#dc3545"
                  android:pathData="M18.92,6.01C18.72,5.42 18.16,5 17.5,5h-11C5.84,5 5.28,5.42 5.08,6.01L3,12v8c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-1h12v1c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-8L18.92,6.01zM6.5,16C5.67,16 5,15.33 5,14.5S5.67,13 6.5,13S8,13.67 8,14.5S7.33,16 6.5,16zM17.5,16c-0.83,0 -1.5,-0.67 -1.5,-1.5s0.67,-1.5 1.5,-1.5s1.5,0.67 1.5,1.5S18.33,16 17.5,16zM5,11l1.5,-4.5h11L19,11H5z"/>
          </vector>
          EOF

      - name: Create DeviceIdentification utility for stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/DeviceIdentification.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;

          import java.security.MessageDigest;
          import java.util.UUID;

          public class DeviceIdentification {
              private static final String TAG = "DeviceIdentification";
              private static final String PREFS_NAME = "DeviceIdentificationPrefs";
              private static final String STABLE_DEVICE_ID_KEY = "stable_device_id";
              private static final String USER_ID_KEY = "user_id";

              public static String getStableDeviceId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String stableId = prefs.getString(STABLE_DEVICE_ID_KEY, null);

                  if (stableId == null) {
                      stableId = generateStableDeviceId(context);
                      prefs.edit().putString(STABLE_DEVICE_ID_KEY, stableId).apply();
                      Log.d(TAG, "Generated new stable device ID: " + stableId);
                  }

                  return stableId;
              }

              public static String getUserId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String userId = prefs.getString(USER_ID_KEY, null);

                  if (userId == null) {
                      userId = generateUserId(context);
                      prefs.edit().putString(USER_ID_KEY, userId).apply();
                      Log.d(TAG, "Generated new user ID: " + userId);
                  }

                  return userId;
              }

              private static String generateStableDeviceId(Context context) {
                  try {
                      // Use Android ID (persists across app installs but not device resets)
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);

                      // Create a stable identifier using device characteristics
                      String deviceInfo = androidId + "-" + Build.MODEL + "-" + Build.MANUFACTURER;

                      // Hash it to create a consistent device ID
                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(deviceInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "device-" + hexString.toString().substring(0, 16);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating stable device ID", e);
                      // Fallback to random UUID if all else fails
                      return "device-" + UUID.randomUUID().toString().replace("-", "").substring(0, 16);
                  }
              }

              private static String generateUserId(Context context) {
                  try {
                      // Create a user ID that's stable across app installs
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                      String userInfo = androidId + "-user-" + Build.MODEL;

                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(userInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "user-" + hexString.toString().substring(0, 12);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating user ID", e);
                      return "user-" + UUID.randomUUID().toString().replace("-", "").substring(0, 12);
                  }
              }
          }
          EOF

      - name: Create OkHttp UserAuthManager for real API authentication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;
          import okhttp3.*;
          import okhttp3.logging.HttpLoggingInterceptor;
          import org.json.JSONObject;
          import java.io.IOException;
          import java.security.MessageDigest;
          import java.security.SecureRandom;
          import java.util.UUID;
          import java.util.concurrent.TimeUnit;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_AUTH_TOKEN = "auth_token";
              private static final String KEY_USER_ID = "user_id";
              private static final String KEY_DEVICE_EMAIL = "device_email";
              private static final String KEY_DEVICE_NAME = "device_name";
              private static final String KEY_SESSION_TOKEN = "session_token";
              
              private Context context;
              private SharedPreferences prefs;
              private OkHttpClient okHttpClient;
              
              // API endpoints - corrected production URL
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              private static final String LOGIN_ENDPOINT = "/api/auth/login";
              private static final String REGISTER_ENDPOINT = "/api/register";
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Initialize OkHttp with logging (from working version)
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor(message -> {
                      Log.d(TAG, "OkHttp: " + message);
                  });
                  logging.setLevel(HttpLoggingInterceptor.Level.HEADERS);
                  
                  this.okHttpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(15, TimeUnit.SECONDS)
                      .readTimeout(15, TimeUnit.SECONDS)
                      .writeTimeout(15, TimeUnit.SECONDS)
                      .build();
              }
              
              public boolean loginWithOkHttp(String email, String password) {
                  Log.d(TAG, "üîê OKHTTP LOGIN for: '" + email + "'");
                  Log.d(TAG, "Password received: '" + password + "' (length: " + (password != null ? password.length() : "null") + ")");
                  Log.d(TAG, "Target URL: " + API_BASE_URL + LOGIN_ENDPOINT);
                  
                  // Log network state
                  logNetworkState();
                  
                  try {
                      // Create JSON payload
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      Log.d(TAG, "JSON payload: " + loginData.toString());
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          loginData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + LOGIN_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      Log.d(TAG, "üåê OkHttp Request URL: " + request.url());
                      Log.d(TAG, "üåê OkHttp Request Headers: " + request.headers());
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "üåê OkHttp Response code: " + response.code());
                          Log.d(TAG, "üåê OkHttp Response message: " + response.message());
                          Log.d(TAG, "üåê OkHttp Response headers: " + response.headers());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "üåê OkHttp Response body: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              boolean success = responseJson.optBoolean("success", false);
                              Log.d(TAG, "OkHttp response success field: " + success);
                              
                              if (success) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  Log.d(TAG, "OkHttp token received: " + (token.isEmpty() ? "empty" : "[" + token.length() + " chars]"));
                                  Log.d(TAG, "OkHttp user ID: '" + userId + "'");
                                  
                                  // Generate device information for family sharing
                                  String deviceEmail = email; // Use login email for device identification
                                  String deviceName = buildDeviceName();
                                  String sessionToken = generateSessionToken();
                                  
                                  Log.d(TAG, "Multi-device info - Email: " + deviceEmail + ", Device: " + deviceName);
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .putString(KEY_DEVICE_EMAIL, deviceEmail)
                                       .putString(KEY_DEVICE_NAME, deviceName)
                                       .putString(KEY_SESSION_TOKEN, sessionToken)
                                       .apply();
                                  
                                  Log.d(TAG, "‚úÖ OKHTTP login successful for: " + email);
                                  return true;
                              } else {
                                  String message = responseJson.optString("message", "Unknown error");
                                  Log.d(TAG, "‚ùå OKHTTP login failed - success=false, message: " + message);
                              }
                          } else {
                              String errorBody = "";
                              try {
                                  errorBody = response.body().string();
                              } catch (Exception ex) {
                                  Log.d(TAG, "Could not read OkHttp error response: " + ex.getMessage());
                              }
                              Log.d(TAG, "‚ùå OKHTTP login failed - HTTP " + response.code() + ", Error body: " + errorBody);
                          }
                      }
                      
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP login exception: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean registerWithOkHttp(String email, String password, String name) {
                  Log.d(TAG, "üìù OKHTTP registration for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("name", name);
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          registerData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + REGISTER_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "OKHTTP registration response code: " + response.code());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "OKHTTP registration response: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              if (responseJson.optBoolean("success", false)) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .apply();
                                  
                                  Log.d(TAG, "‚úÖ OKHTTP registration successful for: " + email);
                                  return true;
                              }
                          }
                          
                          Log.d(TAG, "‚ùå OKHTTP registration failed - HTTP " + response.code());
                          return false;
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP registration error: " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public String getNetworkDiagnostics() {
                  StringBuilder info = new StringBuilder();
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          info.append("Network Type: ").append(activeNetwork.getTypeName()).append("\n");
                          info.append("Connected: ").append(activeNetwork.isConnected()).append("\n");
                          info.append("Available: ").append(activeNetwork.isAvailable()).append("\n");
                          info.append("HTTP Stack: OkHttp enabled\n");
                      } else {
                          info.append("No active network");
                      }
                  } catch (Exception e) {
                      info.append("Network check failed: ").append(e.getMessage());
                  }
                  return info.toString();
              }
              
              // Multi-device family sharing helper methods
              private String buildDeviceName() {
                  String manufacturer = Build.MANUFACTURER;
                  String model = Build.MODEL;
                  if (model.startsWith(manufacturer)) {
                      return model;
                  } else {
                      return manufacturer + " " + model;
                  }
              }
              
              private String generateSessionToken() {
                  return "session_" + UUID.randomUUID().toString().replace("-", "");
              }
              
              public String getDeviceEmail() {
                  return prefs.getString(KEY_DEVICE_EMAIL, "");
              }
              
              public String getDeviceName() {
                  return prefs.getString(KEY_DEVICE_NAME, buildDeviceName());
              }
              
              public String getSessionToken() {
                  return prefs.getString(KEY_SESSION_TOKEN, "");
              }
              
              public void showDeviceManagementDialog() {
                  // TODO: Implement device management dialog for Professional tier users
                  // Shows list of active devices when limit is reached
                  Log.d(TAG, "Device management dialog - Professional tier feature");
              }
              
              private void logNetworkState() {
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          Log.d(TAG, "üåê Network Type: " + activeNetwork.getTypeName());
                          Log.d(TAG, "üåê Network State: " + activeNetwork.getState());
                          Log.d(TAG, "üåê Network Connected: " + activeNetwork.isConnected());
                          Log.d(TAG, "üåê Network Available: " + activeNetwork.isAvailable());
                          Log.d(TAG, "üåê HTTP Stack: OkHttp v4.12.0");
                      } else {
                          Log.d(TAG, "üåê No active network detected");
                      }
                  } catch (Exception e) {
                      Log.d(TAG, "üåê Network state check failed: " + e.getMessage());
                  }
              }
              
              public boolean isLoggedIn() {
                  String email = prefs.getString(KEY_USER_EMAIL, "");
                  String token = prefs.getString(KEY_AUTH_TOKEN, "");
                  boolean loggedIn = !email.isEmpty() && !token.isEmpty();
                  Log.d(TAG, "isLoggedIn check: email=" + (!email.isEmpty()) + ", token=" + (!token.isEmpty()) + " -> " + loggedIn);
                  return loggedIn;
              }
              
              public String getCurrentUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }
              
              public String getAuthToken() {
                  return prefs.getString(KEY_AUTH_TOKEN, "");
              }
              
              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }
              
              public void logout() {
                  Log.d(TAG, "Logging out user");
                  prefs.edit().clear().apply();
              }

              // Add missing register method for AuthActivity compatibility
              public boolean register(String email, String password, String name) {
                  return registerWithOkHttp(email, password, name);
              }

              // Add missing recoverDataWithCredentials method for DataRecoveryActivity compatibility
              public boolean recoverDataWithCredentials(String email, String password) {
                  return loginWithOkHttp(email, password);
              }
          }
          EOF

      - name: Create BluetoothWorker for Background Vehicle Detection
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BluetoothWorker.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothDevice;
          import android.bluetooth.BluetoothManager;
          import android.content.Context;
          import android.content.Intent;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.os.Build;
          import android.util.Log;
          import androidx.annotation.NonNull;
          import androidx.core.app.ActivityCompat;
          import androidx.work.Worker;
          import androidx.work.WorkerParameters;
          import org.json.JSONObject;
          import java.util.Set;

          public class BluetoothWorker extends Worker {
              private static final String TAG = "BluetoothWorker";
              private static final String VEHICLE_PREFS = "vehicle_registry";
              private static final String REGISTERED_VEHICLES = "registered_vehicles";
              
              private BluetoothAdapter bluetoothAdapter;
              private SharedPreferences vehiclePrefs;
              private Context context;

              public BluetoothWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) {
                  super(context, workerParams);
                  this.context = context;
                  this.vehiclePrefs = context.getSharedPreferences(VEHICLE_PREFS, Context.MODE_PRIVATE);
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
                  if (bluetoothManager != null) {
                      this.bluetoothAdapter = bluetoothManager.getAdapter();
                  }
              }

              @NonNull
              @Override
              public Result doWork() {
                  Log.d(TAG, "WorkManager: Starting background Bluetooth vehicle check");
                  
                  if (bluetoothAdapter == null) {
                      Log.e(TAG, "WorkManager: Bluetooth adapter is null - device not supported");
                      return Result.success();
                  }
                  
                  if (!bluetoothAdapter.isEnabled()) {
                      Log.w(TAG, "WorkManager: Bluetooth is disabled - skipping check");
                      return Result.success();
                  }
                  
                  // Check Android 12+ permissions
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                      if (ActivityCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                          Log.w(TAG, "WorkManager: Missing BLUETOOTH_CONNECT permission - skipping check");
                          return Result.success();
                      }
                  }
                  
                  try {
                      checkForVehicleConnections();
                      return Result.success();
                  } catch (SecurityException e) {
                      Log.e(TAG, "WorkManager: SecurityException - missing Bluetooth permissions: " + e.getMessage());
                      return Result.failure();
                  } catch (Exception e) {
                      Log.e(TAG, "WorkManager: Exception during vehicle check: " + e.getMessage(), e);
                      return Result.retry();
                  }
              }

              private void checkForVehicleConnections() throws SecurityException {
                  Log.d(TAG, "WorkManager: Checking paired devices for vehicle connections");
                  
                  Set<BluetoothDevice> pairedDevices = bluetoothAdapter.getBondedDevices();
                  if (pairedDevices == null || pairedDevices.isEmpty()) {
                      Log.d(TAG, "WorkManager: No paired devices found");
                      return;
                  }
                  
                  Log.d(TAG, "WorkManager: Found " + pairedDevices.size() + " paired devices");
                  
                  for (BluetoothDevice device : pairedDevices) {
                      String deviceName = device.getName();
                      String deviceAddress = device.getAddress();
                      
                      if (deviceName == null || deviceAddress == null) {
                          continue;
                      }
                      
                      Log.d(TAG, "WorkManager: Checking device: " + deviceName + " (" + deviceAddress + ")");
                      
                      // Check if this is a vehicle device
                      if (isVehicleDevice(deviceName)) {
                          Log.d(TAG, "WorkManager: Vehicle device detected: " + deviceName);
                          
                          // Check if device is connected by attempting to get connection state
                          boolean isConnected = isDeviceConnected(device);
                          Log.d(TAG, "WorkManager: Device " + deviceName + " connected: " + isConnected);
                          
                          // Check if vehicle is registered
                          boolean isRegistered = isVehicleRegistered(deviceAddress);
                          
                          if (isConnected && isRegistered) {
                              Log.d(TAG, "WorkManager: Registered vehicle connected - starting trip detection");
                              startTripDetection(deviceAddress, deviceName);
                          } else if (isConnected && !isRegistered) {
                              Log.d(TAG, "WorkManager: New vehicle connected - triggering registration");
                              triggerVehicleRegistration(deviceAddress, deviceName);
                          }
                      }
                  }
              }

              private boolean isVehicleDevice(String deviceName) {
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  return name.contains("car") || name.contains("auto") || name.contains("ford") || 
                         name.contains("toyota") || name.contains("honda") || name.contains("bmw") || 
                         name.contains("mercedes") || name.contains("audi") || name.contains("volkswagen") || 
                         name.contains("nissan") || name.contains("hyundai") || name.contains("kia") || 
                         name.contains("mazda") || name.contains("subaru") || name.contains("lexus") || 
                         name.contains("infiniti") || name.contains("acura") || name.contains("cadillac") || 
                         name.contains("buick") || name.contains("gmc") || name.contains("chevrolet") || 
                         name.contains("dodge") || name.contains("ram") || name.contains("jeep") || 
                         name.contains("chrysler") || name.contains("lincoln") || name.contains("tesla") || 
                         name.contains("volvo") || name.contains("jaguar") || name.contains("landrover") || 
                         name.contains("porsche") || name.contains("maserati") || name.contains("ferrari") || 
                         name.contains("lamborghini") || name.contains("bentley") || name.contains("rollsroyce") || 
                         name.contains("uconnect") || name.contains("sync") || name.contains("entune") || 
                         name.contains("infotainment") || name.contains("carplay") || name.contains("androidauto") || 
                         name.contains("mylink") || name.contains("intellilink") || name.contains("cue") || 
                         name.contains("command") || name.contains("comand") || name.contains("mmi") || 
                         name.contains("idrive") || name.contains("navigation");
              }

              private boolean isDeviceConnected(BluetoothDevice device) {
                  try {
                      // Use reflection to check connection state since direct methods may not be available
                      java.lang.reflect.Method method = device.getClass().getMethod("isConnected");
                      return (Boolean) method.invoke(device);
                  } catch (Exception e) {
                      Log.d(TAG, "WorkManager: Cannot determine connection state for " + device.getName() + " - assuming disconnected");
                      return false;
                  }
              }

              private boolean isVehicleRegistered(String deviceAddress) {
                  String registeredVehicles = vehiclePrefs.getString(REGISTERED_VEHICLES, "{}");
                  try {
                      JSONObject vehicles = new JSONObject(registeredVehicles);
                      return vehicles.has(deviceAddress);
                  } catch (Exception e) {
                      Log.e(TAG, "WorkManager: Error checking vehicle registration: " + e.getMessage());
                      return false;
                  }
              }

              private void startTripDetection(String deviceAddress, String deviceName) {
                  Log.d(TAG, "WorkManager: Starting trip detection for vehicle: " + deviceName);
                  
                  // Send broadcast to MainActivity to start trip detection
                  Intent intent = new Intent("com.miletrackerpro.app.VEHICLE_CONNECTED");
                  intent.putExtra("device_address", deviceAddress);
                  intent.putExtra("device_name", deviceName);
                  intent.putExtra("source", "WorkManager");
                  context.sendBroadcast(intent);
              }

              private void triggerVehicleRegistration(String deviceAddress, String deviceName) {
                  Log.d(TAG, "WorkManager: Triggering vehicle registration for: " + deviceName);
                  
                  // Send broadcast to MainActivity to show registration dialog
                  Intent intent = new Intent("com.miletrackerpro.app.NEW_VEHICLE_DETECTED");
                  intent.putExtra("device_address", deviceAddress);
                  intent.putExtra("device_name", deviceName);
                  intent.putExtra("source", "WorkManager");
                  context.sendBroadcast(intent);
              }
          }
          EOF

      - name: Create Authentication Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;
          import android.graphics.Typeface;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private UserAuthManager authManager;
              private LinearLayout mainLayout;
              private boolean isLoginMode = true;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);

                  // If already logged in, go to main app
                  if (authManager.isLoggedIn()) {
                      goToMainApp();
                      return;
                  }

                  createAuthLayout();
              }

              private void createAuthLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(0, 0, 0, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // White header section with car icon and title
                  LinearLayout titleLayout = new LinearLayout(this);
                  titleLayout.setOrientation(LinearLayout.HORIZONTAL);
                  titleLayout.setBackgroundColor(0xFFFFFFFF);
                  titleLayout.setPadding(20, 40, 20, 20);
                  titleLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  TextView titleText = new TextView(this);
                  titleText.setText("üöó MileTracker Pro");
                  titleText.setTextSize(24);
                  titleText.setTextColor(0xFF495057);
                  titleText.setTypeface(null, Typeface.BOLD);
                  titleLayout.addView(titleText);
                  
                  mainLayout.addView(titleLayout);

                  // Version text removed per user request

                  // Benefits explanation in white section
                  LinearLayout benefitsLayout = new LinearLayout(this);
                  benefitsLayout.setOrientation(LinearLayout.VERTICAL);
                  benefitsLayout.setBackgroundColor(0xFFFFFFFF);
                  benefitsLayout.setPadding(20, 0, 20, 30);
                  
                  TextView benefitsText = new TextView(this);
                  benefitsText.setText("‚úÖ Keep your trips safe across all devices\n‚úÖ Automatic backup and sync\n‚úÖ Recover data if phone is lost/stolen\n‚úÖ No constant sign-ins required");
                  benefitsText.setTextSize(14);
                  benefitsText.setTextColor(0xFF495057);
                  benefitsText.setPadding(15, 15, 15, 15);
                  benefitsText.setBackgroundColor(0xFFe8f5e8);
                  benefitsLayout.addView(benefitsText);
                  
                  mainLayout.addView(benefitsLayout);

                  showAuthForm();

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void showAuthForm() {
                  // Clear form area (now accounting for 2 sections: white header, white benefits)
                  if (mainLayout.getChildCount() > 2) {
                      for (int i = mainLayout.getChildCount() - 1; i >= 2; i--) {
                          mainLayout.removeViewAt(i);
                      }
                  }

                  // Mode toggle
                  TextView modeText = new TextView(this);
                  modeText.setText(isLoginMode ? "Login to Your Account" : "Create New Account");
                  modeText.setTextSize(20);
                  modeText.setTextColor(0xFF495057);
                  modeText.setGravity(Gravity.CENTER);
                  modeText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(modeText);

                  // Email field
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email Address:");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF495057);
                  emailLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(emailLabel);

                  EditText emailField = new EditText(this);
                  emailField.setHint("your.email@example.com");
                  emailField.setText("pcates@catesconsultinggroup.com");
                  emailField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(15, 15, 15, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password:");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF495057);
                  passwordLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(passwordLabel);

                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Your secure password");
                  passwordField.setText("password123");
                  passwordField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(15, 15, 15, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 15);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Name field (registration only)
                  EditText nameField = null;
                  if (!isLoginMode) {
                      TextView nameLabel = new TextView(this);
                      nameLabel.setText("Your Name:");
                      nameLabel.setTextSize(16);
                      nameLabel.setTextColor(0xFF495057);
                      nameLabel.setPadding(0, 0, 0, 5);
                      mainLayout.addView(nameLabel);

                      nameField = new EditText(this);
                      nameField.setHint("John Smith");
                      nameField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PERSON_NAME);
                      nameField.setTextSize(16);
                      nameField.setPadding(15, 15, 15, 15);
                      nameField.setBackgroundColor(0xFFFFFFFF);
                      LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      nameParams.setMargins(0, 0, 0, 15);
                      nameField.setLayoutParams(nameParams);
                      mainLayout.addView(nameField);
                  }

                  // Primary action button
                  Button primaryButton = new Button(this);
                  primaryButton.setText(isLoginMode ? "Login" : "Create Account");
                  primaryButton.setBackgroundColor(0xFF667eea);
                  primaryButton.setTextColor(0xFFFFFFFF);
                  primaryButton.setTextSize(18);
                  primaryButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams primaryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  primaryParams.setMargins(0, 10, 0, 15);
                  primaryButton.setLayoutParams(primaryParams);

                  EditText finalNameField = nameField;
                  primaryButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      if (isLoginMode) {
                          handleLogin(email, password);
                      } else {
                          String name = finalNameField != null ? finalNameField.getText().toString().trim() : "";
                          if (name.isEmpty()) {
                              Toast.makeText(this, "Please enter your name", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          handleRegistration(email, password, name);
                      }
                  });
                  mainLayout.addView(primaryButton);

                  // Mode toggle button
                  Button toggleButton = new Button(this);
                  toggleButton.setText(isLoginMode ? "Need an account? Sign up" : "Already have an account? Login");
                  toggleButton.setBackgroundColor(0x00000000);
                  toggleButton.setTextColor(0xFF667eea);
                  toggleButton.setTextSize(16);
                  LinearLayout.LayoutParams toggleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  toggleParams.setMargins(0, 10, 0, 20);
                  toggleButton.setLayoutParams(toggleParams);
                  toggleButton.setOnClickListener(v -> {
                      isLoginMode = !isLoginMode;
                      showAuthForm();
                  });
                  mainLayout.addView(toggleButton);

                  // Data recovery link
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("üîÑ Lost device? Recover your data");
                  recoveryButton.setBackgroundColor(0x00000000);
                  recoveryButton.setTextColor(0xFF28a745);
                  recoveryButton.setTextSize(14);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoveryParams.setMargins(0, 20, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "OkHttp login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== OKHTTP LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread using OkHttp
                  new Thread(() -> {
                      Log.d(TAG, "Starting OkHttp login thread...");
                      boolean loginResult = authManager.loginWithOkHttp(email, password);
                      Log.d(TAG, "OkHttp login result: " + loginResult);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Toast.makeText(this, "Welcome back! üöó (OkHttp Success)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Login failed. Check logs for OkHttp diagnostic info.", Toast.LENGTH_LONG).show();
                              Log.d(TAG, "‚ùå OkHttp login failed - check connection routing");
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  if (authManager.register(email, password, name)) {
                      Toast.makeText(this, "Account created successfully! üéâ", Toast.LENGTH_SHORT).show();
                      goToMainApp();
                  } else {
                      Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }

              private void goToDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create Data Recovery Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);
                  createRecoveryLayout();
              }

              private void createRecoveryLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("üì±üíî Data Recovery");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF495057);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(headerText);

                  // Explanation
                  TextView explanationText = new TextView(this);
                  explanationText.setText("Lost your phone, upgraded devices, or need to reinstall?\n\nEnter your email and password to recover ALL your trip data and mileage history.\n\nThis works even if your old device was stolen or broken.");
                  explanationText.setTextSize(14);
                  explanationText.setTextColor(0xFF6C757D);
                  explanationText.setPadding(15, 15, 15, 15);
                  explanationText.setBackgroundColor(0xFFfff3cd);
                  LinearLayout.LayoutParams explanationParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  explanationParams.setMargins(0, 0, 0, 30);
                  explanationText.setLayoutParams(explanationParams);
                  mainLayout.addView(explanationText);

                  TextView formTitle = new TextView(this);
                  formTitle.setText("Recover Your Trip Data");
                  formTitle.setTextSize(18);
                  formTitle.setTextColor(0xFF495057);
                  formTitle.setPadding(0, 0, 0, 15);
                  mainLayout.addView(formTitle);

                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Your email address");
                  emailInput.setText("pcates@catesconsultinggroup.com");
                  emailInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Your password");
                  passwordInput.setText("password123");
                  passwordInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  Button recoverButton = new Button(this);
                  recoverButton.setText("üîÑ Recover My Trip Data");
                  recoverButton.setTextSize(16);
                  recoverButton.setBackgroundColor(0xFF28a745);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      performDataRecovery(email, password);
                  });
                  mainLayout.addView(recoverButton);

                  // Back button
                  Button backButton = new Button(this);
                  backButton.setText("‚Üê Back to Sign In");
                  backButton.setTextSize(14);
                  backButton.setBackgroundColor(0xFF667eea);
                  backButton.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backParams.setMargins(0, 15, 0, 0);
                  backButton.setLayoutParams(backParams);
                  backButton.setOnClickListener(v -> {
                      finish(); // Go back to AuthActivity
                  });
                  mainLayout.addView(backButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void performDataRecovery(String email, String password) {
                  try {
                      // Show progress
                      Toast.makeText(this, "Recovering your data...", Toast.LENGTH_SHORT).show();

                      boolean success = authManager.recoverDataWithCredentials(email, password);

                      if (success) {
                          // Success message
                          Toast.makeText(this, "SUCCESS! Your trip data is being restored. This includes ALL your historical trips, even from previous devices.", Toast.LENGTH_LONG).show();

                          // Go to main app
                          Intent intent = new Intent(this, MainActivity.class);
                          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                          startActivity(intent);
                          finish();

                      } else {
                          Toast.makeText(this, "Recovery failed. Please check your email and password, or create a new account if you're a new user.", Toast.LENGTH_LONG).show();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Data recovery error", e);
                      Toast.makeText(this, "Recovery error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
          }
          EOF

      - name: Create Trip class - EXACT COPY FROM WORKING VERSION
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long duration;
              private String category;
              private long startTime;
              private long endTime;
              private boolean autoDetected;
              private String clientName;
              private String notes;
              private String roundTripGroupId;
              private boolean isRoundTrip;
              private int roundTripSegment; // 1=outbound, 2=return, 0=not part of round trip
              private String vehicleName;
              private String vehicleType;
              private String vehicleDeviceAddress;

              public Trip() {
                  this.category = "Uncategorized";
                  this.autoDetected = false;
                  this.clientName = null;
                  this.notes = null;
                  this.roundTripGroupId = null;
                  this.isRoundTrip = false;
                  this.roundTripSegment = 0;
              }

              // All getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getRoundTripGroupId() { return roundTripGroupId; }
              public void setRoundTripGroupId(String roundTripGroupId) { this.roundTripGroupId = roundTripGroupId; }

              public boolean isRoundTrip() { return isRoundTrip; }
              public void setRoundTrip(boolean roundTrip) { isRoundTrip = roundTrip; }

              public int getRoundTripSegment() { return roundTripSegment; }
              public void setRoundTripSegment(int roundTripSegment) { this.roundTripSegment = roundTripSegment; }

              public String getVehicleName() { return vehicleName; }
              public void setVehicleName(String vehicleName) { this.vehicleName = vehicleName; }

              public String getVehicleType() { return vehicleType; }
              public void setVehicleType(String vehicleType) { this.vehicleType = vehicleType; }

              public String getVehicleDeviceAddress() { return vehicleDeviceAddress; }
              public void setVehicleDeviceAddress(String vehicleDeviceAddress) { this.vehicleDeviceAddress = vehicleDeviceAddress; }

              // Formatted display methods
              public String getFormattedDate() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDuration() {
                  long minutes = duration / (60 * 1000);
                  if (minutes < 60) {
                      return minutes + "m";
                  } else {
                      long hours = minutes / 60;
                      long remainingMinutes = minutes % 60;
                      return hours + "h " + remainingMinutes + "m";
                  }
              }

              public String getFormattedStartTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getCompactDateTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDateTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedEndTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(endTime));
              }
          }
          EOF

      - name: Create TripStorage with stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.utils.DeviceIdentification;
          import org.json.JSONArray;
          import org.json.JSONObject;

          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Comparator;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerPrefs";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              private static final String LAST_API_SYNC_KEY = "last_api_sync";
              private static final String CUSTOM_CATEGORIES_KEY = "custom_categories";
              private static final String HOME_ADDRESS_KEY = "home_address";
              private static final String HOME_LATITUDE_KEY = "home_latitude";
              private static final String HOME_LONGITUDE_KEY = "home_longitude";

              private SharedPreferences prefs;
              private Context context;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public String getStableDeviceId() {
                  return DeviceIdentification.getStableDeviceId(context);
              }

              public String getUserId() {
                  // Use authenticated user's database ID, not device ID
                  UserAuthManager authManager = new UserAuthManager(context);
                  String authUserId = authManager.getUserId();
                  if (!authUserId.isEmpty()) {
                      return authUserId;
                  }
                  // Fallback to device ID only if not authenticated
                  return DeviceIdentification.getUserId(context);
              }

              public boolean isAutoDetectionEnabled() {
                  return prefs.getBoolean(AUTO_DETECTION_KEY, false);
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  prefs.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, true);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
                  Log.d(TAG, "API sync enabled: " + enabled);
              }

              public long getLastApiSyncTime() {
                  return prefs.getLong(LAST_API_SYNC_KEY, 0);
              }

              public void setLastApiSyncTime(long timestamp) {
                  prefs.edit().putLong(LAST_API_SYNC_KEY, timestamp).apply();
              }

              // Home address management
              public void setHomeAddress(String address, double latitude, double longitude) {
                  prefs.edit()
                      .putString(HOME_ADDRESS_KEY, address)
                      .putFloat(HOME_LATITUDE_KEY, (float) latitude)
                      .putFloat(HOME_LONGITUDE_KEY, (float) longitude)
                      .apply();
                  Log.d(TAG, "Home address set: " + address);
              }

              public String getHomeAddress() {
                  return prefs.getString(HOME_ADDRESS_KEY, null);
              }

              public double getHomeLatitude() {
                  return prefs.getFloat(HOME_LATITUDE_KEY, 0.0f);
              }

              public double getHomeLongitude() {
                  return prefs.getFloat(HOME_LONGITUDE_KEY, 0.0f);
              }

              public boolean hasHomeAddress() {
                  return getHomeAddress() != null && !getHomeAddress().isEmpty();
              }

              public void clearHomeAddress() {
                  prefs.edit()
                      .remove(HOME_ADDRESS_KEY)
                      .remove(HOME_LATITUDE_KEY)
                      .remove(HOME_LONGITUDE_KEY)
                      .apply();
                  Log.d(TAG, "Home address cleared");
              }

              // Check if location is near home (within 100 meters)
              public boolean isNearHome(double latitude, double longitude) {
                  if (!hasHomeAddress()) {
                      return false;
                  }
                  
                  double homeLatitude = getHomeLatitude();
                  double homeLongitude = getHomeLongitude();
                  
                  // Calculate distance using Haversine formula
                  double distance = calculateDistance(latitude, longitude, homeLatitude, homeLongitude);
                  
                  // Consider within 100 meters as "home"
                  return distance <= 0.1; // 0.1 km = 100 meters
              }

              // Get home address if location is near home, otherwise return null
              public String getHomeAddressIfNear(double latitude, double longitude) {
                  if (isNearHome(latitude, longitude)) {
                      return getHomeAddress();
                  }
                  return null;
              }

              // Calculate distance between two coordinates (Haversine formula)
              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Radius of the Earth in km
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c;
                  return distance;
              }

              // Custom categories management
              public List<String> getCustomCategories() {
                  try {
                      String customCategoriesJson = prefs.getString(CUSTOM_CATEGORIES_KEY, "[]");
                      JSONArray jsonArray = new JSONArray(customCategoriesJson);
                      List<String> categories = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          categories.add(jsonArray.getString(i));
                      }
                      return categories;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting custom categories", e);
                      return new ArrayList<>();
                  }
              }

              public void addCustomCategory(String category) {
                  try {
                      List<String> categories = getCustomCategories();
                      if (!categories.contains(category) && !category.trim().isEmpty()) {
                          categories.add(category.trim());
                          saveCustomCategories(categories);
                          Log.d(TAG, "Added custom category: " + category);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding custom category", e);
                  }
              }

              public void removeCustomCategory(String category) {
                  try {
                      List<String> categories = getCustomCategories();
                      if (categories.remove(category)) {
                          saveCustomCategories(categories);
                          Log.d(TAG, "Removed custom category: " + category);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error removing custom category", e);
                  }
              }

              private void saveCustomCategories(List<String> categories) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (String category : categories) {
                          jsonArray.put(category);
                      }
                      prefs.edit().putString(CUSTOM_CATEGORIES_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving custom categories", e);
                  }
              }

              public List<String> getAllCategories() {
                  List<String> allCategories = new ArrayList<>();
                  // Add default categories
                  allCategories.add("Business");
                  allCategories.add("Personal");
                  allCategories.add("Medical");
                  allCategories.add("Charity");
                  // Add custom categories
                  allCategories.addAll(getCustomCategories());
                  return allCategories;
              }



              public void saveTrip(Trip trip) {
                  try {
                      if (trip.getId() == 0) {
                          trip.setId(trip.getStartTime() > 0 ? trip.getStartTime() : System.currentTimeMillis());
                      }

                      Log.d(TAG, "Saving trip: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                            " (Distance: " + trip.getDistance() + " miles)");

                      List<Trip> trips = getAllTrips();

                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }

                      if (!updated) {
                          trips.add(trip);
                      }

                      saveAllTrips(trips);
                      Log.d(TAG, updated ? "Trip updated: " + trip.getId() : "Trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      // Remove from local storage
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      
                      // Delete from API if available
                      new Thread(() -> {
                          try {
                              java.net.URL url = new java.net.URL("https://mileage-tracker-codenurse.replit.app/api/trips/" + tripId);
                              java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
                              conn.setRequestMethod("DELETE");
                              // Get current user email from SharedPreferences (same pattern as auth system)
                              SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                              String userEmail = authPrefs.getString("user_email", "");
                              if (!userEmail.isEmpty()) {
                                  conn.setRequestProperty("X-User-Email", userEmail);
                              } else {
                                  Log.w(TAG, "No user email available for DELETE request");
                                  return;
                              }
                              conn.setRequestProperty("Content-Type", "application/json");
                              conn.setConnectTimeout(5000);
                              conn.setReadTimeout(5000);
                              
                              int responseCode = conn.getResponseCode();
                              Log.d(TAG, "Trip deleted from API: " + tripId + ", Response: " + responseCode);
                              conn.disconnect();
                          } catch (Exception e) {
                              Log.w(TAG, "Could not delete trip from API: " + e.getMessage());
                          }
                      }).start();
                      
                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              // Method to merge API trips with local trips
              public void mergeApiTrips(List<Trip> apiTrips) {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      List<Trip> mergedTrips = new ArrayList<>();

                      // Start with local trips
                      mergedTrips.addAll(localTrips);

                      // Add API trips that don't exist locally
                      for (Trip apiTrip : apiTrips) {
                          boolean exists = false;
                          for (Trip localTrip : localTrips) {
                              // Check if trip already exists (same start time, distance, and locations)
                              if (Math.abs(localTrip.getStartTime() - apiTrip.getStartTime()) < 60000 && // Within 1 minute
                                  Math.abs(localTrip.getDistance() - apiTrip.getDistance()) < 0.1 &&
                                  (localTrip.getStartAddress() != null && localTrip.getStartAddress().equals(apiTrip.getStartAddress()))) {
                                  exists = true;
                                  break;
                              }
                          }

                          if (!exists) {
                              mergedTrips.add(apiTrip);
                              Log.d(TAG, "Added API trip: " + apiTrip.getStartAddress() + " ‚Üí " + apiTrip.getEndAddress());
                          }
                      }

                      saveAllTrips(mergedTrips);
                      setLastApiSyncTime(System.currentTimeMillis());
                      Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " local trips");

                  } catch (Exception e) {
                      Log.e(TAG, "Error merging API trips", e);
                  }
              }

              // User trip merge functionality - combines selected trips into one
              public Trip mergeUserTrips(List<String> tripIds) {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      List<Trip> tripsToMerge = new ArrayList<>();
                      
                      // Find trips to merge by ID
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              for (Trip trip : allTrips) {
                                  if (trip.getId() == id) {
                                      tripsToMerge.add(trip);
                                      break;
                                  }
                              }
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format: " + tripId);
                          }
                      }
                      
                      if (tripsToMerge.size() < 2) {
                          Log.w(TAG, "Need at least 2 trips to merge");
                          return null;
                      }
                      
                      // Sort trips by start time
                      Collections.sort(tripsToMerge, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t1.getStartTime(), t2.getStartTime());
                          }
                      });
                      
                      // Create merged trip using existing Trip structure
                      Trip firstTrip = tripsToMerge.get(0);
                      Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);
                      
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(System.currentTimeMillis());
                      mergedTrip.setStartTime(firstTrip.getStartTime());
                      mergedTrip.setEndTime(lastTrip.getEndTime());
                      mergedTrip.setStartAddress(firstTrip.getStartAddress());
                      mergedTrip.setEndAddress(lastTrip.getEndAddress());
                      mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                      mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                      mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                      mergedTrip.setEndLongitude(lastTrip.getEndLongitude());

                      // Calculate total distance
                      double totalDistance = 0;
                      for (Trip trip : tripsToMerge) {
                          totalDistance += trip.getDistance();
                      }
                      mergedTrip.setDistance(totalDistance);
                      
                      // Calculate total duration
                      long totalDuration = lastTrip.getEndTime() - firstTrip.getStartTime();
                      mergedTrip.setDuration(totalDuration);
                      
                      // Use category from first trip, or "Business" if mixed
                      String category = firstTrip.getCategory();
                      for (Trip trip : tripsToMerge) {
                          if (!trip.getCategory().equals(category)) {
                              category = "Business";
                              break;
                          }
                      }
                      mergedTrip.setCategory(category);
                      
                      // Combine client info  
                      StringBuilder clientBuilder = new StringBuilder();
                      for (Trip trip : tripsToMerge) {
                          if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                              if (clientBuilder.length() > 0) clientBuilder.append(", ");
                              clientBuilder.append(trip.getClientName());
                          }
                      }
                      mergedTrip.setClientName(clientBuilder.toString());
                      
                      mergedTrip.setNotes("Merged from " + tripsToMerge.size() + " trips");
                      mergedTrip.setAutoDetected(false);
                      
                      // Save merged trip and delete originals
                      saveTrip(mergedTrip);
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              deleteTrip(id);
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format for deletion: " + tripId);
                          }
                      }
                      
                      Log.d(TAG, "Successfully merged " + tripsToMerge.size() + " trips into: " + mergedTrip.getId());
                      return mergedTrip;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging user trips", e);
                      return null;
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray array = new JSONArray(tripsJson);

                      for (int i = 0; i < array.length(); i++) {
                          JSONObject obj = array.getJSONObject(i);
                          Trip trip = new Trip();

                          trip.setId(obj.optLong("id", 0));
                          trip.setStartAddress(obj.optString("start_location", ""));
                          trip.setEndAddress(obj.optString("end_location", ""));
                          trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                          trip.setDistance(obj.optDouble("distance", 0));
                          trip.setDuration(obj.optLong("duration", 0));
                          trip.setCategory(obj.optString("category", "Uncategorized"));
                          trip.setStartTime(obj.optLong("start_time", 0));
                          trip.setEndTime(obj.optLong("end_time", 0));
                          trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                          trip.setClientName(obj.optString("client_name", ""));
                          trip.setNotes(obj.optString("notes", ""));
                          trip.setVehicleName(obj.optString("vehicle_name", null));
                          trip.setVehicleType(obj.optString("vehicle_type", null));
                          trip.setVehicleDeviceAddress(obj.optString("vehicle_device_address", null));

                          trips.add(trip);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip == null) {
                          prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                          Log.d(TAG, "Current trip cleared");
                          return;
                      }

                      JSONObject obj = new JSONObject();
                      obj.put("id", trip.getId());
                      obj.put("start_location", trip.getStartAddress());
                      obj.put("end_location", trip.getEndAddress());
                      obj.put("start_latitude", trip.getStartLatitude());
                      obj.put("start_longitude", trip.getStartLongitude());
                      obj.put("end_latitude", trip.getEndLatitude());
                      obj.put("end_longitude", trip.getEndLongitude());
                      obj.put("distance", trip.getDistance());
                      obj.put("duration", trip.getDuration());
                      obj.put("category", trip.getCategory());
                      obj.put("start_time", trip.getStartTime());
                      obj.put("end_time", trip.getEndTime());
                      obj.put("auto_detected", trip.isAutoDetected());
                      obj.put("client_name", trip.getClientName());
                      obj.put("notes", trip.getNotes());
                      obj.put("vehicle_name", trip.getVehicleName());
                      obj.put("vehicle_type", trip.getVehicleType());
                      obj.put("vehicle_device_address", trip.getVehicleDeviceAddress());

                      prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String currentTripJson = prefs.getString(CURRENT_TRIP_KEY, null);
                      if (currentTripJson == null) return null;

                      JSONObject obj = new JSONObject(currentTripJson);
                      Trip trip = new Trip();

                      trip.setId(obj.optLong("id", 0));
                      trip.setStartAddress(obj.optString("start_location", ""));
                      trip.setEndAddress(obj.optString("end_location", ""));
                      trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                      trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                      trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                      trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                      trip.setDistance(obj.optDouble("distance", 0));
                      trip.setDuration(obj.optLong("duration", 0));
                      trip.setCategory(obj.optString("category", "Uncategorized"));
                      trip.setStartTime(obj.optLong("start_time", 0));
                      trip.setEndTime(obj.optLong("end_time", 0));
                      trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                      trip.setClientName(obj.optString("client_name", ""));
                      trip.setNotes(obj.optString("notes", ""));
                      trip.setVehicleName(obj.optString("vehicle_name", null));
                      trip.setVehicleType(obj.optString("vehicle_type", null));
                      trip.setVehicleDeviceAddress(obj.optString("vehicle_device_address", null));

                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                      return null;
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray array = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject obj = new JSONObject();
                          obj.put("id", trip.getId());
                          obj.put("start_location", trip.getStartAddress());
                          obj.put("end_location", trip.getEndAddress());
                          obj.put("start_latitude", trip.getStartLatitude());
                          obj.put("start_longitude", trip.getStartLongitude());
                          obj.put("end_latitude", trip.getEndLatitude());
                          obj.put("end_longitude", trip.getEndLongitude());
                          obj.put("distance", trip.getDistance());
                          obj.put("duration", trip.getDuration());
                          obj.put("category", trip.getCategory());
                          obj.put("start_time", trip.getStartTime());
                          obj.put("end_time", trip.getEndTime());
                          obj.put("auto_detected", trip.isAutoDetected());
                          obj.put("client_name", trip.getClientName());
                          obj.put("notes", trip.getNotes());
                          obj.put("vehicle_name", trip.getVehicleName());
                          obj.put("vehicle_type", trip.getVehicleType());
                          obj.put("vehicle_device_address", trip.getVehicleDeviceAddress());
                          array.put(obj);
                      }
                      prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }
              
              // Work Hours Auto-Classification Methods
              private static final String WORK_HOURS_ENABLED_KEY = "work_hours_enabled";
              private static final String WORK_START_TIME_KEY = "work_start_time";
              private static final String WORK_END_TIME_KEY = "work_end_time";
              private static final String WORK_DAYS_KEY = "work_days";
              
              public boolean isWorkHoursEnabled() {
                  return prefs.getBoolean(WORK_HOURS_ENABLED_KEY, false);
              }
              
              public void setWorkHoursEnabled(boolean enabled) {
                  prefs.edit().putBoolean(WORK_HOURS_ENABLED_KEY, enabled).apply();
              }
              
              public String getWorkStartTime() {
                  return prefs.getString(WORK_START_TIME_KEY, "09:00");
              }
              
              public void setWorkStartTime(String startTime) {
                  prefs.edit().putString(WORK_START_TIME_KEY, startTime).apply();
              }
              
              public String getWorkEndTime() {
                  return prefs.getString(WORK_END_TIME_KEY, "17:00");
              }
              
              public void setWorkEndTime(String endTime) {
                  prefs.edit().putString(WORK_END_TIME_KEY, endTime).apply();
              }
              
              public List<Integer> getWorkDays() {
                  try {
                      String workDaysJson = prefs.getString(WORK_DAYS_KEY, "[2,3,4,5,6]"); // Default Mon-Fri
                      JSONArray jsonArray = new JSONArray(workDaysJson);
                      List<Integer> workDays = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          workDays.add(jsonArray.getInt(i));
                      }
                      return workDays;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading work days", e);
                      // Default to Monday-Friday
                      List<Integer> defaultDays = new ArrayList<>();
                      defaultDays.add(2); // Monday
                      defaultDays.add(3); // Tuesday
                      defaultDays.add(4); // Wednesday
                      defaultDays.add(5); // Thursday
                      defaultDays.add(6); // Friday
                      return defaultDays;
                  }
              }
              
              public void setWorkDays(List<Integer> workDays) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (Integer day : workDays) {
                          jsonArray.put(day);
                      }
                      prefs.edit().putString(WORK_DAYS_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving work days", e);
                  }
              }
              
              public boolean isWithinWorkHours(long timestamp) {
                  if (!isWorkHoursEnabled()) {
                      return false;
                  }
                  
                  try {
                      java.util.Calendar calendar = java.util.Calendar.getInstance();
                      calendar.setTimeInMillis(timestamp);
                      
                      // Check if it's a work day
                      int dayOfWeek = calendar.get(java.util.Calendar.DAY_OF_WEEK);
                      List<Integer> workDays = getWorkDays();
                      if (!workDays.contains(dayOfWeek)) {
                          return false;
                      }
                      
                      // Check if it's within work hours
                      int hour = calendar.get(java.util.Calendar.HOUR_OF_DAY);
                      int minute = calendar.get(java.util.Calendar.MINUTE);
                      int currentTimeMinutes = hour * 60 + minute;
                      
                      String startTime = getWorkStartTime();
                      String endTime = getWorkEndTime();
                      
                      String[] startParts = startTime.split(":");
                      int startHour = Integer.parseInt(startParts[0]);
                      int startMinute = Integer.parseInt(startParts[1]);
                      int startTimeMinutes = startHour * 60 + startMinute;
                      
                      String[] endParts = endTime.split(":");
                      int endHour = Integer.parseInt(endParts[0]);
                      int endMinute = Integer.parseInt(endParts[1]);
                      int endTimeMinutes = endHour * 60 + endMinute;
                      
                      return currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error checking work hours", e);
                      return false;
                  }
              }
              
              // Round-trip detection methods
              public List<List<Trip>> getRoundTripGroups() {
                  try {
                      List<List<Trip>> groups = new ArrayList<>();
                      List<Trip> allTrips = getAllTrips();
                      
                      for (Trip trip : allTrips) {
                          if (trip.isRoundTrip() && trip.getRoundTripGroupId() != null) {
                              String groupId = trip.getRoundTripGroupId();
                              boolean foundGroup = false;
                              
                              for (List<Trip> group : groups) {
                                  if (!group.isEmpty() && groupId.equals(group.get(0).getRoundTripGroupId())) {
                                      group.add(trip);
                                      foundGroup = true;
                                      break;
                                  }
                              }
                              
                              if (!foundGroup) {
                                  List<Trip> newGroup = new ArrayList<>();
                                  newGroup.add(trip);
                                  groups.add(newGroup);
                              }
                          }
                      }
                      
                      // Sort trips within each group by segment number
                      for (List<Trip> group : groups) {
                          Collections.sort(group, (t1, t2) -> Integer.compare(t1.getRoundTripSegment(), t2.getRoundTripSegment()));
                      }
                      
                      return groups;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting round trip groups", e);
                      return new ArrayList<>();
                  }
              }
              
              public void detectRoundTrips() {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      Collections.sort(allTrips, (t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));
                      
                      String groupId = String.valueOf(System.currentTimeMillis());
                      
                      // Level 1: Daily round-trips (A‚ÜíB‚ÜíA same day)
                      for (int i = 0; i < allTrips.size() - 1; i++) {
                          Trip trip1 = allTrips.get(i);
                          Trip trip2 = allTrips.get(i + 1);
                          
                          if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;
                          
                          double distance = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                  trip2.getEndLatitude(), trip2.getEndLongitude());
                          
                          long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                          
                          if (distance <= 0.5 && timeDiff <= 12 * 60 * 60 * 1000) { // 0.5 miles, 12 hours
                              trip1.setRoundTripGroupId(groupId);
                              trip1.setRoundTrip(true);
                              trip1.setRoundTripSegment(1);
                              
                              trip2.setRoundTripGroupId(groupId);
                              trip2.setRoundTrip(true);
                              trip2.setRoundTripSegment(2);
                              
                              saveTrip(trip1);
                              saveTrip(trip2);
                              
                              groupId = String.valueOf(System.currentTimeMillis() + 1);
                          }
                      }
                      
                      // Level 2: Multi-day business trips with airports
                      for (int i = 0; i < allTrips.size() - 2; i++) {
                          Trip trip1 = allTrips.get(i);
                          Trip trip2 = allTrips.get(i + 1);
                          Trip trip3 = allTrips.get(i + 2);
                          
                          if (trip1.isRoundTrip() || trip2.isRoundTrip() || trip3.isRoundTrip()) continue;
                          
                          boolean hasAirport = isAirportLocation(trip1.getEndAddress()) || 
                                             isAirportLocation(trip2.getStartAddress()) ||
                                             isAirportLocation(trip2.getEndAddress()) ||
                                             isAirportLocation(trip3.getStartAddress());
                          
                          if (hasAirport) {
                              double homeToAirport = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                      trip3.getEndLatitude(), trip3.getEndLongitude());
                              
                              long tripDuration = trip3.getEndTime() - trip1.getStartTime();
                              
                              if (homeToAirport <= 1.0 && tripDuration <= 7 * 24 * 60 * 60 * 1000) { // 1 mile, 7 days
                                  trip1.setRoundTripGroupId(groupId);
                                  trip1.setRoundTrip(true);
                                  trip1.setRoundTripSegment(1);
                                  
                                  trip2.setRoundTripGroupId(groupId);
                                  trip2.setRoundTrip(true);
                                  trip2.setRoundTripSegment(2);
                                  
                                  trip3.setRoundTripGroupId(groupId);
                                  trip3.setRoundTrip(true);
                                  trip3.setRoundTripSegment(3);
                                  
                                  saveTrip(trip1);
                                  saveTrip(trip2);
                                  saveTrip(trip3);
                                  
                                  groupId = String.valueOf(System.currentTimeMillis() + 2);
                              }
                          }
                      }
                      
                      Log.d(TAG, "Round-trip detection completed");
                  } catch (Exception e) {
                      Log.e(TAG, "Error in round-trip detection", e);
                  }
              }
              
              private boolean isAirportLocation(String address) {
                  if (address == null) return false;
                  String lowerAddress = address.toLowerCase();
                  return lowerAddress.contains("airport") || lowerAddress.contains("airfield") || 
                         lowerAddress.contains("international") || lowerAddress.contains("terminal");
              }
              

              
              // ==================== FREQUENT LOCATION MANAGEMENT ====================
              // Add or update a known location
              public void addKnownLocation(String name, String address, double latitude, double longitude, String defaultCategory) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      // Check if location already exists within 0.1 miles
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          double existingLat = location.getDouble("latitude");
                          double existingLon = location.getDouble("longitude");
                          
                          if (calculateDistance(latitude, longitude, existingLat, existingLon) <= 0.1) {
                              // Update existing location
                              location.put("name", name);
                              location.put("address", address);
                              location.put("defaultCategory", defaultCategory);
                              prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                              Log.d(TAG, "Updated known location: " + name);
                              return;
                          }
                      }
                      
                      // Add new location
                      JSONObject newLocation = new JSONObject();
                      newLocation.put("name", name);
                      newLocation.put("address", address);
                      newLocation.put("latitude", latitude);
                      newLocation.put("longitude", longitude);
                      newLocation.put("defaultCategory", defaultCategory);
                      newLocation.put("visitCount", 1);
                      newLocation.put("lastVisited", System.currentTimeMillis());
                      
                      locationsArray.put(newLocation);
                      prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                      Log.d(TAG, "Added known location: " + name + " (" + defaultCategory + ")");
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding known location", e);
                  }
              }
              
              // Get known location name if coordinates are near a known location
              public String getKnownLocationName(double latitude, double longitude) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          double locLat = location.getDouble("latitude");
                          double locLon = location.getDouble("longitude");
                          
                          // Within 0.1 miles (about 500 feet)
                          if (calculateDistance(latitude, longitude, locLat, locLon) <= 0.1) {
                              String name = location.getString("name");
                              String address = location.getString("address");
                              
                              // Update visit count
                              int visitCount = location.optInt("visitCount", 0) + 1;
                              location.put("visitCount", visitCount);
                              location.put("lastVisited", System.currentTimeMillis());
                              prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                              
                              Log.d(TAG, "Using known location: " + name + " (visit #" + visitCount + ")");
                              return name + " - " + address;
                          }
                      }
                      return null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting known location", e);
                      return null;
                  }
              }
              
              // Get default category for a known location
              public String getKnownLocationCategory(double latitude, double longitude) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          double locLat = location.getDouble("latitude");
                          double locLon = location.getDouble("longitude");
                          
                          if (calculateDistance(latitude, longitude, locLat, locLon) <= 0.1) {
                              return location.getString("defaultCategory");
                          }
                      }
                      return null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting known location category", e);
                      return null;
                  }
              }
              
              // Auto-detect frequently visited locations (3+ visits)
              public void detectFrequentLocations() {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      java.util.Map<String, LocationData> locationMap = new java.util.HashMap<>();
                      
                      // Analyze all trip start/end locations
                      for (Trip trip : allTrips) {
                          processLocationForFrequency(trip.getStartLatitude(), trip.getStartLongitude(), 
                                                    trip.getStartAddress(), locationMap);
                          processLocationForFrequency(trip.getEndLatitude(), trip.getEndLongitude(), 
                                                    trip.getEndAddress(), locationMap);
                      }
                      
                      // Identify locations visited 3+ times
                      for (java.util.Map.Entry<String, LocationData> entry : locationMap.entrySet()) {
                          LocationData data = entry.getValue();
                          if (data.visitCount >= 3 && !isLocationAlreadyKnown(data.latitude, data.longitude)) {
                              String suggestedCategory = suggestCategoryFromAddress(data.address);
                              String suggestedName = suggestLocationName(data.address, suggestedCategory);
                              addKnownLocation(suggestedName, data.address, data.latitude, data.longitude, suggestedCategory);
                              Log.d(TAG, "Auto-detected frequent location: " + suggestedName + " (" + data.visitCount + " visits)");
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error detecting frequent locations", e);
                  }
              }
              
              // Helper methods for frequent location detection
              private void processLocationForFrequency(double latitude, double longitude, String address, java.util.Map<String, LocationData> locationMap) {
                  if (latitude == 0 && longitude == 0) return;
                  
                  // Round to ~100 meter precision for grouping
                  double roundedLat = Math.round(latitude * 1000.0) / 1000.0;
                  double roundedLon = Math.round(longitude * 1000.0) / 1000.0;
                  String locationKey = roundedLat + "," + roundedLon;
                  
                  LocationData data = locationMap.get(locationKey);
                  if (data == null) {
                      data = new LocationData(latitude, longitude, address);
                      locationMap.put(locationKey, data);
                  }
                  data.visitCount++;
              }
              
              private boolean isLocationAlreadyKnown(double latitude, double longitude) {
                  return getKnownLocationName(latitude, longitude) != null;
              }
              
              private String suggestCategoryFromAddress(String address) {
                  if (address == null) return "Personal";
                  
                  String lowerAddress = address.toLowerCase();
                  
                  // Business indicators
                  if (lowerAddress.contains("office") || lowerAddress.contains("corp") || 
                      lowerAddress.contains("company") || lowerAddress.contains("business") ||
                      lowerAddress.contains("po box") || lowerAddress.contains("p.o. box") ||
                      lowerAddress.contains("suite") || lowerAddress.contains("building") ||
                      lowerAddress.contains("plaza") || lowerAddress.contains("center")) {
                      return "Business";
                  }
                  
                  // Medical indicators
                  if (lowerAddress.contains("hospital") || lowerAddress.contains("clinic") ||
                      lowerAddress.contains("medical") || lowerAddress.contains("doctor") ||
                      lowerAddress.contains("health") || lowerAddress.contains("pharmacy")) {
                      return "Medical";
                  }
                  
                  // Charity indicators
                  if (lowerAddress.contains("church") || lowerAddress.contains("charity") ||
                      lowerAddress.contains("nonprofit") || lowerAddress.contains("foundation") ||
                      lowerAddress.contains("volunteer")) {
                      return "Charity";
                  }
                  
                  return "Personal";
              }
              
              private String suggestLocationName(String address, String category) {
                  if (address == null) return "Unknown Location";
                  
                  String lowerAddress = address.toLowerCase();
                  
                  // Extract meaningful parts of address
                  if (lowerAddress.contains("po box") || lowerAddress.contains("p.o. box")) {
                      return "PO Box";
                  }
                  if (lowerAddress.contains("office")) {
                      return "Office";
                  }
                  if (lowerAddress.contains("hospital")) {
                      return "Hospital";
                  }
                  if (lowerAddress.contains("clinic")) {
                      return "Clinic";
                  }
                  if (lowerAddress.contains("church")) {
                      return "Church";
                  }
                  
                  // Use category as fallback
                  return category + " Location";
              }
              
              // Enhanced trip classification using known locations
              public String getSmartCategoryForLocation(double latitude, double longitude) {
                  try {
                      // Check if it's home (always Personal)
                      if (isNearHome(latitude, longitude)) {
                          return "Personal";
                      }
                      
                      // Check known locations
                      String knownCategory = getKnownLocationCategory(latitude, longitude);
                      if (knownCategory != null) {
                          return knownCategory;
                      }
                      
                      // Fallback to default logic
                      return "Personal";
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting smart category", e);
                      return "Personal";
                  }
              }
              
              // Management methods for settings
              public java.util.List<String> getKnownLocationsList() {
                  try {
                      java.util.List<String> locationNames = new java.util.ArrayList<>();
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          String name = location.getString("name");
                          String category = location.getString("defaultCategory");
                          int visitCount = location.optInt("visitCount", 0);
                          locationNames.add(name + " (" + category + ", " + visitCount + " visits)");
                      }
                      return locationNames;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting known locations list", e);
                      return new java.util.ArrayList<>();
                  }
              }
              
              public void removeKnownLocation(String name) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          if (name.equals(location.getString("name"))) {
                              locationsArray.remove(i);
                              break;
                          }
                      }
                      
                      prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                      Log.d(TAG, "Removed known location: " + name);
                  } catch (Exception e) {
                      Log.e(TAG, "Error removing known location", e);
                  }
              }
              
              // Helper class for location frequency tracking
              private static class LocationData {
                  double latitude;
                  double longitude;
                  String address;
                  int visitCount;
                  
                  LocationData(double lat, double lon, String addr) {
                      latitude = lat;
                      longitude = lon;
                      address = addr;
                      visitCount = 0;
                  }
              }
              // ==================== END FREQUENT LOCATION MANAGEMENT ====================
          }
          EOF

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app/api";

              private Context context;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.executor = Executors.newSingleThreadExecutor();
              }

              // UPLOAD FUNCTIONALITY
              public void backupTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping backup");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting API backup for trip: " + trip.getId());

                          URL url = new URL(API_BASE_URL + "/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          // Use authenticated user's email and token dynamically
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          String jsonPayload = createTripJson(trip, null, tripStorage.getUserId());

                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API backup response: " + responseCode);

                          if (responseCode == 200 || responseCode == 201) {
                              Log.d(TAG, "Trip backed up successfully to API");
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip to API", e);
                      }
                  });
              }

              // DOWNLOAD ALL USER TRIPS (not just device-specific)
              public void downloadAllUserTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping download");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          String userId = tripStorage.getUserId();
                          Log.d(TAG, "Starting download ALL trips for user: " + userId);

                          // Download ALL trips from the API (not device-specific)
                          String apiUrl = API_BASE_URL + "/trips";
                          URL url = new URL(apiUrl);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          // Use authenticated user's email and token dynamically
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API download ALL trips response: " + responseCode);

                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(
                                      new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }

                              List<Trip> apiTrips = parseTripsFromJson(response.toString());
                              Log.d(TAG, "Downloaded " + apiTrips.size() + " trips from API (all user trips)");

                              if (!apiTrips.isEmpty()) {
                                  tripStorage.mergeApiTrips(apiTrips);
                                  Log.d(TAG, "Successfully merged API trips");
                              }
                          } else {
                              Log.w(TAG, "API download failed with code: " + responseCode);
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error downloading trips from API", e);
                      }
                  });
              }

              private List<Trip> parseTripsFromJson(String jsonResponse) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      // Handle server response format: { trips: [...] }
                      JSONObject responseObj = new JSONObject(jsonResponse);
                      JSONArray tripsArray = responseObj.optJSONArray("trips");
                      
                      // Fallback to direct array if no "trips" property
                      if (tripsArray == null) {
                          tripsArray = new JSONArray(jsonResponse);
                      }

                      for (int i = 0; i < tripsArray.length(); i++) {
                          JSONObject tripObj = tripsArray.getJSONObject(i);
                          Trip trip = new Trip();

                          // Parse API response fields - handle actual database structure
                          trip.setId(tripObj.optLong("id", System.currentTimeMillis()));
                          
                          // Address fields - server returns start_location/end_location (encrypted)
                          String startAddr = tripObj.optString("start_location", "Unknown");
                          String endAddr = tripObj.optString("end_location", "Unknown");
                          
                          // If still encrypted (contains colons), show coordinates instead
                          if (startAddr.contains(":")) {
                              double lat = tripObj.optDouble("start_latitude", 0);
                              double lng = tripObj.optDouble("start_longitude", 0);
                              startAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          if (endAddr.contains(":")) {
                              double lat = tripObj.optDouble("end_latitude", 0);
                              double lng = tripObj.optDouble("end_longitude", 0);
                              endAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          
                          trip.setStartAddress(startAddr);
                          trip.setEndAddress(endAddr);
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0));
                          
                          // Distance
                          trip.setDistance(tripObj.optDouble("distance", 0));
                          
                          // Duration - keep in milliseconds (as expected by Trip class)
                          long durationMs = tripObj.optLong("duration", 0);
                          trip.setDuration(durationMs);
                          
                          // Parse timestamps for trip date
                          String startTimeStr = tripObj.optString("start_time", "");
                          if (!startTimeStr.isEmpty()) {
                              long startTime = parseTimestamp(startTimeStr);
                              trip.setStartTime(startTime);
                          }
                          
                          trip.setCategory(tripObj.optString("category", "Uncategorized"));
                          
                          // Auto detection status
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          
                          // Client and notes - handle encrypted values
                          String clientName = tripObj.optString("client_name", "");
                          if (clientName.contains(":")) clientName = ""; // Skip encrypted values
                          trip.setClientName(clientName);
                          
                          String notes = tripObj.optString("notes", "");
                          if (notes.contains(":")) notes = ""; // Skip encrypted values
                          trip.setNotes(notes);

                          // Parse timestamps - use the timestamps from API
                          long startTime = tripObj.optLong("start_time", System.currentTimeMillis());
                          long endTime = tripObj.optLong("end_time", System.currentTimeMillis());

                          trip.setStartTime(startTime);
                          trip.setEndTime(endTime);

                          trips.add(trip);
                          Log.d(TAG, "Parsed API trip: " + trip.getStartAddress() + " ‚Üí " + trip.getEndAddress());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips JSON", e);
                  }
                  return trips;
              }
              
              private long parseTimestamp(String timestampStr) {
                  try {
                      if (timestampStr == null || timestampStr.isEmpty()) return 0;
                      
                      // Handle ISO timestamp format from database
                      if (timestampStr.contains("T")) {
                          return java.time.Instant.parse(timestampStr).toEpochMilli();
                      }
                      
                      // Handle epoch milliseconds
                      return Long.parseLong(timestampStr);
                  } catch (Exception e) {
                      Log.w(TAG, "Failed to parse timestamp: " + timestampStr);
                      return 0;
                  }
              }

              private String createTripJson(Trip trip, String deviceId, String userId) {
                  try {
                      return String.format(Locale.getDefault(),
                          "{"
                          + "\"start_location\":\"%s\","
                          + "\"end_location\":\"%s\","
                          + "\"start_latitude\":%.8f,"
                          + "\"start_longitude\":%.8f,"
                          + "\"end_latitude\":%.8f,"
                          + "\"end_longitude\":%.8f,"
                          + "\"distance\":%.6f,"
                          + "\"duration\":%d,"
                          + "\"category\":\"%s\","
                          + "\"auto_detected\":%s,"
                          + "\"start_time\":%d,"
                          + "\"end_time\":%d,"
                          + "\"client_name\":\"%s\","
                          + "\"notes\":\"%s\","
                          + "\"vehicle_name\":\"%s\","
                          + "\"vehicle_type\":\"%s\","
                          + "\"vehicle_device_address\":\"%s\","
                          + "\"timezone\":\"America/New_York\""
                          + "}",
                          trip.getStartAddress() != null ? trip.getStartAddress().replace("\"", "\\\"") : "",
                          trip.getEndAddress() != null ? trip.getEndAddress().replace("\"", "\\\"") : "",
                          trip.getStartLatitude(),
                          trip.getStartLongitude(),
                          trip.getEndLatitude(),
                          trip.getEndLongitude(),
                          trip.getDistance(),
                          trip.getDuration(),
                          trip.getCategory(),
                          trip.isAutoDetected(),
                          trip.getStartTime(),
                          trip.getEndTime(),
                          trip.getClientName() != null ? trip.getClientName().replace("\"", "\\\"") : "",
                          trip.getNotes() != null ? trip.getNotes().replace("\"", "\\\"") : "",
                          trip.getVehicleName() != null ? trip.getVehicleName().replace("\"", "\\\"") : "",
                          trip.getVehicleType() != null ? trip.getVehicleType().replace("\"", "\\\"") : "",
                          trip.getVehicleDeviceAddress() != null ? trip.getVehicleDeviceAddress().replace("\"", "\\\"") : ""
                      );
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating trip JSON", e);
                      return "{}";
                  }
              }

              // ADVANCED ROUND-TRIP DETECTION SYSTEM
              // Superior to MileIQ's primitive A->B->A detection
              
              /**
               * Detects potential round-trip patterns using multi-level clustering
               * Level 1: Daily round-trips (hotel->meeting->hotel)
               * Level 2: Trip segments (home->airport->destination)
               * Level 3: Complete trip groups (multi-day business trips)
               */
              public void detectRoundTrips() {
                  try {
                      List<Trip> recentTrips = getAllTrips();
                      if (recentTrips.size() < 2) return;

                      // Sort by start time for chronological analysis
                      Collections.sort(recentTrips, (t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));

                      // Detect different types of round trips
                      detectDailyRoundTrips(recentTrips);
                      detectMultiDayRoundTrips(recentTrips);
                      detectComplexTripGroups(recentTrips);

                      Log.d(TAG, "Round-trip detection completed");
                  } catch (Exception e) {
                      Log.e(TAG, "Error detecting round trips", e);
                  }
              }

              /**
               * Detects same-day round trips (A->B->A within 2-12 hours)
               * Example: Hotel->Meeting->Hotel, Home->Office->Home
               */
              private void detectDailyRoundTrips(List<Trip> trips) {
                  for (int i = 0; i < trips.size() - 1; i++) {
                      Trip trip1 = trips.get(i);
                      Trip trip2 = trips.get(i + 1);

                      // Skip if already part of a round trip
                      if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;

                      // Check if trips are within 12 hours
                      long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                      if (timeDiff > 12 * 60 * 60 * 1000) continue; // 12 hours max

                      // Check if start/end locations form A->B->A pattern
                      if (isLocationMatch(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                        trip2.getEndLatitude(), trip2.getEndLongitude(), 200) &&
                          isLocationMatch(trip1.getEndLatitude(), trip1.getEndLongitude(),
                                        trip2.getStartLatitude(), trip2.getStartLongitude(), 200)) {

                          // Create round-trip group
                          String groupId = "RT_" + System.currentTimeMillis();
                          trip1.setRoundTripGroupId(groupId);
                          trip1.setRoundTrip(true);
                          trip1.setRoundTripSegment(1); // Outbound
                          
                          trip2.setRoundTripGroupId(groupId);
                          trip2.setRoundTrip(true);
                          trip2.setRoundTripSegment(2); // Return

                          // Save updated trips
                          saveTrip(trip1);
                          saveTrip(trip2);

                          Log.d(TAG, "Daily round-trip detected: " + trip1.getStartAddress() + " -> " + trip1.getEndAddress());
                      }
                  }
              }

              /**
               * Detects multi-day round trips (business travel patterns)
               * Example: Home->Airport->Client City, Client City->Airport->Home
               */
              private void detectMultiDayRoundTrips(List<Trip> trips) {
                  for (int i = 0; i < trips.size() - 1; i++) {
                      Trip trip1 = trips.get(i);
                      
                      // Look for return trip within 2-14 days
                      for (int j = i + 1; j < trips.size(); j++) {
                          Trip trip2 = trips.get(j);
                          
                          // Skip if already part of a round trip
                          if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;

                          // Check if trips are within 14 days
                          long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                          if (timeDiff > 14 * 24 * 60 * 60 * 1000) break; // 14 days max

                          // Check for business travel pattern (airports, distant locations)
                          if (isBusinessTravelPattern(trip1, trip2)) {
                              String groupId = "BT_" + System.currentTimeMillis();
                              trip1.setRoundTripGroupId(groupId);
                              trip1.setRoundTrip(true);
                              trip1.setRoundTripSegment(1); // Outbound business travel
                              
                              trip2.setRoundTripGroupId(groupId);
                              trip2.setRoundTrip(true);
                              trip2.setRoundTripSegment(2); // Return business travel

                              // Auto-classify as Business if involving airports
                              if (isAirportLocation(trip1.getStartAddress()) || 
                                  isAirportLocation(trip1.getEndAddress()) ||
                                  isAirportLocation(trip2.getStartAddress()) || 
                                  isAirportLocation(trip2.getEndAddress())) {
                                  trip1.setCategory("Business");
                                  trip2.setCategory("Business");
                              }

                              saveTrip(trip1);
                              saveTrip(trip2);

                              Log.d(TAG, "Multi-day business trip detected: " + trip1.getStartAddress() + " -> " + trip2.getEndAddress());
                              break;
                          }
                      }
                  }
              }

              /**
               * Detects complex trip groups with mixed business/personal activities
               * Example: Multi-day business trip with personal activities in destination city
               */
              private void detectComplexTripGroups(List<Trip> trips) {
                  // Group trips by time periods and geographic clusters
                  List<List<Trip>> tripClusters = new ArrayList<>();
                  
                  for (Trip trip : trips) {
                      if (trip.isRoundTrip()) continue; // Skip already grouped trips
                      
                      boolean addedToCluster = false;
                      for (List<Trip> cluster : tripClusters) {
                          if (belongsToCluster(trip, cluster)) {
                              cluster.add(trip);
                              addedToCluster = true;
                              break;
                          }
                      }
                      
                      if (!addedToCluster) {
                          List<Trip> newCluster = new ArrayList<>();
                          newCluster.add(trip);
                          tripClusters.add(newCluster);
                      }
                  }
                  
                  // Analyze clusters for business travel patterns
                  for (List<Trip> cluster : tripClusters) {
                      if (cluster.size() >= 3) {
                          analyzeComplexTripGroup(cluster);
                      }
                  }
              }

              /**
               * Determines if a trip belongs to an existing cluster
               */
              private boolean belongsToCluster(Trip trip, List<Trip> cluster) {
                  if (cluster.isEmpty()) return false;
                  
                  // Check if trip is within time window of cluster
                  long clusterStart = cluster.get(0).getStartTime();
                  long clusterEnd = cluster.get(cluster.size() - 1).getEndTime();
                  
                  return (trip.getStartTime() >= clusterStart - 24 * 60 * 60 * 1000) && // 1 day before
                         (trip.getStartTime() <= clusterEnd + 24 * 60 * 60 * 1000);     // 1 day after
              }

              /**
               * Analyzes complex trip groups for business travel patterns
               */
              private void analyzeComplexTripGroup(List<Trip> cluster) {
                  // Check if cluster represents business travel with mixed activities
                  boolean hasBusinessIndicators = false;
                  boolean hasPersonalIndicators = false;
                  
                  for (Trip trip : cluster) {
                      if (isBusinessLocation(trip.getStartAddress()) || 
                          isBusinessLocation(trip.getEndAddress()) ||
                          isAirportLocation(trip.getStartAddress()) || 
                          isAirportLocation(trip.getEndAddress())) {
                          hasBusinessIndicators = true;
                      }
                      
                      if (isPersonalLocation(trip.getStartAddress()) || 
                          isPersonalLocation(trip.getEndAddress())) {
                          hasPersonalIndicators = true;
                      }
                  }
                  
                  if (hasBusinessIndicators && hasPersonalIndicators) {
                      // Mixed business trip - create group but don't auto-classify
                      String groupId = "MX_" + System.currentTimeMillis();
                      for (int i = 0; i < cluster.size(); i++) {
                          Trip trip = cluster.get(i);
                          trip.setRoundTripGroupId(groupId);
                          trip.setRoundTrip(true);
                          trip.setRoundTripSegment(i + 1);
                          saveTrip(trip);
                      }
                      Log.d(TAG, "Complex mixed business trip detected with " + cluster.size() + " segments");
                  }
              }

              /**
               * Checks if two locations are within the specified distance (meters)
               */
              private boolean isLocationMatch(double lat1, double lon1, double lat2, double lon2, double maxDistance) {
                  double distance = calculateDistance(lat1, lon1, lat2, lon2);
                  return distance <= maxDistance;
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Radius of the Earth in km
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c;
                  return distance;
              }

              /**
               * Determines if two trips form a business travel pattern
               */
              private boolean isBusinessTravelPattern(Trip trip1, Trip trip2) {
                  // Check for long-distance travel (>50 miles)
                  double distance = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                                    trip2.getEndLatitude(), trip2.getEndLongitude());
                  
                  if (distance < 50) return false; // Must be significant travel
                  
                  // Check for airport involvement
                  return isAirportLocation(trip1.getStartAddress()) || 
                         isAirportLocation(trip1.getEndAddress()) ||
                         isAirportLocation(trip2.getStartAddress()) || 
                         isAirportLocation(trip2.getEndAddress());
              }

              /**
               * Identifies airport locations for business travel classification
               */
              private boolean isAirportLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("airport") || lower.contains("terminal") || 
                         lower.contains("intl") || lower.contains("international");
              }

              /**
               * Identifies business locations
               */
              private boolean isBusinessLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("office") || lower.contains("corporate") || 
                         lower.contains("business") || lower.contains("company") ||
                         lower.contains("headquarters") || lower.contains("conference");
              }

              /**
               * Identifies personal/leisure locations
               */
              private boolean isPersonalLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("park") || lower.contains("mall") || 
                         lower.contains("restaurant") || lower.contains("hotel") ||
                         lower.contains("theme") || lower.contains("entertainment") ||
                         lower.contains("shopping") || lower.contains("recreation");
              }

              /**
               * Gets all round-trip groups for display
               */
              public List<String> getRoundTripGroups() {
                  List<String> groups = new ArrayList<>();
                  List<Trip> trips = getAllTrips();
                  
                  for (Trip trip : trips) {
                      if (trip.isRoundTrip() && !groups.contains(trip.getRoundTripGroupId())) {
                          groups.add(trip.getRoundTripGroupId());
                      }
                  }
                  
                  return groups;
              }

              /**
               * Gets all trips in a specific round-trip group
               */
              public List<Trip> getTripsInGroup(String groupId) {
                  List<Trip> groupTrips = new ArrayList<>();
                  List<Trip> allTrips = getAllTrips();
                  
                  for (Trip trip : allTrips) {
                      if (groupId.equals(trip.getRoundTripGroupId())) {
                          groupTrips.add(trip);
                      }
                  }
                  
                  // Sort by segment number
                  Collections.sort(groupTrips, (t1, t2) -> Integer.compare(t1.getRoundTripSegment(), t2.getRoundTripSegment()));
                  
                  return groupTrips;
              }

              /**
               * Ungroups a round-trip, allowing individual classification
               */
              public void ungroupRoundTrip(String groupId) {
                  List<Trip> groupTrips = getTripsInGroup(groupId);
                  for (Trip trip : groupTrips) {
                      trip.setRoundTripGroupId(null);
                      trip.setRoundTrip(false);
                      trip.setRoundTripSegment(0);
                      saveTrip(trip);
                  }
                  Log.d(TAG, "Ungrouped round-trip: " + groupId);
              }

              /**
               * Classifies all trips in a round-trip group with the same category
               */
              public void classifyRoundTripGroup(String groupId, String category) {
                  List<Trip> groupTrips = getTripsInGroup(groupId);
                  for (Trip trip : groupTrips) {
                      trip.setCategory(category);
                      saveTrip(trip);
                  }
                  Log.d(TAG, "Classified round-trip group " + groupId + " as " + category);
              }
              
              // Helper methods for trip operations
              private List<Trip> getAllTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  return tripStorage.getAllTrips();
              }
              
              private void saveTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  tripStorage.saveTrip(trip);
              }
              

              
              // CUSTOM CATEGORIES API SYNC METHODS
              
              /**
               * Syncs custom categories with API - downloads from API and merges with local
               */
              public void syncCustomCategoriesWithAPI() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping category sync");
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting custom categories sync with API");
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Download categories from API
                          URL url = new URL(API_BASE_URL + "/categories");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }
                              
                              // Parse and sync categories
                              JSONObject jsonResponse = new JSONObject(response.toString());
                              JSONArray categories = jsonResponse.getJSONArray("categories");
                              
                              for (int i = 0; i < categories.length(); i++) {
                                  String category = categories.getString(i);
                                  tripStorage.addCustomCategory(category);
                              }
                              
                              Log.d(TAG, "Successfully synced " + categories.length() + " categories from API");
                          } else {
                              Log.e(TAG, "Failed to sync categories from API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error syncing categories with API", e);
                      }
                  });
              }
              
              /**
               * Adds a custom category to the API
               */
              public void addCustomCategoryToAPI(String categoryName) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, adding category locally only");
                      tripStorage.addCustomCategory(categoryName);
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Adding custom category to API: " + categoryName);
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Add category to API
                          URL url = new URL(API_BASE_URL + "/categories");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          String jsonPayload = String.format("{\"name\":\"%s\"}", categoryName.replace("\"", "\\\""));
                          
                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 201) {
                              // Add to local storage after successful API call
                              tripStorage.addCustomCategory(categoryName);
                              Log.d(TAG, "Successfully added category to API and local storage: " + categoryName);
                          } else {
                              Log.e(TAG, "Failed to add category to API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error adding category to API", e);
                      }
                  });
              }
              
              /**
               * Removes a custom category from the API
               */
              public void removeCustomCategoryFromAPI(String categoryName) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, removing category locally only");
                      tripStorage.removeCustomCategory(categoryName);
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Removing custom category from API: " + categoryName);
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Remove category from API
                          URL url = new URL(API_BASE_URL + "/categories/" + java.net.URLEncoder.encode(categoryName, "UTF-8"));
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("DELETE");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 200) {
                              // Remove from local storage after successful API call
                              tripStorage.removeCustomCategory(categoryName);
                              Log.d(TAG, "Successfully removed category from API and local storage: " + categoryName);
                          } else {
                              Log.e(TAG, "Failed to remove category from API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error removing category from API", e);
                      }
                  });
              }

          }
          EOF

      - name: Create corrected MainActivity.java without AutoDetectionService
        run: |
          # Copy the corrected MainActivity.java from repo
          cp MainActivity.java android/app/src/main/java/com/miletrackerpro/app/MainActivity.java
          echo "‚úÖ Using corrected MainActivity.java without AutoDetectionService references"


      - name: Create BluetoothDiscoveryReceiver for device scanning
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/BluetoothDiscoveryReceiver.java << 'EOF'
          package com.miletrackerpro.app;

          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothDevice;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.util.Log;

          public class BluetoothDiscoveryReceiver extends BroadcastReceiver {
              private static final String TAG = "BluetoothDiscovery";

              @Override
              public void onReceive(Context context, Intent intent) {
                  String action = intent.getAction();
                  
                  if (BluetoothDevice.ACTION_FOUND.equals(action)) {
                      // Discovery has found a device
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      if (device != null) {
                          String deviceName = device.getName();
                          String deviceAddress = device.getAddress();
                          
                          Log.d(TAG, "Bluetooth device found: " + deviceName + " (" + deviceAddress + ")");
                          
                          // Check if this is a vehicle-related device
                          if (isVehicleDevice(deviceName)) {
                              Log.d(TAG, "Vehicle device detected: " + deviceName);
                              
                              // Broadcast to MainActivity and BluetoothVehicleService
                              Intent vehicleIntent = new Intent("com.miletrackerpro.app.VEHICLE_DETECTED");
                              vehicleIntent.putExtra("device_name", deviceName);
                              vehicleIntent.putExtra("device_address", deviceAddress);
                              context.sendBroadcast(vehicleIntent);
                          }
                      }
                  } else if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)) {
                      Log.d(TAG, "Bluetooth discovery started");
                  } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {
                      Log.d(TAG, "Bluetooth discovery finished");
                  }
              }

              private boolean isVehicleDevice(String deviceName) {
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  
                  // Exclude common non-vehicle devices first
                  if (name.contains("watch") || name.contains("buds") || name.contains("earbuds") ||
                      name.contains("headphones") || name.contains("speaker") || name.contains("mouse") ||
                      name.contains("keyboard") || name.contains("tablet") || name.contains("phone") ||
                      name.contains("galaxy") || name.contains("iphone") || name.contains("airpods") ||
                      name.contains("beats") || name.contains("jbl") || name.contains("bose")) {
                      return false;
                  }
                  
                  // Vehicle infotainment systems (like Uconnect, SYNC, Entune)
                  if (name.contains("uconnect") || name.contains("sync") || name.contains("entune") ||
                      name.contains("infotainment") || name.contains("multimedia") || name.contains("hmi") ||
                      name.contains("carplay") || name.contains("android auto")) {
                      return true;
                  }
                  
                  // Common vehicle-related terms
                  if (name.contains("car") || name.contains("vehicle") || name.contains("auto") ||
                      name.contains("truck") || name.contains("suv") || name.contains("van")) {
                      return true;
                  }
                  
                  // Vehicle brand names
                  return name.contains("honda") || name.contains("toyota") || name.contains("ford") ||
                         name.contains("chevy") || name.contains("bmw") || name.contains("audi") ||
                         name.contains("mazda") || name.contains("nissan") || name.contains("hyundai") ||
                         name.contains("kia") || name.contains("mercedes") || name.contains("lexus") ||
                         name.contains("acura") || name.contains("infiniti") || name.contains("cadillac") ||
                         name.contains("buick") || name.contains("gmc") || name.contains("jeep") ||
                         name.contains("dodge") || name.contains("chrysler") || name.contains("ram") ||
                         name.contains("lincoln") || name.contains("volvo") || name.contains("subaru") ||
                         name.contains("mitsubishi") || name.contains("jaguar") || name.contains("land rover") ||
                         name.contains("porsche") || name.contains("ferrari") || name.contains("lamborghini") ||
                         name.contains("maserati") || name.contains("bentley") || name.contains("rolls royce") ||
                         name.contains("tesla") || name.contains("prius");
              }
          }
          EOF

      - name: Copy AddressLookup and services exactly from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          // Check for home address first
                          com.miletrackerpro.app.storage.TripStorage tripStorage = new com.miletrackerpro.app.storage.TripStorage(context);
                          String homeAddress = tripStorage.getHomeAddressIfNear(latitude, longitude);
                          if (homeAddress != null) {
                              Log.d(TAG, "Using home address: " + homeAddress);
                              callback.onAddressFound(homeAddress);
                              return;
                          }
                          
                          // Check for known locations second
                          String knownLocation = tripStorage.getKnownLocationName(latitude, longitude);
                          if (knownLocation != null) {
                              Log.d(TAG, "Using known location: " + knownLocation);
                              callback.onAddressFound(knownLocation);
                              return;
                          }
                          
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder addressText = new StringBuilder();

                  if (address.getSubThoroughfare() != null) {
                      addressText.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      addressText.append(address.getThoroughfare()).append(", ");
                  }
                  if (address.getLocality() != null) {
                      addressText.append(address.getLocality()).append(", ");
                  }
                  if (address.getAdminArea() != null) {
                      addressText.append(address.getAdminArea());
                  }

                  String result = addressText.toString().trim();
                  if (result.endsWith(",")) {
                      result = result.substring(0, result.length() - 1);
                  }

                  return result.isEmpty() ? "Unknown Location" : result;
              }
          }
          EOF

          # AutoDetectionService removed - MainActivity.java now handles all auto-detection logic directly
          # This eliminates competing auto-detection systems and prevents build conflicts

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.widget.Toast;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import com.miletrackerpro.app.services.BluetoothVehicleService;
          import android.os.Handler;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "MANUAL_TRIP_CHANNEL";
              private static final int NOTIFICATION_ID = 1002;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private Trip currentTrip = null;
              private Location startLocation = null;
              private Location lastLocation = null;
              
              // Manual trip tracking variables
              private boolean autoDetectionEnabled = false;
              private boolean isCurrentlyTracking = false;
              private Handler speedHandler;
              private Handler blinkHandler;
              private Runnable speedRunnable;
              private Runnable blinkRunnable;

              @Override
              public void onCreate() {
                  super.onCreate();

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      } else if ("REGISTER_VEHICLE".equals(intent.getAction())) {
                          String deviceName = intent.getStringExtra("deviceName");
                          String macAddress = intent.getStringExtra("macAddress");
                          String vehicleType = intent.getStringExtra("vehicleType");
                          registerVehicle(deviceName, macAddress, vehicleType);
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void registerVehicle(String deviceName, String macAddress, String vehicleType) {
                  try {
                      // Send registration request to BluetoothVehicleService
                      Intent serviceIntent = new Intent(this, BluetoothVehicleService.class);
                      serviceIntent.setAction("REGISTER_VEHICLE");
                      serviceIntent.putExtra("deviceName", deviceName);
                      serviceIntent.putExtra("macAddress", macAddress);
                      serviceIntent.putExtra("vehicleType", vehicleType);
                      startService(serviceIntent);
                      
                      Log.d(TAG, "Vehicle registration sent: " + deviceName + " (" + vehicleType + ")");
                  } catch (Exception e) {
                      Log.e(TAG, "Error registering vehicle: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      long currentTime = System.currentTimeMillis();

                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setEndAddress(address);
                              saveTrip();
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setEndAddress("Unknown Location");
                              saveTrip();
                          }
                      });
                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959; // Radius of the Earth in miles
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void saveTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }

                      sendBroadcast("completed", currentTrip.getDistance(), currentTrip.getDuration());
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                  }
              }



              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip == null) return;

                      if (startLocation == null) {
                          startLocation = location;
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());

                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                              }
                          });
                      }

                      lastLocation = location;

                      if (startLocation != null) {
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  try {
                      Intent intent = new Intent("MANUAL_TRIP_UPDATE");
                      intent.putExtra("status", status);
                      intent.putExtra("distance", distance);
                      intent.putExtra("duration", duration);
                      sendBroadcast(intent);
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending broadcast: " + e.getMessage(), e);
                  }
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }



              // Bluetooth methods - Vehicle connection/disconnection now handled through AutoDetectionService
              // This provides proper trip detection with address lookup and automatic stopping when stationary
              
              public void onDestroy() {
                  super.onDestroy();
                  
                  if (speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
                  
                  if (blinkRunnable != null) {
                      blinkHandler.removeCallbacks(blinkRunnable);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: BUTTONS_FIXED_IN_CATEGORIZED_TAB_2025-01-10_10-55pm-EST with STABLE DEVICE ID + USER LINKING
        run: |
          cd android
          echo "BUILDING v4.9.149 - BLUETOOTH BACKGROUND SERVICE FINAL"
          echo "‚úÖ BLUETOOTH SERVICE: Converted to proper Android background service with foreground notification"
          echo "‚úÖ BACKGROUND OPERATION: Service runs independently with START_STICKY restart capability"
          echo "‚úÖ BROADCAST COMMUNICATION: Intent-based communication between services"
          echo "‚úÖ COMPILATION FIXED: All bluetoothVehicleService references removed from MainActivity"
          echo "‚úÖ VEHICLE MONITORING: True background vehicle detection without app being open"
          echo "‚úÖ BATTERY OPTIMIZED: Efficient 3-minute scanning with immediate connection response"
          echo "‚úÖ PRESERVED: Complete authentication system and PostgreSQL sync"
          ./gradlew clean assembleRelease --no-daemon --stacktrace

      - name: Upload APK - Enhanced API Sync + All Editable Fields
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-Bluetooth-Discovery-v4.9.153
          path: android/app/build/outputs/apk/release/*.apk
