name: GRADLE FIXED - Reliable Sync with Missing Trip Recovery

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2
        with:
          gradle-version: '8.6'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create top-level build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 21
                  compileSdkVersion = 35
                  targetSdkVersion = 35
                  ndkVersion = "26.1.10909125"
                  kotlinVersion = "1.9.24"
              }
              repositories {
                  google()
                  mavenCentral()
                  gradlePluginPortal()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.4.0")
                  classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.22")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
                  maven { url 'https://www.jitpack.io' }
              }
          }
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          org.gradle.jvmargs=-Xmx4096m -XX:MaxMetaspaceSize=512m
          android.useAndroidX=true
          android.enableJetifier=true
          android.suppressUnsupportedCompileSdk=35
          EOF

      - name: Create app build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id("com.android.application")
              id("org.jetbrains.kotlin.android")
          }

          android {
              namespace "com.miletrackerpro.app"
              compileSdk 35

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 21
                  targetSdk 35
                  versionCode 1
                  versionName "4.9.34"
                  testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              kotlinOptions {
                  jvmTarget = '1.8'
              }
          }

          dependencies {
              implementation 'androidx.core:core-ktx:1.13.1'
              implementation 'androidx.appcompat:appcompat:1.7.0'
              implementation 'com.google.android.material:material:1.12.0'
              implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
              implementation 'com.google.android.gms:play-services-location:21.3.0'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.google.code.gson:gson:2.10.1'
              implementation 'androidx.work:work-runtime:2.9.0'
              testImplementation 'junit:junit:4.13.2'
              androidTestImplementation 'androidx.test.ext:junit:1.2.1'
              androidTestImplementation 'androidx.test.espresso:espresso-core:3.6.1'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

              <application
                  android:allowBackup="true"
                  android:dataExtractionRules="@xml/data_extraction_rules"
                  android:fullBackupContent="@xml/backup_rules"
                  android:icon="@mipmap/ic_launcher"
                  android:label="@string/app_name"
                  android:roundIcon="@mipmap/ic_launcher_round"
                  android:supportsRtl="true"
                  android:theme="@style/Theme.MileTrackerPro"
                  tools:targetApi="31">

                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:theme="@style/Theme.MileTrackerPro">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <service
                      android:name=".services.BackgroundLocationService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.SyncService"
                      android:enabled="true"
                      android:exported="false" />

              </application>
          </manifest>
          EOF

      - name: Create Trip.java model
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/Trip.java << 'EOF'
          package com.miletrackerpro.app;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String startLocation;
              private String endLocation;
              private double distance;
              private String startTime;
              private String endTime;
              private String category;
              private String clientName;
              private String notes;
              private String deviceId;
              private boolean synced;
              private int retryCount;

              public Trip() {
                  this.synced = false;
                  this.retryCount = 0;
              }

              // Getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartLocation() { return startLocation; }
              public void setStartLocation(String startLocation) { this.startLocation = startLocation; }

              public String getEndLocation() { return endLocation; }
              public void setEndLocation(String endLocation) { this.endLocation = endLocation; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public String getStartTime() { return startTime; }
              public void setStartTime(String startTime) { this.startTime = startTime; }

              public String getEndTime() { return endTime; }
              public void setEndTime(String endTime) { this.endTime = endTime; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getDeviceId() { return deviceId; }
              public void setDeviceId(String deviceId) { this.deviceId = deviceId; }

              public boolean isSynced() { return synced; }
              public void setSynced(boolean synced) { this.synced = synced; }

              public int getRetryCount() { return retryCount; }
              public void setRetryCount(int retryCount) { this.retryCount = retryCount; }

              public void incrementRetryCount() { this.retryCount++; }

              public String getFormattedStartTime() {
                  try {
                      SimpleDateFormat inputFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());
                      SimpleDateFormat outputFormat = new SimpleDateFormat("MMM dd, h:mm a", Locale.getDefault());
                      Date date = inputFormat.parse(startTime);
                      return outputFormat.format(date);
                  } catch (Exception e) {
                      return startTime;
                  }
              }

              public double getBusinessDeduction() {
                  if ("Business".equals(category)) {
                      return distance * 0.70;
                  }
                  return 0.0;
              }

              public double getMedicalDeduction() {
                  if ("Medical".equals(category)) {
                      return distance * 0.21;
                  }
                  return 0.0;
              }

              public double getCharityDeduction() {
                  if ("Charity".equals(category)) {
                      return distance * 0.14;
                  }
                  return 0.0;
              }
          }
          EOF

      - name: Create TripStorage.java with comprehensive sync tracking
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.ContentValues;
          import android.content.Context;
          import android.database.Cursor;
          import android.database.sqlite.SQLiteDatabase;
          import android.database.sqlite.SQLiteOpenHelper;
          import android.util.Log;

          import com.miletrackerpro.app.Trip;

          import java.util.ArrayList;
          import java.util.List;

          public class TripStorage extends SQLiteOpenHelper {
              private static final String DATABASE_NAME = "MileTrackerPro.db";
              private static final int DATABASE_VERSION = 4;
              private static final String TABLE_TRIPS = "trips";
              private static final String TABLE_SETTINGS = "settings";

              // Trip table columns
              private static final String COLUMN_ID = "id";
              private static final String COLUMN_START_LOCATION = "start_location";
              private static final String COLUMN_END_LOCATION = "end_location";
              private static final String COLUMN_DISTANCE = "distance";
              private static final String COLUMN_START_TIME = "start_time";
              private static final String COLUMN_END_TIME = "end_time";
              private static final String COLUMN_CATEGORY = "category";
              private static final String COLUMN_CLIENT_NAME = "client_name";
              private static final String COLUMN_NOTES = "notes";
              private static final String COLUMN_DEVICE_ID = "device_id";
              private static final String COLUMN_SYNCED = "synced";
              private static final String COLUMN_RETRY_COUNT = "retry_count";

              // Settings table columns
              private static final String COLUMN_KEY = "key";
              private static final String COLUMN_VALUE = "value";

              // Setting keys
              public static final String USER_EMAIL_KEY = "user_email";
              public static final String IS_LOGGED_IN_KEY = "is_logged_in";
              public static final String AUTO_DETECTION_KEY = "auto_detection_enabled";

              private Context context;

              public TripStorage(Context context) {
                  super(context, DATABASE_NAME, null, DATABASE_VERSION);
                  this.context = context;
              }

              @Override
              public void onCreate(SQLiteDatabase db) {
                  String createTripsTable = "CREATE TABLE " + TABLE_TRIPS + "("
                          + COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
                          + COLUMN_START_LOCATION + " TEXT,"
                          + COLUMN_END_LOCATION + " TEXT,"
                          + COLUMN_DISTANCE + " REAL,"
                          + COLUMN_START_TIME + " TEXT,"
                          + COLUMN_END_TIME + " TEXT,"
                          + COLUMN_CATEGORY + " TEXT,"
                          + COLUMN_CLIENT_NAME + " TEXT,"
                          + COLUMN_NOTES + " TEXT,"
                          + COLUMN_DEVICE_ID + " TEXT,"
                          + COLUMN_SYNCED + " INTEGER DEFAULT 0,"
                          + COLUMN_RETRY_COUNT + " INTEGER DEFAULT 0"
                          + ")";

                  String createSettingsTable = "CREATE TABLE " + TABLE_SETTINGS + "("
                          + COLUMN_KEY + " TEXT PRIMARY KEY,"
                          + COLUMN_VALUE + " TEXT"
                          + ")";

                  db.execSQL(createTripsTable);
                  db.execSQL(createSettingsTable);
              }

              @Override
              public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
                  if (oldVersion < 4) {
                      db.execSQL("ALTER TABLE " + TABLE_TRIPS + " ADD COLUMN " + COLUMN_SYNCED + " INTEGER DEFAULT 0");
                      db.execSQL("ALTER TABLE " + TABLE_TRIPS + " ADD COLUMN " + COLUMN_RETRY_COUNT + " INTEGER DEFAULT 0");
                  }
              }

              public long addTrip(Trip trip) {
                  SQLiteDatabase db = this.getWritableDatabase();
                  ContentValues values = new ContentValues();

                  values.put(COLUMN_START_LOCATION, trip.getStartLocation());
                  values.put(COLUMN_END_LOCATION, trip.getEndLocation());
                  values.put(COLUMN_DISTANCE, trip.getDistance());
                  values.put(COLUMN_START_TIME, trip.getStartTime());
                  values.put(COLUMN_END_TIME, trip.getEndTime());
                  values.put(COLUMN_CATEGORY, trip.getCategory());
                  values.put(COLUMN_CLIENT_NAME, trip.getClientName());
                  values.put(COLUMN_NOTES, trip.getNotes());
                  values.put(COLUMN_DEVICE_ID, trip.getDeviceId());
                  values.put(COLUMN_SYNCED, trip.isSynced() ? 1 : 0);
                  values.put(COLUMN_RETRY_COUNT, trip.getRetryCount());

                  long id = db.insert(TABLE_TRIPS, null, values);
                  db.close();

                  Log.d("TripStorage", "Trip added with ID: " + id + ", Synced: " + trip.isSynced());
                  return id;
              }

              public List<Trip> getAllTrips() {
                  List<Trip> tripList = new ArrayList<>();
                  String selectQuery = "SELECT * FROM " + TABLE_TRIPS + " ORDER BY " + COLUMN_START_TIME + " DESC";

                  SQLiteDatabase db = this.getReadableDatabase();
                  Cursor cursor = db.rawQuery(selectQuery, null);

                  if (cursor.moveToFirst()) {
                      do {
                          Trip trip = new Trip();
                          trip.setId(cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_ID)));
                          trip.setStartLocation(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_START_LOCATION)));
                          trip.setEndLocation(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_END_LOCATION)));
                          trip.setDistance(cursor.getDouble(cursor.getColumnIndexOrThrow(COLUMN_DISTANCE)));
                          trip.setStartTime(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_START_TIME)));
                          trip.setEndTime(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_END_TIME)));
                          trip.setCategory(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_CATEGORY)));
                          trip.setClientName(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_CLIENT_NAME)));
                          trip.setNotes(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTES)));
                          trip.setDeviceId(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_DEVICE_ID)));
                          trip.setSynced(cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_SYNCED)) == 1);
                          trip.setRetryCount(cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_RETRY_COUNT)));

                          tripList.add(trip);
                      } while (cursor.moveToNext());
                  }

                  cursor.close();
                  db.close();
                  return tripList;
              }

              public List<Trip> getUnsyncedTrips() {
                  List<Trip> unsyncedTrips = new ArrayList<>();
                  String selectQuery = "SELECT * FROM " + TABLE_TRIPS + " WHERE " + COLUMN_SYNCED + " = 0 AND " + COLUMN_RETRY_COUNT + " < 5";

                  SQLiteDatabase db = this.getReadableDatabase();
                  Cursor cursor = db.rawQuery(selectQuery, null);

                  if (cursor.moveToFirst()) {
                      do {
                          Trip trip = new Trip();
                          trip.setId(cursor.getLong(cursor.getColumnIndexOrThrow(COLUMN_ID)));
                          trip.setStartLocation(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_START_LOCATION)));
                          trip.setEndLocation(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_END_LOCATION)));
                          trip.setDistance(cursor.getDouble(cursor.getColumnIndexOrThrow(COLUMN_DISTANCE)));
                          trip.setStartTime(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_START_TIME)));
                          trip.setEndTime(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_END_TIME)));
                          trip.setCategory(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_CATEGORY)));
                          trip.setClientName(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_CLIENT_NAME)));
                          trip.setNotes(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_NOTES)));
                          trip.setDeviceId(cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_DEVICE_ID)));
                          trip.setSynced(false);
                          trip.setRetryCount(cursor.getInt(cursor.getColumnIndexOrThrow(COLUMN_RETRY_COUNT)));

                          unsyncedTrips.add(trip);
                      } while (cursor.moveToNext());
                  }

                  cursor.close();
                  db.close();
                  return unsyncedTrips;
              }

              public void markTripAsSynced(long tripId) {
                  SQLiteDatabase db = this.getWritableDatabase();
                  ContentValues values = new ContentValues();
                  values.put(COLUMN_SYNCED, 1);
                  values.put(COLUMN_RETRY_COUNT, 0);

                  int rowsAffected = db.update(TABLE_TRIPS, values, COLUMN_ID + " = ?", new String[]{String.valueOf(tripId)});
                  db.close();

                  Log.d("TripStorage", "Trip " + tripId + " marked as synced. Rows affected: " + rowsAffected);
              }

              public void incrementTripRetryCount(long tripId) {
                  SQLiteDatabase db = this.getWritableDatabase();
                  db.execSQL("UPDATE " + TABLE_TRIPS + " SET " + COLUMN_RETRY_COUNT + " = " + COLUMN_RETRY_COUNT + " + 1 WHERE " + COLUMN_ID + " = ?", new String[]{String.valueOf(tripId)});
                  db.close();

                  Log.d("TripStorage", "Incremented retry count for trip " + tripId);
              }

              public int getUnsyncedTripCount() {
                  SQLiteDatabase db = this.getReadableDatabase();
                  Cursor cursor = db.rawQuery("SELECT COUNT(*) FROM " + TABLE_TRIPS + " WHERE " + COLUMN_SYNCED + " = 0", null);
                  cursor.moveToFirst();
                  int count = cursor.getInt(0);
                  cursor.close();
                  db.close();
                  return count;
              }

              // Settings methods
              public void saveSetting(String key, String value) {
                  SQLiteDatabase db = this.getWritableDatabase();
                  ContentValues values = new ContentValues();
                  values.put(COLUMN_KEY, key);
                  values.put(COLUMN_VALUE, value);

                  db.insertWithOnConflict(TABLE_SETTINGS, null, values, SQLiteDatabase.CONFLICT_REPLACE);
                  db.close();
              }

              public String getSetting(String key, String defaultValue) {
                  SQLiteDatabase db = this.getReadableDatabase();
                  Cursor cursor = db.query(TABLE_SETTINGS, new String[]{COLUMN_VALUE}, 
                          COLUMN_KEY + " = ?", new String[]{key}, null, null, null);

                  String value = defaultValue;
                  if (cursor.moveToFirst()) {
                      value = cursor.getString(cursor.getColumnIndexOrThrow(COLUMN_VALUE));
                  }

                  cursor.close();
                  db.close();
                  return value;
              }

              public boolean getBooleanSetting(String key, boolean defaultValue) {
                  String value = getSetting(key, String.valueOf(defaultValue));
                  return Boolean.parseBoolean(value);
              }

              public void saveBooleanSetting(String key, boolean value) {
                  saveSetting(key, String.valueOf(value));
              }
          }
          EOF

      - name: Create battery-optimized SyncService.java
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/SyncService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Service;
          import android.content.Intent;
          import android.os.Handler;
          import android.os.IBinder;
          import android.os.Looper;
          import android.util.Log;

          import com.miletrackerpro.app.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.ApiClient;

          import java.util.List;

          public class SyncService extends Service {
              private static final String TAG = "SyncService";
              private static final long SYNC_INTERVAL = 120000; // 2 minutes (battery optimized)

              private Handler syncHandler;
              private Runnable syncRunnable;
              private TripStorage tripStorage;
              private ApiClient apiClient;

              @Override
              public void onCreate() {
                  super.onCreate();
                  tripStorage = new TripStorage(this);
                  apiClient = new ApiClient();
                  syncHandler = new Handler(Looper.getMainLooper());

                  syncRunnable = new Runnable() {
                      @Override
                      public void run() {
                          syncUnsyncedTrips();
                          syncHandler.postDelayed(this, SYNC_INTERVAL);
                      }
                  };
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  Log.d(TAG, "Battery-optimized sync service started");
                  syncHandler.post(syncRunnable);
                  return START_STICKY;
              }

              @Override
              public void onDestroy() {
                  super.onDestroy();
                  if (syncHandler != null) {
                      syncHandler.removeCallbacks(syncRunnable);
                  }
                  Log.d(TAG, "Sync service destroyed");
              }

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }

              private void syncUnsyncedTrips() {
                  try {
                      // Battery optimization: Skip if no network
                      if (!isNetworkAvailable()) {
                          Log.d(TAG, "No network available, skipping sync to save battery");
                          return;
                      }

                      List<Trip> unsyncedTrips = tripStorage.getUnsyncedTrips();
                      
                      if (unsyncedTrips.isEmpty()) {
                          Log.d(TAG, "No unsynced trips to process");
                          return;
                      }

                      Log.d(TAG, "Found " + unsyncedTrips.size() + " unsynced trips to sync");

                      // Battery optimization: Limit to 3 trips per sync cycle
                      int processCount = Math.min(unsyncedTrips.size(), 3);
                      
                      for (int i = 0; i < processCount; i++) {
                          Trip trip = unsyncedTrips.get(i);
                          try {
                              boolean success = apiClient.syncTrip(trip);
                              
                              if (success) {
                                  tripStorage.markTripAsSynced(trip.getId());
                                  Log.d(TAG, "Successfully synced trip " + trip.getId());
                              } else {
                                  tripStorage.incrementTripRetryCount(trip.getId());
                                  Log.w(TAG, "Failed to sync trip " + trip.getId() + ", retry count: " + (trip.getRetryCount() + 1));
                              }
                          } catch (Exception e) {
                              Log.e(TAG, "Error syncing trip " + trip.getId(), e);
                              tripStorage.incrementTripRetryCount(trip.getId());
                          }
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Error in sync process", e);
                  }
              }

              private boolean isNetworkAvailable() {
                  try {
                      android.net.ConnectivityManager cm = (android.net.ConnectivityManager) 
                          getSystemService(android.content.Context.CONNECTIVITY_SERVICE);
                      android.net.NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      return activeNetwork != null && activeNetwork.isConnectedOrConnecting();
                  } catch (Exception e) {
                      return false;
                  }
              }

              public static void startSyncService(android.content.Context context) {
                  Intent intent = new Intent(context, SyncService.class);
                  context.startService(intent);
              }

              public static void stopSyncService(android.content.Context context) {
                  Intent intent = new Intent(context, SyncService.class);
                  context.stopService(intent);
              }
          }
          EOF

      - name: Create ApiClient.java with retry logic
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/ApiClient.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.util.Log;

          import com.google.gson.Gson;
          import com.google.gson.JsonObject;
          import com.miletrackerpro.app.Trip;

          import okhttp3.MediaType;
          import okhttp3.OkHttpClient;
          import okhttp3.Request;
          import okhttp3.RequestBody;
          import okhttp3.Response;

          import java.util.concurrent.TimeUnit;

          public class ApiClient {
              private static final String TAG = "ApiClient";
              private static final String BASE_URL = "https://18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev";
              private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

              private OkHttpClient client;
              private Gson gson;

              public ApiClient() {
                  client = new OkHttpClient.Builder()
                          .connectTimeout(10, TimeUnit.SECONDS)
                          .writeTimeout(10, TimeUnit.SECONDS)
                          .readTimeout(15, TimeUnit.SECONDS)
                          .build();
                  gson = new Gson();
              }

              public boolean syncTrip(Trip trip) {
                  try {
                      JsonObject tripJson = new JsonObject();
                      tripJson.addProperty("start_location", trip.getStartLocation());
                      tripJson.addProperty("end_location", trip.getEndLocation());
                      tripJson.addProperty("distance", trip.getDistance());
                      tripJson.addProperty("start_time", trip.getStartTime());
                      tripJson.addProperty("end_time", trip.getEndTime());
                      tripJson.addProperty("category", trip.getCategory());
                      tripJson.addProperty("client_name", trip.getClientName());
                      tripJson.addProperty("notes", trip.getNotes());
                      tripJson.addProperty("device_id", trip.getDeviceId());

                      String json = gson.toJson(tripJson);
                      RequestBody body = RequestBody.create(json, JSON);

                      Request request = new Request.Builder()
                              .url(BASE_URL + "/api/trips")
                              .post(body)
                              .build();

                      Response response = client.newCall(request).execute();
                      boolean success = response.isSuccessful();

                      Log.d(TAG, "Trip sync - ID: " + trip.getId() + ", Success: " + success + ", Response: " + response.code());

                      response.close();
                      return success;

                  } catch (Exception e) {
                      Log.e(TAG, "Error syncing trip " + trip.getId(), e);
                      return false;
                  }
              }

              public boolean authenticateUser(String email, String password) {
                  try {
                      JsonObject authJson = new JsonObject();
                      authJson.addProperty("email", email);
                      authJson.addProperty("password", password);

                      String json = gson.toJson(authJson);
                      RequestBody body = RequestBody.create(json, JSON);

                      Request request = new Request.Builder()
                              .url(BASE_URL + "/api/auth/login")
                              .post(body)
                              .build();

                      Response response = client.newCall(request).execute();
                      boolean success = response.isSuccessful();

                      Log.d(TAG, "User authentication - Email: " + email + ", Success: " + success + ", Response: " + response.code());

                      response.close();
                      return success;

                  } catch (Exception e) {
                      Log.e(TAG, "Error authenticating user " + email, e);
                      return false;
                  }
              }
          }
          EOF

      - name: Create MainActivity.java with sync status display
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.content.pm.PackageManager;
          import android.graphics.Color;
          import android.location.Address;
          import android.location.Geocoder;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Bundle;
          import android.os.Handler;
          import android.os.Looper;
          import android.util.Log;
          import android.view.View;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;

          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;

          import com.miletrackerpro.app.services.SyncService;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.ApiClient;

          import java.text.DecimalFormat;
          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;

          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final String TAG = "MainActivity";
              private static final int PERMISSION_REQUEST_CODE = 1001;

              private TextView statusText, speedText, syncStatusText;
              private Button autoToggleButton, manualButton, loginButton;
              private LinearLayout tripContainer, loginContainer;
              private ScrollView scrollView;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private ApiClient apiClient;
              private Handler uiHandler;

              private boolean isAutoDetectionEnabled = false;
              private boolean isManualTripActive = false;
              private Trip currentTrip;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  tripStorage = new TripStorage(this);
                  apiClient = new ApiClient();
                  uiHandler = new Handler(Looper.getMainLooper());

                  createUI();
                  requestPermissions();
                  
                  // Start sync service for missing trip recovery
                  SyncService.startSyncService(this);
                  
                  // Update sync status periodically
                  updateSyncStatus();
              }

              private void createUI() {
                  setContentView(createMainLayout());
              }

              private View createMainLayout() {
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(32, 32, 32, 32);
                  mainLayout.setBackgroundColor(Color.parseColor("#f8f9fa"));

                  // Title
                  TextView titleText = new TextView(this);
                  titleText.setText("MileTracker Pro v4.9.34\nReliable Sync + Missing Trip Recovery");
                  titleText.setTextSize(20);
                  titleText.setTextColor(Color.parseColor("#2c3e50"));
                  titleText.setPadding(0, 0, 0, 24);
                  mainLayout.addView(titleText);

                  // Login Container
                  loginContainer = new LinearLayout(this);
                  loginContainer.setOrientation(LinearLayout.VERTICAL);
                  loginContainer.setPadding(20, 20, 20, 20);
                  loginContainer.setBackgroundColor(Color.parseColor("#e3f2fd"));

                  TextView loginTitle = new TextView(this);
                  loginTitle.setText("User Authentication");
                  loginTitle.setTextSize(18);
                  loginTitle.setTextColor(Color.parseColor("#1976d2"));
                  loginTitle.setPadding(0, 0, 0, 16);
                  loginContainer.addView(loginTitle);

                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Enter your email");
                  emailInput.setPadding(16, 16, 16, 16);
                  emailInput.setId(View.generateViewId());
                  loginContainer.addView(emailInput);

                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Enter your password");
                  passwordInput.setPadding(16, 16, 16, 16);
                  passwordInput.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setId(View.generateViewId());
                  loginContainer.addView(passwordInput);

                  loginButton = new Button(this);
                  loginButton.setText("Login / Register");
                  loginButton.setBackgroundColor(Color.parseColor("#1976d2"));
                  loginButton.setTextColor(Color.WHITE);
                  loginButton.setPadding(0, 24, 0, 24);
                  
                  loginButton.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          String email = emailInput.getText().toString().trim();
                          String password = passwordInput.getText().toString().trim();
                          
                          if (email.isEmpty() || password.isEmpty()) {
                              Toast.makeText(MainActivity.this, "Please enter email and password", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          
                          authenticateUser(email, password);
                      }
                  });
                  
                  loginContainer.addView(loginButton);
                  mainLayout.addView(loginContainer);

                  // Status display
                  statusText = new TextView(this);
                  statusText.setText("Ready - GPS Auto Detection");
                  statusText.setTextSize(16);
                  statusText.setTextColor(Color.parseColor("#2c3e50"));
                  statusText.setPadding(0, 24, 0, 8);
                  mainLayout.addView(statusText);

                  speedText = new TextView(this);
                  speedText.setText("Speed: 0.0 mph");
                  speedText.setTextSize(14);
                  speedText.setTextColor(Color.parseColor("#666"));
                  speedText.setPadding(0, 0, 0, 16);
                  mainLayout.addView(speedText);

                  // Sync status with missing trip recovery indicator
                  syncStatusText = new TextView(this);
                  syncStatusText.setText("Sync Status: Battery-optimized recovery active...");
                  syncStatusText.setTextSize(14);
                  syncStatusText.setTextColor(Color.parseColor("#e67e22"));
                  syncStatusText.setPadding(0, 0, 0, 16);
                  mainLayout.addView(syncStatusText);

                  // Auto detection toggle
                  autoToggleButton = new Button(this);
                  autoToggleButton.setText("Auto Detection: OFF");
                  autoToggleButton.setBackgroundColor(Color.parseColor("#95a5a6"));
                  autoToggleButton.setTextColor(Color.WHITE);
                  autoToggleButton.setPadding(0, 24, 0, 24);
                  
                  autoToggleButton.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          toggleAutoDetection();
                      }
                  });
                  
                  mainLayout.addView(autoToggleButton);

                  // Manual trip button
                  manualButton = new Button(this);
                  manualButton.setText("START MANUAL TRIP");
                  manualButton.setBackgroundColor(Color.parseColor("#27ae60"));
                  manualButton.setTextColor(Color.WHITE);
                  manualButton.setPadding(0, 24, 0, 24);
                  
                  manualButton.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          toggleManualTrip();
                      }
                  });
                  
                  mainLayout.addView(manualButton);

                  // Trip list container
                  TextView tripsTitle = new TextView(this);
                  tripsTitle.setText("Recent Trips");
                  tripsTitle.setTextSize(18);
                  tripsTitle.setTextColor(Color.parseColor("#2c3e50"));
                  tripsTitle.setPadding(0, 32, 0, 16);
                  mainLayout.addView(tripsTitle);

                  scrollView = new ScrollView(this);
                  tripContainer = new LinearLayout(this);
                  tripContainer.setOrientation(LinearLayout.VERTICAL);
                  scrollView.addView(tripContainer);
                  mainLayout.addView(scrollView);

                  return mainLayout;
              }

              private void authenticateUser(String email, String password) {
                  loginButton.setText("Authenticating...");
                  loginButton.setEnabled(false);

                  new Thread(new Runnable() {
                      @Override
                      public void run() {
                          boolean success = apiClient.authenticateUser(email, password);
                          
                          uiHandler.post(new Runnable() {
                              @Override
                              public void run() {
                                  if (success) {
                                      tripStorage.saveSetting(TripStorage.USER_EMAIL_KEY, email);
                                      tripStorage.saveBooleanSetting(TripStorage.IS_LOGGED_IN_KEY, true);
                                      
                                      loginContainer.setVisibility(View.GONE);
                                      Toast.makeText(MainActivity.this, "Successfully logged in as " + email, Toast.LENGTH_LONG).show();
                                      
                                      // Force immediate sync of all unsynced trips
                                      forceSyncAllTrips();
                                      
                                  } else {
                                      Toast.makeText(MainActivity.this, "Login failed. Please check credentials.", Toast.LENGTH_LONG).show();
                                  }
                                  
                                  loginButton.setText("Login / Register");
                                  loginButton.setEnabled(true);
                              }
                          });
                      }
                  }).start();
              }

              private void forceSyncAllTrips() {
                  new Thread(new Runnable() {
                      @Override
                      public void run() {
                          List<Trip> unsyncedTrips = tripStorage.getUnsyncedTrips();
                          
                          for (Trip trip : unsyncedTrips) {
                              boolean success = apiClient.syncTrip(trip);
                              if (success) {
                                  tripStorage.markTripAsSynced(trip.getId());
                                  Log.d(TAG, "Force synced trip during authentication: " + trip.getId());
                              }
                          }
                          
                          uiHandler.post(new Runnable() {
                              @Override
                              public void run() {
                                  updateSyncStatus();
                                  loadTrips();
                              }
                          });
                      }
                  }).start();
              }

              private void updateSyncStatus() {
                  new Thread(new Runnable() {
                      @Override
                      public void run() {
                          int unsyncedCount = tripStorage.getUnsyncedTripCount();
                          int totalTrips = tripStorage.getAllTrips().size();
                          
                          uiHandler.post(new Runnable() {
                              @Override
                              public void run() {
                                  if (unsyncedCount == 0) {
                                      syncStatusText.setText("✓ All " + totalTrips + " trips synced to cloud");
                                      syncStatusText.setTextColor(Color.parseColor("#27ae60"));
                                  } else {
                                      syncStatusText.setText("⚠ " + unsyncedCount + " trips pending sync (auto-recovering...)");
                                      syncStatusText.setTextColor(Color.parseColor("#e67e22"));
                                  }
                              }
                          });
                      }
                  }).start();

                  // Update every 10 seconds
                  uiHandler.postDelayed(new Runnable() {
                      @Override
                      public void run() {
                          updateSyncStatus();
                      }
                  }, 10000);
              }

              private void toggleAutoDetection() {
                  isAutoDetectionEnabled = !isAutoDetectionEnabled;
                  tripStorage.saveBooleanSetting(TripStorage.AUTO_DETECTION_KEY, isAutoDetectionEnabled);

                  if (isAutoDetectionEnabled) {
                      autoToggleButton.setText("Auto Detection: ON");
                      autoToggleButton.setBackgroundColor(Color.parseColor("#27ae60"));
                      statusText.setText("Monitoring for movement...");
                      startLocationUpdates();
                  } else {
                      autoToggleButton.setText("Auto Detection: OFF");
                      autoToggleButton.setBackgroundColor(Color.parseColor("#95a5a6"));
                      statusText.setText("Auto detection disabled");
                      stopLocationUpdates();
                  }
              }

              private void toggleManualTrip() {
                  if (!isManualTripActive) {
                      startManualTrip();
                  } else {
                      endManualTrip();
                  }
              }

              private void startManualTrip() {
                  currentTrip = new Trip();
                  currentTrip.setStartTime(getCurrentTimeString());
                  currentTrip.setDeviceId(getDeviceId());
                  currentTrip.setCategory("Business");

                  isManualTripActive = true;
                  manualButton.setText("END MANUAL TRIP");
                  manualButton.setBackgroundColor(Color.parseColor("#e74c3c"));
                  statusText.setText("Manual trip in progress...");

                  startLocationUpdates();
              }

              private void endManualTrip() {
                  if (currentTrip != null) {
                      currentTrip.setEndTime(getCurrentTimeString());
                      
                      if (currentTrip.getStartLocation() == null) {
                          currentTrip.setStartLocation("Manual Start");
                      }
                      if (currentTrip.getEndLocation() == null) {
                          currentTrip.setEndLocation("Manual End");
                      }
                      if (currentTrip.getDistance() <= 0) {
                          currentTrip.setDistance(1.0);
                      }

                      saveTrip(currentTrip);
                      currentTrip = null;
                  }

                  isManualTripActive = false;
                  manualButton.setText("START MANUAL TRIP");
                  manualButton.setBackgroundColor(Color.parseColor("#27ae60"));
                  statusText.setText("Manual trip ended");

                  if (!isAutoDetectionEnabled) {
                      stopLocationUpdates();
                  }
              }

              private void saveTrip(Trip trip) {
                  long tripId = tripStorage.addTrip(trip);
                  Log.d(TAG, "Trip saved locally with ID: " + tripId);
                  
                  loadTrips();
                  updateSyncStatus();
                  
                  Toast.makeText(this, "Trip saved: " + String.format("%.1f", trip.getDistance()) + " miles", Toast.LENGTH_SHORT).show();
              }

              private void loadTrips() {
                  List<Trip> trips = tripStorage.getAllTrips();
                  tripContainer.removeAllViews();

                  DecimalFormat df = new DecimalFormat("#.##");
                  
                  for (Trip trip : trips) {
                      LinearLayout tripCard = new LinearLayout(this);
                      tripCard.setOrientation(LinearLayout.VERTICAL);
                      tripCard.setPadding(24, 16, 24, 16);
                      tripCard.setBackgroundColor(Color.WHITE);
                      
                      LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT,
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      cardParams.setMargins(0, 0, 0, 16);
                      tripCard.setLayoutParams(cardParams);

                      // Trip header with sync status
                      TextView headerText = new TextView(this);
                      String syncIndicator = trip.isSynced() ? "✓" : "⏳";
                      headerText.setText(syncIndicator + " " + df.format(trip.getDistance()) + " miles • " + trip.getFormattedStartTime());
                      headerText.setTextSize(16);
                      headerText.setTextColor(Color.parseColor("#2c3e50"));
                      tripCard.addView(headerText);

                      // Trip details
                      TextView detailText = new TextView(this);
                      detailText.setText("From: " + trip.getStartLocation() + "\nTo: " + trip.getEndLocation());
                      detailText.setTextSize(14);
                      detailText.setTextColor(Color.parseColor("#666"));
                      detailText.setPadding(0, 8, 0, 0);
                      tripCard.addView(detailText);

                      tripContainer.addView(tripCard);
                  }
              }

              // Location and permission methods
              private void requestPermissions() {
                  String[] permissions = {
                      Manifest.permission.ACCESS_FINE_LOCATION,
                      Manifest.permission.ACCESS_COARSE_LOCATION,
                      Manifest.permission.ACCESS_BACKGROUND_LOCATION
                  };

                  boolean needsPermission = false;
                  for (String permission : permissions) {
                      if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                          needsPermission = true;
                          break;
                      }
                  }

                  if (needsPermission) {
                      ActivityCompat.requestPermissions(this, permissions, PERMISSION_REQUEST_CODE);
                  } else {
                      initializeApp();
                  }
              }

              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  
                  if (requestCode == PERMISSION_REQUEST_CODE) {
                      boolean allGranted = true;
                      for (int result : grantResults) {
                          if (result != PackageManager.PERMISSION_GRANTED) {
                              allGranted = false;
                              break;
                          }
                      }

                      if (allGranted) {
                          initializeApp();
                      } else {
                          Toast.makeText(this, "Location permissions required for trip tracking", Toast.LENGTH_LONG).show();
                      }
                  }
              }

              private void initializeApp() {
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                  loadTrips();
                  
                  // Check if user is already logged in
                  boolean isLoggedIn = tripStorage.getBooleanSetting(TripStorage.IS_LOGGED_IN_KEY, false);
                  if (isLoggedIn) {
                      loginContainer.setVisibility(View.GONE);
                  }
                  
                  // Restore auto detection state
                  isAutoDetectionEnabled = tripStorage.getBooleanSetting(TripStorage.AUTO_DETECTION_KEY, false);
                  if (isAutoDetectionEnabled) {
                      toggleAutoDetection();
                  }
              }

              private void startLocationUpdates() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 5000, 10, this);
                      locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 5000, 10, this);
                  }
              }

              private void stopLocationUpdates() {
                  if (locationManager != null) {
                      locationManager.removeUpdates(this);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  float speedMps = location.getSpeed();
                  float speedMph = speedMps * 2.237f;
                  
                  uiHandler.post(new Runnable() {
                      @Override
                      public void run() {
                          speedText.setText(String.format("Speed: %.1f mph", speedMph));
                      }
                  });

                  if (currentTrip != null && isManualTripActive) {
                      updateTripLocation(location);
                  }
              }

              private void updateTripLocation(Location location) {
                  if (currentTrip.getStartLocation() == null) {
                      String address = getAddressFromLocation(location.getLatitude(), location.getLongitude());
                      currentTrip.setStartLocation(address);
                  } else {
                      String address = getAddressFromLocation(location.getLatitude(), location.getLongitude());
                      currentTrip.setEndLocation(address);
                      
                      // Simple distance calculation
                      currentTrip.setDistance(currentTrip.getDistance() + 0.1);
                  }
              }

              private String getAddressFromLocation(double latitude, double longitude) {
                  try {
                      Geocoder geocoder = new Geocoder(this, Locale.getDefault());
                      List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                      
                      if (addresses != null && !addresses.isEmpty()) {
                          Address address = addresses.get(0);
                          return address.getAddressLine(0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting address", e);
                  }
                  
                  return String.format("%.4f, %.4f", latitude, longitude);
              }

              private String getCurrentTimeString() {
                  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());
                  return sdf.format(new Date());
              }

              private String getDeviceId() {
                  return "android-" + android.provider.Settings.Secure.getString(getContentResolver(), android.provider.Settings.Secure.ANDROID_ID);
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  stopLocationUpdates();
              }
          }
          EOF

      - name: Create resource files
        run: |
          # Create strings.xml
          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <resources>
              <string name="app_name">MileTracker Pro</string>
          </resources>
          EOF

          # Create themes.xml
          cat > android/app/src/main/res/values/themes.xml << 'EOF'
          <resources xmlns:tools="http://schemas.android.com/tools">
              <style name="Theme.MileTrackerPro" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryVariant">#5a67d8</item>
                  <item name="colorOnPrimary">#ffffff</item>
                  <item name="colorSecondary">#03dac5</item>
                  <item name="colorSecondaryVariant">#018786</item>
                  <item name="colorOnSecondary">#000000</item>
                  <item name="android:statusBarColor" tools:targetApi="l">#5a67d8</item>
              </style>
          </resources>
          EOF

          # Create backup and data extraction rules
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/backup_rules.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <full-backup-content>
          </full-backup-content>
          EOF

          cat > android/app/src/main/res/xml/data_extraction_rules.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <data-extraction-rules>
              <cloud-backup>
              </cloud-backup>
              <device-transfer>
              </device-transfer>
          </data-extraction-rules>
          EOF

      - name: Create app icon placeholders
        run: |
          mkdir -p android/app/src/main/res/mipmap-hdpi
          mkdir -p android/app/src/main/res/mipmap-mdpi
          mkdir -p android/app/src/main/res/mipmap-xhdpi
          mkdir -p android/app/src/main/res/mipmap-xxhdpi
          mkdir -p android/app/src/main/res/mipmap-xxxhdpi

          # Create placeholder icon files
          for dir in mipmap-hdpi mipmap-mdpi mipmap-xhdpi mipmap-xxhdpi mipmap-xxxhdpi; do
              touch android/app/src/main/res/$dir/ic_launcher.png
              touch android/app/src/main/res/$dir/ic_launcher_round.png
          done

      - name: Create BackgroundLocationService.java placeholder
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BackgroundLocationService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Service;
          import android.content.Intent;
          import android.os.IBinder;

          public class BackgroundLocationService extends Service {
              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  return START_STICKY;
              }
          }
          EOF

      - name: Create proguard rules
        run: |
          cat > android/app/proguard-rules.pro << 'EOF'
          -keep class com.miletrackerpro.app.** { *; }
          -keepclassmembers class * {
              @android.webkit.JavascriptInterface <methods>;
          }
          EOF

      - name: Build Android APK
        run: |
          cd android
          gradle clean
          gradle assembleRelease --no-daemon --stacktrace

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: MileTrackerPro-v4.9.34-GradleFixed-ReliableSync
          path: android/app/build/outputs/apk/release/*.apk
          retention-days: 30
