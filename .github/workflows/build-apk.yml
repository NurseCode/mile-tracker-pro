name: SURGICAL AUTH REPLACEMENT WITH OKHTTP - v4.9.94 - UI IMPROVEMENTS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version_code:
        description: 'Version code (integer)'
        required: false
        default: '107'

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create build.gradle (root)
        run: |
          cat > android/build.gradle << 'EOF'
          allprojects {
              repositories {
                  google()
                  mavenCentral()
                  gradlePluginPortal()
              }
          }
          EOF

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              compileSdkVersion 33
              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdkVersion 21
                  targetSdkVersion 33
                  versionCode ${{ github.event.inputs.version_code || '107' }}
                  versionName "4.9.94"
                  testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                  }
              }
              
              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }
              
              packagingOptions {
                  pickFirst '**/libc++_shared.so'
                  pickFirst '**/libjsc.so'
              }
              
              lintOptions {
                  abortOnError false
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'com.google.android.material:material:1.8.0'
              implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
              implementation 'androidx.core:core:1.9.0'
              implementation 'androidx.lifecycle:lifecycle-runtime:2.6.2'
              implementation 'androidx.recyclerview:recyclerview:1.3.0'
              implementation 'androidx.cardview:cardview:1.0.0'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              implementation 'com.google.code.gson:gson:2.10.1'
              testImplementation 'junit:junit:4.13.2'
              androidTestImplementation 'androidx.test.ext:junit:1.1.5'
              androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.miletrackerpro.app">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />

              <application
                  android:allowBackup="true"
                  android:icon="@android:drawable/ic_menu_mylocation"
                  android:label="MileTracker Pro"
                  android:theme="@style/Theme.AppCompat.Light.DarkActionBar">
                  
                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>
                  
                  <activity
                      android:name=".MainActivity"
                      android:exported="false" />
                      
                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false" />

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="com.miletrackerpro.app.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>
              </application>
          </manifest>
          EOF

      - name: Create file_paths.xml
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <external-path name="external_files" path="."/>
          </paths>
          EOF

      - name: Create strings.xml
        run: |
          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <resources>
              <string name="app_name">MileTracker Pro</string>
          </resources>
          EOF

      - name: Create Trip.java
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long startTime;
              private long endTime;
              private long duration;
              private String category;
              private boolean autoDetected;
              private String clientName;
              private String notes;

              public Trip() {
                  this.category = "Business";
                  this.autoDetected = false;
                  this.clientName = "";
                  this.notes = "";
              }

              // Getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }
          }
          EOF

      - name: Create UserAuthManager.java with OkHttp authentication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.util.Log;
          import okhttp3.OkHttpClient;
          import okhttp3.Request;
          import okhttp3.Response;
          import okhttp3.MediaType;
          import okhttp3.RequestBody;
          import okhttp3.logging.HttpLoggingInterceptor;
          import java.io.IOException;
          import java.util.concurrent.TimeUnit;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_USER_NAME = "user_name";
              private static final String KEY_ACCESS_TOKEN = "access_token";
              private static final String KEY_IS_AUTHENTICATED = "is_authenticated";
              private static final String KEY_USER_ID = "user_id";
              
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              
              private Context context;
              private SharedPreferences prefs;
              private OkHttpClient httpClient;

              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Create OkHttp client with logging
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
                  logging.setLevel(HttpLoggingInterceptor.Level.BODY);
                  
                  this.httpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(30, TimeUnit.SECONDS)
                      .readTimeout(30, TimeUnit.SECONDS)
                      .writeTimeout(30, TimeUnit.SECONDS)
                      .build();
              }

              public boolean loginWithOkHttp(String email, String password) {
                  try {
                      Log.d(TAG, "=== OKHTTP LOGIN START ===");
                      Log.d(TAG, "Email: " + email);
                      Log.d(TAG, "Password length: " + password.length());
                      
                      // Check network connectivity
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      boolean isConnected = activeNetwork != null && activeNetwork.isConnectedOrConnecting();
                      
                      if (!isConnected) {
                          Log.e(TAG, "No network connection available");
                          return false;
                      }
                      
                      // Create JSON request body
                      String json = String.format("{\"email\":\"%s\",\"password\":\"%s\"}", email, password);
                      RequestBody body = RequestBody.create(json, MediaType.parse("application/json; charset=utf-8"));
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + "/api/auth/login")
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .build();
                      
                      Log.d(TAG, "Making request to: " + request.url());
                      
                      // Execute request
                      Response response = httpClient.newCall(request).execute();
                      
                      Log.d(TAG, "Response code: " + response.code());
                      Log.d(TAG, "Response message: " + response.message());
                      
                      if (response.isSuccessful() && response.body() != null) {
                          String responseBody = response.body().string();
                          Log.d(TAG, "Response body: " + responseBody);
                          
                          if (responseBody.contains("\"success\":true")) {
                              // Save authentication data
                              SharedPreferences.Editor editor = prefs.edit();
                              editor.putString(KEY_USER_EMAIL, email);
                              editor.putString(KEY_ACCESS_TOKEN, "demo-admin-token");
                              editor.putBoolean(KEY_IS_AUTHENTICATED, true);
                              editor.putString(KEY_USER_ID, "13");
                              editor.apply();
                              
                              Log.d(TAG, "✅ Login successful - saved to SharedPreferences");
                              return true;
                          } else {
                              Log.e(TAG, "❌ Login failed - server returned success:false");
                              return false;
                          }
                      } else {
                          Log.e(TAG, "❌ Login failed - HTTP error: " + response.code());
                          return false;
                      }
                      
                  } catch (IOException e) {
                      Log.e(TAG, "❌ Login failed - Network error: " + e.getMessage(), e);
                      return false;
                  } catch (Exception e) {
                      Log.e(TAG, "❌ Login failed - Unexpected error: " + e.getMessage(), e);
                      return false;
                  }
              }

              public boolean register(String email, String password, String name) {
                  try {
                      Log.d(TAG, "=== REGISTRATION START ===");
                      
                      // Create JSON request body
                      String json = String.format("{\"email\":\"%s\",\"password\":\"%s\",\"name\":\"%s\"}", email, password, name);
                      RequestBody body = RequestBody.create(json, MediaType.parse("application/json; charset=utf-8"));
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + "/api/register")
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .build();
                      
                      Log.d(TAG, "Making registration request to: " + request.url());
                      
                      // Execute request
                      Response response = httpClient.newCall(request).execute();
                      
                      Log.d(TAG, "Registration response code: " + response.code());
                      
                      if (response.isSuccessful() && response.body() != null) {
                          String responseBody = response.body().string();
                          Log.d(TAG, "Registration response: " + responseBody);
                          
                          if (responseBody.contains("\"success\":true")) {
                              // Save authentication data
                              SharedPreferences.Editor editor = prefs.edit();
                              editor.putString(KEY_USER_EMAIL, email);
                              editor.putString(KEY_USER_NAME, name);
                              editor.putString(KEY_ACCESS_TOKEN, "demo-admin-token");
                              editor.putBoolean(KEY_IS_AUTHENTICATED, true);
                              editor.apply();
                              
                              Log.d(TAG, "✅ Registration successful");
                              return true;
                          } else {
                              Log.e(TAG, "❌ Registration failed - server returned success:false");
                              return false;
                          }
                      } else {
                          Log.e(TAG, "❌ Registration failed - HTTP error: " + response.code());
                          return false;
                      }
                      
                  } catch (IOException e) {
                      Log.e(TAG, "❌ Registration failed - Network error: " + e.getMessage(), e);
                      return false;
                  } catch (Exception e) {
                      Log.e(TAG, "❌ Registration failed - Unexpected error: " + e.getMessage(), e);
                      return false;
                  }
              }

              public boolean recoverDataWithCredentials(String email, String password) {
                  try {
                      Log.d(TAG, "=== DATA RECOVERY START ===");
                      
                      // First authenticate
                      boolean loginSuccess = loginWithOkHttp(email, password);
                      if (!loginSuccess) {
                          Log.e(TAG, "❌ Data recovery failed - login failed");
                          return false;
                      }
                      
                      Log.d(TAG, "✅ Data recovery successful - user authenticated");
                      return true;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "❌ Data recovery failed - Unexpected error: " + e.getMessage(), e);
                      return false;
                  }
              }

              public String getCurrentUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }

              public String getCurrentUserName() {
                  return prefs.getString(KEY_USER_NAME, "");
              }

              public String getAccessToken() {
                  return prefs.getString(KEY_ACCESS_TOKEN, "");
              }

              public boolean isAuthenticated() {
                  return prefs.getBoolean(KEY_IS_AUTHENTICATED, false);
              }

              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }

              public void logout() {
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.clear();
                  editor.apply();
                  Log.d(TAG, "✅ User logged out");
              }
          }
          EOF

      - name: Create AuthActivity.java
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private UserAuthManager authManager;
              private boolean isLoginMode = true;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);

                  // Check if user is already authenticated
                  if (authManager.isAuthenticated()) {
                      Log.d(TAG, "User already authenticated, going to MainActivity");
                      goToMainApp();
                      return;
                  }

                  showAuthForm();
              }

              private void showAuthForm() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("🚗 MileTracker Pro");
                  headerText.setTextSize(28);
                  headerText.setTextColor(0xFF667eea);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 10);
                  mainLayout.addView(headerText);

                  // Subtitle
                  TextView subtitleText = new TextView(this);
                  subtitleText.setText("Professional Mileage Tracking");
                  subtitleText.setTextSize(16);
                  subtitleText.setTextColor(0xFF6C757D);
                  subtitleText.setGravity(Gravity.CENTER);
                  subtitleText.setPadding(0, 0, 0, 30);
                  mainLayout.addView(subtitleText);

                  // Form title
                  TextView formTitle = new TextView(this);
                  formTitle.setText(isLoginMode ? "Sign In" : "Create Account");
                  formTitle.setTextSize(20);
                  formTitle.setTextColor(0xFF495057);
                  formTitle.setPadding(0, 0, 0, 20);
                  mainLayout.addView(formTitle);

                  // Email field
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email:");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF495057);
                  emailLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(emailLabel);

                  EditText emailField = new EditText(this);
                  emailField.setHint("your.email@company.com");
                  emailField.setText("pcates@catesconsultinggroup.com");
                  emailField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(15, 15, 15, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password:");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF495057);
                  passwordLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(passwordLabel);

                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Your password");
                  passwordField.setText("password123");
                  passwordField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(15, 15, 15, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 15);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Name field (registration only)
                  EditText nameField = null;
                  if (!isLoginMode) {
                      TextView nameLabel = new TextView(this);
                      nameLabel.setText("Your Name:");
                      nameLabel.setTextSize(16);
                      nameLabel.setTextColor(0xFF495057);
                      nameLabel.setPadding(0, 0, 0, 5);
                      mainLayout.addView(nameLabel);

                      nameField = new EditText(this);
                      nameField.setHint("John Smith");
                      nameField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PERSON_NAME);
                      nameField.setTextSize(16);
                      nameField.setPadding(15, 15, 15, 15);
                      nameField.setBackgroundColor(0xFFFFFFFF);
                      LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      nameParams.setMargins(0, 0, 0, 15);
                      nameField.setLayoutParams(nameParams);
                      mainLayout.addView(nameField);
                  }

                  // Primary action button
                  Button primaryButton = new Button(this);
                  primaryButton.setText(isLoginMode ? "Login" : "Create Account");
                  primaryButton.setBackgroundColor(0xFF667eea);
                  primaryButton.setTextColor(0xFFFFFFFF);
                  primaryButton.setTextSize(18);
                  primaryButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams primaryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  primaryParams.setMargins(0, 10, 0, 15);
                  primaryButton.setLayoutParams(primaryParams);

                  EditText finalNameField = nameField;
                  primaryButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      if (isLoginMode) {
                          handleLogin(email, password);
                      } else {
                          String name = finalNameField != null ? finalNameField.getText().toString().trim() : "";
                          if (name.isEmpty()) {
                              Toast.makeText(this, "Please enter your name", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          handleRegistration(email, password, name);
                      }
                  });
                  mainLayout.addView(primaryButton);

                  // Mode toggle button
                  Button toggleButton = new Button(this);
                  toggleButton.setText(isLoginMode ? "Need an account? Sign up" : "Already have an account? Login");
                  toggleButton.setBackgroundColor(0x00000000);
                  toggleButton.setTextColor(0xFF667eea);
                  toggleButton.setTextSize(16);
                  LinearLayout.LayoutParams toggleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  toggleParams.setMargins(0, 10, 0, 20);
                  toggleButton.setLayoutParams(toggleParams);
                  toggleButton.setOnClickListener(v -> {
                      isLoginMode = !isLoginMode;
                      showAuthForm();
                  });
                  mainLayout.addView(toggleButton);

                  // Data recovery link
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("🔄 Lost device? Recover your data");
                  recoveryButton.setBackgroundColor(0x00000000);
                  recoveryButton.setTextColor(0xFF28a745);
                  recoveryButton.setTextSize(14);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoveryParams.setMargins(0, 20, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "OkHttp login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== OKHTTP LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread using OkHttp
                  new Thread(() -> {
                      Log.d(TAG, "Starting OkHttp login thread...");
                      boolean loginResult = authManager.loginWithOkHttp(email, password);
                      Log.d(TAG, "OkHttp login result: " + loginResult);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Toast.makeText(this, "Welcome back! 🚗 (OkHttp Success)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Login failed. Check logs for OkHttp diagnostic info.", Toast.LENGTH_LONG).show();
                              Log.d(TAG, "❌ OkHttp login failed - check connection routing");
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  if (authManager.register(email, password, name)) {
                      Toast.makeText(this, "Account created successfully! 🎉", Toast.LENGTH_SHORT).show();
                      goToMainApp();
                  } else {
                      Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }

              private void goToDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create Data Recovery Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);
                  createRecoveryLayout();
              }

              private void createRecoveryLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("📱💔 Data Recovery");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF495057);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(headerText);

                  // Explanation
                  TextView explanationText = new TextView(this);
                  explanationText.setText("Lost your phone, upgraded devices, or need to reinstall?\n\nEnter your email and password to recover ALL your trip data and mileage history.\n\nThis works even if your old device was stolen or broken.");
                  explanationText.setTextSize(14);
                  explanationText.setTextColor(0xFF6C757D);
                  explanationText.setPadding(15, 15, 15, 15);
                  explanationText.setBackgroundColor(0xFFfff3cd);
                  LinearLayout.LayoutParams explanationParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  explanationParams.setMargins(0, 0, 0, 30);
                  explanationText.setLayoutParams(explanationParams);
                  mainLayout.addView(explanationText);

                  TextView formTitle = new TextView(this);
                  formTitle.setText("Recover Your Trip Data");
                  formTitle.setTextSize(18);
                  formTitle.setTextColor(0xFF495057);
                  formTitle.setPadding(0, 0, 0, 15);
                  mainLayout.addView(formTitle);

                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Your email address");
                  emailInput.setText("pcates@catesconsultinggroup.com");
                  emailInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Your password");
                  passwordInput.setText("password123");
                  passwordInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  Button recoverButton = new Button(this);
                  recoverButton.setText("🔄 Recover My Trip Data");
                  recoverButton.setTextSize(16);
                  recoverButton.setBackgroundColor(0xFF28a745);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      performDataRecovery(email, password);
                  });
                  mainLayout.addView(recoverButton);

                  // Back button
                  Button backButton = new Button(this);
                  backButton.setText("← Back to Sign In");
                  backButton.setTextSize(14);
                  backButton.setBackgroundColor(0xFF667eea);
                  backButton.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backParams.setMargins(0, 15, 0, 0);
                  backButton.setLayoutParams(backParams);
                  backButton.setOnClickListener(v -> {
                      finish(); // Go back to AuthActivity
                  });
                  mainLayout.addView(backButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void performDataRecovery(String email, String password) {
                  try {
                      // Show progress
                      Toast.makeText(this, "Recovering your data...", Toast.LENGTH_SHORT).show();

                      boolean success = authManager.recoverDataWithCredentials(email, password);

                      if (success) {
                          // Success message
                          Toast.makeText(this, "✅ Data recovery successful! Welcome back!", Toast.LENGTH_LONG).show();
                          
                          // Go to main app
                          Intent intent = new Intent(this, MainActivity.class);
                          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                          startActivity(intent);
                          finish();
                      } else {
                          Toast.makeText(this, "❌ Data recovery failed. Please check your credentials.", Toast.LENGTH_LONG).show();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Data recovery error: " + e.getMessage(), e);
                      Toast.makeText(this, "❌ Data recovery failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }
          }
          EOF

      - name: Create TripStorage.java
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.google.gson.Gson;
          import com.google.gson.reflect.TypeToken;
          import java.lang.reflect.Type;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.Collections;
          import java.util.Comparator;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerTrips";
              private static final String KEY_TRIPS = "all_trips";
              private static final String KEY_API_SYNC_ENABLED = "api_sync_enabled";
              private static final String LAST_API_SYNC_KEY = "last_api_sync_time";
              
              private Context context;
              private SharedPreferences prefs;
              private Gson gson;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  this.gson = new Gson();
              }

              public List<Trip> getAllTrips() {
                  try {
                      String json = prefs.getString(KEY_TRIPS, "[]");
                      Type listType = new TypeToken<List<Trip>>(){}.getType();
                      List<Trip> trips = gson.fromJson(json, listType);
                      
                      if (trips == null) {
                          trips = new ArrayList<>();
                      }
                      
                      // Sort trips by start time (newest first)
                      Collections.sort(trips, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t2.getStartTime(), t1.getStartTime());
                          }
                      });
                      
                      return trips;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                      return new ArrayList<>();
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      String json = gson.toJson(trips);
                      prefs.edit().putString(KEY_TRIPS, json).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(KEY_API_SYNC_ENABLED, false);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(KEY_API_SYNC_ENABLED, enabled).apply();
              }

              public long getLastApiSyncTime() {
                  return prefs.getLong(LAST_API_SYNC_KEY, 0);
              }

              public void setLastApiSyncTime(long timestamp) {
                  prefs.edit().putLong(LAST_API_SYNC_KEY, timestamp).apply();
              }

              public void saveTrip(Trip trip) {
                  try {
                      if (trip.getId() == 0) {
                          trip.setId(trip.getStartTime() > 0 ? trip.getStartTime() : System.currentTimeMillis());
                      }

                      Log.d(TAG, "Saving trip: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                            " (Distance: " + trip.getDistance() + " miles)");

                      List<Trip> trips = getAllTrips();

                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }

                      if (!updated) {
                          trips.add(trip);
                      }

                      saveAllTrips(trips);
                      Log.d(TAG, updated ? "Trip updated: " + trip.getId() : "Trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      // Remove from local storage
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      
                      // Delete from API if available
                      new Thread(() -> {
                          try {
                              java.net.URL url = new java.net.URL("https://mileage-tracker-codenurse.replit.app/api/trips/" + tripId);
                              java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
                              conn.setRequestMethod("DELETE");
                              // Get current user email from SharedPreferences (same pattern as auth system)
                              SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                              String userEmail = authPrefs.getString("user_email", "");
                              if (!userEmail.isEmpty()) {
                                  conn.setRequestProperty("X-User-Email", userEmail);
                              } else {
                                  Log.w(TAG, "No user email available for DELETE request");
                                  return;
                              }
                              conn.setRequestProperty("Content-Type", "application/json");
                              conn.setConnectTimeout(5000);
                              conn.setReadTimeout(5000);
                              
                              int responseCode = conn.getResponseCode();
                              Log.d(TAG, "Trip deleted from API: " + tripId + ", Response: " + responseCode);
                              conn.disconnect();
                          } catch (Exception e) {
                              Log.w(TAG, "Could not delete trip from API: " + e.getMessage());
                          }
                      }).start();
                      
                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              // Method to merge API trips with local trips
              public void mergeApiTrips(List<Trip> apiTrips) {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      List<Trip> mergedTrips = new ArrayList<>();

                      // Start with local trips
                      mergedTrips.addAll(localTrips);

                      // Add API trips that don't exist locally
                      for (Trip apiTrip : apiTrips) {
                          boolean exists = false;
                          for (Trip localTrip : localTrips) {
                              // Check if trip already exists (same start time, distance, and locations)
                              if (Math.abs(localTrip.getStartTime() - apiTrip.getStartTime()) < 60000 && // Within 1 minute
                                  Math.abs(localTrip.getDistance() - apiTrip.getDistance()) < 0.1 &&
                                  (localTrip.getStartAddress() != null && localTrip.getStartAddress().equals(apiTrip.getStartAddress()))) {
                                  exists = true;
                                  break;
                              }
                          }

                          if (!exists) {
                              mergedTrips.add(apiTrip);
                              Log.d(TAG, "Added API trip: " + apiTrip.getStartAddress() + " → " + apiTrip.getEndAddress());
                          }
                      }

                      saveAllTrips(mergedTrips);
                      setLastApiSyncTime(System.currentTimeMillis());
                      Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " local trips");

                  } catch (Exception e) {
                      Log.e(TAG, "Error merging API trips", e);
                  }
              }

              // User trip merge functionality - combines selected trips into one
              public Trip mergeUserTrips(List<String> tripIds) {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      List<Trip> tripsToMerge = new ArrayList<>();
                      
                      // Find trips to merge by ID
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              for (Trip trip : allTrips) {
                                  if (trip.getId() == id) {
                                      tripsToMerge.add(trip);
                                      break;
                                  }
                              }
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format: " + tripId);
                          }
                      }
                      
                      if (tripsToMerge.size() < 2) {
                          Log.w(TAG, "Need at least 2 trips to merge");
                          return null;
                      }
                      
                      // Sort trips by start time
                      Collections.sort(tripsToMerge, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t1.getStartTime(), t2.getStartTime());
                          }
                      });
                      
                      // Create merged trip using existing Trip structure
                      Trip firstTrip = tripsToMerge.get(0);
                      Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);
                      
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(System.currentTimeMillis());
                      mergedTrip.setStartTime(firstTrip.getStartTime());
                      mergedTrip.setEndTime(lastTrip.getEndTime());
                      mergedTrip.setStartAddress(firstTrip.getStartAddress());
                      mergedTrip.setEndAddress(lastTrip.getEndAddress());
                      mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                      mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                      mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                      mergedTrip.setEndLongitude(lastTrip.getEndLongitude());

                      // Calculate total distance
                      double totalDistance = 0;
                      for (Trip trip : tripsToMerge) {
                          totalDistance += trip.getDistance();
                      }
                      mergedTrip.setDistance(totalDistance);
                      
                      // Calculate total duration
                      long totalDuration = lastTrip.getEndTime() - firstTrip.getStartTime();
                      mergedTrip.setDuration(totalDuration);
                      
                      // Use category from first trip, or "Business" if mixed
                      String category = firstTrip.getCategory();
                      for (Trip trip : tripsToMerge) {
                          if (!trip.getCategory().equals(category)) {
                              category = "Business";
                              break;
                          }
                      }
                      mergedTrip.setCategory(category);
                      
                      // Combine client info  
                      StringBuilder clientBuilder = new StringBuilder();
                      for (Trip trip : tripsToMerge) {
                          if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                              if (clientBuilder.length() > 0) clientBuilder.append(", ");
                              clientBuilder.append(trip.getClientName());
                          }
                      }
                      mergedTrip.setClientName(clientBuilder.toString());
                      
                      mergedTrip.setNotes("Merged from " + tripsToMerge.size() + " trips");
                      mergedTrip.setAutoDetected(false);
                      
                      // Save merged trip and delete originals
                      saveTrip(mergedTrip);
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              deleteTrip(id);
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID for deletion: " + tripId);
                          }
                      }
                      
                      Log.d(TAG, "Successfully merged " + tripsToMerge.size() + " trips");
                      return mergedTrip;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging user trips", e);
                      return null;
                  }
              }

              // Split a trip into multiple trips
              public List<Trip> splitTrip(long tripId, List<Double> splitMiles) {
                  try {
                      List<Trip> trips = getAllTrips();
                      Trip originalTrip = null;
                      
                      // Find the trip to split
                      for (Trip trip : trips) {
                          if (trip.getId() == tripId) {
                              originalTrip = trip;
                              break;
                          }
                      }
                      
                      if (originalTrip == null) {
                          Log.w(TAG, "Trip not found for splitting: " + tripId);
                          return new ArrayList<>();
                      }
                      
                      // Validate split miles
                      double totalSplitMiles = 0;
                      for (Double miles : splitMiles) {
                          totalSplitMiles += miles;
                      }
                      
                      if (Math.abs(totalSplitMiles - originalTrip.getDistance()) > 0.1) {
                          Log.w(TAG, "Split miles don't match original distance: " + totalSplitMiles + " vs " + originalTrip.getDistance());
                          return new ArrayList<>();
                      }
                      
                      // Create split trips
                      List<Trip> splitTrips = new ArrayList<>();
                      long currentTime = System.currentTimeMillis();
                      long timeBetweenTrips = originalTrip.getDuration() / splitMiles.size();
                      
                      for (int i = 0; i < splitMiles.size(); i++) {
                          Trip splitTrip = new Trip();
                          splitTrip.setId(currentTime + i);
                          splitTrip.setStartTime(originalTrip.getStartTime() + (i * timeBetweenTrips));
                          splitTrip.setEndTime(originalTrip.getStartTime() + ((i + 1) * timeBetweenTrips));
                          splitTrip.setDuration(timeBetweenTrips);
                          splitTrip.setDistance(splitMiles.get(i));
                          splitTrip.setStartAddress(originalTrip.getStartAddress() + " (Split " + (i + 1) + ")");
                          splitTrip.setEndAddress(originalTrip.getEndAddress() + " (Split " + (i + 1) + ")");
                          splitTrip.setStartLatitude(originalTrip.getStartLatitude());
                          splitTrip.setStartLongitude(originalTrip.getStartLongitude());
                          splitTrip.setEndLatitude(originalTrip.getEndLatitude());
                          splitTrip.setEndLongitude(originalTrip.getEndLongitude());
                          splitTrip.setCategory(originalTrip.getCategory());
                          splitTrip.setClientName(originalTrip.getClientName());
                          splitTrip.setNotes("Split from original trip");
                          splitTrip.setAutoDetected(false);
                          
                          splitTrips.add(splitTrip);
                      }
                      
                      // Save split trips and delete original
                      for (Trip splitTrip : splitTrips) {
                          saveTrip(splitTrip);
                      }
                      deleteTrip(tripId);
                      
                      Log.d(TAG, "Successfully split trip into " + splitTrips.size() + " trips");
                      return splitTrips;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error splitting trip", e);
                      return new ArrayList<>();
                  }
              }

              // Get user's trips for current authenticated user
              public List<Trip> getUserTrips() {
                  // For now, return all trips since we're using local storage
                  // In a full implementation, this would filter by user ID
                  return getAllTrips();
              }

              // Get statistics for current user
              public TripStatistics getUserStatistics() {
                  List<Trip> userTrips = getUserTrips();
                  return calculateStatistics(userTrips);
              }

              private TripStatistics calculateStatistics(List<Trip> trips) {
                  TripStatistics stats = new TripStatistics();
                  
                  if (trips == null || trips.isEmpty()) {
                      return stats;
                  }
                  
                  stats.totalTrips = trips.size();
                  
                  for (Trip trip : trips) {
                      stats.totalMiles += trip.getDistance();
                      stats.totalDuration += trip.getDuration();
                      
                      if (trip.isAutoDetected()) {
                          stats.autoDetectedTrips++;
                      } else {
                          stats.manualTrips++;
                      }
                      
                      // Count by category
                      String category = trip.getCategory();
                      if ("Business".equals(category)) {
                          stats.businessTrips++;
                          stats.businessMiles += trip.getDistance();
                      } else if ("Personal".equals(category)) {
                          stats.personalTrips++;
                          stats.personalMiles += trip.getDistance();
                      } else if ("Medical".equals(category)) {
                          stats.medicalTrips++;
                          stats.medicalMiles += trip.getDistance();
                      } else if ("Charity".equals(category)) {
                          stats.charityTrips++;
                          stats.charityMiles += trip.getDistance();
                      }
                  }
                  
                  return stats;
              }

              // Statistics class
              public static class TripStatistics {
                  public int totalTrips = 0;
                  public double totalMiles = 0.0;
                  public long totalDuration = 0;
                  public int autoDetectedTrips = 0;
                  public int manualTrips = 0;
                  public int businessTrips = 0;
                  public int personalTrips = 0;
                  public int medicalTrips = 0;
                  public int charityTrips = 0;
                  public double businessMiles = 0.0;
                  public double personalMiles = 0.0;
                  public double medicalMiles = 0.0;
                  public double charityMiles = 0.0;
              }
          }
          EOF

      - name: Create CloudBackupService.java
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.miletrackerpro.app.storage.Trip;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.Locale;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              
              private Context context;

              public CloudBackupService(Context context) {
                  this.context = context;
              }

              public void backupTrip(Trip trip) {
                  new Thread(() -> {
                      try {
                          SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                          String userEmail = authPrefs.getString("user_email", "");
                          
                          if (userEmail.isEmpty()) {
                              Log.w(TAG, "No user email available for backup");
                              return;
                          }

                          URL url = new URL(API_BASE_URL + "/api/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                          conn.setRequestProperty("X-User-Email", userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          String jsonTrip = createTripJson(trip, "android-device", userEmail);
                          
                          OutputStream os = conn.getOutputStream();
                          os.write(jsonTrip.getBytes());
                          os.flush();
                          os.close();

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "Trip backup response: " + responseCode);
                          
                          if (responseCode == 201) {
                              Log.d(TAG, "Trip successfully backed up to cloud");
                          } else {
                              Log.w(TAG, "Trip backup failed with code: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip: " + e.getMessage(), e);
                      }
                  }).start();
              }

              public List<Trip> downloadAllUserTrips() {
                  List<Trip> trips = new ArrayList<>();
                  
                  try {
                      SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                      String userEmail = authPrefs.getString("user_email", "");
                      
                      if (userEmail.isEmpty()) {
                          Log.w(TAG, "No user email available for download");
                          return trips;
                      }

                      URL url = new URL(API_BASE_URL + "/api/trips");
                      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                      conn.setRequestMethod("GET");
                      conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                      conn.setRequestProperty("X-User-Email", userEmail);
                      conn.setConnectTimeout(10000);
                      conn.setReadTimeout(10000);

                      int responseCode = conn.getResponseCode();
                      Log.d(TAG, "Download response code: " + responseCode);

                      if (responseCode == 200) {
                          BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                          StringBuilder response = new StringBuilder();
                          String line;
                          while ((line = reader.readLine()) != null) {
                              response.append(line);
                          }
                          reader.close();

                          String jsonResponse = response.toString();
                          Log.d(TAG, "Downloaded trips JSON: " + jsonResponse);
                          
                          trips = parseTripsFromJson(jsonResponse);
                          Log.d(TAG, "Downloaded " + trips.size() + " trips from API");
                      } else {
                          Log.w(TAG, "Failed to download trips: " + responseCode);
                      }
                      
                      conn.disconnect();
                  } catch (Exception e) {
                      Log.e(TAG, "Error downloading trips: " + e.getMessage(), e);
                  }
                  
                  return trips;
              }

              private List<Trip> parseTripsFromJson(String jsonString) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      JSONObject jsonObject = new JSONObject(jsonString);
                      JSONArray tripsArray = jsonObject.getJSONArray("trips");
                      
                      for (int i = 0; i < tripsArray.length(); i++) {
                          JSONObject tripObj = tripsArray.getJSONObject(i);
                          
                          Trip trip = new Trip();
                          trip.setId(tripObj.optLong("id", System.currentTimeMillis()));
                          trip.setDistance(tripObj.optDouble("distance", 0.0));
                          trip.setCategory(tripObj.optString("category", "Business"));
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          trip.setDuration(tripObj.optLong("duration", 0));
                          
                          // Parse coordinates
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0.0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0.0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0.0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0.0));
                          
                          // Parse addresses - handle encrypted values
                          String startAddress = tripObj.optString("start_location", "");
                          if (startAddress.contains(":")) {
                              // Use coordinates instead of encrypted address
                              startAddress = String.format(Locale.getDefault(), "%.6f, %.6f", 
                                  trip.getStartLatitude(), trip.getStartLongitude());
                          }
                          trip.setStartAddress(startAddress);
                          
                          String endAddress = tripObj.optString("end_location", "");
                          if (endAddress.contains(":")) {
                              // Use coordinates instead of encrypted address
                              endAddress = String.format(Locale.getDefault(), "%.6f, %.6f", 
                                  trip.getEndLatitude(), trip.getEndLongitude());
                          }
                          trip.setEndAddress(endAddress);
                          
                          // Client and notes - handle encrypted values
                          String clientName = tripObj.optString("client_name", "");
                          if (clientName.contains(":")) clientName = ""; // Skip encrypted values
                          trip.setClientName(clientName);
                          
                          String notes = tripObj.optString("notes", "");
                          if (notes.contains(":")) notes = ""; // Skip encrypted values
                          trip.setNotes(notes);

                          // Parse timestamps - use the timestamps from API
                          long startTime = tripObj.optLong("start_time", System.currentTimeMillis());
                          long endTime = tripObj.optLong("end_time", System.currentTimeMillis());

                          trip.setStartTime(startTime);
                          trip.setEndTime(endTime);

                          trips.add(trip);
                          Log.d(TAG, "Parsed API trip: " + trip.getStartAddress() + " → " + trip.getEndAddress());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips JSON", e);
                  }
                  return trips;
              }

              private String createTripJson(Trip trip, String deviceId, String userId) {
                  try {
                      return String.format(Locale.getDefault(),
                          "{"
                          + "\"start_location\":\"%s\","
                          + "\"end_location\":\"%s\","
                          + "\"start_latitude\":%.8f,"
                          + "\"start_longitude\":%.8f,"
                          + "\"end_latitude\":%.8f,"
                          + "\"end_longitude\":%.8f,"
                          + "\"distance\":%.6f,"
                          + "\"duration\":%d,"
                          + "\"category\":\"%s\","
                          + "\"auto_detected\":%s,"
                          + "\"start_time\":%d,"
                          + "\"end_time\":%d,"
                          + "\"client_name\":\"%s\","
                          + "\"notes\":\"%s\","
                          + "\"timezone\":\"America/New_York\""
                          + "}",
                          trip.getStartAddress() != null ? trip.getStartAddress().replace("\"", "\\\"") : "",
                          trip.getEndAddress() != null ? trip.getEndAddress().replace("\"", "\\\"") : "",
                          trip.getStartLatitude(),
                          trip.getStartLongitude(),
                          trip.getEndLatitude(),
                          trip.getEndLongitude(),
                          trip.getDistance(),
                          trip.getDuration(),
                          trip.getCategory(),
                          trip.isAutoDetected(),
                          trip.getStartTime(),
                          trip.getEndTime(),
                          trip.getClientName() != null ? trip.getClientName().replace("\"", "\\\"") : "",
                          trip.getNotes() != null ? trip.getNotes().replace("\"", "\\\"") : ""
                      );
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating trip JSON", e);
                      return "{}";
                  }
              }
          }
          EOF

      - name: Create simplified AutoDetectionService and ManualTripService
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Service;
          import android.content.Intent;
          import android.os.IBinder;
          import android.util.Log;

          public class AutoDetectionService extends Service {
              private static final String TAG = "AutoDetectionService";

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  String action = intent != null ? intent.getAction() : "";
                  Log.d(TAG, "Service action: " + action);
                  
                  if ("START_AUTO_DETECTION".equals(action)) {
                      Log.d(TAG, "Auto detection started");
                  } else if ("STOP_AUTO_DETECTION".equals(action)) {
                      Log.d(TAG, "Auto detection stopped");
                      stopSelf();
                  }
                  
                  return START_STICKY;
              }

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Service;
          import android.content.Intent;
          import android.os.IBinder;
          import android.util.Log;

          public class ManualTripService extends Service {
              private static final String TAG = "ManualTripService";

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  String action = intent != null ? intent.getAction() : "";
                  Log.d(TAG, "Service action: " + action);
                  
                  if ("START_MANUAL_TRIP".equals(action)) {
                      Log.d(TAG, "Manual trip started");
                  } else if ("STOP_MANUAL_TRIP".equals(action)) {
                      Log.d(TAG, "Manual trip stopped");
                      stopSelf();
                  }
                  
                  return START_STICKY;
              }

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
          }
          EOF

      - name: Build APK
        run: |
          cd android
          chmod +x gradlew
          ./gradlew clean
          ./gradlew assembleRelease

      - name: Sign APK
        run: |
          cd android/app/build/outputs/apk/release
          
          # Create keystore if it doesn't exist
          if [ ! -f ../../../../../../keystore.jks ]; then
            keytool -genkey -v -keystore ../../../../../../keystore.jks -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 \
              -dname "CN=MileTracker Pro, OU=Development, O=MileTracker, L=City, S=State, C=US" \
              -storepass password123 -keypass password123
          fi
          
          # Sign the APK
          jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 \
            -keystore ../../../../../../keystore.jks \
            -storepass password123 -keypass password123 \
            app-release-unsigned.apk miletracker
          
          # Verify signing
          jarsigner -verify -verbose app-release-unsigned.apk
          
          # Align the APK
          zipalign -v 4 app-release-unsigned.apk MileTracker-Pro-v4.9.94-UI-IMPROVEMENTS.apk
          
          # Verify alignment
          zipalign -c -v 4 MileTracker-Pro-v4.9.94-UI-IMPROVEMENTS.apk
          
          ls -la *.apk

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.94-UI-IMPROVEMENTS
          path: android/app/build/outputs/apk/release/MileTracker-Pro-v4.9.94-UI-IMPROVEMENTS.apk
          retention-days: 90
