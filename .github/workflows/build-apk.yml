name: SURGICAL AUTH REPLACEMENT WITH OKHTTP - v4.9.93

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create consistent signing keystore
        run: |
          cd android/app
          keytool -genkey -v -keystore miletracker.keystore -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker, L=City, S=State, C=US"

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 49071
                  versionName "4.9.71-data-integrity-fixed"
              }

              signingConfigs {
                  release {
                      storeFile file("miletracker.keystore")
                      storePassword "miletracker123"
                      keyAlias "miletracker"
                      keyPassword "miletracker123"
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.release
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              implementation 'org.json:json:20231013'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name=".MainActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="${applicationId}.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">mileage-tracker-codenurse.replit.app</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <files-path name="files" path="." />
              <cache-path name="cache" path="." />
              <external-files-path name="external_files" path="." />
              <external-cache-path name="external_cache" path="." />
          </paths>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#667eea</color>
              <color name="primary_dark">#5a6fd8</color>
              <color name="accent">#667eea</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
              <color name="success">#28a745</color>
              <color name="danger">#dc3545</color>
              <color name="warning">#ffc107</color>
              <color name="tab_active">#667eea</color>
              <color name="tab_inactive">#9CA3AF</color>
              <color name="background">#f5f5f5</color>
              <color name="card_background">#ffffff</color>
              <color name="text_primary">#495057</color>
              <color name="text_secondary">#6C757D</color>
          </resources>
          EOF

      - name: Create red car icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24.0"
              android:viewportHeight="24.0">
              <path
                  android:fillColor="#dc3545"
                  android:pathData="M18.92,6.01C18.72,5.42 18.16,5 17.5,5h-11C5.84,5 5.28,5.42 5.08,6.01L3,12v8c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-1h12v1c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-8L18.92,6.01zM6.5,16C5.67,16 5,15.33 5,14.5S5.67,13 6.5,13S8,13.67 8,14.5S7.33,16 6.5,16zM17.5,16c-0.83,0 -1.5,-0.67 -1.5,-1.5s0.67,-1.5 1.5,-1.5s1.5,0.67 1.5,1.5S18.33,16 17.5,16zM5,11l1.5,-4.5h11L19,11H5z"/>
          </vector>
          EOF

      - name: Create DeviceIdentification utility for stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/DeviceIdentification.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;

          import java.security.MessageDigest;
          import java.util.UUID;

          public class DeviceIdentification {
              private static final String TAG = "DeviceIdentification";
              private static final String PREFS_NAME = "DeviceIdentificationPrefs";
              private static final String STABLE_DEVICE_ID_KEY = "stable_device_id";
              private static final String USER_ID_KEY = "user_id";

              public static String getStableDeviceId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String stableId = prefs.getString(STABLE_DEVICE_ID_KEY, null);

                  if (stableId == null) {
                      stableId = generateStableDeviceId(context);
                      prefs.edit().putString(STABLE_DEVICE_ID_KEY, stableId).apply();
                      Log.d(TAG, "Generated new stable device ID: " + stableId);
                  }

                  return stableId;
              }

              public static String getUserId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String userId = prefs.getString(USER_ID_KEY, null);

                  if (userId == null) {
                      userId = generateUserId(context);
                      prefs.edit().putString(USER_ID_KEY, userId).apply();
                      Log.d(TAG, "Generated new user ID: " + userId);
                  }

                  return userId;
              }

              private static String generateStableDeviceId(Context context) {
                  try {
                      // Use Android ID (persists across app installs but not device resets)
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);

                      // Create a stable identifier using device characteristics
                      String deviceInfo = androidId + "-" + Build.MODEL + "-" + Build.MANUFACTURER;

                      // Hash it to create a consistent device ID
                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(deviceInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "device-" + hexString.toString().substring(0, 16);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating stable device ID", e);
                      // Fallback to random UUID if all else fails
                      return "device-" + UUID.randomUUID().toString().replace("-", "").substring(0, 16);
                  }
              }

              private static String generateUserId(Context context) {
                  try {
                      // Create a user ID that's stable across app installs
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                      String userInfo = androidId + "-user-" + Build.MODEL;

                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(userInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "user-" + hexString.toString().substring(0, 12);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating user ID", e);
                      return "user-" + UUID.randomUUID().toString().replace("-", "").substring(0, 12);
                  }
              }
          }
          EOF

      - name: Create OkHttp UserAuthManager for real API authentication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;
          import okhttp3.*;
          import okhttp3.logging.HttpLoggingInterceptor;
          import org.json.JSONObject;
          import java.io.IOException;
          import java.security.MessageDigest;
          import java.security.SecureRandom;
          import java.util.UUID;
          import java.util.concurrent.TimeUnit;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_AUTH_TOKEN = "auth_token";
              private static final String KEY_USER_ID = "user_id";
              
              private Context context;
              private SharedPreferences prefs;
              private OkHttpClient okHttpClient;
              
              // API endpoints - corrected production URL
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              private static final String LOGIN_ENDPOINT = "/api/auth/login";
              private static final String REGISTER_ENDPOINT = "/api/register";
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Initialize OkHttp with logging (from working version)
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor(message -> {
                      Log.d(TAG, "OkHttp: " + message);
                  });
                  logging.setLevel(HttpLoggingInterceptor.Level.HEADERS);
                  
                  this.okHttpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(15, TimeUnit.SECONDS)
                      .readTimeout(15, TimeUnit.SECONDS)
                      .writeTimeout(15, TimeUnit.SECONDS)
                      .build();
              }
              
              public boolean loginWithOkHttp(String email, String password) {
                  Log.d(TAG, "🔐 OKHTTP LOGIN for: '" + email + "'");
                  Log.d(TAG, "Password received: '" + password + "' (length: " + (password != null ? password.length() : "null") + ")");
                  Log.d(TAG, "Target URL: " + API_BASE_URL + LOGIN_ENDPOINT);
                  
                  // Log network state
                  logNetworkState();
                  
                  try {
                      // Create JSON payload
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      Log.d(TAG, "JSON payload: " + loginData.toString());
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          loginData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + LOGIN_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      Log.d(TAG, "🌐 OkHttp Request URL: " + request.url());
                      Log.d(TAG, "🌐 OkHttp Request Headers: " + request.headers());
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "🌐 OkHttp Response code: " + response.code());
                          Log.d(TAG, "🌐 OkHttp Response message: " + response.message());
                          Log.d(TAG, "🌐 OkHttp Response headers: " + response.headers());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "🌐 OkHttp Response body: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              boolean success = responseJson.optBoolean("success", false);
                              Log.d(TAG, "OkHttp response success field: " + success);
                              
                              if (success) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  Log.d(TAG, "OkHttp token received: " + (token.isEmpty() ? "empty" : "[" + token.length() + " chars]"));
                                  Log.d(TAG, "OkHttp user ID: '" + userId + "'");
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .apply();
                                  
                                  Log.d(TAG, "✅ OKHTTP login successful for: " + email);
                                  return true;
                              } else {
                                  String message = responseJson.optString("message", "Unknown error");
                                  Log.d(TAG, "❌ OKHTTP login failed - success=false, message: " + message);
                              }
                          } else {
                              String errorBody = "";
                              try {
                                  errorBody = response.body().string();
                              } catch (Exception ex) {
                                  Log.d(TAG, "Could not read OkHttp error response: " + ex.getMessage());
                              }
                              Log.d(TAG, "❌ OKHTTP login failed - HTTP " + response.code() + ", Error body: " + errorBody);
                          }
                      }
                      
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP login exception: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean registerWithOkHttp(String email, String password, String name) {
                  Log.d(TAG, "📝 OKHTTP registration for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("name", name);
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          registerData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + REGISTER_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "OKHTTP registration response code: " + response.code());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "OKHTTP registration response: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              if (responseJson.optBoolean("success", false)) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .apply();
                                  
                                  Log.d(TAG, "✅ OKHTTP registration successful for: " + email);
                                  return true;
                              }
                          }
                          
                          Log.d(TAG, "❌ OKHTTP registration failed - HTTP " + response.code());
                          return false;
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP registration error: " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public String getNetworkDiagnostics() {
                  StringBuilder info = new StringBuilder();
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          info.append("Network Type: ").append(activeNetwork.getTypeName()).append("\n");
                          info.append("Connected: ").append(activeNetwork.isConnected()).append("\n");
                          info.append("Available: ").append(activeNetwork.isAvailable()).append("\n");
                          info.append("HTTP Stack: OkHttp enabled\n");
                      } else {
                          info.append("No active network");
                      }
                  } catch (Exception e) {
                      info.append("Network check failed: ").append(e.getMessage());
                  }
                  return info.toString();
              }
              
              private void logNetworkState() {
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          Log.d(TAG, "🌐 Network Type: " + activeNetwork.getTypeName());
                          Log.d(TAG, "🌐 Network State: " + activeNetwork.getState());
                          Log.d(TAG, "🌐 Network Connected: " + activeNetwork.isConnected());
                          Log.d(TAG, "🌐 Network Available: " + activeNetwork.isAvailable());
                          Log.d(TAG, "🌐 HTTP Stack: OkHttp v4.12.0");
                      } else {
                          Log.d(TAG, "🌐 No active network detected");
                      }
                  } catch (Exception e) {
                      Log.d(TAG, "🌐 Network state check failed: " + e.getMessage());
                  }
              }
              
              public boolean isLoggedIn() {
                  String email = prefs.getString(KEY_USER_EMAIL, "");
                  String token = prefs.getString(KEY_AUTH_TOKEN, "");
                  boolean loggedIn = !email.isEmpty() && !token.isEmpty();
                  Log.d(TAG, "isLoggedIn check: email=" + (!email.isEmpty()) + ", token=" + (!token.isEmpty()) + " -> " + loggedIn);
                  return loggedIn;
              }
              
              public String getCurrentUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }
              
              public String getAuthToken() {
                  return prefs.getString(KEY_AUTH_TOKEN, "");
              }
              
              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }
              
              public void logout() {
                  Log.d(TAG, "Logging out user");
                  prefs.edit().clear().apply();
              }

              // Add missing register method for AuthActivity compatibility
              public boolean register(String email, String password, String name) {
                  return registerWithOkHttp(email, password, name);
              }

              // Add missing recoverDataWithCredentials method for DataRecoveryActivity compatibility
              public boolean recoverDataWithCredentials(String email, String password) {
                  return loginWithOkHttp(email, password);
              }
          }
          EOF

      - name: Create Authentication Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private UserAuthManager authManager;
              private LinearLayout mainLayout;
              private boolean isLoginMode = true;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);

                  // If already logged in, go to main app
                  if (authManager.isLoggedIn()) {
                      goToMainApp();
                      return;
                  }

                  createAuthLayout();
              }

              private void createAuthLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("🚗 MileTracker Pro");
                  headerText.setTextSize(28);
                  headerText.setTextColor(0xFF495057);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 10);
                  mainLayout.addView(headerText);

                  TextView versionText = new TextView(this);
                  versionText.setText("v4.9.17 - Complete User Authentication");
                  versionText.setTextSize(12);
                  versionText.setTextColor(0xFF6C757D);
                  versionText.setGravity(Gravity.CENTER);
                  versionText.setPadding(0, 0, 0, 30);
                  mainLayout.addView(versionText);

                  // Benefits explanation
                  TextView benefitsText = new TextView(this);
                  benefitsText.setText("✅ Keep your trips safe across all devices\n✅ Automatic backup and sync\n✅ Recover data if phone is lost/stolen\n✅ No constant sign-ins required\n✅ Professional tax reporting\n✅ Updates and news via email");
                  benefitsText.setTextSize(14);
                  benefitsText.setTextColor(0xFF495057);
                  benefitsText.setPadding(15, 15, 15, 15);
                  benefitsText.setBackgroundColor(0xFFe8f5e8);
                  LinearLayout.LayoutParams benefitsParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  benefitsParams.setMargins(0, 0, 0, 30);
                  benefitsText.setLayoutParams(benefitsParams);
                  mainLayout.addView(benefitsText);

                  showAuthForm();

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void showAuthForm() {
                  // Clear form area
                  if (mainLayout.getChildCount() > 3) {
                      for (int i = mainLayout.getChildCount() - 1; i >= 3; i--) {
                          mainLayout.removeViewAt(i);
                      }
                  }

                  // Mode toggle
                  TextView modeText = new TextView(this);
                  modeText.setText(isLoginMode ? "Login to Your Account" : "Create New Account");
                  modeText.setTextSize(20);
                  modeText.setTextColor(0xFF495057);
                  modeText.setGravity(Gravity.CENTER);
                  modeText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(modeText);

                  // Email field
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email Address:");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF495057);
                  emailLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(emailLabel);

                  EditText emailField = new EditText(this);
                  emailField.setHint("your.email@example.com");
                  emailField.setText("pcates@catesconsultinggroup.com");
                  emailField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(15, 15, 15, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password:");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF495057);
                  passwordLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(passwordLabel);

                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Your secure password");
                  passwordField.setText("password123");
                  passwordField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(15, 15, 15, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 15);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Name field (registration only)
                  EditText nameField = null;
                  if (!isLoginMode) {
                      TextView nameLabel = new TextView(this);
                      nameLabel.setText("Your Name:");
                      nameLabel.setTextSize(16);
                      nameLabel.setTextColor(0xFF495057);
                      nameLabel.setPadding(0, 0, 0, 5);
                      mainLayout.addView(nameLabel);

                      nameField = new EditText(this);
                      nameField.setHint("John Smith");
                      nameField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PERSON_NAME);
                      nameField.setTextSize(16);
                      nameField.setPadding(15, 15, 15, 15);
                      nameField.setBackgroundColor(0xFFFFFFFF);
                      LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      nameParams.setMargins(0, 0, 0, 15);
                      nameField.setLayoutParams(nameParams);
                      mainLayout.addView(nameField);
                  }

                  // Primary action button
                  Button primaryButton = new Button(this);
                  primaryButton.setText(isLoginMode ? "Login" : "Create Account");
                  primaryButton.setBackgroundColor(0xFF667eea);
                  primaryButton.setTextColor(0xFFFFFFFF);
                  primaryButton.setTextSize(18);
                  primaryButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams primaryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  primaryParams.setMargins(0, 10, 0, 15);
                  primaryButton.setLayoutParams(primaryParams);

                  EditText finalNameField = nameField;
                  primaryButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      if (isLoginMode) {
                          handleLogin(email, password);
                      } else {
                          String name = finalNameField != null ? finalNameField.getText().toString().trim() : "";
                          if (name.isEmpty()) {
                              Toast.makeText(this, "Please enter your name", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          handleRegistration(email, password, name);
                      }
                  });
                  mainLayout.addView(primaryButton);

                  // Mode toggle button
                  Button toggleButton = new Button(this);
                  toggleButton.setText(isLoginMode ? "Need an account? Sign up" : "Already have an account? Login");
                  toggleButton.setBackgroundColor(0x00000000);
                  toggleButton.setTextColor(0xFF667eea);
                  toggleButton.setTextSize(16);
                  LinearLayout.LayoutParams toggleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  toggleParams.setMargins(0, 10, 0, 20);
                  toggleButton.setLayoutParams(toggleParams);
                  toggleButton.setOnClickListener(v -> {
                      isLoginMode = !isLoginMode;
                      showAuthForm();
                  });
                  mainLayout.addView(toggleButton);

                  // Data recovery link
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("🔄 Lost device? Recover your data");
                  recoveryButton.setBackgroundColor(0x00000000);
                  recoveryButton.setTextColor(0xFF28a745);
                  recoveryButton.setTextSize(14);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoveryParams.setMargins(0, 20, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "OkHttp login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== OKHTTP LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread using OkHttp
                  new Thread(() -> {
                      Log.d(TAG, "Starting OkHttp login thread...");
                      boolean loginResult = authManager.loginWithOkHttp(email, password);
                      Log.d(TAG, "OkHttp login result: " + loginResult);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Toast.makeText(this, "Welcome back! 🚗 (OkHttp Success)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Login failed. Check logs for OkHttp diagnostic info.", Toast.LENGTH_LONG).show();
                              Log.d(TAG, "❌ OkHttp login failed - check connection routing");
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  if (authManager.register(email, password, name)) {
                      Toast.makeText(this, "Account created successfully! 🎉", Toast.LENGTH_SHORT).show();
                      goToMainApp();
                  } else {
                      Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }

              private void goToDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create Data Recovery Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);
                  createRecoveryLayout();
              }

              private void createRecoveryLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("📱💔 Data Recovery");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF495057);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(headerText);

                  // Explanation
                  TextView explanationText = new TextView(this);
                  explanationText.setText("Lost your phone, upgraded devices, or need to reinstall?\n\nEnter your email and password to recover ALL your trip data and mileage history.\n\nThis works even if your old device was stolen or broken.");
                  explanationText.setTextSize(14);
                  explanationText.setTextColor(0xFF6C757D);
                  explanationText.setPadding(15, 15, 15, 15);
                  explanationText.setBackgroundColor(0xFFfff3cd);
                  LinearLayout.LayoutParams explanationParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  explanationParams.setMargins(0, 0, 0, 30);
                  explanationText.setLayoutParams(explanationParams);
                  mainLayout.addView(explanationText);

                  TextView formTitle = new TextView(this);
                  formTitle.setText("Recover Your Trip Data");
                  formTitle.setTextSize(18);
                  formTitle.setTextColor(0xFF495057);
                  formTitle.setPadding(0, 0, 0, 15);
                  mainLayout.addView(formTitle);

                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Your email address");
                  emailInput.setText("pcates@catesconsultinggroup.com");
                  emailInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Your password");
                  passwordInput.setText("password123");
                  passwordInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  Button recoverButton = new Button(this);
                  recoverButton.setText("🔄 Recover My Trip Data");
                  recoverButton.setTextSize(16);
                  recoverButton.setBackgroundColor(0xFF28a745);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      performDataRecovery(email, password);
                  });
                  mainLayout.addView(recoverButton);

                  // Back button
                  Button backButton = new Button(this);
                  backButton.setText("← Back to Sign In");
                  backButton.setTextSize(14);
                  backButton.setBackgroundColor(0xFF667eea);
                  backButton.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backParams.setMargins(0, 15, 0, 0);
                  backButton.setLayoutParams(backParams);
                  backButton.setOnClickListener(v -> {
                      finish(); // Go back to AuthActivity
                  });
                  mainLayout.addView(backButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void performDataRecovery(String email, String password) {
                  try {
                      // Show progress
                      Toast.makeText(this, "Recovering your data...", Toast.LENGTH_SHORT).show();

                      boolean success = authManager.recoverDataWithCredentials(email, password);

                      if (success) {
                          // Success message
                          Toast.makeText(this, "SUCCESS! Your trip data is being restored. This includes ALL your historical trips, even from previous devices.", Toast.LENGTH_LONG).show();

                          // Go to main app
                          Intent intent = new Intent(this, MainActivity.class);
                          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                          startActivity(intent);
                          finish();

                      } else {
                          Toast.makeText(this, "Recovery failed. Please check your email and password, or create a new account if you're a new user.", Toast.LENGTH_LONG).show();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Data recovery error", e);
                      Toast.makeText(this, "Recovery error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
          }
          EOF

      - name: Create Trip class - EXACT COPY FROM WORKING VERSION
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long duration;
              private String category;
              private long startTime;
              private long endTime;
              private boolean autoDetected;
              private String clientName;
              private String notes;

              public Trip() {
                  this.category = "Personal";
                  this.autoDetected = false;
                  this.clientName = null;
                  this.notes = null;
              }

              // All getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              // Formatted display methods
              public String getFormattedDate() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDuration() {
                  long minutes = duration / (60 * 1000);
                  if (minutes < 60) {
                      return minutes + "m";
                  } else {
                      long hours = minutes / 60;
                      long remainingMinutes = minutes % 60;
                      return hours + "h " + remainingMinutes + "m";
                  }
              }

              public String getFormattedStartTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedEndTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(endTime));
              }
          }
          EOF

      - name: Create TripStorage with stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.miletrackerpro.app.utils.DeviceIdentification;
          import org.json.JSONArray;
          import org.json.JSONObject;

          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Comparator;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerPrefs";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              private static final String LAST_API_SYNC_KEY = "last_api_sync";

              private SharedPreferences prefs;
              private Context context;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public String getStableDeviceId() {
                  return DeviceIdentification.getStableDeviceId(context);
              }

              public String getUserId() {
                  return DeviceIdentification.getUserId(context);
              }

              public boolean isAutoDetectionEnabled() {
                  return prefs.getBoolean(AUTO_DETECTION_KEY, false);
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  prefs.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, true);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
                  Log.d(TAG, "API sync enabled: " + enabled);
              }

              public long getLastApiSyncTime() {
                  return prefs.getLong(LAST_API_SYNC_KEY, 0);
              }

              public void setLastApiSyncTime(long timestamp) {
                  prefs.edit().putLong(LAST_API_SYNC_KEY, timestamp).apply();
              }

              public void saveTrip(Trip trip) {
                  try {
                      if (trip.getId() == 0) {
                          trip.setId(trip.getStartTime() > 0 ? trip.getStartTime() : System.currentTimeMillis());
                      }

                      Log.d(TAG, "Saving trip: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                            " (Distance: " + trip.getDistance() + " miles)");

                      List<Trip> trips = getAllTrips();

                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }

                      if (!updated) {
                          trips.add(trip);
                      }

                      saveAllTrips(trips);
                      Log.d(TAG, updated ? "Trip updated: " + trip.getId() : "Trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      // Remove from local storage
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      
                      // Delete from API if available
                      new Thread(() -> {
                          try {
                              java.net.URL url = new java.net.URL("https://mileage-tracker-codenurse.replit.app/api/trips/" + tripId);
                              java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
                              conn.setRequestMethod("DELETE");
                              // Get current user email from SharedPreferences (same pattern as auth system)
                              SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                              String userEmail = authPrefs.getString("user_email", "");
                              if (!userEmail.isEmpty()) {
                                  conn.setRequestProperty("X-User-Email", userEmail);
                              } else {
                                  Log.w(TAG, "No user email available for DELETE request");
                                  return;
                              }
                              conn.setRequestProperty("Content-Type", "application/json");
                              conn.setConnectTimeout(5000);
                              conn.setReadTimeout(5000);
                              
                              int responseCode = conn.getResponseCode();
                              Log.d(TAG, "Trip deleted from API: " + tripId + ", Response: " + responseCode);
                              conn.disconnect();
                          } catch (Exception e) {
                              Log.w(TAG, "Could not delete trip from API: " + e.getMessage());
                          }
                      }).start();
                      
                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              // Method to merge API trips with local trips
              public void mergeApiTrips(List<Trip> apiTrips) {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      List<Trip> mergedTrips = new ArrayList<>();

                      // Start with local trips
                      mergedTrips.addAll(localTrips);

                      // Add API trips that don't exist locally
                      for (Trip apiTrip : apiTrips) {
                          boolean exists = false;
                          for (Trip localTrip : localTrips) {
                              // Check if trip already exists (same start time, distance, and locations)
                              if (Math.abs(localTrip.getStartTime() - apiTrip.getStartTime()) < 60000 && // Within 1 minute
                                  Math.abs(localTrip.getDistance() - apiTrip.getDistance()) < 0.1 &&
                                  (localTrip.getStartAddress() != null && localTrip.getStartAddress().equals(apiTrip.getStartAddress()))) {
                                  exists = true;
                                  break;
                              }
                          }

                          if (!exists) {
                              mergedTrips.add(apiTrip);
                              Log.d(TAG, "Added API trip: " + apiTrip.getStartAddress() + " → " + apiTrip.getEndAddress());
                          }
                      }

                      saveAllTrips(mergedTrips);
                      setLastApiSyncTime(System.currentTimeMillis());
                      Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " local trips");

                  } catch (Exception e) {
                      Log.e(TAG, "Error merging API trips", e);
                  }
              }

              // User trip merge functionality - combines selected trips into one
              public Trip mergeUserTrips(List<String> tripIds) {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      List<Trip> tripsToMerge = new ArrayList<>();
                      
                      // Find trips to merge by ID
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              for (Trip trip : allTrips) {
                                  if (trip.getId() == id) {
                                      tripsToMerge.add(trip);
                                      break;
                                  }
                              }
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format: " + tripId);
                          }
                      }
                      
                      if (tripsToMerge.size() < 2) {
                          Log.w(TAG, "Need at least 2 trips to merge");
                          return null;
                      }
                      
                      // Sort trips by start time
                      Collections.sort(tripsToMerge, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t1.getStartTime(), t2.getStartTime());
                          }
                      });
                      
                      // Create merged trip using existing Trip structure
                      Trip firstTrip = tripsToMerge.get(0);
                      Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);
                      
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(System.currentTimeMillis());
                      mergedTrip.setStartTime(firstTrip.getStartTime());
                      mergedTrip.setEndTime(lastTrip.getEndTime());
                      mergedTrip.setStartAddress(firstTrip.getStartAddress());
                      mergedTrip.setEndAddress(lastTrip.getEndAddress());
                      mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                      mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                      mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                      mergedTrip.setEndLongitude(lastTrip.getEndLongitude());

                      // Calculate total distance
                      double totalDistance = 0;
                      for (Trip trip : tripsToMerge) {
                          totalDistance += trip.getDistance();
                      }
                      mergedTrip.setDistance(totalDistance);
                      
                      // Calculate total duration
                      long totalDuration = lastTrip.getEndTime() - firstTrip.getStartTime();
                      mergedTrip.setDuration(totalDuration);
                      
                      // Use category from first trip, or "Business" if mixed
                      String category = firstTrip.getCategory();
                      for (Trip trip : tripsToMerge) {
                          if (!trip.getCategory().equals(category)) {
                              category = "Business";
                              break;
                          }
                      }
                      mergedTrip.setCategory(category);
                      
                      // Combine client info  
                      StringBuilder clientBuilder = new StringBuilder();
                      for (Trip trip : tripsToMerge) {
                          if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                              if (clientBuilder.length() > 0) clientBuilder.append(", ");
                              clientBuilder.append(trip.getClientName());
                          }
                      }
                      mergedTrip.setClientName(clientBuilder.toString());
                      
                      mergedTrip.setNotes("Merged from " + tripsToMerge.size() + " trips");
                      mergedTrip.setAutoDetected(false);
                      
                      // Save merged trip and delete originals
                      saveTrip(mergedTrip);
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              deleteTrip(id);
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format for deletion: " + tripId);
                          }
                      }
                      
                      Log.d(TAG, "Successfully merged " + tripsToMerge.size() + " trips into: " + mergedTrip.getId());
                      return mergedTrip;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging user trips", e);
                      return null;
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray array = new JSONArray(tripsJson);

                      for (int i = 0; i < array.length(); i++) {
                          JSONObject obj = array.getJSONObject(i);
                          Trip trip = new Trip();

                          trip.setId(obj.optLong("id", 0));
                          trip.setStartAddress(obj.optString("start_location", ""));
                          trip.setEndAddress(obj.optString("end_location", ""));
                          trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                          trip.setDistance(obj.optDouble("distance", 0));
                          trip.setDuration(obj.optLong("duration", 0));
                          trip.setCategory(obj.optString("category", "Personal"));
                          trip.setStartTime(obj.optLong("start_time", 0));
                          trip.setEndTime(obj.optLong("end_time", 0));
                          trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                          trip.setClientName(obj.optString("client_name", ""));
                          trip.setNotes(obj.optString("notes", ""));

                          trips.add(trip);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip == null) {
                          prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                          Log.d(TAG, "Current trip cleared");
                          return;
                      }

                      JSONObject obj = new JSONObject();
                      obj.put("id", trip.getId());
                      obj.put("start_location", trip.getStartAddress());
                      obj.put("end_location", trip.getEndAddress());
                      obj.put("start_latitude", trip.getStartLatitude());
                      obj.put("start_longitude", trip.getStartLongitude());
                      obj.put("end_latitude", trip.getEndLatitude());
                      obj.put("end_longitude", trip.getEndLongitude());
                      obj.put("distance", trip.getDistance());
                      obj.put("duration", trip.getDuration());
                      obj.put("category", trip.getCategory());
                      obj.put("start_time", trip.getStartTime());
                      obj.put("end_time", trip.getEndTime());
                      obj.put("auto_detected", trip.isAutoDetected());
                      obj.put("client_name", trip.getClientName());
                      obj.put("notes", trip.getNotes());

                      prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String currentTripJson = prefs.getString(CURRENT_TRIP_KEY, null);
                      if (currentTripJson == null) return null;

                      JSONObject obj = new JSONObject(currentTripJson);
                      Trip trip = new Trip();

                      trip.setId(obj.optLong("id", 0));
                      trip.setStartAddress(obj.optString("start_location", ""));
                      trip.setEndAddress(obj.optString("end_location", ""));
                      trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                      trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                      trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                      trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                      trip.setDistance(obj.optDouble("distance", 0));
                      trip.setDuration(obj.optLong("duration", 0));
                      trip.setCategory(obj.optString("category", "Personal"));
                      trip.setStartTime(obj.optLong("start_time", 0));
                      trip.setEndTime(obj.optLong("end_time", 0));
                      trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                      trip.setClientName(obj.optString("client_name", ""));
                      trip.setNotes(obj.optString("notes", ""));

                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                      return null;
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray array = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject obj = new JSONObject();
                          obj.put("id", trip.getId());
                          obj.put("start_location", trip.getStartAddress());
                          obj.put("end_location", trip.getEndAddress());
                          obj.put("start_latitude", trip.getStartLatitude());
                          obj.put("start_longitude", trip.getStartLongitude());
                          obj.put("end_latitude", trip.getEndLatitude());
                          obj.put("end_longitude", trip.getEndLongitude());
                          obj.put("distance", trip.getDistance());
                          obj.put("duration", trip.getDuration());
                          obj.put("category", trip.getCategory());
                          obj.put("start_time", trip.getStartTime());
                          obj.put("end_time", trip.getEndTime());
                          obj.put("auto_detected", trip.isAutoDetected());
                          obj.put("client_name", trip.getClientName());
                          obj.put("notes", trip.getNotes());
                          array.put(obj);
                      }
                      prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }
          }
          EOF

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app/api";

              private Context context;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.executor = Executors.newSingleThreadExecutor();
              }

              // UPLOAD FUNCTIONALITY
              public void backupTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping backup");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting API backup for trip: " + trip.getId());

                          URL url = new URL(API_BASE_URL + "/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                          conn.setRequestProperty("X-User-Email", "pcates@catesconsultinggroup.com");
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          String jsonPayload = createTripJson(trip, null, tripStorage.getUserId());

                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API backup response: " + responseCode);

                          if (responseCode == 200 || responseCode == 201) {
                              Log.d(TAG, "Trip backed up successfully to API");
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip to API", e);
                      }
                  });
              }

              // DOWNLOAD ALL USER TRIPS (not just device-specific)
              public void downloadAllUserTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping download");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          String userId = tripStorage.getUserId();
                          Log.d(TAG, "Starting download ALL trips for user: " + userId);

                          // Download ALL trips from the API (not device-specific)
                          String apiUrl = API_BASE_URL + "/trips";
                          URL url = new URL(apiUrl);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                          conn.setRequestProperty("X-User-Email", "pcates@catesconsultinggroup.com");
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API download ALL trips response: " + responseCode);

                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(
                                      new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }

                              List<Trip> apiTrips = parseTripsFromJson(response.toString());
                              Log.d(TAG, "Downloaded " + apiTrips.size() + " trips from API (all user trips)");

                              if (!apiTrips.isEmpty()) {
                                  tripStorage.mergeApiTrips(apiTrips);
                                  Log.d(TAG, "Successfully merged API trips");
                              }
                          } else {
                              Log.w(TAG, "API download failed with code: " + responseCode);
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error downloading trips from API", e);
                      }
                  });
              }

              private List<Trip> parseTripsFromJson(String jsonResponse) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      // Handle server response format: { trips: [...] }
                      JSONObject responseObj = new JSONObject(jsonResponse);
                      JSONArray tripsArray = responseObj.optJSONArray("trips");
                      
                      // Fallback to direct array if no "trips" property
                      if (tripsArray == null) {
                          tripsArray = new JSONArray(jsonResponse);
                      }

                      for (int i = 0; i < tripsArray.length(); i++) {
                          JSONObject tripObj = tripsArray.getJSONObject(i);
                          Trip trip = new Trip();

                          // Parse API response fields - handle actual database structure
                          trip.setId(tripObj.optLong("id", System.currentTimeMillis()));
                          
                          // Address fields - server returns start_location/end_location (encrypted)
                          String startAddr = tripObj.optString("start_location", "Unknown");
                          String endAddr = tripObj.optString("end_location", "Unknown");
                          
                          // If still encrypted (contains colons), show coordinates instead
                          if (startAddr.contains(":")) {
                              double lat = tripObj.optDouble("start_latitude", 0);
                              double lng = tripObj.optDouble("start_longitude", 0);
                              startAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          if (endAddr.contains(":")) {
                              double lat = tripObj.optDouble("end_latitude", 0);
                              double lng = tripObj.optDouble("end_longitude", 0);
                              endAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          
                          trip.setStartAddress(startAddr);
                          trip.setEndAddress(endAddr);
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0));
                          
                          // Distance
                          trip.setDistance(tripObj.optDouble("distance", 0));
                          
                          // Duration - keep in milliseconds (as expected by Trip class)
                          long durationMs = tripObj.optLong("duration", 0);
                          trip.setDuration(durationMs);
                          
                          // Parse timestamps for trip date
                          String startTimeStr = tripObj.optString("start_time", "");
                          if (!startTimeStr.isEmpty()) {
                              long startTime = parseTimestamp(startTimeStr);
                              trip.setStartTime(startTime);
                          }
                          
                          trip.setCategory(tripObj.optString("category", "Personal"));
                          
                          // Auto detection status
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          
                          // Client and notes - handle encrypted values
                          String clientName = tripObj.optString("client_name", "");
                          if (clientName.contains(":")) clientName = ""; // Skip encrypted values
                          trip.setClientName(clientName);
                          
                          String notes = tripObj.optString("notes", "");
                          if (notes.contains(":")) notes = ""; // Skip encrypted values
                          trip.setNotes(notes);

                          // Parse timestamps - use the timestamps from API
                          long startTime = tripObj.optLong("start_time", System.currentTimeMillis());
                          long endTime = tripObj.optLong("end_time", System.currentTimeMillis());

                          trip.setStartTime(startTime);
                          trip.setEndTime(endTime);

                          trips.add(trip);
                          Log.d(TAG, "Parsed API trip: " + trip.getStartAddress() + " → " + trip.getEndAddress());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips JSON", e);
                  }
                  return trips;
              }
              
              private long parseTimestamp(String timestampStr) {
                  try {
                      if (timestampStr == null || timestampStr.isEmpty()) return 0;
                      
                      // Handle ISO timestamp format from database
                      if (timestampStr.contains("T")) {
                          return java.time.Instant.parse(timestampStr).toEpochMilli();
                      }
                      
                      // Handle epoch milliseconds
                      return Long.parseLong(timestampStr);
                  } catch (Exception e) {
                      Log.w(TAG, "Failed to parse timestamp: " + timestampStr);
                      return 0;
                  }
              }

              private String createTripJson(Trip trip, String deviceId, String userId) {
                  try {
                      return String.format(Locale.getDefault(),
                          "{"
                          + "\"start_location\":\"%s\","
                          + "\"end_location\":\"%s\","
                          + "\"start_latitude\":%.8f,"
                          + "\"start_longitude\":%.8f,"
                          + "\"end_latitude\":%.8f,"
                          + "\"end_longitude\":%.8f,"
                          + "\"distance\":%.6f,"
                          + "\"duration\":%d,"
                          + "\"category\":\"%s\","
                          + "\"auto_detected\":%s,"
                          + "\"start_time\":%d,"
                          + "\"end_time\":%d,"
                          + "\"client_name\":\"%s\","
                          + "\"notes\":\"%s\","
                          + "\"timezone\":\"America/New_York\""
                          + "}",
                          trip.getStartAddress() != null ? trip.getStartAddress().replace("\"", "\\\"") : "",
                          trip.getEndAddress() != null ? trip.getEndAddress().replace("\"", "\\\"") : "",
                          trip.getStartLatitude(),
                          trip.getStartLongitude(),
                          trip.getEndLatitude(),
                          trip.getEndLongitude(),
                          trip.getDistance(),
                          trip.getDuration(),
                          trip.getCategory(),
                          trip.isAutoDetected(),
                          trip.getStartTime(),
                          trip.getEndTime(),
                          trip.getClientName() != null ? trip.getClientName().replace("\"", "\\\"") : "",
                          trip.getNotes() != null ? trip.getNotes().replace("\"", "\\\"") : ""
                      );
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating trip JSON", e);
                      return "{}";
                  }
              }
          }
          EOF

      - name: Create MainActivity with enhanced user identification and ALL trips download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.ActivityManager;
          import android.app.AlertDialog;
          import android.app.DatePickerDialog;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.graphics.Typeface;
          import android.graphics.drawable.GradientDrawable;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.text.Editable;
          import android.text.InputType;
          import android.text.TextWatcher;
          import android.util.Log;
          import android.view.Gravity;
          import android.view.View;
          import android.widget.AdapterView;
          import android.widget.ArrayAdapter;
          import android.widget.Button;
          import android.widget.CheckBox;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.SearchView;
          import android.widget.SeekBar;
          import android.widget.Spinner;
          import android.widget.Switch;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.services.AutoDetectionService;
          import com.miletrackerpro.app.services.ManualTripService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import android.net.Uri;
          import java.io.File;
          import java.io.FileWriter;
          import java.io.IOException;
          import java.text.SimpleDateFormat;
          import java.util.ArrayList;
          import java.util.Calendar;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;
          import androidx.core.content.FileProvider;

          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final String TAG = "MainActivity";
              private static final int LOCATION_PERMISSION_REQUEST = 1001;
              private static final int BACKGROUND_LOCATION_PERMISSION_REQUEST = 1002;

              // Main layout
              private LinearLayout mainContentLayout;
              private LinearLayout bottomTabLayout;

              // Tab content
              private LinearLayout dashboardContent;
              private LinearLayout tripsContent;
              private Button homeTabButton;
              private Button tripsTabButton;
              private String currentTab = "home";

              // Dashboard UI Elements
              private TextView statusText;
              private TextView speedText;
              private TextView statsText;
              private Button autoToggle;
              private Button apiToggle;
              private Button manualStartButton;
              private Button manualStopButton;
              private Button addTripButton;
              private LinearLayout recentTripsLayout;

              // Trips UI Elements
              private LinearLayout allTripsLayout;
              private ScrollView allTripsScroll;

              // Services and storage
              private LocationManager locationManager;
              private TripStorage tripStorage;
              private boolean autoDetectionEnabled = false;
              private boolean manualTripInProgress = false;
              private Handler speedHandler = new Handler();
              private Runnable speedRunnable;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  try {
                      Log.d(TAG, "MainActivity onCreate starting - v4.9.71 DATA INTEGRITY FIXED...");

                      tripStorage = new TripStorage(this);
                      createCleanLayout();
                      initializeGPS();
                      setupSpeedMonitoring();
                      requestPermissions();
                      updateStats();
                      registerBroadcastReceiver();
                      restoreAutoDetectionState();

                      // TRIGGER DOWNLOAD OF ALL USER TRIPS
                      triggerAllUserTripsDownload();

                      Log.d(TAG, "MainActivity onCreate completed successfully");

                  } catch (Exception e) {
                      Log.e(TAG, "Error in onCreate: " + e.getMessage(), e);
                      Toast.makeText(this, "App initialization error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              @Override
              protected void onResume() {
                  super.onResume();
                  // Refresh trips from API when user returns to app
                  if (tripStorage.isApiSyncEnabled()) {
                      new Thread(() -> {
                          try {
                              CloudBackupService cloudBackup = new CloudBackupService(this);
                              cloudBackup.downloadAllUserTrips();
                              
                              // Update UI on main thread
                              runOnUiThread(() -> {
                                  updateStats();
                                  updateAllTrips();
                              });
                          } catch (Exception e) {
                              Log.e(TAG, "Error refreshing trips: " + e.getMessage());
                          }
                      });
                  }
              }

              // Download ALL user trips (not just device-specific)
              private void triggerAllUserTripsDownload() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudBackup = new CloudBackupService(this);
                          cloudBackup.downloadAllUserTrips();
                          Log.d(TAG, "Triggered download of ALL user trips (not device-specific)");

                          // Update UI after a short delay to allow download to complete
                          Handler handler = new Handler();
                          handler.postDelayed(() -> {
                              updateStats();
                              if ("home".equals(currentTab)) {
                                  updateRecentTrips();
                              } else {
                                  updateAllTrips();
                              }
                          }, 3000); // 3 second delay
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error triggering ALL user trips download: " + e.getMessage(), e);
                  }
              }

              private void createCleanLayout() {
                  try {
                      // MAIN CONTAINER
                      LinearLayout mainLayout = new LinearLayout(this);
                      mainLayout.setOrientation(LinearLayout.VERTICAL);
                      mainLayout.setBackgroundColor(0xFFF5F5F5);

                      // MAIN CONTENT AREA
                      mainContentLayout = new LinearLayout(this);
                      mainContentLayout.setOrientation(LinearLayout.VERTICAL);
                      LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          0, 
                          1.0f
                      );
                      mainContentLayout.setLayoutParams(contentParams);

                      // BOTTOM TAB BAR
                      bottomTabLayout = new LinearLayout(this);
                      bottomTabLayout.setOrientation(LinearLayout.HORIZONTAL);
                      bottomTabLayout.setBackgroundColor(0xFFFFFFFF);
                      bottomTabLayout.setPadding(0, 10, 0, 20);
                      bottomTabLayout.setGravity(Gravity.CENTER);

                      // HOME TAB BUTTON
                      homeTabButton = new Button(this);
                      homeTabButton.setText("🏠 Home");
                      homeTabButton.setTextSize(14);
                      homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                      homeTabButton.setTextColor(0xFFFFFFFF);
                      homeTabButton.setOnClickListener(v -> switchToTab("home"));
                      LinearLayout.LayoutParams homeParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      homeParams.setMargins(20, 0, 10, 0);
                      homeTabButton.setLayoutParams(homeParams);
                      bottomTabLayout.addView(homeTabButton);

                      // TRIPS TAB BUTTON  
                      tripsTabButton = new Button(this);
                      tripsTabButton.setText("📋 Trips");
                      tripsTabButton.setTextSize(14);
                      tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY
                      tripsTabButton.setTextColor(0xFFFFFFFF);
                      tripsTabButton.setOnClickListener(v -> switchToTab("trips"));
                      LinearLayout.LayoutParams tripsParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      tripsParams.setMargins(10, 0, 20, 0);
                      tripsTabButton.setLayoutParams(tripsParams);
                      bottomTabLayout.addView(tripsTabButton);

                      // CREATE TAB CONTENT
                      createDashboardContent();
                      createTripsContent();

                      // Add to main layout
                      mainLayout.addView(mainContentLayout);
                      mainLayout.addView(bottomTabLayout);

                      switchToTab("home");
                      setContentView(mainLayout);

                  } catch (Exception e) {
                      Log.e(TAG, "Error creating layout: " + e.getMessage(), e);
                      throw e;
                  }
              }

              private void createDashboardContent() {
                  dashboardContent = new LinearLayout(this);
                  dashboardContent.setOrientation(LinearLayout.VERTICAL);
                  dashboardContent.setPadding(20, 20, 20, 20);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("🚗 MileTracker Pro");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF495057);
                  headerText.setPadding(0, 0, 0, 10);
                  dashboardContent.addView(headerText);

                  // Subtitle
                  TextView subtitleText = new TextView(this);
                  subtitleText.setText("v4.9.71-data-integrity-fixed • Professional Business Tracking");
                  subtitleText.setTextSize(12);
                  subtitleText.setTextColor(0xFF6C757D);
                  subtitleText.setPadding(0, 0, 0, 15);
                  dashboardContent.addView(subtitleText);

                  // Status
                  statusText = new TextView(this);
                  statusText.setText("Initializing...");
                  statusText.setTextSize(14);
                  statusText.setTextColor(0xFF495057);
                  statusText.setPadding(15, 15, 15, 15);
                  statusText.setBackgroundColor(0xFFe3f2fd);
                  dashboardContent.addView(statusText);

                  // Speed
                  speedText = new TextView(this);
                  speedText.setText("Speed: -- mph");
                  speedText.setTextSize(12);
                  speedText.setTextColor(0xFF6C757D);
                  speedText.setPadding(15, 5, 15, 10);
                  dashboardContent.addView(speedText);

                  // API SYNC SECTION
                  TextView apiSectionHeader = new TextView(this);
                  apiSectionHeader.setText("🌐 API Sync");
                  apiSectionHeader.setTextSize(16);
                  apiSectionHeader.setTextColor(0xFF495057);
                  apiSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(apiSectionHeader);

                  apiToggle = new Button(this);
                  updateApiToggleUI();
                  apiToggle.setTextSize(14);
                  apiToggle.setOnClickListener(v -> toggleApiSync());
                  dashboardContent.addView(apiToggle);

                  // AUTO DETECTION SECTION
                  TextView autoSectionHeader = new TextView(this);
                  autoSectionHeader.setText("🤖 Auto Detection");
                  autoSectionHeader.setTextSize(16);
                  autoSectionHeader.setTextColor(0xFF495057);
                  autoSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(autoSectionHeader);

                  autoToggle = new Button(this);
                  autoToggle.setText("🔄 Auto OFF");
                  autoToggle.setTextSize(14);
                  autoToggle.setBackgroundColor(0xFF9CA3AF);
                  autoToggle.setTextColor(0xFFFFFFFF);
                  autoToggle.setOnClickListener(v -> toggleAutoDetection());
                  dashboardContent.addView(autoToggle);

                  // MANUAL CONTROLS SECTION
                  TextView manualSectionHeader = new TextView(this);
                  manualSectionHeader.setText("✋ Manual Controls");
                  manualSectionHeader.setTextSize(16);
                  manualSectionHeader.setTextColor(0xFF495057);
                  manualSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(manualSectionHeader);

                  LinearLayout manualButtonLayout = new LinearLayout(this);
                  manualButtonLayout.setOrientation(LinearLayout.HORIZONTAL);

                  manualStartButton = new Button(this);
                  manualStartButton.setText("▶️ START");
                  manualStartButton.setTextSize(12);
                  manualStartButton.setBackgroundColor(0xFF28a745);
                  manualStartButton.setTextColor(0xFFFFFFFF);
                  manualStartButton.setOnClickListener(v -> startManualTrip());
                  LinearLayout.LayoutParams startParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                  startParams.setMargins(0, 0, 5, 0);
                  manualStartButton.setLayoutParams(startParams);
                  manualButtonLayout.addView(manualStartButton);

                  manualStopButton = new Button(this);
                  manualStopButton.setText("⏹️ STOP");
                  manualStopButton.setTextSize(12);
                  manualStopButton.setBackgroundColor(0xFFdc3545);
                  manualStopButton.setTextColor(0xFFFFFFFF);
                  manualStopButton.setEnabled(false);
                  manualStopButton.setOnClickListener(v -> stopManualTrip());
                  LinearLayout.LayoutParams stopParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                  stopParams.setMargins(5, 0, 0, 0);
                  manualStopButton.setLayoutParams(stopParams);
                  manualButtonLayout.addView(manualStopButton);

                  dashboardContent.addView(manualButtonLayout);

                  // ADD TRIP MANUALLY
                  addTripButton = new Button(this);
                  addTripButton.setText("➕ Add Trip with Duration & Client");
                  addTripButton.setTextSize(14);
                  addTripButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                  addTripButton.setTextColor(0xFFFFFFFF);
                  addTripButton.setOnClickListener(v -> showAddTripDialog());
                  LinearLayout.LayoutParams addParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  addParams.setMargins(0, 10, 0, 0);
                  addTripButton.setLayoutParams(addParams);
                  dashboardContent.addView(addTripButton);

                  // ENHANCED: Refresh Button with Visual Feedback
                  Button refreshButton = new Button(this);
                  refreshButton.setText("🔄 Refresh Trips");
                  refreshButton.setTextSize(14);
                  refreshButton.setBackgroundColor(0xFF059669); // GREEN
                  refreshButton.setTextColor(0xFFFFFFFF);
                  refreshButton.setOnClickListener(v -> performRefreshWithFeedback(refreshButton));
                  LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  refreshParams.setMargins(0, 10, 0, 0);
                  refreshButton.setLayoutParams(refreshParams);
                  dashboardContent.addView(refreshButton);

                  // Stats
                  statsText = new TextView(this);
                  statsText.setText("Loading stats...");
                  statsText.setTextSize(12);
                  statsText.setTextColor(0xFF495057);
                  statsText.setPadding(15, 10, 15, 10);
                  statsText.setBackgroundColor(0xFFfafafa);
                  LinearLayout.LayoutParams statsParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  statsParams.setMargins(0, 10, 0, 0);
                  statsText.setLayoutParams(statsParams);
                  dashboardContent.addView(statsText);

                  // Recent Trips
                  TextView recentTripsHeader = new TextView(this);
                  recentTripsHeader.setText("📍 Recent Trips");
                  recentTripsHeader.setTextSize(16);
                  recentTripsHeader.setTextColor(0xFF495057);
                  recentTripsHeader.setPadding(0, 15, 0, 5);
                  dashboardContent.addView(recentTripsHeader);

                  ScrollView recentTripsScroll = new ScrollView(this);
                  recentTripsLayout = new LinearLayout(this);
                  recentTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  recentTripsScroll.addView(recentTripsLayout);

                  LinearLayout.LayoutParams recentScrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      200
                  );
                  recentTripsScroll.setLayoutParams(recentScrollParams);
                  dashboardContent.addView(recentTripsScroll);
              }

              private void createTripsContent() {
                  tripsContent = new LinearLayout(this);
                  tripsContent.setOrientation(LinearLayout.VERTICAL);
                  tripsContent.setPadding(20, 20, 20, 20);

                  // Header with merge functionality
                  LinearLayout headerLayout = new LinearLayout(this);
                  headerLayout.setOrientation(LinearLayout.HORIZONTAL);
                  headerLayout.setPadding(0, 0, 0, 15);
                  
                  TextView headerText = new TextView(this);
                  headerText.setText("📋 All Trips");
                  headerText.setTextSize(20);
                  headerText.setTextColor(0xFF495057);
                  LinearLayout.LayoutParams headerParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  headerText.setLayoutParams(headerParams);
                  headerLayout.addView(headerText);
                  
                  // Merge button
                  Button mergeButton = new Button(this);
                  mergeButton.setText("🔀 Merge");
                  mergeButton.setTextSize(12);
                  mergeButton.setBackgroundColor(0xFF007bff);
                  mergeButton.setTextColor(0xFFFFFFFF);
                  mergeButton.setPadding(20, 10, 20, 10);
                  LinearLayout.LayoutParams mergeParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  mergeButton.setLayoutParams(mergeParams);
                  headerLayout.addView(mergeButton);
                  
                  // Export button
                  Button exportButton = new Button(this);
                  exportButton.setText("📤 Export");
                  exportButton.setTextSize(12);
                  exportButton.setBackgroundColor(0xFF28a745);
                  exportButton.setTextColor(0xFFFFFFFF);
                  exportButton.setPadding(20, 10, 20, 10);
                  LinearLayout.LayoutParams exportParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  exportParams.setMargins(10, 0, 0, 0); // Left margin to separate from merge button
                  exportButton.setLayoutParams(exportParams);
                  headerLayout.addView(exportButton);
                  
                  // Add export button click handler
                  exportButton.setOnClickListener(v -> showExportDialog());
                  
                  // Add merge button click handler
                  mergeButton.setOnClickListener(v -> {
                      if (!mergeMode) {
                          // Enter merge mode
                          mergeMode = true;
                          mergeButton.setText("✅ Execute Merge (" + selectedTripIds.size() + ")");
                          mergeButton.setBackgroundColor(0xFF28a745);
                          updateAllTrips(); // Refresh to show checkboxes
                          Toast.makeText(MainActivity.this, "📋 Select trips to merge, then tap Execute", Toast.LENGTH_SHORT).show();
                      } else {
                          // Execute merge
                          if (selectedTripIds.size() < 2) {
                              Toast.makeText(MainActivity.this, "❌ Select at least 2 trips to merge", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          
                          // Confirm merge
                          new AlertDialog.Builder(MainActivity.this)
                              .setTitle("🔀 Confirm Merge")
                              .setMessage("Merge " + selectedTripIds.size() + " selected trips?\n\nThis will combine them into one trip and delete the originals.")
                              .setPositiveButton("✅ Merge", (dialog, which) -> {
                                  executeTripseMerge();
                              })
                              .setNegativeButton("❌ Cancel", null)
                              .show();
                      }
                  });
                  
                  tripsContent.addView(headerLayout);
                  
                  // Search and Filter Section
                  LinearLayout searchFilterSection = new LinearLayout(this);
                  searchFilterSection.setOrientation(LinearLayout.VERTICAL);
                  searchFilterSection.setPadding(0, 0, 0, 15);
                  
                  // Search bar using Android SearchView
                  SearchView searchView = new SearchView(this);
                  searchView.setQueryHint("🔍 Search trips by address, client, notes...");
                  searchView.setIconifiedByDefault(false);
                  searchView.setBackgroundColor(0xFFF8F9FA);
                  LinearLayout.LayoutParams searchParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  searchParams.setMargins(0, 0, 0, 10);
                  searchView.setLayoutParams(searchParams);
                  searchFilterSection.addView(searchView);
                  
                  // Filter row with sort and category options
                  LinearLayout filterRow = new LinearLayout(this);
                  filterRow.setOrientation(LinearLayout.HORIZONTAL);
                  filterRow.setPadding(0, 10, 0, 0);
                  filterRow.setGravity(Gravity.CENTER_VERTICAL);
                  
                  // Sort dropdown
                  TextView sortLabel = new TextView(this);
                  sortLabel.setText("Sort:");
                  sortLabel.setTextSize(12);
                  sortLabel.setPadding(0, 0, 10, 0);
                  filterRow.addView(sortLabel);
                  
                  Spinner sortSpinner = new Spinner(this);
                  String[] sortOptions = {"Newest First", "Oldest First", "Distance High-Low", "Distance Low-High"};
                  ArrayAdapter<String> sortAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, sortOptions);
                  sortAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  sortSpinner.setAdapter(sortAdapter);
                  
                  LinearLayout.LayoutParams sortParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  sortParams.setMargins(0, 0, 15, 0);
                  sortSpinner.setLayoutParams(sortParams);
                  filterRow.addView(sortSpinner);
                  
                  // Category filter dropdown  
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("Category:");
                  categoryLabel.setTextSize(12);
                  categoryLabel.setPadding(0, 0, 10, 0);
                  filterRow.addView(categoryLabel);
                  
                  Spinner categoryFilterSpinner = new Spinner(this);
                  String[] categoryFilterOptions = {"All Categories", "Business", "Personal", "Medical", "Charity"};
                  ArrayAdapter<String> categoryFilterAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categoryFilterOptions);
                  categoryFilterAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categoryFilterSpinner.setAdapter(categoryFilterAdapter);
                  
                  LinearLayout.LayoutParams categoryParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  categoryFilterSpinner.setLayoutParams(categoryParams);
                  filterRow.addView(categoryFilterSpinner);
                  
                  searchFilterSection.addView(filterRow);
                  tripsContent.addView(searchFilterSection);
                  
                  // Add event listeners for search and filtering
                  searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
                      @Override
                      public boolean onQueryTextSubmit(String query) {
                          String sortOption = sortSpinner.getSelectedItem().toString();
                          String categoryFilter = categoryFilterSpinner.getSelectedItem().toString();
                          filterAndDisplayTrips(query, sortOption, categoryFilter);
                          return true;
                      }
                      
                      @Override
                      public boolean onQueryTextChange(String newText) {
                          String sortOption = sortSpinner.getSelectedItem().toString();
                          String categoryFilter = categoryFilterSpinner.getSelectedItem().toString();
                          filterAndDisplayTrips(newText, sortOption, categoryFilter);
                          return true;
                      }
                  });
                  
                  sortSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
                      @Override
                      public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                          String searchQuery = searchView.getQuery().toString();
                          String sortOption = sortSpinner.getSelectedItem().toString();
                          String categoryFilter = categoryFilterSpinner.getSelectedItem().toString();
                          filterAndDisplayTrips(searchQuery, sortOption, categoryFilter);
                      }
                      
                      @Override
                      public void onNothingSelected(AdapterView<?> parent) {}
                  });
                  
                  categoryFilterSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
                      @Override
                      public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                          String searchQuery = searchView.getQuery().toString();
                          String sortOption = sortSpinner.getSelectedItem().toString();
                          String categoryFilter = categoryFilterSpinner.getSelectedItem().toString();
                          filterAndDisplayTrips(searchQuery, sortOption, categoryFilter);
                      }
                      
                      @Override
                      public void onNothingSelected(AdapterView<?> parent) {}
                  });

                  allTripsScroll = new ScrollView(this);
                  allTripsLayout = new LinearLayout(this);
                  allTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  
                  // Set layout parameters for allTripsLayout within ScrollView
                  ScrollView.LayoutParams allTripsLayoutParams = new ScrollView.LayoutParams(
                      ScrollView.LayoutParams.MATCH_PARENT,
                      ScrollView.LayoutParams.WRAP_CONTENT
                  );
                  allTripsLayout.setLayoutParams(allTripsLayoutParams);
                  allTripsScroll.addView(allTripsLayout);

                  // Full screen layout params - fill all available space above bottom tabs
                  LinearLayout.LayoutParams allTripsParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      0, // Use weight to fill remaining space
                      1.0f // Weight 1 = take all remaining vertical space
                  );
                  allTripsScroll.setLayoutParams(allTripsParams);
                  tripsContent.addView(allTripsScroll);
              }

              private void toggleApiSync() {
                  try {
                      boolean currentState = tripStorage.isApiSyncEnabled();
                      tripStorage.setApiSyncEnabled(!currentState);
                      updateApiToggleUI();
                      updateStats();

                      String message = tripStorage.isApiSyncEnabled() ? 
                          "API sync ON - downloading ALL your trips..." : 
                          "API sync OFF - local storage only";
                      Toast.makeText(this, message, Toast.LENGTH_SHORT).show();

                      // Trigger download when API sync is turned ON
                      if (tripStorage.isApiSyncEnabled()) {
                          triggerAllUserTripsDownload();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling API sync: " + e.getMessage(), e);
                  }
              }

              private void updateApiToggleUI() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          apiToggle.setText("🌐 API ON");
                          apiToggle.setBackgroundColor(0xFF28a745);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      } else {
                          apiToggle.setText("🌐 API OFF");
                          apiToggle.setBackgroundColor(0xFF9CA3AF);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating API toggle UI: " + e.getMessage(), e);
                  }
              }

              private void switchToTab(String tabName) {
                  try {
                      currentTab = tabName;
                      mainContentLayout.removeAllViews();

                      if ("home".equals(tabName)) {
                          mainContentLayout.addView(dashboardContent);
                          homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          updateRecentTrips();
                      } else if ("trips".equals(tabName)) {
                          mainContentLayout.addView(tripsContent);
                          homeTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          tripsTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          updateAllTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error switching tabs: " + e.getMessage(), e);
                  }
              }

              private void updateRecentTrips() {
                  try {
                      recentTripsLayout.removeAllViews();
                      List<Trip> trips = tripStorage.getAllTrips();

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips yet. API sync will download ALL your historic trips!");
                          noTripsText.setTextSize(12);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(10, 10, 10, 10);
                          recentTripsLayout.addView(noTripsText);
                      } else {
                          int maxTrips = Math.min(2, trips.size());
                          for (int i = trips.size() - maxTrips; i < trips.size(); i++) {
                              Trip trip = trips.get(i);
                              addTripCard(recentTripsLayout, trip, true);
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
                  }
              }

              // Field to track selected trips for merging
              private final List<String> selectedTripIds = new ArrayList<>();
              private boolean mergeMode = false;

              private void updateAllTrips() {
                  filterAndDisplayTrips("", "Newest First", "All Categories");
              }
              
              private void filterAndDisplayTrips(String searchQuery, String sortOption, String categoryFilter) {
                  try {
                      allTripsLayout.removeAllViews();
                      selectedTripIds.clear(); // Clear selection when refreshing
                      List<Trip> trips = tripStorage.getAllTrips();
                      
                      Log.d(TAG, "filterAndDisplayTrips() called - found " + trips.size() + " trips, search: '" + searchQuery + "', sort: '" + sortOption + "', category: '" + categoryFilter + "'");

                      // Apply search filter with null safety
                      if (!searchQuery.isEmpty()) {
                          List<Trip> filteredTrips = new ArrayList<>();
                          String query = searchQuery.toLowerCase();
                          for (Trip trip : trips) {
                              // Null-safe string checking
                              String startAddr = trip.getStartAddress() != null ? trip.getStartAddress().toLowerCase() : "";
                              String endAddr = trip.getEndAddress() != null ? trip.getEndAddress().toLowerCase() : "";
                              String clientName = trip.getClientName() != null ? trip.getClientName().toLowerCase() : "";
                              String notes = trip.getNotes() != null ? trip.getNotes().toLowerCase() : "";
                              
                              if (startAddr.contains(query) || endAddr.contains(query) || 
                                  clientName.contains(query) || notes.contains(query)) {
                                  filteredTrips.add(trip);
                              }
                          }
                          trips = filteredTrips;
                      }
                      
                      // Apply category filter
                      if (!"All Categories".equals(categoryFilter)) {
                          List<Trip> filteredTrips = new ArrayList<>();
                          for (Trip trip : trips) {
                              if (categoryFilter.equals(trip.getCategory())) {
                                  filteredTrips.add(trip);
                              }
                          }
                          trips = filteredTrips;
                      }
                      
                      // Apply sorting
                      switch (sortOption) {
                          case "Newest First":
                              trips.sort((a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
                              break;
                          case "Oldest First":
                              trips.sort((a, b) -> Long.compare(a.getStartTime(), b.getStartTime()));
                              break;
                          case "Distance High-Low":
                              trips.sort((a, b) -> Double.compare(b.getDistance(), a.getDistance()));
                              break;
                          case "Distance Low-High":
                              trips.sort((a, b) -> Double.compare(a.getDistance(), b.getDistance()));
                              break;
                      }

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          if (searchQuery.isEmpty() && "All Categories".equals(categoryFilter)) {
                              noTripsText.setText("No trips recorded yet.\n\n✅ NEW FEATURE v4.9.71:\n• DATABASE FIELD MAPPING FIXED\n• PROPER TIMESTAMP PARSING\n• AUTO-DETECTION STATUS RESTORED\n• DURATION & DATE CALCULATIONS\n• ENCRYPTED DATA HANDLING\n\nTurn ON API sync to see ALL your historic trips!");
                          } else {
                              noTripsText.setText("🔍 No trips match your search\n\nTry different keywords or change the category filter");
                          }
                          noTripsText.setTextSize(14);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(15, 30, 15, 15);
                          allTripsLayout.addView(noTripsText);
                      } else {
                          // Add result count header
                          TextView tripCount = new TextView(this);
                          tripCount.setText(String.format("📊 Showing %d trip%s", trips.size(), trips.size() == 1 ? "" : "s"));
                          tripCount.setTextSize(12);
                          tripCount.setTextColor(0xFF6C757D);
                          tripCount.setPadding(15, 5, 15, 10);
                          allTripsLayout.addView(tripCount);
                          
                          for (Trip trip : trips) {
                              addTripCard(allTripsLayout, trip, false);
                          }
                      }
                      
                      // Force UI refresh - critical fix for SearchView data display issue
                      allTripsLayout.invalidate();
                      allTripsLayout.requestLayout();
                      allTripsScroll.invalidate();
                      allTripsScroll.requestLayout();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating all trips: " + e.getMessage(), e);
                  }
              }

              private void executeTripseMerge() {
                  try {
                      tripStorage.mergeUserTrips(selectedTripIds);
                      Toast.makeText(this, "✅ Successfully merged " + selectedTripIds.size() + " trips!", Toast.LENGTH_SHORT).show();
                      
                      // Exit merge mode and refresh
                      mergeMode = false;
                      selectedTripIds.clear();
                      updateAllTrips();
                      updateStats();
                      
                      // Reset merge button
                      Button mergeButton = (Button) ((LinearLayout) tripsContent.getChildAt(0)).getChildAt(1);
                      mergeButton.setText("🔀 Merge");
                      mergeButton.setBackgroundColor(0xFF007bff);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                      Toast.makeText(this, "❌ Error merging trips: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private void addTripCard(LinearLayout parentLayout, Trip trip, boolean compact) {
                  try {
                      Log.d(TAG, "Adding trip card for: " + trip.getStartAddress() + " -> " + trip.getEndAddress());
                      
                      // Create container for checkbox + trip info
                      LinearLayout cardContainer = new LinearLayout(this);
                      cardContainer.setOrientation(LinearLayout.VERTICAL); // Changed to vertical for better icon attachment
                      cardContainer.setPadding(15, 15, 15, 15);
                      cardContainer.setBackgroundColor(0xFFffffff); // White background
                      
                      // Add border for clear card separation
                      GradientDrawable border = new GradientDrawable();
                      border.setColor(0xFFffffff);
                      border.setStroke(2, 0xFFd0d0d0); // Thicker border for separation
                      border.setCornerRadius(8);
                      cardContainer.setBackground(border);
                      
                      // Add checkbox in merge mode
                      if (mergeMode && !compact) {
                          CheckBox checkbox = new CheckBox(this);
                          checkbox.setChecked(selectedTripIds.contains(String.valueOf(trip.getId())));
                          checkbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                              String tripId = String.valueOf(trip.getId());
                              if (isChecked) {
                                  if (!selectedTripIds.contains(tripId)) {
                                      selectedTripIds.add(tripId);
                                  }
                              } else {
                                  selectedTripIds.remove(tripId);
                              }
                              
                              // Update merge button text
                              Button mergeButton = (Button) ((LinearLayout) tripsContent.getChildAt(0)).getChildAt(1);
                              mergeButton.setText("✅ Execute Merge (" + selectedTripIds.size() + ")");
                          });
                          
                          LinearLayout.LayoutParams checkboxParams = new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.WRAP_CONTENT, 
                              LinearLayout.LayoutParams.WRAP_CONTENT
                          );
                          checkbox.setLayoutParams(checkboxParams);
                          cardContainer.addView(checkbox);
                      }
                      
                      TextView tripView = new TextView(this);
                      String tripType = trip.isAutoDetected() ? "🤖 Auto" : "✋ Manual";
                      String apiStatus = tripStorage.isApiSyncEnabled() ? "📤 API" : "💾 Local";

                      if (compact) {
                          String clientInfo = trip.getClientName() != null ? " • " + trip.getClientName() : "";
                          tripView.setText(String.format(
                              "%s %s • %.1f mi • %s%s",
                              tripType,
                              apiStatus,
                              trip.getDistance(),
                              trip.getCategory(),
                              clientInfo
                          ));
                          tripView.setTextSize(11);
                      } else {
                          StringBuilder tripDetails = new StringBuilder();
                          tripDetails.append(String.format(
                              "%s %s • %s\n%.2f miles • %s • %s\nFrom: %s\nTo: %s",
                              tripType,
                              apiStatus,
                              trip.getFormattedDate(),
                              trip.getDistance(),
                              trip.getFormattedDuration(),
                              trip.getCategory(),
                              trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown",
                              trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown"
                          ));

                          // ADD CLIENT AND NOTES TO TRIP DISPLAY
                          if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                              tripDetails.append("\nClient: ").append(trip.getClientName());
                          }
                          if (trip.getNotes() != null && !trip.getNotes().trim().isEmpty()) {
                              tripDetails.append("\nNotes: ").append(trip.getNotes());
                          }

                          tripView.setText(tripDetails.toString());
                          tripView.setTextSize(12);
                      }

                      tripView.setTextColor(0xFF495057);
                      tripView.setPadding(10, 10, 10, 10);
                      tripView.setBackgroundColor(0xFFffffff);
                      tripView.setMinHeight(60); // Ensure minimum height for visibility

                      // Create vertical layout for trip content + icons FIRST
                      LinearLayout tripContentLayout = new LinearLayout(this);
                      tripContentLayout.setOrientation(LinearLayout.VERTICAL);
                      tripContentLayout.addView(tripView);
                      
                      // Add icons row at the bottom of the trip content (non-compact view only)
                      if (!compact) {
                          // Icons row positioned at bottom with background to clearly attach to trip
                          LinearLayout iconsRow = new LinearLayout(this);
                          iconsRow.setOrientation(LinearLayout.HORIZONTAL);
                          iconsRow.setGravity(Gravity.CENTER);
                          iconsRow.setPadding(10, 8, 10, 8);
                          iconsRow.setBackgroundColor(0xFFF5F5F5); // Light gray background to visually attach icons to trip
                          
                          // Create rounded corners for icon area
                          GradientDrawable iconBorder = new GradientDrawable();
                          iconBorder.setColor(0xFFF5F5F5);
                          iconBorder.setCornerRadius(6);
                          iconsRow.setBackground(iconBorder);
                          
                          LinearLayout.LayoutParams iconsRowParams = new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.MATCH_PARENT,
                              LinearLayout.LayoutParams.WRAP_CONTENT
                          );
                          iconsRowParams.setMargins(0, 15, 0, 0); // Top margin to separate from trip details
                          iconsRow.setLayoutParams(iconsRowParams);
                          
                          // Edit icon - clean, no background
                          TextView editIcon = new TextView(this);
                          editIcon.setText("✏️");
                          editIcon.setTextSize(24);
                          editIcon.setPadding(12, 8, 12, 8);
                          editIcon.setGravity(Gravity.CENTER);
                          editIcon.setClickable(true);
                          editIcon.setOnClickListener(v -> showEditTripDialog(trip));
                          
                          LinearLayout.LayoutParams iconParams = new LinearLayout.LayoutParams(
                              LinearLayout.LayoutParams.WRAP_CONTENT,
                              LinearLayout.LayoutParams.WRAP_CONTENT
                          );
                          iconParams.setMargins(15, 0, 15, 0); // Space between icons
                          
                          // Split icon - clean, no background
                          TextView splitIcon = new TextView(this);
                          splitIcon.setText("✂️");
                          splitIcon.setTextSize(24);
                          splitIcon.setPadding(12, 8, 12, 8);
                          splitIcon.setGravity(Gravity.CENTER);
                          splitIcon.setClickable(true);
                          splitIcon.setOnClickListener(v -> showSplitTripDialog(trip));
                          
                          // Delete icon - clean, no background
                          TextView deleteIcon = new TextView(this);
                          deleteIcon.setText("🗑️");
                          deleteIcon.setTextSize(24);
                          deleteIcon.setPadding(12, 8, 12, 8);
                          deleteIcon.setGravity(Gravity.CENTER);
                          deleteIcon.setClickable(true);
                          deleteIcon.setOnClickListener(v -> showDeleteConfirmationDialog(trip));
                          
                          iconsRow.addView(editIcon, iconParams);
                          iconsRow.addView(splitIcon, iconParams);
                          iconsRow.addView(deleteIcon, iconParams);
                          
                          tripContentLayout.addView(iconsRow);
                      }
                      
                      // Set layout params for trip content within container
                      LinearLayout.LayoutParams tripContentParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      tripContentLayout.setLayoutParams(tripContentParams);
                      cardContainer.addView(tripContentLayout);

                      // Set layout params with better spacing between cards
                      LinearLayout.LayoutParams containerParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT,
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      containerParams.setMargins(0, 5, 0, 20); // Increased bottom margin for better separation
                      cardContainer.setLayoutParams(containerParams);

                      // Add the card container to parent layout AFTER everything is built
                      parentLayout.addView(cardContainer);
                      Log.d(TAG, "Trip card added successfully to parent layout");
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding trip card: " + e.getMessage(), e);
                  }
              }

              // ENHANCED ADD TRIP DIALOG WITH DURATION INPUT FIELD
              private void showAddTripDialog() {
                  try {
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Add Trip with Duration & Client");

                      ScrollView scrollView = new ScrollView(this);
                      LinearLayout layout = new LinearLayout(this);
                      layout.setOrientation(LinearLayout.VERTICAL);
                      layout.setPadding(40, 15, 40, 15);

                      // DATE PICKER FIELD
                      TextView dateLabel = new TextView(this);
                      dateLabel.setText("Trip Date:");
                      dateLabel.setTextSize(14);
                      dateLabel.setTextColor(0xFF495057);
                      dateLabel.setPadding(0, 0, 0, 5);
                      layout.addView(dateLabel);

                      Button datePickerButton = new Button(this);
                      datePickerButton.setText("Select Date");
                      datePickerButton.setBackgroundColor(0xFFe9ecef);
                      datePickerButton.setTextColor(0xFF495057);
                      java.util.Calendar calendar = java.util.Calendar.getInstance();
                      final int[] selectedYear = {calendar.get(java.util.Calendar.YEAR)};
                      final int[] selectedMonth = {calendar.get(java.util.Calendar.MONTH)};
                      final int[] selectedDay = {calendar.get(java.util.Calendar.DAY_OF_MONTH)};
                      
                      datePickerButton.setText(String.format("%d/%d/%d", selectedMonth[0] + 1, selectedDay[0], selectedYear[0]));
                      
                      datePickerButton.setOnClickListener(v -> {
                          android.app.DatePickerDialog datePickerDialog = new android.app.DatePickerDialog(
                              this,
                              (view, year, month, dayOfMonth) -> {
                                  selectedYear[0] = year;
                                  selectedMonth[0] = month;
                                  selectedDay[0] = dayOfMonth;
                                  datePickerButton.setText(String.format("%d/%d/%d", month + 1, dayOfMonth, year));
                              },
                              selectedYear[0], selectedMonth[0], selectedDay[0]
                          );
                          datePickerDialog.show();
                      });
                      layout.addView(datePickerButton);

                      EditText startLocationInput = new EditText(this);
                      startLocationInput.setHint("Start location (e.g., Home)");
                      layout.addView(startLocationInput);

                      EditText endLocationInput = new EditText(this);
                      endLocationInput.setHint("End location (e.g., Client Office)");
                      layout.addView(endLocationInput);

                      EditText distanceInput = new EditText(this);
                      distanceInput.setHint("Distance in miles (e.g., 12.5)");
                      distanceInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                      layout.addView(distanceInput);

                      // DURATION INPUT FIELD
                      TextView durationLabel = new TextView(this);
                      durationLabel.setText("Duration (enter your own time):");
                      durationLabel.setTextSize(14);
                      durationLabel.setTextColor(0xFF495057);
                      durationLabel.setPadding(0, 10, 0, 5);
                      layout.addView(durationLabel);

                      EditText durationInput = new EditText(this);
                      durationInput.setHint("Duration in minutes (e.g., 25)");
                      durationInput.setInputType(InputType.TYPE_CLASS_NUMBER);
                      layout.addView(durationInput);

                      Spinner categorySpinner = new Spinner(this);
                      String[] categories = {"Personal", "Business", "Medical", "Charity"};
                      ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                      categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                      categorySpinner.setAdapter(categoryAdapter);
                      layout.addView(categorySpinner);

                      // CLIENT DROPDOWN
                      TextView clientLabel = new TextView(this);
                      clientLabel.setText("Client (Optional):");
                      clientLabel.setTextSize(14);
                      clientLabel.setTextColor(0xFF495057);
                      clientLabel.setPadding(0, 10, 0, 5);
                      layout.addView(clientLabel);

                      Spinner clientSpinner = new Spinner(this);
                      List<String> clientOptions = getClientOptions();
                      ArrayAdapter<String> clientAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, clientOptions);
                      clientAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                      clientSpinner.setAdapter(clientAdapter);
                      layout.addView(clientSpinner);

                      // NOTES FIELD
                      TextView notesLabel = new TextView(this);
                      notesLabel.setText("Notes/Description (Optional):");
                      notesLabel.setTextSize(14);
                      notesLabel.setTextColor(0xFF495057);
                      notesLabel.setPadding(0, 10, 0, 5);
                      layout.addView(notesLabel);

                      EditText notesInput = new EditText(this);
                      notesInput.setHint("Purpose, meeting details, project notes, etc.");
                      notesInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE);
                      notesInput.setMinLines(2);
                      notesInput.setMaxLines(4);
                      layout.addView(notesInput);

                      scrollView.addView(layout);
                      builder.setView(scrollView);

                      builder.setPositiveButton("Save Trip", (dialog, which) -> {
                          String startLocation = startLocationInput.getText().toString().trim();
                          String endLocation = endLocationInput.getText().toString().trim();
                          String distanceStr = distanceInput.getText().toString().trim();
                          String durationStr = durationInput.getText().toString().trim();
                          String category = categorySpinner.getSelectedItem().toString();
                          String selectedClient = clientSpinner.getSelectedItem().toString();
                          String notes = notesInput.getText().toString().trim();

                          if (startLocation.isEmpty() || endLocation.isEmpty() || distanceStr.isEmpty() || durationStr.isEmpty()) {
                              Toast.makeText(this, "Please fill all required fields including duration", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          try {
                              double distance = Double.parseDouble(distanceStr);
                              int durationMinutes = Integer.parseInt(durationStr);

                              // Process client selection
                              String clientName = null;
                              if (!"None".equals(selectedClient) && !"+ Add New Client".equals(selectedClient)) {
                                  clientName = selectedClient;
                              }

                              // Create selected date timestamp
                              java.util.Calendar selectedDate = java.util.Calendar.getInstance();
                              selectedDate.set(selectedYear[0], selectedMonth[0], selectedDay[0], 0, 0, 0);
                              selectedDate.set(java.util.Calendar.MILLISECOND, 0);
                              long selectedDateTimestamp = selectedDate.getTimeInMillis();

                              if ("+ Add New Client".equals(selectedClient)) {
                                  // Show add new client dialog
                                  showAddClientDialog(startLocation, endLocation, distance, durationMinutes, category, notes, selectedDateTimestamp);
                                  return;
                              }
                              
                              saveManualTripWithDuration(startLocation, endLocation, distance, durationMinutes, category, clientName, notes, selectedDateTimestamp);

                          } catch (NumberFormatException e) {
                              Toast.makeText(this, "Invalid distance or duration format", Toast.LENGTH_SHORT).show();
                          }
                      });

                      builder.setNegativeButton("Cancel", null);
                      builder.show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error showing add trip dialog: " + e.getMessage(), e);
                  }
              }

              private List<String> getClientOptions() {
                  List<String> options = new ArrayList<>();
                  options.add("None");

                  // Get existing clients from trips
                  List<Trip> trips = tripStorage.getAllTrips();
                  List<String> existingClients = new ArrayList<>();
                  for (Trip trip : trips) {
                      if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                          String clientName = trip.getClientName().trim();
                          if (!existingClients.contains(clientName)) {
                              existingClients.add(clientName);
                          }
                      }
                  }

                  options.addAll(existingClients);
                  options.add("+ Add New Client");

                  return options;
              }

              private void showAddClientDialog(String startLocation, String endLocation, double distance, int durationMinutes, String category, String notes, long selectedDateTimestamp) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Add New Client");

                  EditText clientInput = new EditText(this);
                  clientInput.setHint("Client name (e.g., ABC Company)");
                  builder.setView(clientInput);

                  builder.setPositiveButton("Add Client", (dialog, which) -> {
                      String newClientName = clientInput.getText().toString().trim();
                      if (!newClientName.isEmpty()) {
                          saveManualTripWithDuration(startLocation, endLocation, distance, durationMinutes, category, newClientName, notes, selectedDateTimestamp);
                      } else {
                          Toast.makeText(this, "Client name cannot be empty", Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              // Use user-entered duration instead of calculated
              private void saveManualTripWithDuration(String startLocation, String endLocation, double distance, int durationMinutes, String category, String clientName, String notes, long selectedDateTimestamp) {
                  try {
                      Trip trip = new Trip();
                      trip.setStartAddress(startLocation);
                      trip.setEndAddress(endLocation);
                      trip.setDistance(distance);
                      trip.setCategory(category);
                      trip.setAutoDetected(false);

                      // SET CLIENT AND NOTES
                      trip.setClientName(clientName);
                      trip.setNotes(notes);

                      // Set approximate coordinates
                      trip.setStartLatitude(40.7128);
                      trip.setStartLongitude(-74.0060);
                      trip.setEndLatitude(40.7589);
                      trip.setEndLongitude(-73.9851);

                      // USE USER-ENTERED DURATION AND SELECTED DATE
                      long userDuration = durationMinutes * 60 * 1000; // Convert minutes to milliseconds
                      trip.setStartTime(selectedDateTimestamp);
                      trip.setEndTime(selectedDateTimestamp + userDuration);
                      trip.setDuration(userDuration);

                      // Generate unique ID
                      long currentTime = System.currentTimeMillis();
                      trip.setId(currentTime);

                      Log.d(TAG, String.format("Manual trip with USER duration: %.2f miles, %d minutes", distance, durationMinutes));

                      // Save locally
                      tripStorage.saveTrip(trip);

                      // Save to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudBackup = new CloudBackupService(this);
                          cloudBackup.backupTrip(trip);
                          String clientInfo = clientName != null ? " for " + clientName : "";
                          String notesInfo = notes != null && !notes.isEmpty() ? " with notes" : "";
                          Toast.makeText(this, String.format("Trip saved (%dm)%s%s and synced!", durationMinutes, clientInfo, notesInfo), Toast.LENGTH_SHORT).show();
                      } else {
                          Toast.makeText(this, String.format("Trip saved locally (%dm)!", durationMinutes), Toast.LENGTH_SHORT).show();
                      }

                      updateStats();

                      if ("home".equals(currentTab)) {
                          updateRecentTrips();
                      } else {
                          updateAllTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving manual trip with duration: " + e.getMessage(), e);
                  }
              }

              // Rest of methods - copy exactly from working version (no changes needed)
              private void startManualTrip() {
                  try {
                      if (manualTripInProgress) {
                          Toast.makeText(this, "Manual trip already in progress", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      
                      // Pause auto detection during manual trip to prevent duplicates
                      if (autoDetectionEnabled) {
                          SharedPreferences prefs = getSharedPreferences("MileTrackerPrefs", Context.MODE_PRIVATE);
                          prefs.edit().putBoolean("auto_detection_was_enabled", true).apply();
                          autoDetectionEnabled = false;
                          if (autoToggle != null) {
                              autoToggle.setText("🔄 Auto OFF");
                              autoToggle.setBackgroundColor(0xFF9CA3AF);
                          }
                          Toast.makeText(this, "🤖 Auto detection paused during manual trip", Toast.LENGTH_SHORT).show();
                      }

                      Intent serviceIntent = new Intent(this, ManualTripService.class);
                      serviceIntent.setAction("START_MANUAL_TRIP");
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                          startForegroundService(serviceIntent);
                      } else {
                          startService(serviceIntent);
                      }

                      manualTripInProgress = true;
                      manualStartButton.setEnabled(false);
                      manualStopButton.setEnabled(true);
                      statusText.setText("Manual trip recording...");

                      String apiStatus = tripStorage.isApiSyncEnabled() ? " with API sync" : " (local only)";
                      Toast.makeText(this, "Manual trip started" + apiStatus, Toast.LENGTH_SHORT).show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (!manualTripInProgress) {
                          Toast.makeText(this, "No manual trip in progress", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      Intent serviceIntent = new Intent(this, ManualTripService.class);
                      serviceIntent.setAction("STOP_MANUAL_TRIP");
                      startService(serviceIntent);

                      manualTripInProgress = false;
                      manualStartButton.setEnabled(true);
                      manualStopButton.setEnabled(false);
                      statusText.setText("Manual trip completed");

                      // Resume auto detection if it was enabled before manual trip
                      SharedPreferences prefs = getSharedPreferences("MileTrackerPrefs", Context.MODE_PRIVATE);
                      boolean wasAutoEnabled = prefs.getBoolean("auto_detection_was_enabled", false);
                      if (wasAutoEnabled) {
                          autoDetectionEnabled = true;
                          if (autoToggle != null) {
                              autoToggle.setText("🔄 Auto ON");
                              autoToggle.setBackgroundColor(0xFF667eea);
                          }
                          prefs.edit().remove("auto_detection_was_enabled").apply();
                          Toast.makeText(this, "🤖 Auto detection resumed", Toast.LENGTH_SHORT).show();
                      }

                      String apiStatus = tripStorage.isApiSyncEnabled() ? " and synced!" : " (saved locally)!";
                      Toast.makeText(this, "Trip saved" + apiStatus, Toast.LENGTH_SHORT).show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void toggleAutoDetection() {
                  try {
                      autoDetectionEnabled = !autoDetectionEnabled;

                      if (autoDetectionEnabled) {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");

                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }

                          autoToggle.setText("🤖 Auto ON");
                          autoToggle.setBackgroundColor(0xFF28a745);
                          statusText.setText("Auto detection active - Monitoring for trips");

                          String apiStatus = tripStorage.isApiSyncEnabled() ? " with API sync" : " (local only)";
                          Toast.makeText(this, "Auto detection started" + apiStatus, Toast.LENGTH_SHORT).show();
                      } else {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("STOP_AUTO_DETECTION");
                          startService(serviceIntent);

                          autoToggle.setText("🔄 Auto OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Auto detection stopped");
                          Toast.makeText(this, "Auto detection stopped", Toast.LENGTH_SHORT).show();
                      }

                      updateStats();
                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling auto detection: " + e.getMessage(), e);
                  }
              }

              private void updateStats() {
                  try {
                      List<Trip> trips = tripStorage.getAllTrips();
                      double totalMiles = 0;
                      double businessMiles = 0;
                      double personalMiles = 0;
                      double medicalMiles = 0;
                      double charityMiles = 0;

                      for (Trip trip : trips) {
                          totalMiles += trip.getDistance();

                          if ("Business".equals(trip.getCategory())) {
                              businessMiles += trip.getDistance();
                          } else if ("Personal".equals(trip.getCategory())) {
                              personalMiles += trip.getDistance();
                          } else if ("Medical".equals(trip.getCategory())) {
                              medicalMiles += trip.getDistance();
                          } else if ("Charity".equals(trip.getCategory())) {
                              charityMiles += trip.getDistance();
                          }
                      }

                      double businessDeduction = businessMiles * 0.70;
                      double personalDeduction = personalMiles * 0.21;
                      double medicalDeduction = medicalMiles * 0.21;
                      double charityDeduction = charityMiles * 0.14;
                      double totalDeduction = businessDeduction + personalDeduction + medicalDeduction + charityDeduction;

                      String apiStatus = tripStorage.isApiSyncEnabled() ? "API ON" : "API OFF";
                      String autoStatus = autoDetectionEnabled ? "Auto ON" : "Auto OFF";

                      String stats = String.format(
                          "📊 Total: %.1f miles (%d trips)\n💼 Business: %.1f mi ($%.2f)\n🏠 Personal: %.1f mi ($%.2f)\n🏥 Medical: %.1f mi ($%.2f)\n❤️ Charity: %.1f mi ($%.2f)\n💰 Total Deduction: $%.2f\n\n🌐 %s • 🤖 %s\n📱 Device: %s\n👤 User: %s\n\n✅ STABLE DEVICE + USER LINKING!\nDownloads ALL trips for this user",
                          totalMiles, trips.size(),
                          businessMiles, businessDeduction,
                          personalMiles, personalDeduction,
                          medicalMiles, medicalDeduction,
                          charityMiles, charityDeduction,
                          totalDeduction,
                          apiStatus, autoStatus,
                          tripStorage.getStableDeviceId(),
                          tripStorage.getUserId()
                      );

                      if (statsText != null) {
                          statsText.setText(stats);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                  }
              }

              private void initializeGPS() {
                  try {
                      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                      if (locationManager != null && ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                          statusText.setText("GPS ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error initializing GPS: " + e.getMessage(), e);
                  }
              }

              private void setupSpeedMonitoring() {
                  try {
                      speedRunnable = new Runnable() {
                          @Override
                          public void run() {
                              if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED && locationManager != null) {
                                  try {
                                      android.location.Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                                      if (lastKnownLocation != null && speedText != null) {
                                          float speed = lastKnownLocation.getSpeed() * 2.237f; // Convert m/s to mph
                                          speedText.setText(String.format("Speed: %.1f mph", speed));
                                      }
                                  } catch (Exception e) {
                                      Log.w(TAG, "Error getting speed: " + e.getMessage());
                                  }
                              }
                              speedHandler.postDelayed(this, 5000); // Update every 5 seconds
                          }
                      };
                      speedHandler.post(speedRunnable);
                  } catch (Exception e) {
                      Log.e(TAG, "Error setting up speed monitoring: " + e.getMessage(), e);
                  }
              }

              private void registerBroadcastReceiver() {
                  try {
                      BroadcastReceiver manualTripReceiver = new BroadcastReceiver() {
                          @Override
                          public void onReceive(Context context, Intent intent) {
                              String status = intent.getStringExtra("status");
                              double distance = intent.getDoubleExtra("distance", 0);
                              long duration = intent.getLongExtra("duration", 0);

                              if ("started".equals(status)) {
                                  statusText.setText("Manual trip recording...");
                              } else if ("recording".equals(status)) {
                                  statusText.setText(String.format("Recording: %.2f miles", distance));
                              } else if ("completed".equals(status)) {
                                  statusText.setText("Manual trip completed");
                                  updateStats();
                                  if ("home".equals(currentTab)) {
                                      updateRecentTrips();
                                  } else {
                                      updateAllTrips();
                                  }
                              }
                          }
                      };

                      IntentFilter filter = new IntentFilter("MANUAL_TRIP_UPDATE");
                      registerReceiver(manualTripReceiver, filter);
                  } catch (Exception e) {
                      Log.e(TAG, "Error registering broadcast receiver: " + e.getMessage(), e);
                  }
              }

              private void restoreAutoDetectionState() {
                  try {
                      autoDetectionEnabled = tripStorage.isAutoDetectionEnabled();
                      if (autoDetectionEnabled) {
                          // MINIMAL FIX: Start the actual service when user previously enabled it
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }
                          
                          autoToggle.setText("🤖 Auto ON");
                          autoToggle.setBackgroundColor(0xFF28a745);
                          statusText.setText("Auto detection active");
                      } else {
                          autoToggle.setText("🔄 Auto OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error restoring auto detection state: " + e.getMessage(), e);
                  }
              }

              private void requestPermissions() {
                  try {
                      if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this, 
                              new String[]{
                                  Manifest.permission.ACCESS_FINE_LOCATION,
                                  Manifest.permission.ACCESS_COARSE_LOCATION
                              }, 
                              LOCATION_PERMISSION_REQUEST);
                      } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && 
                                 ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this,
                              new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION},
                              BACKGROUND_LOCATION_PERMISSION_REQUEST);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error requesting permissions: " + e.getMessage(), e);
                  }
              }

              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);

                  if (requestCode == LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Location permission granted", Toast.LENGTH_SHORT).show();
                          initializeGPS();

                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                              requestPermissions();
                          }
                      } else {
                          Toast.makeText(this, "Location permission required for trip tracking", Toast.LENGTH_LONG).show();
                      }
                  } else if (requestCode == BACKGROUND_LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Background location permission granted", Toast.LENGTH_SHORT).show();
                      } else {
                          Toast.makeText(this, "Background location permission recommended for auto detection", Toast.LENGTH_LONG).show();
                      }
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  // Handle location updates if needed
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  if (speedHandler != null && speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
              }

              // ENHANCED: Refresh with visual feedback and API sync
              private void performRefreshWithFeedback(Button refreshButton) {
                  // Show loading state
                  refreshButton.setText("⏳ Loading...");
                  refreshButton.setEnabled(false);
                  
                  Toast.makeText(this, "🔄 Refreshing trips from API...", Toast.LENGTH_SHORT).show();
                  
                  new Thread(() -> {
                      try {
                          // Download latest trips from API if sync enabled
                          if (tripStorage.isApiSyncEnabled()) {
                              try {
                                  CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                  cloudService.downloadAllUserTrips();
                              } catch (Exception e) {
                                  Log.e(TAG, "API download failed: " + e.getMessage());
                              }
                          }
                          
                          // Update UI on main thread
                          runOnUiThread(() -> {
                              // Reset button
                              refreshButton.setText("🔄 Refresh Trips");
                              refreshButton.setEnabled(true);
                              
                              // Update displays
                              if ("home".equals(currentTab)) {
                                  updateRecentTrips();
                              } else {
                                  updateAllTrips();
                              }
                              updateStats();
                              
                              // Show success feedback
                              Toast.makeText(MainActivity.this, "✅ Trips refreshed successfully!", Toast.LENGTH_SHORT).show();
                          });
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error during refresh: " + e.getMessage(), e);
                          
                          runOnUiThread(() -> {
                              // Reset button
                              refreshButton.setText("🔄 Refresh Trips");
                              refreshButton.setEnabled(true);
                              
                              // Show error feedback
                              Toast.makeText(MainActivity.this, "⚠️ Refresh failed - using local data", Toast.LENGTH_SHORT).show();
                          });
                      }
                  }).start();
              }

              // ENHANCED: Complete edit dialog for all trip fields
              private void showEditTripDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("✏️ Edit Trip - All Fields");

                  // Create scrollable layout
                  ScrollView scrollView = new ScrollView(this);
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(50, 20, 50, 20);

                  // Trip Date
                  TextView dateLabel = new TextView(this);
                  dateLabel.setText("Trip Date:");
                  dateLabel.setTextSize(14);
                  dateLabel.setTypeface(null, Typeface.BOLD);
                  
                  Button dateButton = new Button(this);
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy", Locale.US);
                  Calendar tripDate = Calendar.getInstance();
                  tripDate.setTimeInMillis(trip.getStartTime());
                  dateButton.setText(dateFormat.format(tripDate.getTime()));
                  dateButton.setBackgroundColor(0xFFE5E7EB);
                  dateButton.setTextColor(0xFF374151);
                  
                  dateButton.setOnClickListener(v -> {
                      DatePickerDialog datePicker = new DatePickerDialog(this,
                          (view, year, month, dayOfMonth) -> {
                              tripDate.set(year, month, dayOfMonth);
                              dateButton.setText(dateFormat.format(tripDate.getTime()));
                          },
                          tripDate.get(Calendar.YEAR),
                          tripDate.get(Calendar.MONTH),
                          tripDate.get(Calendar.DAY_OF_MONTH));
                      datePicker.show();
                  });

                  // Start Time
                  TextView startTimeLabel = new TextView(this);
                  startTimeLabel.setText("Start Time:");
                  startTimeLabel.setTextSize(14);
                  startTimeLabel.setTypeface(null, Typeface.BOLD);
                  startTimeLabel.setPadding(0, 10, 0, 0);
                  
                  EditText startTimeEdit = new EditText(this);
                  SimpleDateFormat timeFormat = new SimpleDateFormat("h:mm a", Locale.US);
                  startTimeEdit.setText(timeFormat.format(new Date(trip.getStartTime())));
                  startTimeEdit.setHint("9:00 AM");

                  // Duration (minutes)
                  TextView durationLabel = new TextView(this);
                  durationLabel.setText("Duration (minutes):");
                  durationLabel.setTextSize(14);
                  durationLabel.setTypeface(null, Typeface.BOLD);
                  durationLabel.setPadding(0, 10, 0, 0);
                  
                  EditText durationEdit = new EditText(this);
                  long durationMinutes = trip.getDuration() / (60 * 1000); // Convert ms to minutes
                  durationEdit.setText(String.valueOf(durationMinutes));
                  durationEdit.setInputType(InputType.TYPE_CLASS_NUMBER);
                  durationEdit.setHint("30");

                  // Start Location
                  TextView startLabel = new TextView(this);
                  startLabel.setText("Start Location:");
                  startLabel.setTextSize(14);
                  startLabel.setTypeface(null, Typeface.BOLD);
                  startLabel.setPadding(0, 10, 0, 0);
                  
                  EditText startLocationEdit = new EditText(this);
                  startLocationEdit.setText(trip.getStartAddress());
                  startLocationEdit.setHint("Home, office, client address, etc.");

                  // End Location
                  TextView endLabel = new TextView(this);
                  endLabel.setText("End Location:");
                  endLabel.setTextSize(14);
                  endLabel.setTypeface(null, Typeface.BOLD);
                  endLabel.setPadding(0, 10, 0, 0);
                  
                  EditText endLocationEdit = new EditText(this);
                  endLocationEdit.setText(trip.getEndAddress());
                  endLocationEdit.setHint("Meeting location, store, etc.");

                  // Distance
                  TextView distanceLabel = new TextView(this);
                  distanceLabel.setText("Distance (miles):");
                  distanceLabel.setTextSize(14);
                  distanceLabel.setTypeface(null, Typeface.BOLD);
                  distanceLabel.setPadding(0, 10, 0, 0);
                  
                  EditText distanceEdit = new EditText(this);
                  distanceEdit.setText(String.valueOf(trip.getDistance()));
                  distanceEdit.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  distanceEdit.setHint("0.0");

                  // Category
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("Category:");
                  categoryLabel.setTextSize(14);
                  categoryLabel.setTypeface(null, Typeface.BOLD);
                  categoryLabel.setPadding(0, 10, 0, 0);
                  
                  Spinner categorySpinner = new Spinner(this);
                  String[] categories = {"Personal", "Business", "Medical", "Charity"};
                  ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                  categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categorySpinner.setAdapter(categoryAdapter);
                  
                  // Set current category
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(trip.getCategory())) {
                          categorySpinner.setSelection(i);
                          break;
                      }
                  }

                  // Auto-Detected Toggle
                  TextView autoDetectedLabel = new TextView(this);
                  autoDetectedLabel.setText("Auto-Detected:");
                  autoDetectedLabel.setTextSize(14);
                  autoDetectedLabel.setTypeface(null, Typeface.BOLD);
                  autoDetectedLabel.setPadding(0, 10, 0, 0);
                  
                  LinearLayout autoDetectedLayout = new LinearLayout(this);
                  autoDetectedLayout.setOrientation(LinearLayout.HORIZONTAL);
                  autoDetectedLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  Switch autoDetectedSwitch = new Switch(this);
                  autoDetectedSwitch.setChecked(trip.isAutoDetected());
                  
                  TextView autoDetectedInfo = new TextView(this);
                  autoDetectedInfo.setText("🤖 Auto vs ✋ Manual");
                  autoDetectedInfo.setTextSize(12);
                  autoDetectedInfo.setTextColor(0xFF6B7280);
                  autoDetectedInfo.setPadding(10, 0, 0, 0);
                  
                  autoDetectedLayout.addView(autoDetectedSwitch);
                  autoDetectedLayout.addView(autoDetectedInfo);

                  // Client Name
                  TextView clientLabel = new TextView(this);
                  clientLabel.setText("Client Name (optional):");
                  clientLabel.setTextSize(14);
                  clientLabel.setTypeface(null, Typeface.BOLD);
                  clientLabel.setPadding(0, 10, 0, 0);
                  
                  EditText clientEdit = new EditText(this);
                  clientEdit.setText(trip.getClientName() != null ? trip.getClientName() : "");
                  clientEdit.setHint("Client or company name");

                  // Notes
                  TextView notesLabel = new TextView(this);
                  notesLabel.setText("Notes (optional):");
                  notesLabel.setTextSize(14);
                  notesLabel.setTypeface(null, Typeface.BOLD);
                  notesLabel.setPadding(0, 10, 0, 0);
                  
                  EditText notesEdit = new EditText(this);
                  notesEdit.setText(trip.getNotes() != null ? trip.getNotes() : "");
                  notesEdit.setHint("Trip purpose, meeting details, etc.");
                  notesEdit.setMaxLines(3);

                  // Add all components to layout
                  layout.addView(dateLabel);
                  layout.addView(dateButton);
                  layout.addView(startTimeLabel);
                  layout.addView(startTimeEdit);
                  layout.addView(durationLabel);
                  layout.addView(durationEdit);
                  layout.addView(startLabel);
                  layout.addView(startLocationEdit);
                  layout.addView(endLabel);
                  layout.addView(endLocationEdit);
                  layout.addView(distanceLabel);
                  layout.addView(distanceEdit);
                  layout.addView(categoryLabel);
                  layout.addView(categorySpinner);
                  layout.addView(autoDetectedLabel);
                  layout.addView(autoDetectedLayout);
                  layout.addView(clientLabel);
                  layout.addView(clientEdit);
                  layout.addView(notesLabel);
                  layout.addView(notesEdit);

                  scrollView.addView(layout);
                  builder.setView(scrollView);

                  builder.setPositiveButton("💾 Save Changes", (dialog, which) -> {
                      try {
                          // Parse and validate all fields
                          String startLocation = startLocationEdit.getText().toString().trim();
                          String endLocation = endLocationEdit.getText().toString().trim();
                          double distance = Double.parseDouble(distanceEdit.getText().toString());
                          long durationMins = Long.parseLong(durationEdit.getText().toString());
                          String startTimeStr = startTimeEdit.getText().toString().trim();
                          
                          // Validation
                          if (startLocation.isEmpty() || endLocation.isEmpty()) {
                              Toast.makeText(this, "Start and end locations are required", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          
                          // Update trip date and time
                          Calendar updatedDate = Calendar.getInstance();
                          updatedDate.setTimeInMillis(tripDate.getTimeInMillis());
                          
                          // Parse start time (simplified - assumes format like "9:00 AM")
                          try {
                              Date startTime = timeFormat.parse(startTimeStr);
                              if (startTime != null) {
                                  Calendar timeCalendar = Calendar.getInstance();
                                  timeCalendar.setTime(startTime);
                                  updatedDate.set(Calendar.HOUR_OF_DAY, timeCalendar.get(Calendar.HOUR_OF_DAY));
                                  updatedDate.set(Calendar.MINUTE, timeCalendar.get(Calendar.MINUTE));
                              }
                          } catch (Exception e) {
                              Log.w(TAG, "Could not parse start time, keeping original time");
                          }
                          
                          // Update all trip fields
                          trip.setStartAddress(startLocation);
                          trip.setEndAddress(endLocation);
                          trip.setDistance(distance);
                          trip.setDuration(durationMins * 60 * 1000); // Convert minutes to milliseconds
                          trip.setCategory(categorySpinner.getSelectedItem().toString());
                          trip.setAutoDetected(autoDetectedSwitch.isChecked());
                          trip.setClientName(clientEdit.getText().toString().trim());
                          trip.setNotes(notesEdit.getText().toString().trim());
                          
                          // Update timestamps
                          trip.setStartTime(updatedDate.getTimeInMillis());
                          trip.setEndTime(updatedDate.getTimeInMillis() + trip.getDuration());

                          // Save trip and sync to API
                          tripStorage.saveTrip(trip);
                          if (tripStorage.isApiSyncEnabled()) {
                              try {
                                  CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                  cloudService.backupTrip(trip);
                              } catch (Exception e) {
                                  Log.e(TAG, "API backup failed: " + e.getMessage());
                              }
                          }
                          
                          Toast.makeText(this, "✅ All trip details updated successfully!", Toast.LENGTH_SHORT).show();
                          if ("home".equals(currentTab)) {
                              updateRecentTrips();
                          } else {
                              updateAllTrips();
                          }
                          updateStats();
                          
                          Log.d(TAG, "Trip fully updated: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                                " on " + dateFormat.format(new Date(trip.getStartTime())));
                          
                      } catch (NumberFormatException e) {
                          Toast.makeText(this, "Please enter valid numbers for distance and duration", Toast.LENGTH_SHORT).show();
                      } catch (Exception e) {
                          Log.e(TAG, "Error updating trip: " + e.getMessage(), e);
                          Toast.makeText(this, "Error updating trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("❌ Cancel", null);
                  
                  AlertDialog editDialog = builder.create();
                  editDialog.show();
              }

              private void showDeleteConfirmationDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("🗑️ Delete Trip - Permanent Action");
                  
                  String message = String.format(
                      "⚠️ Delete this trip?\n\n" +
                      "📍 From: %s\n" +
                      "📍 To: %s\n" +
                      "📏 Distance: %.1f miles\n" +
                      "📅 Date: %s\n" +
                      "🏢 Client: %s\n" +
                      "📝 Purpose: %s\n\n" +
                      "❗ This action cannot be undone.\n" +
                      "💾 Trip will be permanently deleted from both local storage and cloud backup.",
                      trip.getStartAddress(),
                      trip.getEndAddress(),
                      trip.getDistance(),
                      trip.getFormattedDate(),
                      trip.getClientName() != null ? trip.getClientName() : "Personal",
                      trip.getNotes() != null ? trip.getNotes() : "Not specified"
                  );
                  
                  builder.setMessage(message);
                  
                  builder.setPositiveButton("🗑️ DELETE PERMANENTLY", (dialog, which) -> {
                      try {
                          // Delete trip using TripStorage's delete method
                          tripStorage.deleteTrip(trip.getId());
                          
                          // Refresh display
                          updateRecentTrips();
                          updateAllTrips();
                          updateStats();
                          
                          Toast.makeText(this, "🗑️ Trip deleted successfully", Toast.LENGTH_SHORT).show();
                      } catch (Exception e) {
                          Log.e(TAG, "Error deleting trip: " + e.getMessage(), e);
                          Toast.makeText(this, "❌ Error deleting trip", Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("❌ Cancel", null);
                  
                  AlertDialog deleteDialog = builder.create();
                  deleteDialog.show();
              }

              // Export functionality with date range picker
              private void showExportDialog() {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("📤 Export Trips");
                  
                  ScrollView scrollView = new ScrollView(this);
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(40, 20, 40, 20);
                  
                  // Category filter selection
                  TextView categoryLabel = new TextView(this);
                  categoryLabel.setText("🏷️ Filter by Category:");
                  categoryLabel.setTextSize(16);
                  categoryLabel.setTextColor(0xFF495057);
                  categoryLabel.setPadding(0, 10, 0, 10);
                  layout.addView(categoryLabel);
                  
                  Spinner categorySpinner = new Spinner(this);
                  String[] categoryOptions = {"All Categories", "Business", "Personal", "Medical", "Charity"};
                  ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categoryOptions);
                  categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  categorySpinner.setAdapter(categoryAdapter);
                  categorySpinner.setPadding(20, 10, 20, 20);
                  layout.addView(categorySpinner);
                  
                  // Date range selection
                  TextView dateRangeLabel = new TextView(this);
                  dateRangeLabel.setText("📅 Select Date Range:");
                  dateRangeLabel.setTextSize(16);
                  dateRangeLabel.setTextColor(0xFF495057);
                  dateRangeLabel.setPadding(0, 10, 0, 10);
                  layout.addView(dateRangeLabel);
                  
                  // Start date picker
                  Button startDateButton = new Button(this);
                  startDateButton.setText("📅 Start Date: Tap to select");
                  startDateButton.setBackgroundColor(0xFF007bff);
                  startDateButton.setTextColor(0xFFFFFFFF);
                  startDateButton.setPadding(20, 15, 20, 15);
                  layout.addView(startDateButton);
                  
                  // End date picker  
                  Button endDateButton = new Button(this);
                  endDateButton.setText("📅 End Date: Tap to select");
                  endDateButton.setBackgroundColor(0xFF007bff);
                  endDateButton.setTextColor(0xFFFFFFFF);
                  endDateButton.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams endDateParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  endDateParams.setMargins(0, 10, 0, 20);
                  endDateButton.setLayoutParams(endDateParams);
                  layout.addView(endDateButton);
                  
                  // Export format selection
                  TextView formatLabel = new TextView(this);
                  formatLabel.setText("📄 Export Format:");
                  formatLabel.setTextSize(16);
                  formatLabel.setTextColor(0xFF495057);
                  formatLabel.setPadding(0, 20, 0, 10);
                  layout.addView(formatLabel);
                  
                  Spinner formatSpinner = new Spinner(this);
                  String[] formatOptions = {"CSV Spreadsheet (.csv)", "Text File (.txt)"};
                  ArrayAdapter<String> formatAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, formatOptions);
                  formatAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  formatSpinner.setAdapter(formatAdapter);
                  formatSpinner.setPadding(20, 10, 20, 20);
                  layout.addView(formatSpinner);
                  
                  // Export method selection
                  TextView methodLabel = new TextView(this);
                  methodLabel.setText("📤 Export Method:");
                  methodLabel.setTextSize(16);
                  methodLabel.setTextColor(0xFF495057);
                  methodLabel.setPadding(0, 20, 0, 10);
                  layout.addView(methodLabel);
                  
                  // Email button
                  Button emailButton = new Button(this);
                  emailButton.setText("📧 Send via Email");
                  emailButton.setBackgroundColor(0xFF6f42c1);
                  emailButton.setTextColor(0xFFFFFFFF);
                  emailButton.setPadding(20, 15, 20, 15);
                  layout.addView(emailButton);
                  
                  // Cloud storage button
                  Button cloudButton = new Button(this);
                  cloudButton.setText("☁️ Share to Cloud (Drive, Dropbox, OneDrive)");
                  cloudButton.setBackgroundColor(0xFF17a2b8);
                  cloudButton.setTextColor(0xFFFFFFFF);
                  cloudButton.setPadding(20, 15, 20, 15);
                  LinearLayout.LayoutParams cloudParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  cloudParams.setMargins(0, 10, 0, 0);
                  cloudButton.setLayoutParams(cloudParams);
                  layout.addView(cloudButton);
                  
                  scrollView.addView(layout);
                  builder.setView(scrollView);
                  
                  // Date picker state
                  final Calendar startCal = Calendar.getInstance();
                  final Calendar endCal = Calendar.getInstance();
                  final boolean[] startDateSet = {false};
                  final boolean[] endDateSet = {false};
                  
                  // Start date picker click handler
                  startDateButton.setOnClickListener(v -> {
                      new DatePickerDialog(this, (view, year, month, dayOfMonth) -> {
                          startCal.set(year, month, dayOfMonth);
                          startDateButton.setText("📅 Start: " + (month + 1) + "/" + dayOfMonth + "/" + year);
                          startDateSet[0] = true;
                      }, startCal.get(Calendar.YEAR), startCal.get(Calendar.MONTH), startCal.get(Calendar.DAY_OF_MONTH)).show();
                  });
                  
                  // End date picker click handler
                  endDateButton.setOnClickListener(v -> {
                      new DatePickerDialog(this, (view, year, month, dayOfMonth) -> {
                          endCal.set(year, month, dayOfMonth);
                          endDateButton.setText("📅 End: " + (month + 1) + "/" + dayOfMonth + "/" + year);
                          endDateSet[0] = true;
                      }, endCal.get(Calendar.YEAR), endCal.get(Calendar.MONTH), endCal.get(Calendar.DAY_OF_MONTH)).show();
                  });
                  
                  // Export handlers
                  emailButton.setOnClickListener(v -> {
                      if (!startDateSet[0] || !endDateSet[0]) {
                          Toast.makeText(this, "❌ Please select both start and end dates", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      String selectedCategory = categorySpinner.getSelectedItem().toString();
                      boolean isCSV = formatSpinner.getSelectedItemPosition() == 0; // CSV is first option
                      exportAndEmail(startCal.getTime(), endCal.getTime(), selectedCategory, isCSV);
                  });
                  
                  cloudButton.setOnClickListener(v -> {
                      if (!startDateSet[0] || !endDateSet[0]) {
                          Toast.makeText(this, "❌ Please select both start and end dates", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      String selectedCategory = categorySpinner.getSelectedItem().toString();
                      boolean isCSV = formatSpinner.getSelectedItemPosition() == 0; // CSV is first option
                      exportToCloud(startCal.getTime(), endCal.getTime(), selectedCategory, isCSV);
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.create().show();
              }
              
              private void exportAndEmail(Date startDate, Date endDate, String category, boolean isCSV) {
                  try {
                      List<Trip> tripsInRange = getTripsInDateRange(startDate, endDate, category);
                      if (tripsInRange.isEmpty()) {
                          String categoryText = category.equals("All Categories") ? "selected date range" : category + " trips in selected date range";
                          Toast.makeText(this, "❌ No " + categoryText + " found", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      
                      String exportContent;
                      String fileExtension;
                      String mimeType;
                      if (isCSV) {
                          exportContent = generateCSV(tripsInRange, startDate, endDate, category);
                          fileExtension = ".csv";
                          mimeType = "text/csv";
                      } else {
                          exportContent = generateTXT(tripsInRange, startDate, endDate, category);
                          fileExtension = ".txt";
                          mimeType = "text/plain";
                      }
                      
                      // Create temporary file
                      SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
                      String fileName = "MileTracker_Export_" + dateFormat.format(startDate) + "_to_" + dateFormat.format(endDate);
                      if (!category.equals("All Categories")) {
                          fileName += "_" + category.replace(" ", "_");
                      }
                      fileName += fileExtension;
                      
                      try {
                          // Create file in external cache directory
                          File exportFile = new File(getExternalCacheDir(), fileName);
                          FileWriter writer = new FileWriter(exportFile);
                          writer.write(exportContent);
                          writer.close();
                          
                          // Create URI for the file
                          Uri fileUri = FileProvider.getUriForFile(this, getPackageName() + ".fileprovider", exportFile);
                          
                          String categoryFilter = category.equals("All Categories") ? "" : " (" + category + ")";
                          
                          Intent emailIntent = new Intent(Intent.ACTION_SEND);
                          emailIntent.setType("message/rfc822"); // Force email apps instead of text apps
                          emailIntent.putExtra(Intent.EXTRA_SUBJECT, "MileTracker Pro - Trip Export" + categoryFilter + " " + 
                              new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(startDate) + " to " +
                              new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(endDate));
                          emailIntent.putExtra(Intent.EXTRA_TEXT, "Please find your MileTracker Pro trip data attached as " + fileName + ".\n\n" +
                              "Export Summary:\n" +
                              "Date Range: " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(startDate) + " to " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(endDate) + "\n" +
                              "Category: " + category + "\n" +
                              "Total Trips: " + tripsInRange.size() + "\n" +
                              "File Format: " + (isCSV ? "CSV Spreadsheet" : "Text Document") + "\n\n" +
                              "This file can be opened in Excel, Google Sheets, or any spreadsheet application.\n\n" +
                              "Generated by MileTracker Pro");
                          emailIntent.putExtra(Intent.EXTRA_STREAM, fileUri);
                          emailIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                          
                          // Try email-specific apps first, fallback to general sharing
                          try {
                              emailIntent.setPackage("com.google.android.gm"); // Try Gmail first
                              if (emailIntent.resolveActivity(getPackageManager()) != null) {
                                  startActivity(emailIntent);
                                  Toast.makeText(this, "✅ Opening Gmail with " + tripsInRange.size() + " trips attached as " + fileName, Toast.LENGTH_LONG).show();
                              } else {
                                  // Try Outlook
                                  emailIntent.setPackage("com.microsoft.office.outlook");
                                  if (emailIntent.resolveActivity(getPackageManager()) != null) {
                                      startActivity(emailIntent);
                                      Toast.makeText(this, "✅ Opening Outlook with " + tripsInRange.size() + " trips attached as " + fileName, Toast.LENGTH_LONG).show();
                                  } else {
                                      // Fallback to any email app
                                      emailIntent.setPackage(null);
                                      emailIntent.setType("message/rfc822");
                                      if (emailIntent.resolveActivity(getPackageManager()) != null) {
                                          startActivity(Intent.createChooser(emailIntent, "Send via email..."));
                                          Toast.makeText(this, "✅ Email created with " + tripsInRange.size() + " trips attached as " + fileName, Toast.LENGTH_LONG).show();
                                      } else {
                                          Toast.makeText(this, "❌ No email app available", Toast.LENGTH_SHORT).show();
                                      }
                                  }
                              }
                          } catch (Exception e) {
                              Log.e(TAG, "Error launching email: " + e.getMessage(), e);
                              Toast.makeText(this, "❌ Failed to open email app", Toast.LENGTH_SHORT).show();
                          }
                      } catch (IOException e) {
                          Log.e(TAG, "Error creating export file: " + e.getMessage(), e);
                          Toast.makeText(this, "❌ Failed to create export file: " + e.getMessage(), Toast.LENGTH_LONG).show();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error exporting to email: " + e.getMessage(), e);
                      Toast.makeText(this, "❌ Export failed: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
              
              private void exportToCloud(Date startDate, Date endDate, String category, boolean isCSV) {
                  try {
                      List<Trip> tripsInRange = getTripsInDateRange(startDate, endDate, category);
                      if (tripsInRange.isEmpty()) {
                          String categoryText = category.equals("All Categories") ? "selected date range" : category + " trips in selected date range";
                          Toast.makeText(this, "❌ No " + categoryText + " found", Toast.LENGTH_SHORT).show();
                          return;
                      }
                      
                      String exportContent;
                      String fileExtension;
                      String mimeType;
                      if (isCSV) {
                          exportContent = generateCSV(tripsInRange, startDate, endDate, category);
                          fileExtension = ".csv";
                          mimeType = "text/csv";
                      } else {
                          exportContent = generateTXT(tripsInRange, startDate, endDate, category);
                          fileExtension = ".txt";
                          mimeType = "text/plain";
                      }
                      
                      // Create temporary file
                      SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
                      String fileName = "MileTracker_Export_" + dateFormat.format(startDate) + "_to_" + dateFormat.format(endDate);
                      if (!category.equals("All Categories")) {
                          fileName += "_" + category.replace(" ", "_");
                      }
                      fileName += fileExtension;
                      
                      try {
                          // Create file in external cache directory
                          File exportFile = new File(getExternalCacheDir(), fileName);
                          FileWriter writer = new FileWriter(exportFile);
                          writer.write(exportContent);
                          writer.close();
                          
                          // Create URI for the file
                          Uri fileUri = FileProvider.getUriForFile(this, getPackageName() + ".fileprovider", exportFile);
                          
                          String categoryFilter = category.equals("All Categories") ? "" : " (" + category + ")";
                          
                          Intent shareIntent = new Intent(Intent.ACTION_SEND);
                          shareIntent.setType(mimeType);
                          shareIntent.putExtra(Intent.EXTRA_SUBJECT, "MileTracker Pro - Trip Export" + categoryFilter);
                          shareIntent.putExtra(Intent.EXTRA_TEXT, "MileTracker Pro trip data export file attached.\n\n" +
                              "File: " + fileName + "\n" +
                              "Date Range: " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(startDate) + " to " + new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault()).format(endDate) + "\n" +
                              "Category: " + category + "\n" +
                              "Total Trips: " + tripsInRange.size());
                          shareIntent.putExtra(Intent.EXTRA_STREAM, fileUri);
                          shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                      
                          if (shareIntent.resolveActivity(getPackageManager()) != null) {
                              startActivity(Intent.createChooser(shareIntent, "Share to cloud storage..."));
                              Toast.makeText(this, "✅ Sharing " + tripsInRange.size() + " trips (" + (isCSV ? "CSV" : "TXT") + ") to cloud", Toast.LENGTH_SHORT).show();
                          } else {
                              Toast.makeText(this, "❌ No sharing apps available", Toast.LENGTH_SHORT).show();
                          }
                      } catch (IOException e) {
                          Log.e(TAG, "Error creating export file: " + e.getMessage(), e);
                          Toast.makeText(this, "❌ Failed to create export file: " + e.getMessage(), Toast.LENGTH_LONG).show();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error exporting to cloud: " + e.getMessage(), e);
                      Toast.makeText(this, "❌ Export failed: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
              
              private List<Trip> getTripsInDateRange(Date startDate, Date endDate, String category) {
                  List<Trip> allTrips = tripStorage.getAllTrips();
                  List<Trip> filteredTrips = new ArrayList<>();
                  
                  for (Trip trip : allTrips) {
                      Date tripDate = new Date(trip.getStartTime());
                      if (!tripDate.before(startDate) && !tripDate.after(endDate)) {
                          // Apply category filter
                          if (category.equals("All Categories") || trip.getCategory().equals(category)) {
                              filteredTrips.add(trip);
                          }
                      }
                  }
                  
                  return filteredTrips;
              }
              
              private String generateCSV(List<Trip> trips, Date startDate, Date endDate, String category) {
                  StringBuilder csv = new StringBuilder();
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
                  SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
                  
                  // Header
                  csv.append("MileTracker Pro - Trip Export\n");
                  csv.append("Export Date Range: ").append(dateFormat.format(startDate))
                     .append(" to ").append(dateFormat.format(endDate)).append("\n");
                  csv.append("Category Filter: ").append(category).append("\n");
                  csv.append("Generated: ").append(dateFormat.format(new Date())).append("\n\n");
                  
                  // CSV Headers
                  csv.append("Date,Start Time,End Time,Start Location,End Location,Distance (mi),Duration,Category,Client,Notes,Type\n");
                  
                  // Data rows
                  double totalMiles = 0;
                  for (Trip trip : trips) {
                      Date tripDate = new Date(trip.getStartTime());
                      Date endTime = new Date(trip.getEndTime());
                      
                      csv.append("\"").append(dateFormat.format(tripDate)).append("\",");
                      csv.append("\"").append(timeFormat.format(tripDate)).append("\",");
                      csv.append("\"").append(timeFormat.format(endTime)).append("\",");
                      csv.append("\"").append(trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown").append("\",");
                      csv.append("\"").append(trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown").append("\",");
                      csv.append(String.format("%.2f", trip.getDistance())).append(",");
                      csv.append("\"").append(trip.getFormattedDuration()).append("\",");
                      csv.append("\"").append(trip.getCategory()).append("\",");
                      csv.append("\"").append(trip.getClientName() != null ? trip.getClientName() : "").append("\",");
                      csv.append("\"").append(trip.getNotes() != null ? trip.getNotes() : "").append("\",");
                      csv.append("\"").append(trip.isAutoDetected() ? "Auto" : "Manual").append("\"\n");
                      
                      totalMiles += trip.getDistance();
                  }
                  
                  // Summary
                  csv.append("\nSUMMARY\n");
                  csv.append("Total Trips,").append(trips.size()).append("\n");
                  csv.append("Total Miles,").append(String.format("%.2f", totalMiles)).append("\n");
                  csv.append("Business Deduction (IRS $0.70/mi),\"$").append(String.format("%.2f", totalMiles * 0.70)).append("\"\n");
                  
                  return csv.toString();
              }
              
              private String generateTXT(List<Trip> trips, Date startDate, Date endDate, String category) {
                  StringBuilder txt = new StringBuilder();
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
                  SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
                  
                  // Header
                  txt.append("MileTracker Pro - Trip Export\n");
                  txt.append("================================\n\n");
                  txt.append("Export Date Range: ").append(dateFormat.format(startDate))
                     .append(" to ").append(dateFormat.format(endDate)).append("\n");
                  txt.append("Category Filter: ").append(category).append("\n");
                  txt.append("Generated: ").append(dateFormat.format(new Date())).append("\n\n");
                  
                  // Trip details
                  double totalMiles = 0;
                  int tripNumber = 1;
                  
                  for (Trip trip : trips) {
                      Date tripDate = new Date(trip.getStartTime());
                      Date endTime = new Date(trip.getEndTime());
                      
                      txt.append("TRIP #").append(tripNumber++).append("\n");
                      txt.append("--------\n");
                      txt.append("Date: ").append(dateFormat.format(tripDate)).append("\n");
                      txt.append("Time: ").append(timeFormat.format(tripDate))
                         .append(" - ").append(timeFormat.format(endTime)).append("\n");
                      txt.append("From: ").append(trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown").append("\n");
                      txt.append("To: ").append(trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown").append("\n");
                      txt.append("Distance: ").append(String.format("%.2f", trip.getDistance())).append(" miles\n");
                      txt.append("Duration: ").append(trip.getFormattedDuration()).append("\n");
                      txt.append("Category: ").append(trip.getCategory()).append("\n");
                      if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                          txt.append("Client: ").append(trip.getClientName()).append("\n");
                      }
                      if (trip.getNotes() != null && !trip.getNotes().isEmpty()) {
                          txt.append("Notes: ").append(trip.getNotes()).append("\n");
                      }
                      txt.append("Type: ").append(trip.isAutoDetected() ? "Auto-detected" : "Manual entry").append("\n\n");
                      
                      totalMiles += trip.getDistance();
                  }
                  
                  // Summary
                  txt.append("SUMMARY\n");
                  txt.append("=======\n");
                  txt.append("Total Trips: ").append(trips.size()).append("\n");
                  txt.append("Total Miles: ").append(String.format("%.2f", totalMiles)).append("\n");
                  txt.append("Business Deduction (IRS $0.70/mi): $").append(String.format("%.2f", totalMiles * 0.70)).append("\n");
                  
                  return txt.toString();
              }

              private void showSplitTripDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("✂️ Split Trip");
                  
                  // Create scrollable layout with proper sizing
                  ScrollView scrollView = new ScrollView(this);
                  scrollView.setLayoutParams(new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      700 // Increased height for better button visibility
                  ));
                  scrollView.setPadding(0, 0, 0, 50); // Bottom padding for buttons
                  
                  LinearLayout layout = new LinearLayout(this);
                  layout.setOrientation(LinearLayout.VERTICAL);
                  layout.setPadding(30, 20, 30, 20);
                  
                  // Trip info header
                  TextView tripInfo = new TextView(this);
                  tripInfo.setText(String.format("Split Trip: %.1f miles\n%s → %s", 
                      trip.getDistance(), trip.getStartAddress(), trip.getEndAddress()));
                  tripInfo.setTextSize(14);
                  tripInfo.setTextColor(0xFF495057);
                  tripInfo.setPadding(0, 0, 0, 20);
                  layout.addView(tripInfo);
                  
                  // Split method toggle
                  TextView splitMethodLabel = new TextView(this);
                  splitMethodLabel.setText("Split Method:");
                  splitMethodLabel.setTextSize(14);
                  splitMethodLabel.setTypeface(null, android.graphics.Typeface.BOLD);
                  layout.addView(splitMethodLabel);
                  
                  // Radio button group for split method
                  LinearLayout radioGroup = new LinearLayout(this);
                  radioGroup.setOrientation(LinearLayout.HORIZONTAL);
                  radioGroup.setPadding(0, 5, 0, 15);
                  
                  CheckBox percentageRadio = new CheckBox(this);
                  percentageRadio.setText("Percentage");
                  percentageRadio.setChecked(false);
                  percentageRadio.setPadding(0, 0, 20, 0);
                  
                  CheckBox exactMilesRadio = new CheckBox(this);
                  exactMilesRadio.setText("Exact Miles");
                  exactMilesRadio.setChecked(true); // Default to exact miles
                  
                  radioGroup.addView(percentageRadio);
                  radioGroup.addView(exactMilesRadio);
                  layout.addView(radioGroup);
                  
                  // Percentage split section
                  LinearLayout percentageSection = new LinearLayout(this);
                  percentageSection.setOrientation(LinearLayout.VERTICAL);
                  percentageSection.setVisibility(View.GONE); // Hidden by default
                  
                  SeekBar splitSlider = new SeekBar(this);
                  splitSlider.setMax(80); // 20% to 100%
                  splitSlider.setProgress(30); // Default 50%
                  splitSlider.setPadding(0, 10, 0, 10);
                  
                  TextView splitPercentage = new TextView(this);
                  splitPercentage.setText("50% split");
                  splitPercentage.setTextSize(12);
                  splitPercentage.setTextColor(0xFF6C757D);
                  
                  percentageSection.addView(splitSlider);
                  percentageSection.addView(splitPercentage);
                  layout.addView(percentageSection);
                  
                  // Exact miles section
                  LinearLayout exactMilesSection = new LinearLayout(this);
                  exactMilesSection.setOrientation(LinearLayout.VERTICAL);
                  
                  TextView firstMilesLabel = new TextView(this);
                  firstMilesLabel.setText("First Trip Distance (miles):");
                  firstMilesLabel.setTextSize(12);
                  exactMilesSection.addView(firstMilesLabel);
                  
                  EditText firstMilesInput = new EditText(this);
                  firstMilesInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  firstMilesInput.setHint("e.g., 25.5");
                  firstMilesInput.setText(String.format("%.1f", trip.getDistance() / 2.0)); // Default to half
                  exactMilesSection.addView(firstMilesInput);
                  
                  TextView secondMilesLabel = new TextView(this);
                  secondMilesLabel.setText("Second Trip Distance (miles):");
                  secondMilesLabel.setTextSize(12);
                  secondMilesLabel.setPadding(0, 10, 0, 0);
                  exactMilesSection.addView(secondMilesLabel);
                  
                  EditText secondMilesInput = new EditText(this);
                  secondMilesInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                  secondMilesInput.setHint("e.g., 75.0");
                  secondMilesInput.setText(String.format("%.1f", trip.getDistance() / 2.0)); // Default to half
                  exactMilesSection.addView(secondMilesInput);
                  
                  TextView totalCheck = new TextView(this);
                  totalCheck.setText(String.format("Total should equal: %.1f miles", trip.getDistance()));
                  totalCheck.setTextSize(11);
                  totalCheck.setTextColor(0xFF6C757D);
                  totalCheck.setPadding(0, 5, 0, 0);
                  exactMilesSection.addView(totalCheck);
                  
                  layout.addView(exactMilesSection);
                  
                  // Radio button toggle logic
                  percentageRadio.setOnClickListener(v -> {
                      if (percentageRadio.isChecked()) {
                          exactMilesRadio.setChecked(false);
                          percentageSection.setVisibility(View.VISIBLE);
                          exactMilesSection.setVisibility(View.GONE);
                      }
                  });
                  
                  exactMilesRadio.setOnClickListener(v -> {
                      if (exactMilesRadio.isChecked()) {
                          percentageRadio.setChecked(false);
                          percentageSection.setVisibility(View.GONE);
                          exactMilesSection.setVisibility(View.VISIBLE);
                      }
                  });
                  
                  // Update percentage display
                  splitSlider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
                      @Override
                      public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                          int percentage = progress + 20; // 20% to 100%
                          splitPercentage.setText(percentage + "% split");
                      }
                      
                      @Override
                      public void onStartTrackingTouch(SeekBar seekBar) {}
                      
                      @Override
                      public void onStopTrackingTouch(SeekBar seekBar) {}
                  });
                  
                  // Intermediate location
                  TextView intermediateLabelx = new TextView(this);
                  intermediateLabelx.setText("Intermediate Stop Location:");
                  intermediateLabelx.setTextSize(14);
                  intermediateLabelx.setTypeface(null, android.graphics.Typeface.BOLD);
                  intermediateLabelx.setPadding(0, 20, 0, 5);
                  layout.addView(intermediateLabelx);
                  
                  EditText intermediateLocation = new EditText(this);
                  intermediateLocation.setHint("Gas station, restaurant, etc.");
                  intermediateLocation.setText("Intermediate Stop");
                  layout.addView(intermediateLocation);
                  
                  // Categories for each trip part
                  TextView categoriesLabel = new TextView(this);
                  categoriesLabel.setText("Categories for Split Trips:");
                  categoriesLabel.setTextSize(14);
                  categoriesLabel.setTypeface(null, android.graphics.Typeface.BOLD);
                  categoriesLabel.setPadding(0, 20, 0, 10);
                  layout.addView(categoriesLabel);
                  
                  // First trip category
                  TextView firstLabel = new TextView(this);
                  firstLabel.setText("First Trip Category:");
                  firstLabel.setTextSize(12);
                  layout.addView(firstLabel);
                  
                  Spinner firstCategorySpinner = new Spinner(this);
                  String[] categories = {"Personal", "Business", "Medical", "Charity"};
                  ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                  categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                  firstCategorySpinner.setAdapter(categoryAdapter);
                  
                  // Set current category as default
                  String currentCategory = trip.getCategory();
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(currentCategory)) {
                          firstCategorySpinner.setSelection(i);
                          break;
                      }
                  }
                  layout.addView(firstCategorySpinner);
                  
                  // Second trip category
                  TextView secondLabel = new TextView(this);
                  secondLabel.setText("Second Trip Category:");
                  secondLabel.setTextSize(12);
                  secondLabel.setPadding(0, 10, 0, 0);
                  layout.addView(secondLabel);
                  
                  Spinner secondCategorySpinner = new Spinner(this);
                  secondCategorySpinner.setAdapter(categoryAdapter);
                  for (int i = 0; i < categories.length; i++) {
                      if (categories[i].equals(currentCategory)) {
                          secondCategorySpinner.setSelection(i);
                          break;
                      }
                  }
                  layout.addView(secondCategorySpinner);
                  
                  scrollView.addView(layout);
                  builder.setView(scrollView);
                  
                  builder.setPositiveButton("✂️ Split Trip", (dialog, which) -> {
                      try {
                          double firstDistance, secondDistance;
                          long firstDuration, secondDuration;
                          
                          if (exactMilesRadio.isChecked()) {
                              // Use exact miles input
                              try {
                                  firstDistance = Double.parseDouble(firstMilesInput.getText().toString());
                                  secondDistance = Double.parseDouble(secondMilesInput.getText().toString());
                                  
                                  // Validate totals match approximately
                                  double totalInput = firstDistance + secondDistance;
                                  if (Math.abs(totalInput - trip.getDistance()) > 0.1) {
                                      Toast.makeText(this, "⚠️ Split distances don't match total: " + 
                                          String.format("%.1f + %.1f = %.1f (should be %.1f)", 
                                          firstDistance, secondDistance, totalInput, trip.getDistance()), 
                                          Toast.LENGTH_LONG).show();
                                      return;
                                  }
                                  
                                  // Calculate proportional durations
                                  double firstPercent = firstDistance / trip.getDistance();
                                  firstDuration = (long)(trip.getDuration() * firstPercent);
                                  secondDuration = trip.getDuration() - firstDuration;
                                  
                              } catch (NumberFormatException e) {
                                  Toast.makeText(this, "⚠️ Please enter valid numbers for distances", Toast.LENGTH_SHORT).show();
                                  return;
                              }
                          } else {
                              // Use percentage slider
                              int splitPercent = splitSlider.getProgress() + 20;
                              firstDistance = (trip.getDistance() * splitPercent) / 100.0;
                              secondDistance = trip.getDistance() - firstDistance;
                              
                              firstDuration = (trip.getDuration() * splitPercent) / 100;
                              secondDuration = trip.getDuration() - firstDuration;
                          }
                          
                          String intermediateStop = intermediateLocation.getText().toString().trim();
                          if (intermediateStop.isEmpty()) {
                              intermediateStop = "Intermediate Stop";
                          }
                          
                          // Create first trip
                          Trip firstTrip = new Trip();
                          firstTrip.setId(System.currentTimeMillis());
                          firstTrip.setStartAddress(trip.getStartAddress());
                          firstTrip.setEndAddress(intermediateStop);
                          firstTrip.setStartLatitude(trip.getStartLatitude());
                          firstTrip.setStartLongitude(trip.getStartLongitude());
                          firstTrip.setEndLatitude(trip.getEndLatitude()); // Will be updated with intermediate coords
                          firstTrip.setEndLongitude(trip.getEndLongitude());
                          firstTrip.setDistance(firstDistance);
                          firstTrip.setDuration(firstDuration);
                          firstTrip.setStartTime(trip.getStartTime());
                          firstTrip.setEndTime(trip.getStartTime() + firstDuration);
                          firstTrip.setCategory(firstCategorySpinner.getSelectedItem().toString());
                          firstTrip.setAutoDetected(false);
                          firstTrip.setClientName(trip.getClientName());
                          firstTrip.setNotes("Split from original trip - First part");
                          
                          // Create second trip  
                          Trip secondTrip = new Trip();
                          secondTrip.setId(System.currentTimeMillis() + 1);
                          secondTrip.setStartAddress(intermediateStop);
                          secondTrip.setEndAddress(trip.getEndAddress());
                          secondTrip.setStartLatitude(trip.getEndLatitude()); // Will be updated with intermediate coords
                          secondTrip.setStartLongitude(trip.getEndLongitude());
                          secondTrip.setEndLatitude(trip.getEndLatitude());
                          secondTrip.setEndLongitude(trip.getEndLongitude());
                          secondTrip.setDistance(secondDistance);
                          secondTrip.setDuration(secondDuration);
                          secondTrip.setStartTime(trip.getStartTime() + firstDuration);
                          secondTrip.setEndTime(trip.getEndTime());
                          secondTrip.setCategory(secondCategorySpinner.getSelectedItem().toString());
                          secondTrip.setAutoDetected(false);
                          secondTrip.setClientName(trip.getClientName());
                          secondTrip.setNotes("Split from original trip - Second part");
                          
                          // Delete original trip and save new ones
                          tripStorage.deleteTrip(trip.getId());
                          tripStorage.saveTrip(firstTrip);
                          tripStorage.saveTrip(secondTrip);
                          
                          // Backup to API if enabled
                          if (tripStorage.isApiSyncEnabled()) {
                              try {
                                  CloudBackupService cloudService = new CloudBackupService(MainActivity.this);
                                  cloudService.backupTrip(firstTrip);
                                  cloudService.backupTrip(secondTrip);
                              } catch (Exception e) {
                                  Log.e(TAG, "API backup failed for split trips: " + e.getMessage());
                              }
                          }
                          
                          // Refresh display
                          updateRecentTrips();
                          updateAllTrips();
                          updateStats();
                          
                          Toast.makeText(this, "✂️ Trip split successfully into 2 trips", Toast.LENGTH_SHORT).show();
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error splitting trip: " + e.getMessage(), e);
                          Toast.makeText(this, "❌ Error splitting trip", Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("❌ Cancel", null);
                  
                  AlertDialog splitDialog = builder.create();
                  splitDialog.show();
              }
          }
          EOF

      - name: Copy AddressLookup and services exactly from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder addressText = new StringBuilder();

                  if (address.getSubThoroughfare() != null) {
                      addressText.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      addressText.append(address.getThoroughfare()).append(", ");
                  }
                  if (address.getLocality() != null) {
                      addressText.append(address.getLocality()).append(", ");
                  }
                  if (address.getAdminArea() != null) {
                      addressText.append(address.getAdminArea());
                  }

                  String result = addressText.toString().trim();
                  if (result.endsWith(",")) {
                      result = result.substring(0, result.length() - 1);
                  }

                  return result.isEmpty() ? "Unknown Location" : result;
              }
          }
          EOF

          # Services (exact copy from working)
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import java.util.ArrayList;
          import java.util.List;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              private static final int NOTIFICATION_ID = 1001;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private boolean isTracking = false;
              private Trip currentTrip = null;
              private Location lastLocation = null;
              private int stationaryCount = 0;
              private int movingCount = 0;
              private long lastMovementTime = 0;
              private List<Location> pathPoints = new ArrayList<>();
              private double cumulativeDistance = 0.0;

              private static final double SPEED_THRESHOLD_START = 8.0;
              private static final double SPEED_THRESHOLD_STOP = 3.0;
              private static final int START_CONFIRMATIONS = 3;
              private static final int STOP_CONFIRMATIONS = 4;
              private static final long MAX_STATIONARY_TIME = 120000;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();

                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          startAutoDetection();
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopAutoDetection();
                      }
                  }
                  return START_STICKY;
              }

              private void startAutoDetection() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      isTracking = true;
                      tripStorage.setAutoDetectionEnabled(true);

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          10000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (!isTracking || location == null) return;

                  try {
                      float speed = location.getSpeed() * 2.237f;
                      long currentTime = System.currentTimeMillis();

                      if (currentTrip == null) {
                          if (speed >= SPEED_THRESHOLD_START) {
                              movingCount++;
                              stationaryCount = 0;

                              if (movingCount >= START_CONFIRMATIONS) {
                                  startNewTrip(location, currentTime);
                              }
                          } else {
                              movingCount = 0;
                          }
                      } else {
                          // We're in an active trip - add path point
                          addPathPoint(location);
                          
                          if (speed <= SPEED_THRESHOLD_STOP) {
                              stationaryCount++;
                              movingCount = 0;

                              long timeSinceLastMovement = currentTime - lastMovementTime;

                              if (stationaryCount >= STOP_CONFIRMATIONS || 
                                  timeSinceLastMovement > MAX_STATIONARY_TIME) {
                                  endCurrentTrip();
                              }
                          } else {
                              stationaryCount = 0;
                              lastMovementTime = currentTime;
                          }
                      }

                      lastLocation = location;
                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location update", e);
                  }
              }

              private void startNewTrip(Location location, long currentTime) {
                  try {
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(true);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());
                      
                      // Initialize path tracking
                      pathPoints.clear();
                      pathPoints.add(location);
                      cumulativeDistance = 0.0;

                      addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setStartAddress(address);
                              tripStorage.saveCurrentTrip(currentTrip);
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setStartAddress("Unknown Location");
                              tripStorage.saveCurrentTrip(currentTrip);
                          }
                      });

                      movingCount = 0;
                      lastMovementTime = currentTime;

                      Notification notification = createNotification("Trip in progress", "Recording your trip");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting trip", e);
                  }
              }

              private void endCurrentTrip() {
                  if (currentTrip == null) return;

                  try {
                      long currentTime = System.currentTimeMillis();
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      // Add final path point if needed
                      addPathPoint(lastLocation);
                      
                      // Use cumulative distance from path tracking instead of straight-line
                      currentTrip.setDistance(cumulativeDistance);

                      if (cumulativeDistance >= 0.5) {
                          addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  saveCompletedTrip();
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setEndAddress("Unknown Location");
                                  saveCompletedTrip();
                              }
                          });
                      } else {
                          tripStorage.saveCurrentTrip(null);
                          currentTrip = null;
                      }

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip: " + e.getMessage(), e);
                  }
              }

              private void saveCompletedTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }
                      
                      tripStorage.saveCurrentTrip(null);
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving completed trip: " + e.getMessage(), e);
                  }
              }

              private void addPathPoint(Location location) {
                  try {
                      if (pathPoints.isEmpty()) {
                          pathPoints.add(location);
                          return;
                      }

                      Location lastPoint = pathPoints.get(pathPoints.size() - 1);
                      double segmentDistance = calculateDistance(
                          lastPoint.getLatitude(), lastPoint.getLongitude(),
                          location.getLatitude(), location.getLongitude()
                      );

                      // Only add point if we've moved a significant distance (about 50 feet)
                      if (segmentDistance >= 0.01) {
                          pathPoints.add(location);
                          cumulativeDistance += segmentDistance;
                          
                          Log.d(TAG, String.format("Path point added. Segment: %.3f mi, Total: %.3f mi", 
                              segmentDistance, cumulativeDistance));
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding path point", e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void stopAutoDetection() {
                  try {
                      isTracking = false;
                      tripStorage.setAutoDetectionEnabled(false);

                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && lastLocation != null) {
                          endCurrentTrip();
                      }

                      stopForeground(true);
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto detection", e);
                  }
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.widget.Toast;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "MANUAL_TRIP_CHANNEL";
              private static final int NOTIFICATION_ID = 1002;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private Trip currentTrip = null;
              private Location startLocation = null;
              private Location lastLocation = null;

              @Override
              public void onCreate() {
                  super.onCreate();

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      long currentTime = System.currentTimeMillis();

                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setEndAddress(address);
                              saveTrip();
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setEndAddress("Unknown Location");
                              saveTrip();
                          }
                      });
                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private void saveTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }

                      sendBroadcast("completed", currentTrip.getDistance(), currentTrip.getDuration());
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                  }
              }



              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip == null) return;

                      if (startLocation == null) {
                          startLocation = location;
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());

                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                              }
                          });
                      }

                      lastLocation = location;

                      if (startLocation != null) {
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  try {
                      Intent intent = new Intent("MANUAL_TRIP_UPDATE");
                      intent.putExtra("status", status);
                      intent.putExtra("distance", distance);
                      intent.putExtra("duration", duration);
                      sendBroadcast(intent);
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending broadcast: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Build Android APK with STABLE DEVICE ID + USER LINKING
        run: |
          cd android
          echo "BUILDING v4.9.72 - ACCURATE GPS PATH TRACKING RESTORED"
          echo "✅ FIXED: Auto-detection now uses actual driving path instead of straight-line distance"
          echo "✅ ENHANCED: Refresh button with visual loading feedback"
          echo "✅ ENHANCED: Complete edit dialog for ALL trip fields (date, time, duration, locations, category, client, notes, auto-detect)"
          echo "✅ ENHANCED: Edit buttons on every trip in full view"
          echo "✅ ENHANCED: Immediate API sync for all edits and refreshes"
          echo "✅ PRESERVED: Complete authentication system and all working features"
          echo "✅ PRESERVED: Stable device ID + user linking"
          echo "✅ PRESERVED: Existing API merge functionality intact"
          ./gradlew clean assembleRelease --no-daemon --stacktrace

      - name: Upload APK - Enhanced API Sync + All Editable Fields
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.64-Compilation-Errors-Fixed
          path: android/app/build/outputs/apk/release/*.apk
