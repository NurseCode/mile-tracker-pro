name: Build Android APK
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version_code:
        description: 'Version code for the build'
        required: false
        default: '49123'
  schedule:
    - cron: '0 */6 * * *'

env:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  JAVA_OPTS: "-Xmx2g"

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Cache Gradle dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
        
    - name: Create Android project structure
      run: |
        mkdir -p android/app/src/main/java/com/miletrackerpro/app
        mkdir -p android/app/src/main/res/values
        mkdir -p android/app/src/main/res/drawable
        mkdir -p android/app/src/main/res/mipmap-hdpi
        mkdir -p android/app/src/main/res/mipmap-mdpi
        mkdir -p android/app/src/main/res/mipmap-xhdpi
        mkdir -p android/app/src/main/res/mipmap-xxhdpi
        mkdir -p android/app/src/main/res/mipmap-xxxhdpi
        mkdir -p android/gradle/wrapper
        
    - name: Create settings.gradle
      run: |
        cat > android/settings.gradle << 'EOF'
        pluginManagement {
            repositories {
                google()
                mavenCentral()
                gradlePluginPortal()
            }
        }
        dependencyResolutionManagement {
            repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
            repositories {
                google()
                mavenCentral()
            }
        }
        rootProject.name = "MileTrackerPro"
        include ':app'
        EOF
        
    - name: Create build.gradle (Project)
      run: |
        cat > android/build.gradle << 'EOF'
        buildscript {
            ext {
                buildToolsVersion = "34.0.0"
                minSdkVersion = 21
                compileSdkVersion = 34
                targetSdkVersion = 34
                ndkVersion = "25.1.8937393"
                kotlinVersion = "1.8.10"
            }
            repositories {
                google()
                mavenCentral()
                gradlePluginPortal()
            }
            dependencies {
                classpath("com.android.tools.build:gradle:8.1.1")
                classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion")
            }
        }
        
        allprojects {
            repositories {
                google()
                mavenCentral()
            }
        }
        EOF
        
    - name: Create app/build.gradle
      run: |
        cat > android/app/build.gradle << 'EOF'
        apply plugin: "com.android.application"
        apply plugin: "kotlin-android"
        
        android {
            namespace "com.miletrackerpro.app"
            compileSdkVersion rootProject.ext.compileSdkVersion
            buildToolsVersion rootProject.ext.buildToolsVersion
            
            defaultConfig {
                applicationId "com.miletrackerpro.app"
                minSdkVersion rootProject.ext.minSdkVersion
                targetSdkVersion rootProject.ext.targetSdkVersion
                versionCode ${{ github.event.inputs.version_code || '49123' }}
                versionName "4.9.123"
                testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
            }
            
            signingConfigs {
                release {
                    storeFile file("../keystore.jks")
                    storePassword "miletracker123"
                    keyAlias "miletracker"
                    keyPassword "miletracker123"
                }
            }
            
            buildTypes {
                release {
                    minifyEnabled false
                    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                    signingConfig signingConfigs.release
                }
            }
            
            compileOptions {
                sourceCompatibility JavaVersion.VERSION_1_8
                targetCompatibility JavaVersion.VERSION_1_8
            }
            
            kotlinOptions {
                jvmTarget = '1.8'
            }
        }
        
        dependencies {
            implementation "androidx.core:core-ktx:1.12.0"
            implementation "androidx.appcompat:appcompat:1.6.1"
            implementation "com.google.android.material:material:1.11.0"
            implementation "androidx.constraintlayout:constraintlayout:2.1.4"
            implementation "androidx.activity:activity-ktx:1.8.2"
            implementation "androidx.fragment:fragment-ktx:1.6.2"
            
            // Location services
            implementation "com.google.android.gms:play-services-location:21.0.1"
            implementation "com.google.android.gms:play-services-maps:18.2.0"
            
            // Network
            implementation "com.squareup.okhttp3:okhttp:4.12.0"
            implementation "com.squareup.okhttp3:logging-interceptor:4.12.0"
            
            // JSON parsing
            implementation "com.google.code.gson:gson:2.10.1"
            
            testImplementation "junit:junit:4.13.2"
            androidTestImplementation "androidx.test.ext:junit:1.1.5"
            androidTestImplementation "androidx.test.espresso:espresso-core:3.5.1"
        }
        EOF
        
    - name: Create MainActivity.java
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
        package com.miletrackerpro.app;
        
        import android.Manifest;
        import android.app.AlertDialog;
        import android.content.Context;
        import android.content.SharedPreferences;
        import android.content.pm.PackageManager;
        import android.graphics.drawable.GradientDrawable;
        import android.location.Location;
        import android.location.LocationListener;
        import android.location.LocationManager;
        import android.os.Bundle;
        import android.os.Handler;
        import android.os.Looper;
        import android.text.Editable;
        import android.text.TextWatcher;
        import android.util.Log;
        import android.view.Gravity;
        import android.view.MotionEvent;
        import android.view.View;
        import android.view.ViewGroup;
        import android.widget.Button;
        import android.widget.CheckBox;
        import android.widget.EditText;
        import android.widget.LinearLayout;
        import android.widget.ScrollView;
        import android.widget.TextView;
        import android.widget.Toast;
        
        import androidx.appcompat.app.AppCompatActivity;
        import androidx.core.app.ActivityCompat;
        import androidx.core.content.ContextCompat;
        
        import java.text.SimpleDateFormat;
        import java.util.ArrayList;
        import java.util.Date;
        import java.util.List;
        import java.util.Locale;
        
        public class MainActivity extends AppCompatActivity {
            private static final String TAG = "MileTrackerPro";
            private static final int PERMISSION_REQUEST_CODE = 1001;
            
            // Core tracking variables
            private TripStorage tripStorage;
            private LocationManager locationManager;
            private LocationListener locationListener;
            private Handler handler;
            private boolean isTracking = false;
            private boolean autoDetectionEnabled = false;
            private Trip currentTrip;
            private Location lastKnownLocation;
            private long lastMovementTime = 0;
            private double totalDistance = 0.0;
            private double currentSpeed = 0.0;
            private int stationaryCount = 0;
            private boolean mergeMode = false;
            private List<String> selectedTripIds = new ArrayList<>();
            
            // UI Components
            private LinearLayout mainContentLayout;
            private Button homeTabButton, classifyTabButton, categorizedTabButton;
            private Button startStopButton, autoToggle, apiToggle;
            private TextView statusText, speedText, distanceText;
            private LinearLayout homeContent, classifyContent, categorizedContent;
            private ScrollView classifyTripsScroll, categorizedTripsScroll;
            private LinearLayout classifyTripsLayout, categorizedTripsContainer;
            private String currentTab = "Home";
            private String currentCategoryFilter = "All";
            
            // Swipe detection
            private Trip currentSwipeTrip;
            private TextView currentSwipeView;
            private boolean swipeInProgress = false;
            
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                
                try {
                    // Initialize core components
                    tripStorage = new TripStorage(this);
                    handler = new Handler(Looper.getMainLooper());
                    
                    // Setup UI
                    setupUI();
                    
                    // Request permissions
                    if (checkLocationPermissions()) {
                        initializeLocationServices();
                    } else {
                        requestLocationPermissions();
                    }
                    
                    // Load saved state
                    loadSettings();
                    updateStats();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error in onCreate: " + e.getMessage(), e);
                    showErrorDialog("Initialization Error", "Failed to initialize app: " + e.getMessage());
                }
            }
            
            private void setupUI() {
                // Main container
                LinearLayout mainLayout = new LinearLayout(this);
                mainLayout.setOrientation(LinearLayout.VERTICAL);
                mainLayout.setBackgroundColor(0xFFF8F9FA);
                
                // Tab navigation
                createTabNavigation(mainLayout);
                
                // Main content area
                mainContentLayout = new LinearLayout(this);
                mainContentLayout.setOrientation(LinearLayout.VERTICAL);
                LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    0,
                    1.0f
                );
                mainContentLayout.setLayoutParams(contentParams);
                mainLayout.addView(mainContentLayout);
                
                // Create content for each tab
                createHomeContent();
                createClassifyContent();
                createCategorizedContent();
                
                // Show initial tab
                switchToTab("Home");
                
                setContentView(mainLayout);
            }
            
            private void createTabNavigation(LinearLayout mainLayout) {
                LinearLayout tabLayout = new LinearLayout(this);
                tabLayout.setOrientation(LinearLayout.HORIZONTAL);
                tabLayout.setBackgroundColor(0xFFFFFFFF);
                tabLayout.setPadding(0, 20, 0, 20);
                tabLayout.setGravity(Gravity.CENTER);
                
                // Home tab
                homeTabButton = new Button(this);
                homeTabButton.setText("üè† Home");
                homeTabButton.setTextSize(14);
                homeTabButton.setBackgroundColor(0xFF667eea);
                homeTabButton.setTextColor(0xFFFFFFFF);
                homeTabButton.setPadding(25, 12, 25, 12);
                homeTabButton.setOnClickListener(v -> switchToTab("Home"));
                LinearLayout.LayoutParams homeParams = new LinearLayout.LayoutParams(
                    0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f
                );
                homeParams.setMargins(10, 0, 5, 0);
                homeTabButton.setLayoutParams(homeParams);
                tabLayout.addView(homeTabButton);
                
                // Classify tab
                classifyTabButton = new Button(this);
                classifyTabButton.setText("üìã Classify");
                classifyTabButton.setTextSize(14);
                classifyTabButton.setBackgroundColor(0xFF9CA3AF);
                classifyTabButton.setTextColor(0xFFFFFFFF);
                classifyTabButton.setPadding(25, 12, 25, 12);
                classifyTabButton.setOnClickListener(v -> switchToTab("Classify"));
                LinearLayout.LayoutParams classifyParams = new LinearLayout.LayoutParams(
                    0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f
                );
                classifyParams.setMargins(5, 0, 5, 0);
                classifyTabButton.setLayoutParams(classifyParams);
                tabLayout.addView(classifyTabButton);
                
                // Categorized tab
                categorizedTabButton = new Button(this);
                categorizedTabButton.setText("‚úÖ Categorized");
                categorizedTabButton.setTextSize(14);
                categorizedTabButton.setBackgroundColor(0xFF9CA3AF);
                categorizedTabButton.setTextColor(0xFFFFFFFF);
                categorizedTabButton.setPadding(25, 12, 25, 12);
                categorizedTabButton.setOnClickListener(v -> switchToTab("Categorized"));
                LinearLayout.LayoutParams categorizedParams = new LinearLayout.LayoutParams(
                    0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f
                );
                categorizedParams.setMargins(5, 0, 10, 0);
                categorizedTabButton.setLayoutParams(categorizedParams);
                tabLayout.addView(categorizedTabButton);
                
                mainLayout.addView(tabLayout);
            }
            
            private void createHomeContent() {
                homeContent = new LinearLayout(this);
                homeContent.setOrientation(LinearLayout.VERTICAL);
                homeContent.setPadding(20, 20, 20, 20);
                
                // Header
                TextView headerText = new TextView(this);
                headerText.setText("MileTracker Pro");
                headerText.setTextSize(24);
                headerText.setTextColor(0xFF333333);
                headerText.setGravity(Gravity.CENTER);
                headerText.setPadding(0, 0, 0, 20);
                homeContent.addView(headerText);
                
                // Status display
                statusText = new TextView(this);
                statusText.setText("Ready to track");
                statusText.setTextSize(16);
                statusText.setTextColor(0xFF495057);
                statusText.setGravity(Gravity.CENTER);
                statusText.setPadding(0, 0, 0, 10);
                homeContent.addView(statusText);
                
                // Speed and distance display
                LinearLayout metricsLayout = new LinearLayout(this);
                metricsLayout.setOrientation(LinearLayout.HORIZONTAL);
                metricsLayout.setGravity(Gravity.CENTER);
                
                speedText = new TextView(this);
                speedText.setText("Speed: 0 mph");
                speedText.setTextSize(14);
                speedText.setTextColor(0xFF495057);
                speedText.setPadding(0, 0, 20, 0);
                metricsLayout.addView(speedText);
                
                distanceText = new TextView(this);
                distanceText.setText("Distance: 0.0 miles");
                distanceText.setTextSize(14);
                distanceText.setTextColor(0xFF495057);
                metricsLayout.addView(distanceText);
                
                homeContent.addView(metricsLayout);
                
                // Auto Detection button
                autoToggle = new Button(this);
                autoToggle.setText("Auto Detection: OFF");
                autoToggle.setTextSize(14);
                autoToggle.setBackgroundColor(0xFF9CA3AF);
                autoToggle.setTextColor(0xFFFFFFFF);
                autoToggle.setPadding(25, 15, 25, 15);
                autoToggle.setOnClickListener(v -> toggleAutoDetection());
                LinearLayout.LayoutParams autoParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                );
                autoParams.setMargins(0, 20, 0, 10);
                autoToggle.setLayoutParams(autoParams);
                homeContent.addView(autoToggle);
                
                // Manual Trip Controls label
                TextView manualLabel = new TextView(this);
                manualLabel.setText("Manual Trip Controls");
                manualLabel.setTextSize(16);
                manualLabel.setTextColor(0xFF333333);
                manualLabel.setGravity(Gravity.CENTER);
                manualLabel.setPadding(0, 10, 0, 5);
                homeContent.addView(manualLabel);
                
                // Start/Stop button
                startStopButton = new Button(this);
                startStopButton.setText("START TRIP");
                startStopButton.setTextSize(16);
                startStopButton.setBackgroundColor(0xFF28a745);
                startStopButton.setTextColor(0xFFFFFFFF);
                startStopButton.setPadding(25, 15, 25, 15);
                startStopButton.setOnClickListener(v -> toggleTracking());
                LinearLayout.LayoutParams startStopParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                );
                startStopParams.setMargins(0, 10, 0, 20);
                startStopButton.setLayoutParams(startStopParams);
                homeContent.addView(startStopButton);
                
                // API Toggle button
                apiToggle = new Button(this);
                apiToggle.setText("üåê API OFF");
                apiToggle.setTextSize(14);
                apiToggle.setBackgroundColor(0xFF9CA3AF);
                apiToggle.setTextColor(0xFFFFFFFF);
                apiToggle.setPadding(25, 15, 25, 15);
                apiToggle.setOnClickListener(v -> toggleApiSync());
                LinearLayout.LayoutParams apiParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                );
                apiParams.setMargins(0, 10, 0, 20);
                apiToggle.setLayoutParams(apiParams);
                homeContent.addView(apiToggle);
                
                // Statistics
                createStatisticsSection(homeContent);
                
                // Recent Trips section
                createRecentTripsSection(homeContent);
            }
            
            private void createClassifyContent() {
                classifyContent = new LinearLayout(this);
                classifyContent.setOrientation(LinearLayout.VERTICAL);
                classifyContent.setPadding(20, 20, 20, 20);
                
                // Header text
                TextView headerText = new TextView(this);
                headerText.setText("Classify Trips");
                headerText.setTextSize(18);
                headerText.setTextColor(0xFF333333);
                headerText.setGravity(Gravity.CENTER);
                headerText.setPadding(0, 0, 0, 20);
                classifyContent.addView(headerText);
                
                // REFRESH, MERGE, EXPORT buttons
                LinearLayout buttonContainer = new LinearLayout(this);
                buttonContainer.setOrientation(LinearLayout.VERTICAL);
                buttonContainer.setPadding(0, 10, 0, 10);
                
                // Button row with uniform height buttons  
                LinearLayout buttonLayout = new LinearLayout(this);
                buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                buttonLayout.setPadding(20, 0, 20, 0);
                buttonLayout.setGravity(Gravity.CENTER);
                
                // Uniform button height (50dp converted to pixels)
                int buttonHeight = (int) (50 * getResources().getDisplayMetrics().density);
                
                // Refresh button
                Button refreshButton = new Button(this);
                refreshButton.setText("REFRESH");
                refreshButton.setTextSize(11);
                refreshButton.setBackgroundColor(0xFF6C757D);
                refreshButton.setTextColor(0xFFFFFFFF);
                refreshButton.setPadding(20, 12, 20, 12); // INCREASED PADDING
                refreshButton.setOnClickListener(v -> performRefreshWithFeedback(refreshButton));
                LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(
                    0, 
                    buttonHeight,
                    1.0f
                );
                refreshParams.setMargins(0, 0, 15, 0);
                refreshButton.setLayoutParams(refreshParams);
                buttonLayout.addView(refreshButton);
                
                // Merge button
                Button mergeButton = new Button(this);
                mergeButton.setText("MERGE");
                mergeButton.setTextSize(11);
                mergeButton.setBackgroundColor(0xFF007bff);
                mergeButton.setTextColor(0xFFFFFFFF);
                mergeButton.setPadding(20, 12, 20, 12); // INCREASED PADDING
                LinearLayout.LayoutParams mergeParams = new LinearLayout.LayoutParams(
                    0, 
                    buttonHeight,
                    1.0f
                );
                mergeParams.setMargins(15, 0, 15, 0);
                mergeButton.setLayoutParams(mergeParams);
                buttonLayout.addView(mergeButton);
                
                // Export button
                Button exportButton = new Button(this);
                exportButton.setText("EXPORT");
                exportButton.setTextSize(11);
                exportButton.setBackgroundColor(0xFF28a745);
                exportButton.setTextColor(0xFFFFFFFF);
                exportButton.setPadding(20, 12, 20, 12); // INCREASED PADDING
                LinearLayout.LayoutParams exportParams = new LinearLayout.LayoutParams(
                    0, 
                    buttonHeight,
                    1.0f
                );
                exportParams.setMargins(15, 0, 0, 0);
                exportButton.setLayoutParams(exportParams);
                buttonLayout.addView(exportButton);
                
                buttonContainer.addView(buttonLayout);
                
                // Add export button click handler
                exportButton.setOnClickListener(v -> showExportDialog());
                
                // Add merge button click handler with CANCEL option
                mergeButton.setOnClickListener(v -> {
                    if (!mergeMode) {
                        // Enter merge mode
                        mergeMode = true;
                        mergeButton.setText("EXECUTE");
                        mergeButton.setBackgroundColor(0xFF28a745);
                        updateClassifyTrips();
                        Toast.makeText(MainActivity.this, "üìã Select trips to merge, then tap Execute", Toast.LENGTH_SHORT).show();
                    } else {
                        // Execute merge
                        if (selectedTripIds.size() < 2) {
                            Toast.makeText(MainActivity.this, "‚ùå Select at least 2 trips to merge", Toast.LENGTH_SHORT).show();
                            return;
                        }
                        
                        // Confirm merge with CANCEL option
                        new AlertDialog.Builder(MainActivity.this)
                            .setTitle("üîÄ Confirm Merge")
                            .setMessage("Merge " + selectedTripIds.size() + " selected trips?\n\nThis will combine them into one trip and delete the originals.")
                            .setPositiveButton("‚úÖ Merge", (dialog, which) -> {
                                executeTripseMerge();
                                // Reset merge mode
                                mergeMode = false;
                                selectedTripIds.clear();
                                mergeButton.setText("MERGE");
                                mergeButton.setBackgroundColor(0xFF007bff);
                                updateClassifyTrips();
                            })
                            .setNegativeButton("‚ùå Cancel", (dialog, which) -> {
                                // Reset merge mode on cancel
                                mergeMode = false;
                                selectedTripIds.clear();
                                mergeButton.setText("MERGE");
                                mergeButton.setBackgroundColor(0xFF007bff);
                                updateClassifyTrips();
                            })
                            .show();
                    }
                });
                
                classifyContent.addView(buttonContainer);
                
                // Scrollable trips container
                classifyTripsScroll = new ScrollView(this);
                classifyTripsLayout = new LinearLayout(this);
                classifyTripsLayout.setOrientation(LinearLayout.VERTICAL);
                classifyTripsScroll.addView(classifyTripsLayout);
                
                LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    0,
                    1.0f
                );
                classifyTripsScroll.setLayoutParams(scrollParams);
                classifyContent.addView(classifyTripsScroll);
            }
            
            private void createCategorizedContent() {
                categorizedContent = new LinearLayout(this);
                categorizedContent.setOrientation(LinearLayout.VERTICAL);
                categorizedContent.setPadding(20, 20, 20, 20);
                
                // Header text
                TextView headerText = new TextView(this);
                headerText.setText("Categorized Trips");
                headerText.setTextSize(18);
                headerText.setTextColor(0xFF333333);
                headerText.setGravity(Gravity.CENTER);
                headerText.setPadding(0, 0, 0, 20);
                categorizedContent.addView(headerText);
                
                // REFRESH, MERGE, EXPORT buttons
                LinearLayout buttonContainer = new LinearLayout(this);
                buttonContainer.setOrientation(LinearLayout.VERTICAL);
                buttonContainer.setPadding(0, 10, 0, 10);
                
                // Button row with uniform height buttons  
                LinearLayout buttonLayout = new LinearLayout(this);
                buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                buttonLayout.setPadding(20, 0, 20, 0);
                buttonLayout.setGravity(Gravity.CENTER);
                
                // Uniform button height (50dp converted to pixels)
                int buttonHeight = (int) (50 * getResources().getDisplayMetrics().density);
                
                // Refresh button
                Button refreshButton = new Button(this);
                refreshButton.setText("REFRESH");
                refreshButton.setTextSize(11);
                refreshButton.setBackgroundColor(0xFF6C757D);
                refreshButton.setTextColor(0xFFFFFFFF);
                refreshButton.setPadding(20, 12, 20, 12); // INCREASED PADDING
                refreshButton.setOnClickListener(v -> performRefreshWithFeedback(refreshButton));
                LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(
                    0, 
                    buttonHeight,
                    1.0f
                );
                refreshParams.setMargins(0, 0, 15, 0);
                refreshButton.setLayoutParams(refreshParams);
                buttonLayout.addView(refreshButton);
                
                // Merge button
                Button mergeButton = new Button(this);
                mergeButton.setText("MERGE");
                mergeButton.setTextSize(11);
                mergeButton.setBackgroundColor(0xFF007bff);
                mergeButton.setTextColor(0xFFFFFFFF);
                mergeButton.setPadding(20, 12, 20, 12); // INCREASED PADDING
                LinearLayout.LayoutParams mergeParams = new LinearLayout.LayoutParams(
                    0, 
                    buttonHeight,
                    1.0f
                );
                mergeParams.setMargins(15, 0, 15, 0);
                mergeButton.setLayoutParams(mergeParams);
                buttonLayout.addView(mergeButton);
                
                // Export button
                Button exportButton = new Button(this);
                exportButton.setText("EXPORT");
                exportButton.setTextSize(11);
                exportButton.setBackgroundColor(0xFF28a745);
                exportButton.setTextColor(0xFFFFFFFF);
                exportButton.setPadding(20, 12, 20, 12); // INCREASED PADDING
                LinearLayout.LayoutParams exportParams = new LinearLayout.LayoutParams(
                    0, 
                    buttonHeight,
                    1.0f
                );
                exportParams.setMargins(15, 0, 0, 0);
                exportButton.setLayoutParams(exportParams);
                buttonLayout.addView(exportButton);
                
                buttonContainer.addView(buttonLayout);
                
                // Add export button click handler
                exportButton.setOnClickListener(v -> showExportDialog());
                
                // Add merge button click handler for categorized tab
                mergeButton.setOnClickListener(v -> {
                    if (!mergeMode) {
                        // Enter merge mode
                        mergeMode = true;
                        mergeButton.setText("EXECUTE");
                        mergeButton.setBackgroundColor(0xFF28a745);
                        updateCategorizedTrips();
                        Toast.makeText(MainActivity.this, "üìã Select trips to merge, then tap Execute", Toast.LENGTH_SHORT).show();
                    } else {
                        // Execute merge
                        if (selectedTripIds.size() < 2) {
                            Toast.makeText(MainActivity.this, "‚ùå Select at least 2 trips to merge", Toast.LENGTH_SHORT).show();
                            return;
                        }
                        
                        // Confirm merge with CANCEL option
                        new AlertDialog.Builder(MainActivity.this)
                            .setTitle("üîÄ Confirm Merge")
                            .setMessage("Merge " + selectedTripIds.size() + " selected trips?\n\nThis will combine them into one trip and delete the originals.")
                            .setPositiveButton("‚úÖ Merge", (dialog, which) -> {
                                executeTripseMerge();
                                // Reset merge mode
                                mergeMode = false;
                                selectedTripIds.clear();
                                mergeButton.setText("MERGE");
                                mergeButton.setBackgroundColor(0xFF007bff);
                                updateCategorizedTrips();
                            })
                            .setNegativeButton("‚ùå Cancel", (dialog, which) -> {
                                // Reset merge mode on cancel
                                mergeMode = false;
                                selectedTripIds.clear();
                                mergeButton.setText("MERGE");
                                mergeButton.setBackgroundColor(0xFF007bff);
                                updateCategorizedTrips();
                            })
                            .show();
                    }
                });
                
                categorizedContent.addView(buttonContainer);
                
                // Category filter buttons
                LinearLayout categoryButtonsLayout = new LinearLayout(this);
                categoryButtonsLayout.setOrientation(LinearLayout.HORIZONTAL);
                categoryButtonsLayout.setGravity(Gravity.CENTER);
                categoryButtonsLayout.setPadding(0, 0, 0, 20);
                
                String[] categories = {"All", "Business", "Personal", "Medical", "Charity"};
                for (String category : categories) {
                    Button categoryButton = new Button(this);
                    categoryButton.setText(category);
                    categoryButton.setTextSize(12);
                    categoryButton.setBackgroundColor(0xFF9CA3AF);
                    categoryButton.setTextColor(0xFFFFFFFF);
                    categoryButton.setPadding(15, 5, 15, 5);
                    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    );
                    params.setMargins(5, 0, 5, 0);
                    categoryButton.setLayoutParams(params);
                    categoryButton.setOnClickListener(v -> {
                        currentCategoryFilter = category;
                        updateCategorizedTrips();
                    });
                    categoryButtonsLayout.addView(categoryButton);
                }
                categorizedContent.addView(categoryButtonsLayout);
                
                // Scrollable trips container
                categorizedTripsScroll = new ScrollView(this);
                categorizedTripsContainer = new LinearLayout(this);
                categorizedTripsContainer.setOrientation(LinearLayout.VERTICAL);
                categorizedTripsScroll.addView(categorizedTripsContainer);
                
                LinearLayout.LayoutParams scrollParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    0,
                    1.0f
                );
                categorizedTripsScroll.setLayoutParams(scrollParams);
                categorizedContent.addView(categorizedTripsScroll);
            }
            
            private void executeTripseMerge() {
                try {
                    tripStorage.mergeUserTrips(selectedTripIds);
                    Toast.makeText(this, "‚úÖ Successfully merged " + selectedTripIds.size() + " trips!", Toast.LENGTH_SHORT).show();
                    
                    // Exit merge mode and refresh
                    mergeMode = false;
                    selectedTripIds.clear();
                    updateStats();
                    
                    // Refresh the current tab
                    if ("Classify".equals(currentTab)) {
                        updateClassifyTrips();
                    } else if ("Categorized".equals(currentTab)) {
                        updateCategorizedTrips();
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                    Toast.makeText(this, "‚ùå Error merging trips: " + e.getMessage(), Toast.LENGTH_LONG).show();
                }
            }
            
            private void updateClassifyTrips() {
                try {
                    classifyTripsLayout.removeAllViews();
                    
                    List<Trip> unclassifiedTrips = tripStorage.getUnclassifiedTrips();
                    
                    if (unclassifiedTrips.isEmpty()) {
                        TextView noTripsText = new TextView(this);
                        noTripsText.setText("üéâ All trips classified!\n\nGreat work! All your trips have been categorized.\nCheck the 'Categorized' tab to review them.");
                        noTripsText.setTextSize(14);
                        noTripsText.setTextColor(0xFF6C757D);
                        noTripsText.setGravity(Gravity.CENTER);
                        noTripsText.setPadding(15, 30, 15, 15);
                        classifyTripsLayout.addView(noTripsText);
                    } else {
                        for (Trip trip : unclassifiedTrips) {
                            addTripCard(classifyTripsLayout, trip, false);
                        }
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error updating classify trips: " + e.getMessage(), e);
                }
            }
            
            private void updateCategorizedTrips() {
                try {
                    categorizedTripsContainer.removeAllViews();
                    
                    List<Trip> categorizedTrips = tripStorage.getCategorizedTrips();
                    
                    // Apply filter
                    if (!"All".equals(currentCategoryFilter)) {
                        List<Trip> filteredTrips = new ArrayList<>();
                        for (Trip trip : categorizedTrips) {
                            if (currentCategoryFilter.equals(trip.getCategory())) {
                                filteredTrips.add(trip);
                            }
                        }
                        categorizedTrips = filteredTrips;
                    }
                    
                    if (categorizedTrips.isEmpty()) {
                        TextView noTripsText = new TextView(this);
                        String filterText = "All".equals(currentCategoryFilter) ? 
                            "üìã No categorized trips yet.\n\nSwipe trips left/right in the 'Classify' tab to categorize them!" :
                            "üîç No " + currentCategoryFilter.toLowerCase() + " trips found.\n\nTry a different category filter or classify more trips.";
                        noTripsText.setText(filterText);
                        noTripsText.setTextSize(14);
                        noTripsText.setTextColor(0xFF6C757D);
                        noTripsText.setGravity(Gravity.CENTER);
                        noTripsText.setPadding(15, 30, 15, 15);
                        categorizedTripsContainer.addView(noTripsText);
                    } else {
                        for (Trip trip : categorizedTrips) {
                            addTripCard(categorizedTripsContainer, trip, false);
                        }
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error updating categorized trips: " + e.getMessage(), e);
                }
            }
            
            private void addTripCard(LinearLayout parentLayout, Trip trip, boolean compact) {
                try {
                    Log.d(TAG, "Adding trip card for: " + trip.getStartAddress() + " -> " + trip.getEndAddress());
                    
                    // Create container for checkbox + trip info
                    LinearLayout cardContainer = new LinearLayout(this);
                    cardContainer.setOrientation(LinearLayout.VERTICAL);
                    cardContainer.setPadding(15, 15, 15, 15);
                    cardContainer.setBackgroundColor(0xFFffffff);
                    
                    // Add border for clear card separation
                    GradientDrawable border = new GradientDrawable();
                    border.setColor(0xFFffffff);
                    border.setStroke(2, 0xFFd0d0d0);
                    border.setCornerRadius(8);
                    cardContainer.setBackground(border);
                    
                    // Add checkbox in merge mode
                    if (mergeMode && !compact) {
                        CheckBox checkbox = new CheckBox(this);
                        checkbox.setChecked(selectedTripIds.contains(String.valueOf(trip.getId())));
                        checkbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                            String tripId = String.valueOf(trip.getId());
                            if (isChecked) {
                                if (!selectedTripIds.contains(tripId)) {
                                    selectedTripIds.add(tripId);
                                }
                            } else {
                                selectedTripIds.remove(tripId);
                            }
                        });
                        
                        LinearLayout.LayoutParams checkboxParams = new LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT, 
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        );
                        checkbox.setLayoutParams(checkboxParams);
                        cardContainer.addView(checkbox);
                    }
                    
                    TextView tripView = new TextView(this);
                    String tripType = trip.isAutoDetected() ? "ü§ñ" : "‚úã";
                    
                    if (compact) {
                        tripView.setText(String.format(
                            "%s ‚Ä¢ %s ‚Ä¢ %.1f mi",
                            trip.getCompactDateTime(),
                            tripType,
                            trip.getDistance()
                        ));
                        tripView.setTextSize(11);
                    } else {
                        StringBuilder tripDetails = new StringBuilder();
                        
                        // Get auto-classification suggestion
                        String startSuggestion = getAutoClassificationSuggestion(trip.getStartAddress());
                        String endSuggestion = getAutoClassificationSuggestion(trip.getEndAddress());
                        String autoSuggestion = startSuggestion != null ? startSuggestion : endSuggestion;
                        
                        // Add swipe hint if there's an auto-classification suggestion
                        String swipeHint = "";
                        if (autoSuggestion != null && !autoSuggestion.equals(trip.getCategory())) {
                            swipeHint = String.format(" (Suggest: %s)", autoSuggestion);
                        }
                        
                        tripDetails.append(String.format(
                            "%s ‚Ä¢ %s\n%.2f miles ‚Ä¢ %s ‚Ä¢ %s%s\nFrom: %s\nTo: %s",
                            tripType,
                            trip.getFormattedDateTime(),
                            trip.getDistance(),
                            trip.getFormattedDuration(),
                            trip.getCategory(),
                            swipeHint,
                            trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown",
                            trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown"
                        ));
                        
                        // Add client and notes if available
                        if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                            tripDetails.append("\nClient: ").append(trip.getClientName());
                        }
                        if (trip.getNotes() != null && !trip.getNotes().trim().isEmpty()) {
                            tripDetails.append("\nNotes: ").append(trip.getNotes());
                        }
                        
                        // Add swipe instructions
                        if (!mergeMode) {
                            tripDetails.append("\n‚Üê Swipe Left: Personal | Swipe Right: Business ‚Üí");
                        }
                        
                        tripView.setText(tripDetails.toString());
                        tripView.setTextSize(12);
                    }
                    
                    tripView.setTextColor(0xFF495057);
                    tripView.setPadding(10, 10, 10, 10);
                    // Set background color based on trip category
                    int backgroundColor = getPersistentCategoryColor(trip.getCategory());
                    tripView.setBackgroundColor(backgroundColor);
                    tripView.setMinHeight(60);
                    
                    // Enable swipe detection only when not in merge mode
                    if (!compact && !mergeMode) {
                        tripView.setOnTouchListener(new View.OnTouchListener() {
                            private float startX, startY;
                            private long startTime;
                            private boolean touchStarted = false;
                            
                            @Override
                            public boolean onTouch(View v, MotionEvent event) {
                                switch (event.getAction()) {
                                    case MotionEvent.ACTION_DOWN:
                                        startX = event.getX();
                                        startY = event.getY();
                                        startTime = System.currentTimeMillis();
                                        touchStarted = true;
                                        currentSwipeTrip = trip;
                                        currentSwipeView = tripView;
                                        return true;
                                        
                                    case MotionEvent.ACTION_MOVE:
                                        if (touchStarted && !swipeInProgress) {
                                            float deltaX = event.getX() - startX;
                                            float deltaY = event.getY() - startY;
                                            
                                            // Sensitive swipe detection
                                            if (Math.abs(deltaX) > 8 && Math.abs(deltaX) > Math.abs(deltaY)) {
                                                swipeInProgress = true;
                                                
                                                if (deltaX > 0) {
                                                    // Right swipe - Business
                                                    performSwipeClassification(trip, "Business", 0xFF28A745);
                                                } else {
                                                    // Left swipe - Personal
                                                    performSwipeClassification(trip, "Personal", 0xFF0044FF);
                                                }
                                                return true;
                                            }
                                        }
                                        return true;
                                        
                                    case MotionEvent.ACTION_UP:
                                        if (touchStarted && !swipeInProgress) {
                                            // Normal click
                                            long touchDuration = System.currentTimeMillis() - startTime;
                                            if (touchDuration < 300) {
                                                v.performClick();
                                            }
                                        }
                                        touchStarted = false;
                                        return true;
                                        
                                    case MotionEvent.ACTION_CANCEL:
                                        touchStarted = false;
                                        return true;
                                }
                                return false;
                            }
                        });
                        
                        tripView.setClickable(true);
                        tripView.setFocusable(true);
                        tripView.setLongClickable(false);
                    }
                    
                    cardContainer.addView(tripView);
                    parentLayout.addView(cardContainer);
                    
                    // Add margin between cards
                    LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    );
                    cardParams.setMargins(0, 0, 0, 15);
                    cardContainer.setLayoutParams(cardParams);
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error adding trip card: " + e.getMessage(), e);
                }
            }
            
            private void performSwipeClassification(Trip trip, String category, int flashColor) {
                try {
                    Log.d(TAG, "Performing swipe classification: " + trip.getId() + " -> " + category);
                    
                    // Flash the card
                    if (currentSwipeView != null) {
                        int originalColor = currentSwipeView.getBackgroundColor();
                        currentSwipeView.setBackgroundColor(flashColor);
                        
                        handler.postDelayed(() -> {
                            currentSwipeView.setBackgroundColor(originalColor);
                            swipeInProgress = false;
                        }, 300);
                    }
                    
                    // Update the trip
                    trip.setCategory(category);
                    tripStorage.updateTrip(trip);
                    
                    // Show success message
                    Toast.makeText(this, "‚úÖ " + category + " trip saved!", Toast.LENGTH_SHORT).show();
                    
                    // Auto-learn from this classification
                    autoLearnFromClassification(trip);
                    
                    // Refresh the current tab
                    if ("Classify".equals(currentTab)) {
                        updateClassifyTrips();
                    } else if ("Categorized".equals(currentTab)) {
                        updateCategorizedTrips();
                    }
                    
                    // Update statistics
                    updateStats();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error performing swipe classification: " + e.getMessage(), e);
                }
            }
            
            private void autoLearnFromClassification(Trip trip) {
                try {
                    SharedPreferences prefs = getSharedPreferences("MileTrackerPro", Context.MODE_PRIVATE);
                    SharedPreferences.Editor editor = prefs.edit();
                    
                    // Learn from start address
                    if (trip.getStartAddress() != null) {
                        String simplifiedStart = simplifyAddress(trip.getStartAddress());
                        String startKey = "location_" + simplifiedStart;
                        int startCount = prefs.getInt(startKey + "_count", 0);
                        
                        if (startCount >= 2) {
                            editor.putString(startKey, trip.getCategory());
                            Log.d(TAG, "Auto-learned: " + simplifiedStart + " -> " + trip.getCategory());
                        }
                        editor.putInt(startKey + "_count", startCount + 1);
                    }
                    
                    // Learn from end address
                    if (trip.getEndAddress() != null) {
                        String simplifiedEnd = simplifyAddress(trip.getEndAddress());
                        String endKey = "location_" + simplifiedEnd;
                        int endCount = prefs.getInt(endKey + "_count", 0);
                        
                        if (endCount >= 2) {
                            editor.putString(endKey, trip.getCategory());
                            Log.d(TAG, "Auto-learned: " + simplifiedEnd + " -> " + trip.getCategory());
                        }
                        editor.putInt(endKey + "_count", endCount + 1);
                    }
                    
                    editor.apply();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error in auto-learning: " + e.getMessage(), e);
                }
            }
            
            private String getAutoClassificationSuggestion(String address) {
                try {
                    if (address == null || address.trim().isEmpty()) {
                        return null;
                    }
                    
                    // Check for business keywords
                    String lowerAddress = address.toLowerCase();
                    if (lowerAddress.contains("office") || lowerAddress.contains("corp") || 
                        lowerAddress.contains("company") || lowerAddress.contains("business")) {
                        return "Business";
                    }
                    
                    // Check for medical keywords
                    if (lowerAddress.contains("hospital") || lowerAddress.contains("clinic") || 
                        lowerAddress.contains("medical") || lowerAddress.contains("doctor")) {
                        return "Medical";
                    }
                    
                    // Check learned locations
                    SharedPreferences prefs = getSharedPreferences("MileTrackerPro", Context.MODE_PRIVATE);
                    String simplifiedAddress = simplifyAddress(address);
                    String learnedCategory = prefs.getString("location_" + simplifiedAddress, null);
                    
                    return learnedCategory;
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error getting auto-classification suggestion: " + e.getMessage(), e);
                    return null;
                }
            }
            
            private String simplifyAddress(String address) {
                if (address == null) return "";
                
                // Remove numbers and common suffixes, normalize to lowercase
                return address.toLowerCase()
                    .replaceAll("\\d+", "")
                    .replaceAll("\\b(st|ave|rd|blvd|ln|dr|ct|pl|way)\\b", "")
                    .replaceAll("[^a-z\\s]", "")
                    .trim()
                    .replaceAll("\\s+", " ");
            }
            
            private int getPersistentCategoryColor(String category) {
                if (category == null) return 0xFFF8F9FA;
                
                switch (category.toLowerCase()) {
                    case "business":
                        return 0xFFE8F5E8;
                    case "personal":
                        return 0xFFE3F2FD;
                    case "medical":
                        return 0xFFFFF3E0;
                    case "charity":
                        return 0xFFF3E5F5;
                    default:
                        return 0xFFF8F9FA;
                }
            }
            
            private void createStatisticsSection(LinearLayout parentLayout) {
                TextView statsHeader = new TextView(this);
                statsHeader.setText("üìä Statistics");
                statsHeader.setTextSize(16);
                statsHeader.setTextColor(0xFF333333);
                statsHeader.setPadding(0, 10, 0, 10);
                parentLayout.addView(statsHeader);
                
                TextView statsContent = new TextView(this);
                statsContent.setId(View.generateViewId());
                statsContent.setTextSize(14);
                statsContent.setTextColor(0xFF495057);
                statsContent.setPadding(0, 0, 0, 10);
                parentLayout.addView(statsContent);
            }
            
            private void createRecentTripsSection(LinearLayout parentLayout) {
                TextView recentHeader = new TextView(this);
                recentHeader.setText("üìã Recent Trips");
                recentHeader.setTextSize(16);
                recentHeader.setTextColor(0xFF333333);
                recentHeader.setPadding(0, 10, 0, 10);
                parentLayout.addView(recentHeader);
                
                ScrollView recentScroll = new ScrollView(this);
                LinearLayout recentContainer = new LinearLayout(this);
                recentContainer.setOrientation(LinearLayout.VERTICAL);
                recentContainer.setId(View.generateViewId());
                recentScroll.addView(recentContainer);
                
                LinearLayout.LayoutParams recentParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    (int) (300 * getResources().getDisplayMetrics().density)
                );
                recentScroll.setLayoutParams(recentParams);
                parentLayout.addView(recentScroll);
            }
            
            private void updateStats() {
                try {
                    List<Trip> allTrips = tripStorage.getAllTrips();
                    
                    double totalMiles = 0;
                    int autoTrips = 0;
                    int manualTrips = 0;
                    
                    for (Trip trip : allTrips) {
                        totalMiles += trip.getDistance();
                        if (trip.isAutoDetected()) {
                            autoTrips++;
                        } else {
                            manualTrips++;
                        }
                    }
                    
                    TextView statsContent = findViewById(View.generateViewId());
                    if (statsContent != null) {
                        String autoStatus = autoDetectionEnabled ? "ON" : "OFF";
                        String apiStatus = tripStorage.isApiSyncEnabled() ? "ON" : "OFF";
                        
                        statsContent.setText(String.format(
                            "‚Ä¢ Total Trips: %d\n‚Ä¢ Total Miles: %.1f\n‚Ä¢ Auto Detection: %s\n‚Ä¢ API Sync: %s",
                            allTrips.size(),
                            totalMiles,
                            autoStatus,
                            apiStatus
                        ));
                    }
                    
                    // Update recent trips
                    updateRecentTrips(allTrips);
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                }
            }
            
            private void updateRecentTrips(List<Trip> allTrips) {
                try {
                    LinearLayout recentContainer = findViewById(View.generateViewId());
                    if (recentContainer != null) {
                        recentContainer.removeAllViews();
                        
                        // Sort by start time and get the 3 most recent
                        allTrips.sort((a, b) -> Long.compare(b.getStartTime(), a.getStartTime()));
                        
                        int count = Math.min(3, allTrips.size());
                        for (int i = 0; i < count; i++) {
                            addTripCard(recentContainer, allTrips.get(i), true);
                        }
                        
                        if (allTrips.isEmpty()) {
                            TextView noRecentText = new TextView(this);
                            noRecentText.setText("No recent trips");
                            noRecentText.setTextSize(12);
                            noRecentText.setTextColor(0xFF9CA3AF);
                            noRecentText.setPadding(15, 15, 15, 15);
                            recentContainer.addView(noRecentText);
                        }
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
                }
            }
            
            private void performRefreshWithFeedback(Button refreshButton) {
                try {
                    String originalText = refreshButton.getText().toString();
                    refreshButton.setText("üîÑ Refreshing...");
                    refreshButton.setEnabled(false);
                    
                    // Perform refresh based on current tab
                    if ("Classify".equals(currentTab)) {
                        updateClassifyTrips();
                    } else if ("Categorized".equals(currentTab)) {
                        updateCategorizedTrips();
                    }
                    
                    // Update statistics
                    updateStats();
                    
                    // Reset button after delay
                    handler.postDelayed(() -> {
                        refreshButton.setText(originalText);
                        refreshButton.setEnabled(true);
                        Toast.makeText(this, "‚úÖ Refreshed!", Toast.LENGTH_SHORT).show();
                    }, 1000);
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error performing refresh: " + e.getMessage(), e);
                }
            }
            
            private void showExportDialog() {
                try {
                    List<Trip> allTrips = tripStorage.getAllTrips();
                    
                    if (allTrips.isEmpty()) {
                        Toast.makeText(this, "‚ùå No trips to export", Toast.LENGTH_SHORT).show();
                        return;
                    }
                    
                    // Create CSV content
                    StringBuilder csvContent = new StringBuilder();
                    csvContent.append("Date,Start Time,End Time,Start Address,End Address,Distance (miles),Duration,Category,Type,Client,Notes\n");
                    
                    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
                    SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm:ss", Locale.US);
                    
                    for (Trip trip : allTrips) {
                        Date startDate = new Date(trip.getStartTime());
                        Date endDate = new Date(trip.getEndTime());
                        
                        csvContent.append(String.format(
                            "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%.2f\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\"\n",
                            dateFormat.format(startDate),
                            timeFormat.format(startDate),
                            timeFormat.format(endDate),
                            trip.getStartAddress() != null ? trip.getStartAddress() : "",
                            trip.getEndAddress() != null ? trip.getEndAddress() : "",
                            trip.getDistance(),
                            trip.getFormattedDuration(),
                            trip.getCategory(),
                            trip.isAutoDetected() ? "Auto" : "Manual",
                            trip.getClientName() != null ? trip.getClientName() : "",
                            trip.getNotes() != null ? trip.getNotes() : ""
                        ));
                    }
                    
                    // Show export dialog
                    AlertDialog.Builder builder = new AlertDialog.Builder(this);
                    builder.setTitle("üìä Export Trips");
                    builder.setMessage("Export " + allTrips.size() + " trips to CSV format?");
                    builder.setPositiveButton("‚úÖ Export", (dialog, which) -> {
                        // In a real app, you would use the system's file picker
                        // For now, just show the CSV content
                        showCsvContent(csvContent.toString());
                    });
                    builder.setNegativeButton("‚ùå Cancel", null);
                    builder.show();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error showing export dialog: " + e.getMessage(), e);
                }
            }
            
            private void showCsvContent(String csvContent) {
                AlertDialog.Builder builder = new AlertDialog.Builder(this);
                builder.setTitle("üìä CSV Export");
                builder.setMessage("Copy this CSV data to your computer:\n\n" + csvContent.substring(0, Math.min(500, csvContent.length())) + "...");
                builder.setPositiveButton("‚úÖ Close", null);
                builder.show();
            }
            
            private void switchToTab(String tabName) {
                try {
                    currentTab = tabName;
                    mainContentLayout.removeAllViews();
                    
                    // Update tab button colors
                    homeTabButton.setBackgroundColor(0xFF9CA3AF);
                    classifyTabButton.setBackgroundColor(0xFF9CA3AF);
                    categorizedTabButton.setBackgroundColor(0xFF9CA3AF);
                    
                    // Add current tab content
                    switch (tabName) {
                        case "Home":
                            homeTabButton.setBackgroundColor(0xFF667eea);
                            mainContentLayout.addView(homeContent);
                            updateStats();
                            break;
                        case "Classify":
                            classifyTabButton.setBackgroundColor(0xFF667eea);
                            mainContentLayout.addView(classifyContent);
                            updateClassifyTrips();
                            break;
                        case "Categorized":
                            categorizedTabButton.setBackgroundColor(0xFF667eea);
                            mainContentLayout.addView(categorizedContent);
                            updateCategorizedTrips();
                            break;
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error switching to tab: " + e.getMessage(), e);
                }
            }
            
            private void toggleAutoDetection() {
                try {
                    autoDetectionEnabled = !autoDetectionEnabled;
                    
                    if (autoDetectionEnabled) {
                        autoToggle.setText("Auto Detection: ON");
                        autoToggle.setBackgroundColor(0xFF28a745);
                        startAutoDetection();
                    } else {
                        autoToggle.setText("Auto Detection: OFF");
                        autoToggle.setBackgroundColor(0xFF9CA3AF);
                        stopAutoDetection();
                    }
                    
                    saveSettings();
                    updateStats();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error toggling auto detection: " + e.getMessage(), e);
                }
            }
            
            private void toggleApiSync() {
                try {
                    boolean currentState = tripStorage.isApiSyncEnabled();
                    tripStorage.setApiSyncEnabled(!currentState);
                    
                    if (tripStorage.isApiSyncEnabled()) {
                        apiToggle.setText("üåê API ON");
                        apiToggle.setBackgroundColor(0xFF28a745);
                        Toast.makeText(this, "API sync ON - downloading trips...", Toast.LENGTH_SHORT).show();
                    } else {
                        apiToggle.setText("üåê API OFF");
                        apiToggle.setBackgroundColor(0xFF9CA3AF);
                        Toast.makeText(this, "API sync OFF - local storage only", Toast.LENGTH_SHORT).show();
                    }
                    
                    updateStats();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error toggling API sync: " + e.getMessage(), e);
                }
            }
            
            private void toggleTracking() {
                try {
                    if (isTracking) {
                        stopTracking();
                    } else {
                        startTracking();
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error toggling tracking: " + e.getMessage(), e);
                }
            }
            
            private void startTracking() {
                try {
                    if (!checkLocationPermissions()) {
                        Toast.makeText(this, "‚ùå Location permission required", Toast.LENGTH_SHORT).show();
                        return;
                    }
                    
                    isTracking = true;
                    currentTrip = new Trip();
                    currentTrip.setStartTime(System.currentTimeMillis());
                    currentTrip.setAutoDetected(false);
                    totalDistance = 0.0;
                    
                    startStopButton.setText("STOP TRIP");
                    startStopButton.setBackgroundColor(0xFFDC3545);
                    statusText.setText("üöó Tracking active");
                    
                    startLocationUpdates();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error starting tracking: " + e.getMessage(), e);
                }
            }
            
            private void stopTracking() {
                try {
                    isTracking = false;
                    
                    if (currentTrip != null) {
                        currentTrip.setEndTime(System.currentTimeMillis());
                        currentTrip.setDistance(totalDistance);
                        
                        // Save the trip
                        tripStorage.saveTrip(currentTrip);
                        
                        Toast.makeText(this, "‚úÖ Trip saved: " + String.format("%.1f miles", totalDistance), Toast.LENGTH_SHORT).show();
                        
                        currentTrip = null;
                    }
                    
                    startStopButton.setText("START TRIP");
                    startStopButton.setBackgroundColor(0xFF28a745);
                    statusText.setText("Ready to track");
                    
                    stopLocationUpdates();
                    updateStats();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error stopping tracking: " + e.getMessage(), e);
                }
            }
            
            private void startAutoDetection() {
                try {
                    if (!checkLocationPermissions()) {
                        Toast.makeText(this, "‚ùå Location permission required", Toast.LENGTH_SHORT).show();
                        return;
                    }
                    
                    startLocationUpdates();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error starting auto detection: " + e.getMessage(), e);
                }
            }
            
            private void stopAutoDetection() {
                try {
                    stopLocationUpdates();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error stopping auto detection: " + e.getMessage(), e);
                }
            }
            
            private void startLocationUpdates() {
                try {
                    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                        return;
                    }
                    
                    locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 5000, 0, locationListener);
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error starting location updates: " + e.getMessage(), e);
                }
            }
            
            private void stopLocationUpdates() {
                try {
                    locationManager.removeUpdates(locationListener);
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error stopping location updates: " + e.getMessage(), e);
                }
            }
            
            private void initializeLocationServices() {
                try {
                    locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                    
                    locationListener = new LocationListener() {
                        @Override
                        public void onLocationChanged(Location location) {
                            handleLocationUpdate(location);
                        }
                        
                        @Override
                        public void onStatusChanged(String provider, int status, Bundle extras) {}
                        
                        @Override
                        public void onProviderEnabled(String provider) {}
                        
                        @Override
                        public void onProviderDisabled(String provider) {}
                    };
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error initializing location services: " + e.getMessage(), e);
                }
            }
            
            private void handleLocationUpdate(Location location) {
                try {
                    // Calculate speed (convert from m/s to mph)
                    currentSpeed = location.getSpeed() * 2.237;
                    
                    // Update UI
                    speedText.setText(String.format("Speed: %.1f mph", currentSpeed));
                    
                    // Calculate distance if we have a previous location
                    if (lastKnownLocation != null) {
                        float distance = lastKnownLocation.distanceTo(location);
                        totalDistance += distance * 0.000621371; // Convert meters to miles
                        distanceText.setText(String.format("Distance: %.1f miles", totalDistance));
                    }
                    
                    // Auto-detection logic
                    if (autoDetectionEnabled && !isTracking) {
                        if (currentSpeed > 5.0) { // Moving
                            if (currentTrip == null) {
                                // Start new trip
                                currentTrip = new Trip();
                                currentTrip.setStartTime(System.currentTimeMillis());
                                currentTrip.setAutoDetected(true);
                                statusText.setText("üöó Auto trip started");
                                totalDistance = 0.0;
                            }
                            stationaryCount = 0;
                            lastMovementTime = System.currentTimeMillis();
                        } else if (currentTrip != null) {
                            // Check if stationary for too long
                            stationaryCount++;
                            if (stationaryCount > 12) { // 1 minute at 5-second intervals
                                // End current trip
                                currentTrip.setEndTime(System.currentTimeMillis());
                                currentTrip.setDistance(totalDistance);
                                tripStorage.saveTrip(currentTrip);
                                
                                Toast.makeText(this, "‚úÖ Auto trip ended: " + String.format("%.1f miles", totalDistance), Toast.LENGTH_SHORT).show();
                                
                                currentTrip = null;
                                statusText.setText("Auto detection active");
                                stationaryCount = 0;
                                updateStats();
                            }
                        }
                    }
                    
                    lastKnownLocation = location;
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error handling location update: " + e.getMessage(), e);
                }
            }
            
            private boolean checkLocationPermissions() {
                return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED;
            }
            
            private void requestLocationPermissions() {
                ActivityCompat.requestPermissions(this, 
                    new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 
                    PERMISSION_REQUEST_CODE);
            }
            
            @Override
            public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                
                if (requestCode == PERMISSION_REQUEST_CODE) {
                    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                        initializeLocationServices();
                    } else {
                        Toast.makeText(this, "‚ùå Location permission required for tracking", Toast.LENGTH_LONG).show();
                    }
                }
            }
            
            private void loadSettings() {
                try {
                    SharedPreferences prefs = getSharedPreferences("MileTrackerPro", Context.MODE_PRIVATE);
                    autoDetectionEnabled = prefs.getBoolean("auto_detection", false);
                    
                    if (autoDetectionEnabled) {
                        autoToggle.setText("Auto Detection: ON");
                        autoToggle.setBackgroundColor(0xFF28a745);
                    } else {
                        autoToggle.setText("Auto Detection: OFF");
                        autoToggle.setBackgroundColor(0xFF9CA3AF);
                    }
                    
                    // Update API toggle
                    if (tripStorage.isApiSyncEnabled()) {
                        apiToggle.setText("üåê API ON");
                        apiToggle.setBackgroundColor(0xFF28a745);
                    } else {
                        apiToggle.setText("üåê API OFF");
                        apiToggle.setBackgroundColor(0xFF9CA3AF);
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error loading settings: " + e.getMessage(), e);
                }
            }
            
            private void saveSettings() {
                try {
                    SharedPreferences prefs = getSharedPreferences("MileTrackerPro", Context.MODE_PRIVATE);
                    SharedPreferences.Editor editor = prefs.edit();
                    editor.putBoolean("auto_detection", autoDetectionEnabled);
                    editor.apply();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error saving settings: " + e.getMessage(), e);
                }
            }
            
            private void showErrorDialog(String title, String message) {
                AlertDialog.Builder builder = new AlertDialog.Builder(this);
                builder.setTitle(title);
                builder.setMessage(message);
                builder.setPositiveButton("OK", null);
                builder.show();
            }
            
            @Override
            protected void onDestroy() {
                super.onDestroy();
                try {
                    if (locationManager != null && locationListener != null) {
                        locationManager.removeUpdates(locationListener);
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error in onDestroy: " + e.getMessage(), e);
                }
            }
        }
        EOF
        
    - name: Create TripStorage.java
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/TripStorage.java << 'EOF'
        package com.miletrackerpro.app;
        
        import android.content.Context;
        import android.content.SharedPreferences;
        import android.util.Log;
        
        import com.google.gson.Gson;
        import com.google.gson.reflect.TypeToken;
        
        import java.lang.reflect.Type;
        import java.util.ArrayList;
        import java.util.List;
        
        public class TripStorage {
            private static final String TAG = "TripStorage";
            private static final String PREFS_NAME = "MileTrackerPro";
            private static final String TRIPS_KEY = "trips";
            private static final String API_SYNC_KEY = "api_sync_enabled";
            
            private Context context;
            private SharedPreferences prefs;
            private Gson gson;
            
            public TripStorage(Context context) {
                this.context = context;
                this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                this.gson = new Gson();
            }
            
            public void saveTrip(Trip trip) {
                try {
                    List<Trip> trips = getAllTrips();
                    
                    // Generate ID if not set
                    if (trip.getId() == 0) {
                        trip.setId(System.currentTimeMillis());
                    }
                    
                    trips.add(trip);
                    saveAllTrips(trips);
                    
                    Log.d(TAG, "Trip saved: " + trip.getId());
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                }
            }
            
            public void updateTrip(Trip trip) {
                try {
                    List<Trip> trips = getAllTrips();
                    
                    for (int i = 0; i < trips.size(); i++) {
                        if (trips.get(i).getId() == trip.getId()) {
                            trips.set(i, trip);
                            break;
                        }
                    }
                    
                    saveAllTrips(trips);
                    Log.d(TAG, "Trip updated: " + trip.getId());
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error updating trip: " + e.getMessage(), e);
                }
            }
            
            public List<Trip> getAllTrips() {
                try {
                    String json = prefs.getString(TRIPS_KEY, "[]");
                    Type listType = new TypeToken<List<Trip>>(){}.getType();
                    List<Trip> trips = gson.fromJson(json, listType);
                    return trips != null ? trips : new ArrayList<>();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error getting all trips: " + e.getMessage(), e);
                    return new ArrayList<>();
                }
            }
            
            public List<Trip> getUnclassifiedTrips() {
                try {
                    List<Trip> allTrips = getAllTrips();
                    List<Trip> unclassified = new ArrayList<>();
                    
                    for (Trip trip : allTrips) {
                        if ("Unclassified".equals(trip.getCategory()) || trip.getCategory() == null) {
                            unclassified.add(trip);
                        }
                    }
                    
                    return unclassified;
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error getting unclassified trips: " + e.getMessage(), e);
                    return new ArrayList<>();
                }
            }
            
            public List<Trip> getCategorizedTrips() {
                try {
                    List<Trip> allTrips = getAllTrips();
                    List<Trip> categorized = new ArrayList<>();
                    
                    for (Trip trip : allTrips) {
                        if (!"Unclassified".equals(trip.getCategory()) && trip.getCategory() != null) {
                            categorized.add(trip);
                        }
                    }
                    
                    return categorized;
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error getting categorized trips: " + e.getMessage(), e);
                    return new ArrayList<>();
                }
            }
            
            public void mergeUserTrips(List<String> tripIds) {
                try {
                    List<Trip> allTrips = getAllTrips();
                    List<Trip> tripsToMerge = new ArrayList<>();
                    
                    // Find trips to merge
                    for (String tripId : tripIds) {
                        for (Trip trip : allTrips) {
                            if (String.valueOf(trip.getId()).equals(tripId)) {
                                tripsToMerge.add(trip);
                                break;
                            }
                        }
                    }
                    
                    if (tripsToMerge.size() < 2) {
                        throw new Exception("Need at least 2 trips to merge");
                    }
                    
                    // Sort by start time
                    tripsToMerge.sort((a, b) -> Long.compare(a.getStartTime(), b.getStartTime()));
                    
                    // Create merged trip
                    Trip mergedTrip = new Trip();
                    mergedTrip.setId(System.currentTimeMillis());
                    mergedTrip.setStartTime(tripsToMerge.get(0).getStartTime());
                    mergedTrip.setEndTime(tripsToMerge.get(tripsToMerge.size() - 1).getEndTime());
                    mergedTrip.setStartAddress(tripsToMerge.get(0).getStartAddress());
                    mergedTrip.setEndAddress(tripsToMerge.get(tripsToMerge.size() - 1).getEndAddress());
                    mergedTrip.setCategory(tripsToMerge.get(0).getCategory());
                    mergedTrip.setAutoDetected(tripsToMerge.get(0).isAutoDetected());
                    
                    // Calculate total distance
                    double totalDistance = 0;
                    for (Trip trip : tripsToMerge) {
                        totalDistance += trip.getDistance();
                    }
                    mergedTrip.setDistance(totalDistance);
                    
                    // Remove original trips
                    for (Trip tripToRemove : tripsToMerge) {
                        allTrips.removeIf(trip -> trip.getId() == tripToRemove.getId());
                    }
                    
                    // Add merged trip
                    allTrips.add(mergedTrip);
                    saveAllTrips(allTrips);
                    
                    Log.d(TAG, "Merged " + tripsToMerge.size() + " trips into trip: " + mergedTrip.getId());
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                    throw new RuntimeException("Error merging trips: " + e.getMessage());
                }
            }
            
            private void saveAllTrips(List<Trip> trips) {
                try {
                    String json = gson.toJson(trips);
                    prefs.edit().putString(TRIPS_KEY, json).apply();
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error saving all trips: " + e.getMessage(), e);
                }
            }
            
            public boolean isApiSyncEnabled() {
                return prefs.getBoolean(API_SYNC_KEY, false);
            }
            
            public void setApiSyncEnabled(boolean enabled) {
                prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
            }
        }
        EOF
        
    - name: Create Trip.java
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/Trip.java << 'EOF'
        package com.miletrackerpro.app;
        
        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.Locale;
        
        public class Trip {
            private long id;
            private long startTime;
            private long endTime;
            private String startAddress;
            private String endAddress;
            private double distance;
            private String category = "Unclassified";
            private boolean autoDetected;
            private String clientName;
            private String notes;
            
            public Trip() {
                this.id = System.currentTimeMillis();
                this.startTime = System.currentTimeMillis();
                this.endTime = System.currentTimeMillis();
                this.distance = 0.0;
                this.autoDetected = false;
            }
            
            // Getters and setters
            public long getId() { return id; }
            public void setId(long id) { this.id = id; }
            
            public long getStartTime() { return startTime; }
            public void setStartTime(long startTime) { this.startTime = startTime; }
            
            public long getEndTime() { return endTime; }
            public void setEndTime(long endTime) { this.endTime = endTime; }
            
            public String getStartAddress() { return startAddress; }
            public void setStartAddress(String startAddress) { this.startAddress = startAddress; }
            
            public String getEndAddress() { return endAddress; }
            public void setEndAddress(String endAddress) { this.endAddress = endAddress; }
            
            public double getDistance() { return distance; }
            public void setDistance(double distance) { this.distance = distance; }
            
            public String getCategory() { return category; }
            public void setCategory(String category) { this.category = category; }
            
            public boolean isAutoDetected() { return autoDetected; }
            public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }
            
            public String getClientName() { return clientName; }
            public void setClientName(String clientName) { this.clientName = clientName; }
            
            public String getNotes() { return notes; }
            public void setNotes(String notes) { this.notes = notes; }
            
            // Helper methods
            public String getFormattedDateTime() {
                SimpleDateFormat format = new SimpleDateFormat("MMM dd, yyyy HH:mm", Locale.US);
                return format.format(new Date(startTime));
            }
            
            public String getCompactDateTime() {
                SimpleDateFormat format = new SimpleDateFormat("MM/dd HH:mm", Locale.US);
                return format.format(new Date(startTime));
            }
            
            public String getFormattedDuration() {
                long duration = endTime - startTime;
                long minutes = duration / (1000 * 60);
                long hours = minutes / 60;
                minutes = minutes % 60;
                
                if (hours > 0) {
                    return String.format("%dh %dm", hours, minutes);
                } else {
                    return String.format("%dm", minutes);
                }
            }
        }
        EOF
        
    - name: Create AndroidManifest.xml
      run: |
        cat > android/app/src/main/AndroidManifest.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            package="com.miletrackerpro.app">
            
            <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
            <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
            <uses-permission android:name="android.permission.INTERNET" />
            <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
            
            <application
                android:allowBackup="true"
                android:icon="@mipmap/ic_launcher"
                android:label="@string/app_name"
                android:theme="@style/Theme.MileTrackerPro">
                
                <activity
                    android:name=".MainActivity"
                    android:exported="true"
                    android:screenOrientation="portrait">
                    <intent-filter>
                        <action android:name="android.intent.action.MAIN" />
                        <category android:name="android.intent.category.LAUNCHER" />
                    </intent-filter>
                </activity>
                
            </application>
        </manifest>
        EOF
        
    - name: Create strings.xml
      run: |
        cat > android/app/src/main/res/values/strings.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <string name="app_name">MileTracker Pro</string>
        </resources>
        EOF
        
    - name: Create themes.xml
      run: |
        cat > android/app/src/main/res/values/themes.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <style name="Theme.MileTrackerPro" parent="Theme.AppCompat.Light.DarkActionBar">
                <item name="colorPrimary">@color/purple_500</item>
                <item name="colorPrimaryVariant">@color/purple_700</item>
                <item name="colorOnPrimary">@color/white</item>
                <item name="colorSecondary">@color/teal_200</item>
                <item name="colorSecondaryVariant">@color/teal_700</item>
                <item name="colorOnSecondary">@color/black</item>
                <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
            </style>
        </resources>
        EOF
        
    - name: Create colors.xml
      run: |
        cat > android/app/src/main/res/values/colors.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <resources>
            <color name="purple_200">#FFBB86FC</color>
            <color name="purple_500">#FF6200EE</color>
            <color name="purple_700">#FF3700B3</color>
            <color name="teal_200">#FF03DAC5</color>
            <color name="teal_700">#FF018786</color>
            <color name="black">#FF000000</color>
            <color name="white">#FFFFFFFF</color>
        </resources>
        EOF
        
    - name: Create app icons
      run: |
        # Create simple colored squares as app icons
        mkdir -p android/app/src/main/res/mipmap-mdpi
        mkdir -p android/app/src/main/res/mipmap-hdpi
        mkdir -p android/app/src/main/res/mipmap-xhdpi
        mkdir -p android/app/src/main/res/mipmap-xxhdpi
        mkdir -p android/app/src/main/res/mipmap-xxxhdpi
        
        # Create simple PNG files (base64 encoded 1x1 blue pixel)
        echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==" | base64 -d > android/app/src/main/res/mipmap-mdpi/ic_launcher.png
        echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==" | base64 -d > android/app/src/main/res/mipmap-hdpi/ic_launcher.png
        echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==" | base64 -d > android/app/src/main/res/mipmap-xhdpi/ic_launcher.png
        echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==" | base64 -d > android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
        echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==" | base64 -d > android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
        
    - name: Create gradle wrapper
      run: |
        cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
        distributionBase=GRADLE_USER_HOME
        distributionPath=wrapper/dists
        distributionUrl=https\://services.gradle.org/distributions/gradle-8.0-bin.zip
        zipStoreBase=GRADLE_USER_HOME
        zipStorePath=wrapper/dists
        EOF
        
    - name: Create keystore
      run: |
        cd android
        keytool -genkey -v -keystore keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias miletracker -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker, L=City, S=State, C=US"
        
    - name: Make gradlew executable
      run: |
        chmod +x android/gradlew || echo "No gradlew found, using system gradle"
        
    - name: Clean build
      run: |
        cd android
        ./gradlew clean || gradle clean
        
    - name: Build APK
      run: |
        cd android
        ./gradlew assembleRelease || gradle assembleRelease
        
    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: MileTracker-Pro-v4.9.123
        path: android/app/build/outputs/apk/release/app-release.apk
        retention-days: 30
