name: Build Android APK
on:
  workflow_dispatch:
    inputs:
      version_code:
        description: 'Version code for the build'
        required: true
        default: '90'
        type: string
  push:
    branches:
      - main
    paths:
      - '**/*.yml'
      - '.github/workflows/**'
  schedule:
    - cron: '0 */6 * * *'  # Build every 6 hours automatically

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
        
      - name: Create Android project structure
        run: |
          mkdir -p android-app/app/src/main/java/com/miletrackerpro/app
          mkdir -p android-app/app/src/main/res/{layout,values,drawable,xml}
          mkdir -p android-app/app/src/main/assets
          
      - name: Create gradle.properties FIRST
        run: |
          cat > android-app/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          org.gradle.parallel=true
          org.gradle.caching=true
          org.gradle.daemon=false
          org.gradle.configureondemand=false
          EOF
          
      - name: Create settings.gradle
        run: |
          cat > android-app/settings.gradle << 'EOF'
          pluginManagement {
              repositories {
                  google()
                  mavenCentral()
                  gradlePluginPortal()
              }
          }
          dependencyResolutionManagement {
              repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)
              repositories {
                  google()
                  mavenCentral()
              }
          }
          
          rootProject.name = "MileTracker Pro"
          include ':app'
          EOF
          
      - name: Create project-level build.gradle (minimal)
        run: |
          cat > android-app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application' version '8.2.0' apply false
          }
          
          task clean(type: Delete) {
              delete rootProject.buildDir
          }
          EOF
          
      - name: Create app-level build.gradle
        run: |
          cat > android-app/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }
          
          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34
              
              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 26
                  targetSdk 34
                  versionCode Integer.parseInt("${{ github.event.inputs.version_code || '90' }}")
                  versionName "4.9.${{ github.event.inputs.version_code || '90' }}"
                  
                  testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
              }
              
              buildTypes {
                  release {
                      minifyEnabled false
                      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                      signingConfig signingConfigs.debug
                  }
              }
              
              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }
              
              buildFeatures {
                  buildConfig true
              }
              
              packagingOptions {
                  resources {
                      excludes += ['META-INF/DEPENDENCIES', 'META-INF/LICENSE', 'META-INF/LICENSE.txt', 'META-INF/NOTICE', 'META-INF/NOTICE.txt']
                  }
              }
          }
          
          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
              implementation 'com.google.android.material:material:1.10.0'
              implementation 'androidx.work:work-runtime:2.8.1'
              implementation 'androidx.lifecycle:lifecycle-service:2.7.0'
              
              testImplementation 'junit:junit:4.13.2'
              androidTestImplementation 'androidx.test.ext:junit:1.1.5'
              androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
          }
          EOF
          
      - name: Create AndroidManifest.xml
        run: |
          cat > android-app/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.miletrackerpro.app"
              android:versionCode="${{ github.event.inputs.version_code || '90' }}"
              android:versionName="4.9.${{ github.event.inputs.version_code || '90' }}">
              
              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              
              <application
                  android:allowBackup="true"
                  android:icon="@android:drawable/ic_menu_mylocation"
                  android:label="MileTracker Pro"
                  android:theme="@android:style/Theme.Material.Light.DarkActionBar"
                  android:usesCleartextTraffic="false">
                  
                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>
                  
                  <service
                      android:name=".CloudBackupService"
                      android:enabled="true"
                      android:exported="false" />
                      
                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="com.miletrackerpro.app.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>
              </application>
          </manifest>
          EOF
      
      - name: Create file paths config
        run: |
          cat > android-app/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <external-path name="external_files" path="."/>
              <external-cache-path name="external_cache" path="."/>
              <files-path name="files" path="."/>
              <cache-path name="cache" path="."/>
          </paths>
          EOF
      
      - name: Create strings.xml
        run: |
          cat > android-app/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="location_permission_rationale">This app needs location access to track your trips automatically.</string>
              <string name="notification_channel_name">Trip Tracking</string>
              <string name="notification_channel_description">Notifications for active trip tracking</string>
          </resources>
          EOF
      
      - name: Create colors.xml
        run: |
          cat > android-app/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary_blue">#007BFF</color>
              <color name="success_green">#28A745</color>
              <color name="warning_orange">#FFC107</color>
              <color name="danger_red">#DC3545</color>
              <color name="light_gray">#F8F9FA</color>
              <color name="dark_gray">#6C757D</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
          </resources>
          EOF
      
      - name: Create MainActivity.java
        run: |
          cat > android-app/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;
          
          import android.Manifest;
          import android.app.Activity;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Bundle;
          import android.os.Handler;
          import android.os.Looper;
          import android.util.Log;
          import android.view.View;
          import android.widget.*;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import java.util.*;
          import java.text.SimpleDateFormat;
          import java.util.concurrent.atomic.AtomicBoolean;
          
          public class MainActivity extends Activity implements LocationListener {
              private static final String TAG = "MileTracker";
              private static final int PERMISSION_REQUEST_CODE = 100;
              
              private LocationManager locationManager;
              private UserAuthManager authManager;
              private ScrollView mainScrollView;
              private boolean isAuthenticated = false;
              private String currentUserEmail = "";
              
              // Store input fields for reuse
              private EditText emailInput;
              private EditText passwordInput;
              
              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  Log.d(TAG, "🚗 MileTracker Pro v4.9.${{ github.event.inputs.version_code || '90' }} Starting (Diagnostic Localhost Fix)");
                  
                  // Initialize authentication manager
                  authManager = new UserAuthManager(this);
                  
                  // Initialize location manager
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                  
                  // Check if user is already authenticated
                  if (authManager.isLoggedIn()) {
                      currentUserEmail = authManager.getCurrentUserEmail();
                      isAuthenticated = true;
                      Log.d(TAG, "User already authenticated: " + currentUserEmail);
                      createMainInterface();
                  } else {
                      Log.d(TAG, "User not authenticated, showing login screen");
                      createAuthenticationInterface();
                  }
              }
              
              private void createAuthenticationInterface() {
                  // Create main scroll view
                  mainScrollView = new ScrollView(this);
                  mainScrollView.setLayoutParams(new ScrollView.LayoutParams(
                      ScrollView.LayoutParams.MATCH_PARENT,
                      ScrollView.LayoutParams.MATCH_PARENT
                  ));
                  
                  // Create main layout
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 60, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF8F9FA);
                  
                  // App title
                  TextView titleText = new TextView(this);
                  titleText.setText("🚗 MileTracker Pro");
                  titleText.setTextSize(28);
                  titleText.setTextColor(0xFF007BFF);
                  titleText.setGravity(android.view.Gravity.CENTER);
                  LinearLayout.LayoutParams titleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  titleParams.setMargins(0, 0, 0, 30);
                  titleText.setLayoutParams(titleParams);
                  mainLayout.addView(titleText);
                  
                  // Subtitle
                  TextView subtitleText = new TextView(this);
                  subtitleText.setText("Professional Mileage Tracking\nDiagnostic Build v4.9.${{ github.event.inputs.version_code || '90' }}\nDebugging localhost routing issue");
                  subtitleText.setTextSize(16);
                  subtitleText.setTextColor(0xFF6C757D);
                  subtitleText.setGravity(android.view.Gravity.CENTER);
                  LinearLayout.LayoutParams subtitleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  subtitleParams.setMargins(0, 0, 0, 40);
                  subtitleText.setLayoutParams(subtitleParams);
                  mainLayout.addView(subtitleText);
                  
                  // Email input
                  emailInput = new EditText(this);
                  emailInput.setHint("Email Address");
                  emailInput.setText("pcates@catesconsultinggroup.com");
                  emailInput.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setPadding(20, 20, 20, 20);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);
                  
                  // Password input
                  passwordInput = new EditText(this);
                  passwordInput.setHint("Password");
                  passwordInput.setText("password123");
                  passwordInput.setInputType(android.text.InputType.TYPE_CLASS_TEXT | android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setPadding(20, 20, 20, 20);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 25);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);
                  
                  // Login button
                  Button loginButton = new Button(this);
                  loginButton.setText("🔑 Login (Diagnostic)");
                  loginButton.setBackgroundColor(0xFF007BFF);
                  loginButton.setTextColor(0xFFFFFFFF);
                  loginButton.setTextSize(18);
                  LinearLayout.LayoutParams loginParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  loginParams.setMargins(0, 0, 0, 15);
                  loginButton.setLayoutParams(loginParams);
                  loginButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();
                      
                      if (!email.isEmpty() && !password.isEmpty()) {
                          handleLogin(email, password);
                      } else {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                      }
                  });
                  mainLayout.addView(loginButton);
                  
                  // Register button
                  Button registerButton = new Button(this);
                  registerButton.setText("📝 Create Account");
                  registerButton.setBackgroundColor(0xFF28A745);
                  registerButton.setTextColor(0xFFFFFFFF);
                  registerButton.setTextSize(16);
                  LinearLayout.LayoutParams registerParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  registerParams.setMargins(0, 0, 0, 20);
                  registerButton.setLayoutParams(registerParams);
                  registerButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();
                      
                      if (!email.isEmpty() && !password.isEmpty()) {
                          handleRegistration(email, password, "User");
                      } else {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                      }
                  });
                  mainLayout.addView(registerButton);
                  
                  // Debug button to test API connectivity
                  Button debugButton = new Button(this);
                  debugButton.setText("🔍 DEBUG: Test Direct Connection");
                  debugButton.setBackgroundColor(0xFF17a2b8);
                  debugButton.setTextColor(0xFFFFFFFF);
                  debugButton.setTextSize(14);
                  LinearLayout.LayoutParams debugParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  debugParams.setMargins(0, 20, 0, 10);
                  debugButton.setLayoutParams(debugParams);
                  debugButton.setOnClickListener(v -> testDirectConnection());
                  mainLayout.addView(debugButton);

                  // Network info button
                  Button networkButton = new Button(this);
                  networkButton.setText("📱 Show Network Info");
                  networkButton.setBackgroundColor(0xFFffc107);
                  networkButton.setTextColor(0xFF000000);
                  networkButton.setTextSize(14);
                  LinearLayout.LayoutParams networkParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  networkParams.setMargins(0, 10, 0, 10);
                  networkButton.setLayoutParams(networkParams);
                  networkButton.setOnClickListener(v -> showNetworkInfo());
                  mainLayout.addView(networkButton);
                  
                  // Set the content view
                  mainScrollView.addView(mainLayout);
                  setContentView(mainScrollView);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "Diagnostic login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== DIAGNOSTIC LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread like debug test
                  new Thread(() -> {
                      Log.d(TAG, "Starting diagnostic login thread...");
                      boolean loginResult = authManager.login(email, password);
                      Log.d(TAG, "Diagnostic login result: " + loginResult);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Toast.makeText(this, "Welcome back! 🚗 (Diagnostic Success)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Login failed. Check logs for diagnostic info.", Toast.LENGTH_LONG).show();
                              Log.d(TAG, "❌ Diagnostic login failed - check connection routing");
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  // Show loading message
                  Toast.makeText(this, "Creating account (diagnostic)...", Toast.LENGTH_SHORT).show();
                  
                  // Run registration in background thread
                  new Thread(() -> {
                      boolean registrationResult = authManager.register(email, password, name);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (registrationResult) {
                              Toast.makeText(this, "Account created successfully! 🎉 (Diagnostic)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Registration failed. Check diagnostic logs.", Toast.LENGTH_LONG).show();
                          }
                      });
                  }).start();
              }

              private void testDirectConnection() {
                  Toast.makeText(this, "Testing direct connection... Check logs", Toast.LENGTH_LONG).show();
                  
                  new Thread(() -> {
                      Log.d(TAG, "=== DIRECT CONNECTION DIAGNOSTIC TEST ===");
                      Log.d(TAG, "Testing multiple connection methods to identify localhost routing");
                      
                      // Test with different approaches
                      boolean testResult1 = authManager.testDirectConnection();
                      boolean testResult2 = authManager.testAlternativeConnection();
                      
                      runOnUiThread(() -> {
                          String message = "Direct: " + (testResult1 ? "✅" : "❌") + 
                                          ", Alternative: " + (testResult2 ? "✅" : "❌") + 
                                          " - Check logs for details";
                          Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                      });
                  }).start();
              }

              private void showNetworkInfo() {
                  new Thread(() -> {
                      String networkInfo = authManager.getNetworkDiagnostics();
                      runOnUiThread(() -> {
                          Toast.makeText(this, networkInfo, Toast.LENGTH_LONG).show();
                          Log.d(TAG, "NETWORK INFO: " + networkInfo);
                      });
                  }).start();
              }
              
              private void goToMainApp() {
                  isAuthenticated = true;
                  currentUserEmail = authManager.getCurrentUserEmail();
                  createMainInterface();
              }
              
              private void createMainInterface() {
                  // Simple main interface for now
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 60, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF8F9FA);
                  
                  TextView welcomeText = new TextView(this);
                  welcomeText.setText("Welcome to MileTracker Pro!\n\nUser: " + currentUserEmail + "\n\nDiagnostic Build v4.9.${{ github.event.inputs.version_code || '90' }}\n\nLocahost routing issue being investigated...");
                  welcomeText.setTextSize(18);
                  welcomeText.setTextColor(0xFF000000);
                  welcomeText.setGravity(android.view.Gravity.CENTER);
                  mainLayout.addView(welcomeText);
                  
                  Button logoutButton = new Button(this);
                  logoutButton.setText("Logout");
                  logoutButton.setBackgroundColor(0xFFDC3545);
                  logoutButton.setTextColor(0xFFFFFFFF);
                  logoutButton.setOnClickListener(v -> {
                      authManager.logout();
                      isAuthenticated = false;
                      currentUserEmail = "";
                      createAuthenticationInterface();
                  });
                  
                  LinearLayout.LayoutParams logoutParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  logoutParams.setMargins(0, 40, 0, 0);
                  logoutButton.setLayoutParams(logoutParams);
                  mainLayout.addView(logoutButton);
                  
                  setContentView(mainLayout);
              }

              @Override
              public void onLocationChanged(Location location) {
                  // Location tracking logic here
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF
      
      - name: Create UserAuthManager.java with enhanced diagnostics
        run: |
          cat > android-app/app/src/main/java/com/miletrackerpro/app/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app;
          
          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.Network;
          import android.net.NetworkInfo;
          import android.util.Log;
          import java.io.*;
          import java.net.HttpURLConnection;
          import java.net.InetAddress;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import org.json.JSONObject;
          
          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_AUTH_TOKEN = "auth_token";
              private static final String KEY_USER_ID = "user_id";
              
              private Context context;
              private SharedPreferences prefs;
              
              // API endpoints - Multiple for testing
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              private static final String LOGIN_ENDPOINT = "/api/auth/login";
              private static final String REGISTER_ENDPOINT = "/api/register";
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }
              
              public boolean login(String email, String password) {
                  Log.d(TAG, "🔐 DIAGNOSTIC LOGIN for: '" + email + "'");
                  Log.d(TAG, "Password received: '" + password + "' (length: " + (password != null ? password.length() : "null") + ")");
                  Log.d(TAG, "Target URL: " + API_BASE_URL + LOGIN_ENDPOINT);
                  
                  // Log network state
                  logNetworkState();
                  
                  try {
                      // Create JSON payload
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      Log.d(TAG, "JSON payload: " + loginData.toString());
                      
                      // Make API call with enhanced logging
                      URL url = new URL(API_BASE_URL + LOGIN_ENDPOINT);
                      Log.d(TAG, "🌐 Resolved URL: " + url.toString());
                      Log.d(TAG, "🌐 URL Host: " + url.getHost());
                      Log.d(TAG, "🌐 URL Port: " + url.getPort());
                      Log.d(TAG, "🌐 URL Protocol: " + url.getProtocol());
                      
                      // Try to resolve the host to see what IP we get
                      try {
                          InetAddress address = InetAddress.getByName(url.getHost());
                          Log.d(TAG, "🌐 DNS Resolution: " + url.getHost() + " -> " + address.getHostAddress());
                      } catch (Exception dns) {
                          Log.d(TAG, "🌐 DNS Resolution failed: " + dns.getMessage());
                      }
                      
                      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                      conn.setRequestMethod("POST");
                      conn.setRequestProperty("Content-Type", "application/json");
                      conn.setRequestProperty("User-Agent", "MileTrackerPro-Diagnostic/4.9.${{ github.event.inputs.version_code || '90' }} (Android)");
                      conn.setRequestProperty("X-Diagnostic", "localhost-routing-debug");
                      conn.setConnectTimeout(15000); // 15 second timeout
                      conn.setReadTimeout(15000); // 15 second timeout
                      conn.setDoOutput(true);
                      
                      Log.d(TAG, "🌐 Connection configured");
                      Log.d(TAG, "🌐 Request Headers: " + conn.getRequestProperties());
                      
                      // Send data
                      try (OutputStream os = conn.getOutputStream()) {
                          byte[] input = loginData.toString().getBytes(StandardCharsets.UTF_8);
                          os.write(input, 0, input.length);
                          Log.d(TAG, "🌐 Data sent (" + input.length + " bytes)");
                      }
                      
                      // Check response
                      int responseCode = conn.getResponseCode();
                      String responseMessage = conn.getResponseMessage();
                      Log.d(TAG, "🌐 Response code: " + responseCode + " (" + responseMessage + ")");
                      Log.d(TAG, "🌐 Response headers: " + conn.getHeaderFields());
                      
                      if (responseCode == HttpURLConnection.HTTP_OK) {
                          // Read response
                          StringBuilder response = new StringBuilder();
                          try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                              String line;
                              while ((line = br.readLine()) != null) {
                                  response.append(line);
                              }
                          }
                          
                          String responseString = response.toString();
                          Log.d(TAG, "🌐 Response body: " + responseString);
                          
                          // Parse response
                          JSONObject responseJson = new JSONObject(responseString);
                          boolean success = responseJson.optBoolean("success", false);
                          Log.d(TAG, "Response success field: " + success);
                          
                          if (success) {
                              // Save authentication data
                              String token = responseJson.optString("token", "");
                              JSONObject userObj = responseJson.optJSONObject("user");
                              String userId = userObj != null ? userObj.optString("id", "") : "";
                              
                              Log.d(TAG, "Token received: " + (token.isEmpty() ? "empty" : "[" + token.length() + " chars]"));
                              Log.d(TAG, "User ID: '" + userId + "'");
                              
                              prefs.edit()
                                   .putString(KEY_USER_EMAIL, email)
                                   .putString(KEY_AUTH_TOKEN, token)
                                   .putString(KEY_USER_ID, userId)
                                   .apply();
                              
                              Log.d(TAG, "✅ DIAGNOSTIC login successful for: " + email);
                              return true;
                          } else {
                              String message = responseJson.optString("message", "Unknown error");
                              Log.d(TAG, "❌ DIAGNOSTIC login failed - success=false, message: " + message);
                          }
                      } else {
                          // Try to read error response
                          StringBuilder errorResponse = new StringBuilder();
                          try (InputStream errorStream = conn.getErrorStream()) {
                              if (errorStream != null) {
                                  try (BufferedReader br = new BufferedReader(new InputStreamReader(errorStream, StandardCharsets.UTF_8))) {
                                      String line;
                                      while ((line = br.readLine()) != null) {
                                          errorResponse.append(line);
                                      }
                                  }
                              }
                          } catch (Exception ex) {
                              Log.d(TAG, "Could not read error response: " + ex.getMessage());
                          }
                          Log.d(TAG, "❌ DIAGNOSTIC login failed - HTTP " + responseCode + ", Error body: " + errorResponse.toString());
                      }
                      
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "DIAGNOSTIC login exception: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean testDirectConnection() {
                  Log.d(TAG, "=== DIRECT CONNECTION TEST ===");
                  try {
                      URL url = new URL(API_BASE_URL + "/api/health");
                      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                      conn.setRequestMethod("GET");
                      conn.setRequestProperty("User-Agent", "DirectTest/1.0");
                      conn.setConnectTimeout(10000);
                      conn.setReadTimeout(10000);
                      
                      int responseCode = conn.getResponseCode();
                      Log.d(TAG, "Direct connection test response: " + responseCode);
                      return responseCode == 200;
                  } catch (Exception e) {
                      Log.d(TAG, "Direct connection test failed: " + e.getMessage());
                      return false;
                  }
              }
              
              public boolean testAlternativeConnection() {
                  Log.d(TAG, "=== ALTERNATIVE CONNECTION TEST ===");
                  // Test with different URL construction
                  try {
                      String altUrl = "https://" + "mileage-tracker-codenurse.replit.app" + "/api/health";
                      URL url = new URL(altUrl);
                      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                      conn.setRequestMethod("GET");
                      conn.setRequestProperty("User-Agent", "AltTest/1.0");
                      conn.setRequestProperty("Host", "mileage-tracker-codenurse.replit.app");
                      conn.setConnectTimeout(10000);
                      conn.setReadTimeout(10000);
                      
                      int responseCode = conn.getResponseCode();
                      Log.d(TAG, "Alternative connection test response: " + responseCode);
                      return responseCode == 200;
                  } catch (Exception e) {
                      Log.d(TAG, "Alternative connection test failed: " + e.getMessage());
                      return false;
                  }
              }
              
              public String getNetworkDiagnostics() {
                  StringBuilder info = new StringBuilder();
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          info.append("Network Type: ").append(activeNetwork.getTypeName()).append("\n");
                          info.append("Connected: ").append(activeNetwork.isConnected()).append("\n");
                          info.append("Available: ").append(activeNetwork.isAvailable()).append("\n");
                      } else {
                          info.append("No active network");
                      }
                  } catch (Exception e) {
                      info.append("Network check failed: ").append(e.getMessage());
                  }
                  return info.toString();
              }
              
              private void logNetworkState() {
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          Log.d(TAG, "🌐 Network Type: " + activeNetwork.getTypeName());
                          Log.d(TAG, "🌐 Network State: " + activeNetwork.getState());
                          Log.d(TAG, "🌐 Network Connected: " + activeNetwork.isConnected());
                          Log.d(TAG, "🌐 Network Available: " + activeNetwork.isAvailable());
                      } else {
                          Log.d(TAG, "🌐 No active network detected");
                      }
                  } catch (Exception e) {
                      Log.d(TAG, "🌐 Network state check failed: " + e.getMessage());
                  }
              }
              
              public boolean register(String email, String password, String name) {
                  Log.d(TAG, "📝 DIAGNOSTIC registration for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("name", name);
                      
                      // Make API call
                      URL url = new URL(API_BASE_URL + REGISTER_ENDPOINT);
                      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                      conn.setRequestMethod("POST");
                      conn.setRequestProperty("Content-Type", "application/json");
                      conn.setRequestProperty("User-Agent", "MileTrackerPro-Diagnostic/4.9.${{ github.event.inputs.version_code || '90' }} (Android)");
                      conn.setConnectTimeout(15000);
                      conn.setReadTimeout(15000);
                      conn.setDoOutput(true);
                      
                      // Send data
                      try (OutputStream os = conn.getOutputStream()) {
                          byte[] input = registerData.toString().getBytes(StandardCharsets.UTF_8);
                          os.write(input, 0, input.length);
                      }
                      
                      // Check response
                      int responseCode = conn.getResponseCode();
                      Log.d(TAG, "DIAGNOSTIC registration response code: " + responseCode);
                      
                      if (responseCode == HttpURLConnection.HTTP_OK) {
                          // Read response
                          StringBuilder response = new StringBuilder();
                          try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                              String line;
                              while ((line = br.readLine()) != null) {
                                  response.append(line);
                              }
                          }
                          
                          Log.d(TAG, "DIAGNOSTIC registration response: " + response.toString());
                          
                          // Parse response
                          JSONObject responseJson = new JSONObject(response.toString());
                          if (responseJson.optBoolean("success", false)) {
                              // Save authentication data
                              String token = responseJson.optString("token", "");
                              JSONObject userObj = responseJson.optJSONObject("user");
                              String userId = userObj != null ? userObj.optString("id", "") : "";
                              
                              prefs.edit()
                                   .putString(KEY_USER_EMAIL, email)
                                   .putString(KEY_AUTH_TOKEN, token)
                                   .putString(KEY_USER_ID, userId)
                                   .apply();
                              
                              Log.d(TAG, "✅ DIAGNOSTIC registration successful for: " + email);
                              return true;
                          }
                      }
                      
                      Log.d(TAG, "❌ DIAGNOSTIC registration failed - HTTP " + responseCode);
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "DIAGNOSTIC registration error: " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean isLoggedIn() {
                  String email = prefs.getString(KEY_USER_EMAIL, "");
                  String token = prefs.getString(KEY_AUTH_TOKEN, "");
                  boolean loggedIn = !email.isEmpty() && !token.isEmpty();
                  Log.d(TAG, "isLoggedIn check: email=" + (!email.isEmpty()) + ", token=" + (!token.isEmpty()) + " -> " + loggedIn);
                  return loggedIn;
              }
              
              public String getCurrentUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }
              
              public String getAuthToken() {
                  return prefs.getString(KEY_AUTH_TOKEN, "");
              }
              
              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }
              
              public void logout() {
                  Log.d(TAG, "Logging out user");
                  prefs.edit().clear().apply();
              }
          }
          EOF
      
      - name: Create CloudBackupService.java
        run: |
          cat > android-app/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;
          
          import android.app.Service;
          import android.content.Intent;
          import android.os.IBinder;
          import android.util.Log;
          
          public class CloudBackupService extends Service {
              private static final String TAG = "CloudBackupService";
              
              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "CloudBackupService created");
              }
              
              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  Log.d(TAG, "CloudBackupService started");
                  return START_NOT_STICKY;
              }
              
              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
              
              @Override
              public void onDestroy() {
                  super.onDestroy();
                  Log.d(TAG, "CloudBackupService destroyed");
              }
          }
          EOF
      
      - name: Create gradle wrapper and build
        run: |
          cd android-app
          gradle wrapper --gradle-version 8.4
          chmod +x gradlew
          echo "Starting Gradle build with diagnostic localhost fix..."
          ./gradlew clean assembleRelease --no-daemon --stacktrace --info
          
      - name: Sign APK with modern APK v2 signature scheme
        run: |
          cd android-app
          
          # Find the unsigned APK
          UNSIGNED_APK=$(find . -name "app-release.apk" -type f | head -1)
          echo "Found unsigned APK: $UNSIGNED_APK"
          
          if [ -f "$UNSIGNED_APK" ]; then
              # Create keystore for signing
              keytool -genkey -v -keystore release-key.keystore -alias release-key -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -dname "CN=MileTracker Pro, OU=Development, O=MileTracker, L=City, S=State, C=US"
              
              # Sign with modern apksigner tool (supports both v1 and v2 signatures)
              $ANDROID_HOME/build-tools/34.0.0/apksigner sign \
                  --ks release-key.keystore \
                  --ks-key-alias release-key \
                  --ks-pass pass:android \
                  --key-pass pass:android \
                  --v1-signing-enabled true \
                  --v2-signing-enabled true \
                  --out "MileTracker-Pro-Diagnostic-v4.9.${{ github.event.inputs.version_code || '90' }}.apk" \
                  "$UNSIGNED_APK"
              
              echo "APK signed with both v1 and v2 signatures (Diagnostic)"
              
              # Verify the signature
              $ANDROID_HOME/build-tools/34.0.0/apksigner verify -v "MileTracker-Pro-Diagnostic-v4.9.${{ github.event.inputs.version_code || '90' }}.apk"
              
              # List final APK details
              ls -la "MileTracker-Pro-Diagnostic-v4.9.${{ github.event.inputs.version_code || '90' }}.apk"
              echo "Final diagnostic APK ready for localhost routing investigation"
          else
              echo "ERROR: No unsigned APK file found"
              exit 1
          fi
          
      - name: Upload APK Artifact
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-Diagnostic-v4.9.${{ github.event.inputs.version_code || '90' }}
          path: android-app/MileTracker-Pro-Diagnostic-v4.9.${{ github.event.inputs.version_code || '90' }}.apk
          retention-days: 30
