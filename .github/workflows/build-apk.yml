name: Build Android APK
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version_code:
        description: 'Version code for the APK'
        required: true
        default: '49116'
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Create android project structure
        run: |
          mkdir -p android/app/src/main/java/com/miletrackerpro/app
          mkdir -p android/app/src/main/res/values
          mkdir -p android/app/src/main/res/xml
          mkdir -p android/app/src/main/res/drawable
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/models
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/api
          mkdir -p android/gradle/wrapper

      - name: Create MainActivity with TWO-TAB CLASSIFICATION SYSTEM
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.AlertDialog;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.graphics.Color;
          import android.graphics.Typeface;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.os.Looper;
          import android.text.InputType;
          import android.text.TextUtils;
          import android.util.Log;
          import android.view.Gravity;
          import android.view.MotionEvent;
          import android.view.View;
          import android.view.ViewGroup;
          import android.widget.ArrayAdapter;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.Spinner;
          import android.widget.Switch;
          import android.widget.TextView;
          import android.widget.Toast;
          import android.widget.TabHost;
          import android.widget.TabWidget;
          import android.widget.FrameLayout;

          import androidx.annotation.NonNull;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;

          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.models.Trip;
          import com.miletrackerpro.app.services.AutoDetectionService;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.api.CloudBackupService;

          import java.text.SimpleDateFormat;
          import java.util.ArrayList;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;

          public class MainActivity extends AppCompatActivity {
              private static final String TAG = "MileTracker";
              private static final int LOCATION_PERMISSION_REQUEST_CODE = 1001;
              
              // Core components
              private TripStorage tripStorage;
              private UserAuthManager authManager;
              private SharedPreferences locationPrefs;
              
              // UI Components
              private TabHost tabHost;
              private TextView statusText;
              private TextView statsText;
              private Button autoToggle;
              private Button startButton;
              private Button stopButton;
              private LinearLayout classifyTripsContainer;
              private LinearLayout allTripsContainer;
              private TextView classifyCountText;
              private TextView allTripsCountText;
              
              // State
              private boolean autoDetectionEnabled = false;
              private BroadcastReceiver tripUpdateReceiver;
              private Handler blinkHandler = new Handler(Looper.getMainLooper());
              private Runnable blinkRunnable;
              private boolean isBlinking = false;
              
              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  // Initialize storage and auth
                  tripStorage = new TripStorage(this);
                  authManager = new UserAuthManager(this);
                  locationPrefs = getSharedPreferences("location_prefs", MODE_PRIVATE);
                  
                  setupUI();
                  setupBroadcastReceiver();
                  restoreAutoDetectionState();
                  updateStats();
                  
                  // Load trips for both tabs
                  updateClassifyTrips();
                  updateAllTrips();
                  
                  Log.d(TAG, "MainActivity created with two-tab classification system");
              }
              
              private void setupUI() {
                  // Create main layout
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setBackgroundColor(Color.WHITE);
                  mainLayout.setPadding(20, 20, 20, 20);
                  
                  // Header
                  createHeader(mainLayout);
                  
                  // Status and stats
                  createStatusSection(mainLayout);
                  
                  // Control buttons
                  createControlButtons(mainLayout);
                  
                  // TWO-TAB SYSTEM
                  createTwoTabSystem(mainLayout);
                  
                  setContentView(mainLayout);
              }
              
              private void createHeader(LinearLayout parent) {
                  TextView header = new TextView(this);
                  header.setText("🚗 MileTracker Pro");
                  header.setTextSize(24);
                  header.setTypeface(null, Typeface.BOLD);
                  header.setTextColor(Color.BLACK);
                  header.setGravity(Gravity.CENTER);
                  header.setPadding(0, 0, 0, 20);
                  parent.addView(header);
              }
              
              private void createStatusSection(LinearLayout parent) {
                  // Status text
                  statusText = new TextView(this);
                  statusText.setText("Ready");
                  statusText.setTextSize(16);
                  statusText.setGravity(Gravity.CENTER);
                  statusText.setPadding(0, 0, 0, 10);
                  parent.addView(statusText);
                  
                  // Stats text
                  statsText = new TextView(this);
                  statsText.setTextSize(14);
                  statsText.setGravity(Gravity.CENTER);
                  statsText.setPadding(0, 0, 0, 20);
                  parent.addView(statsText);
              }
              
              private void createControlButtons(LinearLayout parent) {
                  // Auto detection toggle
                  autoToggle = new Button(this);
                  autoToggle.setText("Auto Detection: OFF");
                  autoToggle.setBackgroundColor(0xFF9CA3AF);
                  autoToggle.setTextColor(Color.WHITE);
                  autoToggle.setOnClickListener(v -> toggleAutoDetection());
                  parent.addView(autoToggle);
                  
                  // Manual controls label
                  TextView manualLabel = new TextView(this);
                  manualLabel.setText("Manual Trip Controls");
                  manualLabel.setTextSize(12);
                  manualLabel.setTypeface(null, Typeface.BOLD);
                  manualLabel.setGravity(Gravity.CENTER);
                  manualLabel.setPadding(0, 20, 0, 10);
                  parent.addView(manualLabel);
                  
                  // Manual control buttons
                  LinearLayout buttonLayout = new LinearLayout(this);
                  buttonLayout.setOrientation(LinearLayout.HORIZONTAL);
                  buttonLayout.setGravity(Gravity.CENTER);
                  
                  startButton = new Button(this);
                  startButton.setText("START");
                  startButton.setBackgroundColor(0xFF10B981);
                  startButton.setTextColor(Color.WHITE);
                  startButton.setOnClickListener(v -> startManualTrip());
                  LinearLayout.LayoutParams startParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
                  startParams.setMargins(0, 0, 10, 0);
                  startButton.setLayoutParams(startParams);
                  
                  stopButton = new Button(this);
                  stopButton.setText("STOP");
                  stopButton.setBackgroundColor(0xFFEF4444);
                  stopButton.setTextColor(Color.WHITE);
                  stopButton.setOnClickListener(v -> stopManualTrip());
                  LinearLayout.LayoutParams stopParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
                  stopParams.setMargins(10, 0, 0, 0);
                  stopButton.setLayoutParams(stopParams);
                  
                  buttonLayout.addView(startButton);
                  buttonLayout.addView(stopButton);
                  parent.addView(buttonLayout);
              }
              
              private void createTwoTabSystem(LinearLayout parent) {
                  // Tab host setup
                  tabHost = new TabHost(this);
                  tabHost.setId(android.R.id.tabhost);
                  
                  LinearLayout tabLayout = new LinearLayout(this);
                  tabLayout.setOrientation(LinearLayout.VERTICAL);
                  tabLayout.setLayoutParams(new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.MATCH_PARENT));
                  
                  // Tab widget
                  TabWidget tabWidget = new TabWidget(this);
                  tabWidget.setId(android.R.id.tabs);
                  tabWidget.setOrientation(LinearLayout.HORIZONTAL);
                  tabLayout.addView(tabWidget);
                  
                  // Tab content
                  FrameLayout tabContent = new FrameLayout(this);
                  tabContent.setId(android.R.id.tabcontent);
                  LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.MATCH_PARENT);
                  contentParams.weight = 1;
                  tabContent.setLayoutParams(contentParams);
                  tabLayout.addView(tabContent);
                  
                  tabHost.addView(tabLayout);
                  tabHost.setup();
                  
                  // Create tabs
                  createClassifyTab(tabContent);
                  createAllTripsTab(tabContent);
                  
                  // Set default tab
                  tabHost.setCurrentTab(0);
                  
                  parent.addView(tabHost);
              }
              
              private void createClassifyTab(FrameLayout tabContent) {
                  // Tab content layout
                  LinearLayout classifyLayout = new LinearLayout(this);
                  classifyLayout.setOrientation(LinearLayout.VERTICAL);
                  classifyLayout.setPadding(10, 10, 10, 10);
                  
                  // Header with count
                  LinearLayout headerLayout = new LinearLayout(this);
                  headerLayout.setOrientation(LinearLayout.HORIZONTAL);
                  headerLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  TextView headerText = new TextView(this);
                  headerText.setText("📋 Needs Classification");
                  headerText.setTextSize(16);
                  headerText.setTypeface(null, Typeface.BOLD);
                  headerText.setTextColor(0xFF667eea);
                  
                  classifyCountText = new TextView(this);
                  classifyCountText.setTextSize(14);
                  classifyCountText.setTextColor(0xFF6B7280);
                  classifyCountText.setPadding(10, 0, 0, 0);
                  
                  headerLayout.addView(headerText);
                  headerLayout.addView(classifyCountText);
                  classifyLayout.addView(headerLayout);
                  
                  // Instructions
                  TextView instructions = new TextView(this);
                  instructions.setText("Swipe right for Business, left for Personal");
                  instructions.setTextSize(12);
                  instructions.setTextColor(0xFF6B7280);
                  instructions.setPadding(0, 5, 0, 15);
                  classifyLayout.addView(instructions);
                  
                  // Scrollable container for trips
                  ScrollView scrollView = new ScrollView(this);
                  classifyTripsContainer = new LinearLayout(this);
                  classifyTripsContainer.setOrientation(LinearLayout.VERTICAL);
                  scrollView.addView(classifyTripsContainer);
                  classifyLayout.addView(scrollView);
                  
                  // Add to tab content
                  tabContent.addView(classifyLayout);
                  
                  // Add tab spec
                  TabHost.TabSpec classifySpec = tabHost.newTabSpec("classify");
                  classifySpec.setContent(classifyLayout.getId());
                  classifySpec.setIndicator("Classify");
                  tabHost.addTab(classifySpec);
              }
              
              private void createAllTripsTab(FrameLayout tabContent) {
                  // Tab content layout
                  LinearLayout allTripsLayout = new LinearLayout(this);
                  allTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  allTripsLayout.setPadding(10, 10, 10, 10);
                  
                  // Header with count and controls
                  LinearLayout headerLayout = new LinearLayout(this);
                  headerLayout.setOrientation(LinearLayout.HORIZONTAL);
                  headerLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  TextView headerText = new TextView(this);
                  headerText.setText("📊 All Trips");
                  headerText.setTextSize(16);
                  headerText.setTypeface(null, Typeface.BOLD);
                  headerText.setTextColor(0xFF667eea);
                  
                  allTripsCountText = new TextView(this);
                  allTripsCountText.setTextSize(14);
                  allTripsCountText.setTextColor(0xFF6B7280);
                  allTripsCountText.setPadding(10, 0, 0, 0);
                  
                  headerLayout.addView(headerText);
                  headerLayout.addView(allTripsCountText);
                  allTripsLayout.addView(headerLayout);
                  
                  // Control buttons
                  LinearLayout controlsLayout = new LinearLayout(this);
                  controlsLayout.setOrientation(LinearLayout.HORIZONTAL);
                  controlsLayout.setPadding(0, 10, 0, 10);
                  
                  Button refreshButton = new Button(this);
                  refreshButton.setText("REFRESH");
                  refreshButton.setBackgroundColor(0xFF667eea);
                  refreshButton.setTextColor(Color.WHITE);
                  refreshButton.setOnClickListener(v -> {
                      updateAllTrips();
                      updateClassifyTrips();
                      updateStats();
                  });
                  LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
                  refreshParams.setMargins(0, 0, 5, 0);
                  refreshButton.setLayoutParams(refreshParams);
                  
                  Button exportButton = new Button(this);
                  exportButton.setText("EXPORT");
                  exportButton.setBackgroundColor(0xFF10B981);
                  exportButton.setTextColor(Color.WHITE);
                  exportButton.setOnClickListener(v -> showExportDialog());
                  LinearLayout.LayoutParams exportParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
                  exportParams.setMargins(5, 0, 5, 0);
                  exportButton.setLayoutParams(exportParams);
                  
                  Button resetButton = new Button(this);
                  resetButton.setText("RESET");
                  resetButton.setBackgroundColor(0xFFEF4444);
                  resetButton.setTextColor(Color.WHITE);
                  resetButton.setOnClickListener(v -> showResetDialog());
                  LinearLayout.LayoutParams resetParams = new LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1);
                  resetParams.setMargins(5, 0, 0, 0);
                  resetButton.setLayoutParams(resetParams);
                  
                  controlsLayout.addView(refreshButton);
                  controlsLayout.addView(exportButton);
                  controlsLayout.addView(resetButton);
                  allTripsLayout.addView(controlsLayout);
                  
                  // Scrollable container for trips
                  ScrollView scrollView = new ScrollView(this);
                  allTripsContainer = new LinearLayout(this);
                  allTripsContainer.setOrientation(LinearLayout.VERTICAL);
                  scrollView.addView(allTripsContainer);
                  allTripsLayout.addView(scrollView);
                  
                  // Add to tab content
                  tabContent.addView(allTripsLayout);
                  
                  // Add tab spec
                  TabHost.TabSpec allTripsSpec = tabHost.newTabSpec("all_trips");
                  allTripsSpec.setContent(allTripsLayout.getId());
                  allTripsSpec.setIndicator("All Trips");
                  tabHost.addTab(allTripsSpec);
              }
              
              private void updateClassifyTrips() {
                  if (classifyTripsContainer == null) return;
                  
                  classifyTripsContainer.removeAllViews();
                  
                  List<Trip> uncategorizedTrips = new ArrayList<>();
                  List<Trip> allTrips = tripStorage.getAllTrips();
                  
                  for (Trip trip : allTrips) {
                      if ("Uncategorized".equals(trip.getCategory())) {
                          uncategorizedTrips.add(trip);
                      }
                  }
                  
                  // Update count
                  if (classifyCountText != null) {
                      classifyCountText.setText("(" + uncategorizedTrips.size() + " remaining)");
                  }
                  
                  if (uncategorizedTrips.isEmpty()) {
                      // Show completion message
                      TextView emptyText = new TextView(this);
                      emptyText.setText("🎉 All trips classified!\n\nGreat job! All your trips have been categorized.");
                      emptyText.setTextSize(16);
                      emptyText.setGravity(Gravity.CENTER);
                      emptyText.setTextColor(0xFF10B981);
                      emptyText.setPadding(20, 50, 20, 20);
                      classifyTripsContainer.addView(emptyText);
                  } else {
                      // Show uncategorized trips with swipe functionality
                      for (Trip trip : uncategorizedTrips) {
                          View tripCard = createClassifyTripCard(trip);
                          classifyTripsContainer.addView(tripCard);
                      }
                  }
              }
              
              private View createClassifyTripCard(Trip trip) {
                  LinearLayout card = new LinearLayout(this);
                  card.setOrientation(LinearLayout.VERTICAL);
                  card.setBackgroundColor(Color.WHITE);
                  card.setPadding(15, 15, 15, 15);
                  
                  // Light gray background for uncategorized
                  card.setBackgroundColor(0xFFF9FAFB);
                  
                  LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT);
                  cardParams.setMargins(0, 0, 0, 10);
                  card.setLayoutParams(cardParams);
                  
                  // Trip info
                  TextView tripInfo = new TextView(this);
                  String info = String.format("%s → %s\n%.1f miles • %s",
                      trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown",
                      trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown",
                      trip.getDistance(),
                      new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault()).format(new Date(trip.getStartTime())));
                  tripInfo.setText(info);
                  tripInfo.setTextSize(14);
                  tripInfo.setTextColor(Color.BLACK);
                  card.addView(tripInfo);
                  
                  // Swipe instructions
                  TextView swipeHint = new TextView(this);
                  swipeHint.setText("← Swipe left for Personal • Swipe right for Business →");
                  swipeHint.setTextSize(12);
                  swipeHint.setTextColor(0xFF6B7280);
                  swipeHint.setGravity(Gravity.CENTER);
                  swipeHint.setPadding(0, 10, 0, 0);
                  card.addView(swipeHint);
                  
                  // Add swipe gesture detection
                  setupSwipeGesture(card, trip);
                  
                  return card;
              }
              
              private void setupSwipeGesture(View card, Trip trip) {
                  card.setOnTouchListener(new View.OnTouchListener() {
                      private float startX;
                      private float startY;
                      private boolean isSwipeGesture = false;
                      
                      @Override
                      public boolean onTouch(View v, MotionEvent event) {
                          switch (event.getAction()) {
                              case MotionEvent.ACTION_DOWN:
                                  startX = event.getX();
                                  startY = event.getY();
                                  isSwipeGesture = false;
                                  break;
                                  
                              case MotionEvent.ACTION_MOVE:
                                  float deltaX = event.getX() - startX;
                                  float deltaY = event.getY() - startY;
                                  
                                  // Check if it's a horizontal swipe
                                  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                                      isSwipeGesture = true;
                                  }
                                  break;
                                  
                              case MotionEvent.ACTION_UP:
                                  if (isSwipeGesture) {
                                      float deltaX = event.getX() - startX;
                                      
                                      if (deltaX > 100) {
                                          // Swipe right - Business
                                          classifyTrip(trip, "Business");
                                          return true;
                                      } else if (deltaX < -100) {
                                          // Swipe left - Personal
                                          classifyTrip(trip, "Personal");
                                          return true;
                                      }
                                  }
                                  break;
                          }
                          return false;
                      }
                  });
              }
              
              private void classifyTrip(Trip trip, String category) {
                  try {
                      // Update trip category
                      trip.setCategory(category);
                      tripStorage.saveTrip(trip);
                      
                      // Visual feedback
                      String color = category.equals("Business") ? "🟢" : "🔵";
                      Toast.makeText(this, color + " Classified as " + category, Toast.LENGTH_SHORT).show();
                      
                      // Auto-classify similar trips
                      performLocationBasedLearning(trip, category);
                      
                      // Sync to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudService = new CloudBackupService(this);
                          cloudService.backupTrip(trip);
                      }
                      
                      // Update both tabs
                      updateClassifyTrips();
                      updateAllTrips();
                      updateStats();
                      
                      Log.d(TAG, "Trip classified as " + category + " via swipe gesture");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error classifying trip: " + e.getMessage(), e);
                      Toast.makeText(this, "❌ Error classifying trip", Toast.LENGTH_SHORT).show();
                  }
              }
              
              private void updateAllTrips() {
                  if (allTripsContainer == null) return;
                  
                  allTripsContainer.removeAllViews();
                  
                  List<Trip> allTrips = tripStorage.getAllTrips();
                  
                  // Update count
                  if (allTripsCountText != null) {
                      allTripsCountText.setText("(" + allTrips.size() + " total)");
                  }
                  
                  if (allTrips.isEmpty()) {
                      TextView emptyText = new TextView(this);
                      emptyText.setText("No trips recorded yet");
                      emptyText.setTextSize(16);
                      emptyText.setGravity(Gravity.CENTER);
                      emptyText.setTextColor(0xFF6B7280);
                      emptyText.setPadding(20, 50, 20, 20);
                      allTripsContainer.addView(emptyText);
                  } else {
                      for (Trip trip : allTrips) {
                          View tripCard = createAllTripCard(trip);
                          allTripsContainer.addView(tripCard);
                      }
                  }
              }
              
              private View createAllTripCard(Trip trip) {
                  LinearLayout card = new LinearLayout(this);
                  card.setOrientation(LinearLayout.VERTICAL);
                  card.setBackgroundColor(Color.WHITE);
                  card.setPadding(15, 15, 15, 15);
                  
                  // Color coding based on category
                  int backgroundColor = Color.WHITE;
                  if ("Uncategorized".equals(trip.getCategory())) {
                      backgroundColor = 0xFFF9FAFB; // Light gray
                  } else if ("Business".equals(trip.getCategory())) {
                      backgroundColor = 0xFFF0FDF4; // Light green
                  } else if ("Personal".equals(trip.getCategory())) {
                      backgroundColor = 0xFFF0F9FF; // Light blue
                  }
                  card.setBackgroundColor(backgroundColor);
                  
                  LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT,
                      LinearLayout.LayoutParams.WRAP_CONTENT);
                  cardParams.setMargins(0, 0, 0, 10);
                  card.setLayoutParams(cardParams);
                  
                  // Trip info
                  TextView tripInfo = new TextView(this);
                  String categoryIcon = getCategoryIcon(trip.getCategory());
                  String autoIcon = trip.isAutoDetected() ? "🤖" : "✋";
                  String info = String.format("%s %s %s → %s\n%.1f miles • %s • %s",
                      categoryIcon, autoIcon,
                      trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown",
                      trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown",
                      trip.getDistance(),
                      trip.getCategory(),
                      new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault()).format(new Date(trip.getStartTime())));
                  tripInfo.setText(info);
                  tripInfo.setTextSize(14);
                  tripInfo.setTextColor(Color.BLACK);
                  card.addView(tripInfo);
                  
                  // Edit button
                  Button editButton = new Button(this);
                  editButton.setText("Edit");
                  editButton.setBackgroundColor(0xFF667eea);
                  editButton.setTextColor(Color.WHITE);
                  editButton.setOnClickListener(v -> showEditTripDialog(trip));
                  card.addView(editButton);
                  
                  return card;
              }
              
              private String getCategoryIcon(String category) {
                  switch (category) {
                      case "Business": return "💼";
                      case "Personal": return "🏠";
                      case "Medical": return "🏥";
                      case "Charity": return "💝";
                      default: return "❓";
                  }
              }
              
              private void showResetDialog() {
                  new AlertDialog.Builder(this)
                      .setTitle("Reset All Trips")
                      .setMessage("This will reset ALL trips to 'Uncategorized' status. Are you sure?")
                      .setPositiveButton("Reset", (dialog, which) -> resetAllTripsToUncategorized())
                      .setNegativeButton("Cancel", null)
                      .show();
              }
              
              // Reset all trips to Uncategorized
              private void resetAllTripsToUncategorized() {
                  try {
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      int resetCount = 0;
                      
                      for (Trip trip : allTrips) {
                          if (!"Uncategorized".equals(trip.getCategory())) {
                              trip.setCategory("Uncategorized");
                              tripStorage.saveTrip(trip);
                              resetCount++;
                          }
                      }
                      
                      // Sync to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudService = new CloudBackupService(this);
                          for (Trip trip : allTrips) {
                              cloudService.backupTrip(trip);
                          }
                      }
                      
                      Toast.makeText(this, "✅ Reset " + resetCount + " trips to Uncategorized", Toast.LENGTH_LONG).show();
                      Log.d(TAG, "Reset " + resetCount + " trips to Uncategorized");
                      
                      // Refresh both tabs
                      updateClassifyTrips();
                      updateAllTrips();
                      updateStats();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error resetting trips: " + e.getMessage(), e);
                      Toast.makeText(this, "❌ Error resetting trips", Toast.LENGTH_SHORT).show();
                  }
              }
              
              private void performLocationBasedLearning(Trip trip, String category) {
                  try {
                      // Save location preference
                      String startKey = "location_" + simplifyAddress(trip.getStartAddress());
                      String endKey = "location_" + simplifyAddress(trip.getEndAddress());
                      
                      SharedPreferences.Editor editor = locationPrefs.edit();
                      editor.putString(startKey + "_category", category);
                      editor.putInt(startKey + "_count", locationPrefs.getInt(startKey + "_count", 0) + 1);
                      editor.putString(endKey + "_category", category);
                      editor.putInt(endKey + "_count", locationPrefs.getInt(endKey + "_count", 0) + 1);
                      editor.apply();
                      
                      // Get all uncategorized trips to check for similar locations
                      List<Trip> uncategorizedTrips = tripStorage.getAllTrips();
                      List<Trip> similarTrips = new ArrayList<>();
                      
                      String startLocationKey = normalizeLocationForClassification(trip.getStartAddress());
                      String endLocationKey = normalizeLocationForClassification(trip.getEndAddress());
                      
                      for (Trip uncategorizedTrip : uncategorizedTrips) {
                          if (uncategorizedTrip.getId() == trip.getId()) continue;
                          if (!"Uncategorized".equals(uncategorizedTrip.getCategory())) continue;
                          
                          String uncategorizedStartKey = normalizeLocationForClassification(uncategorizedTrip.getStartAddress());
                          String uncategorizedEndKey = normalizeLocationForClassification(uncategorizedTrip.getEndAddress());
                          
                          if (startLocationKey.equals(uncategorizedStartKey) || endLocationKey.equals(uncategorizedEndKey)) {
                              similarTrips.add(uncategorizedTrip);
                          }
                      }
                      
                      // Auto-classify similar trips
                      if (!similarTrips.isEmpty()) {
                          for (Trip similarTrip : similarTrips) {
                              similarTrip.setCategory(category);
                              tripStorage.saveTrip(similarTrip);
                          }
                          
                          String message = "🤖 Auto-classified " + similarTrips.size() + " similar trip" + (similarTrips.size() == 1 ? "" : "s") + " as " + category;
                          Toast.makeText(this, message, Toast.LENGTH_LONG).show();
                          
                          Log.d(TAG, "Auto-classified " + similarTrips.size() + " similar trips as " + category);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in location-based learning: " + e.getMessage(), e);
                  }
              }
              
              private String normalizeLocationForClassification(String location) {
                  if (location == null || location.trim().isEmpty()) return "";
                  
                  String normalized = location.toLowerCase().trim();
                  normalized = normalized.replaceAll("^\\d+\\s*", "");
                  normalized = normalized.replaceAll("\\s*,.*$", "");
                  normalized = normalized.replaceAll("\\s+", " ");
                  
                  if (normalized.contains("home") || normalized.contains("house") || normalized.contains("residence")) {
                      return "home";
                  }
                  
                  if (normalized.contains("office") || normalized.contains("corp") || normalized.contains("company") || 
                      normalized.contains("business") || normalized.contains("workplace") || normalized.contains("work")) {
                      return "business_location";
                  }
                  
                  if (normalized.contains("hospital") || normalized.contains("clinic") || normalized.contains("medical") || 
                      normalized.contains("doctor") || normalized.contains("dentist") || normalized.contains("pharmacy")) {
                      return "medical_location";
                  }
                  
                  String[] parts = normalized.split(" ");
                  return parts.length > 0 ? parts[0] : normalized;
              }
              
              private String simplifyAddress(String address) {
                  if (address == null) return "";
                  
                  String simplified = address.toLowerCase()
                      .replaceAll("\\d+", "")
                      .replaceAll("[^a-z\\s]", "")
                      .replaceAll("\\s+", " ")
                      .trim();
                  
                  String[] words = simplified.split("\\s+");
                  StringBuilder result = new StringBuilder();
                  for (int i = 0; i < Math.min(3, words.length); i++) {
                      if (i > 0) result.append(" ");
                      result.append(words[i]);
                  }
                  
                  return result.toString();
              }
              
              private void toggleAutoDetection() {
                  try {
                      autoDetectionEnabled = !autoDetectionEnabled;
                      tripStorage.setAutoDetectionEnabled(autoDetectionEnabled);
                      
                      Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                      
                      if (autoDetectionEnabled) {
                          if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) 
                              != PackageManager.PERMISSION_GRANTED) {
                              ActivityCompat.requestPermissions(this, 
                                  new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 
                                  LOCATION_PERMISSION_REQUEST_CODE);
                              return;
                          }
                          
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }
                          
                          autoToggle.setText("Auto Detection: ON");
                          autoToggle.setBackgroundColor(0xFF667eea);
                          statusText.setText("Auto detection active");
                          startBlinkingAnimation();
                          
                      } else {
                          serviceIntent.setAction("STOP_AUTO_DETECTION");
                          stopService(serviceIntent);
                          
                          autoToggle.setText("Auto Detection: OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Ready");
                          stopBlinkingAnimation();
                      }
                      
                      Log.d(TAG, "Auto detection " + (autoDetectionEnabled ? "enabled" : "disabled"));
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling auto detection: " + e.getMessage(), e);
                  }
              }
              
              private void startBlinkingAnimation() {
                  stopBlinkingAnimation();
                  isBlinking = true;
                  
                  blinkRunnable = new Runnable() {
                      private boolean showHeadlights = false;
                      
                      @Override
                      public void run() {
                          if (!isBlinking) return;
                          
                          if (showHeadlights) {
                              autoToggle.setText("🔆🚘🔆 Auto Detection: ON");
                          } else {
                              autoToggle.setText("🚘 Auto Detection: ON");
                          }
                          
                          showHeadlights = !showHeadlights;
                          blinkHandler.postDelayed(this, 800);
                      }
                  };
                  
                  blinkHandler.post(blinkRunnable);
              }
              
              private void stopBlinkingAnimation() {
                  isBlinking = false;
                  if (blinkRunnable != null) {
                      blinkHandler.removeCallbacks(blinkRunnable);
                      blinkRunnable = null;
                  }
              }
              
              private void startManualTrip() {
                  // Manual trip implementation
                  Toast.makeText(this, "Manual trip started", Toast.LENGTH_SHORT).show();
              }
              
              private void stopManualTrip() {
                  // Manual trip implementation
                  Toast.makeText(this, "Manual trip stopped", Toast.LENGTH_SHORT).show();
              }
              
              private void showExportDialog() {
                  // Export implementation
                  Toast.makeText(this, "Export functionality", Toast.LENGTH_SHORT).show();
              }
              
              private void showEditTripDialog(Trip trip) {
                  // Edit trip implementation
                  Toast.makeText(this, "Edit trip: " + trip.getId(), Toast.LENGTH_SHORT).show();
              }
              
              private void updateStats() {
                  try {
                      List<Trip> allTrips = tripStorage.getAllTrips();
                      int totalTrips = allTrips.size();
                      double totalMiles = 0;
                      int uncategorizedCount = 0;
                      
                      for (Trip trip : allTrips) {
                          totalMiles += trip.getDistance();
                          if ("Uncategorized".equals(trip.getCategory())) {
                              uncategorizedCount++;
                          }
                      }
                      
                      String stats = String.format(Locale.getDefault(),
                          "• Total Trips: %d • Total Miles: %.1f • Need Classification: %d",
                          totalTrips, totalMiles, uncategorizedCount);
                      
                      if (statsText != null) {
                          statsText.setText(stats);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                  }
              }
              
              private void setupBroadcastReceiver() {
                  tripUpdateReceiver = new BroadcastReceiver() {
                      @Override
                      public void onReceive(Context context, Intent intent) {
                          String action = intent.getAction();
                          if ("com.miletrackerpro.app.TRIP_UPDATE".equals(action)) {
                              updateClassifyTrips();
                              updateAllTrips();
                              updateStats();
                          }
                      }
                  };
                  
                  IntentFilter filter = new IntentFilter("com.miletrackerpro.app.TRIP_UPDATE");
                  registerReceiver(tripUpdateReceiver, filter);
              }
              
              private void restoreAutoDetectionState() {
                  try {
                      autoDetectionEnabled = tripStorage.isAutoDetectionEnabled();
                      if (autoDetectionEnabled) {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }
                          
                          autoToggle.setText("Auto Detection: ON");
                          autoToggle.setBackgroundColor(0xFF667eea);
                          statusText.setText("Auto detection active");
                          startBlinkingAnimation();
                      } else {
                          autoToggle.setText("Auto Detection: OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error restoring auto detection state: " + e.getMessage(), e);
                  }
              }
              
              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  if (tripUpdateReceiver != null) {
                      unregisterReceiver(tripUpdateReceiver);
                  }
                  stopBlinkingAnimation();
              }
              
              @Override
              public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  if (requestCode == LOCATION_PERMISSION_REQUEST_CODE) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          toggleAutoDetection();
                      } else {
                          autoDetectionEnabled = false;
                          tripStorage.setAutoDetectionEnabled(false);
                          Toast.makeText(this, "Location permission required for auto detection", Toast.LENGTH_LONG).show();
                      }
                  }
              }
          }
          EOF

      - name: Copy all supporting files from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder addressText = new StringBuilder();

                  if (address.getSubThoroughfare() != null) {
                      addressText.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      addressText.append(address.getThoroughfare()).append(", ");
                  }
                  if (address.getLocality() != null) {
                      addressText.append(address.getLocality()).append(", ");
                  }
                  if (address.getAdminArea() != null) {
                      addressText.append(address.getAdminArea());
                  }

                  String result = addressText.toString().trim();
                  if (result.endsWith(",")) {
                      result = result.substring(0, result.length() - 1);
                  }

                  return result.isEmpty() ? "Unknown Location" : result;
              }
          }
          EOF

          # AutoDetectionService with FIXED default category
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.api.CloudBackupService;
          import com.miletrackerpro.app.models.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import java.util.ArrayList;
          import java.util.List;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              private static final int NOTIFICATION_ID = 1001;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private boolean isTracking = false;
              private Trip currentTrip = null;
              private Location lastLocation = null;
              private int stationaryCount = 0;
              private int movingCount = 0;
              private long lastMovementTime = 0;
              private List<Location> pathPoints = new ArrayList<>();
              private double cumulativeDistance = 0.0;

              private static final double SPEED_THRESHOLD_START = 8.0;
              private static final double SPEED_THRESHOLD_STOP = 3.0;
              private static final int START_CONFIRMATIONS = 3;
              private static final int STOP_CONFIRMATIONS = 4;
              private static final long MAX_STATIONARY_TIME = 120000;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();

                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          startAutoDetection();
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopAutoDetection();
                      }
                  }
                  return START_STICKY;
              }

              private void startAutoDetection() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      isTracking = true;
                      tripStorage.setAutoDetectionEnabled(true);

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          10000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              private void startNewTrip(Location location, long currentTime) {
                  try {
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(true);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());
                      
                      // CRITICAL BUG FIX: Set new auto-detected trips to "Uncategorized" instead of "Business"
                      currentTrip.setCategory("Uncategorized");
                      
                      // Initialize path tracking
                      pathPoints.clear();
                      pathPoints.add(location);
                      cumulativeDistance = 0.0;

                      addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setStartAddress(address);
                              tripStorage.saveCurrentTrip(currentTrip);
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setStartAddress("Unknown Location");
                              tripStorage.saveCurrentTrip(currentTrip);
                          }
                      });

                      movingCount = 0;
                      lastMovementTime = currentTime;

                      Notification notification = createNotification("Trip in progress", "Recording your trip");
                      startForeground(NOTIFICATION_ID, notification);
                      
                      Log.d(TAG, "Started new trip with category: Uncategorized");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting trip", e);
                  }
              }

              private void endCurrentTrip() {
                  if (currentTrip == null) return;

                  try {
                      long currentTime = System.currentTimeMillis();
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      addPathPoint(lastLocation);
                      currentTrip.setDistance(cumulativeDistance);

                      if (cumulativeDistance >= 0.5) {
                          addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  tripStorage.saveTrip(currentTrip);
                                  
                                  // Sync to API if enabled
                                  if (tripStorage.isApiSyncEnabled()) {
                                      cloudBackupService.backupTrip(currentTrip);
                                  }
                                  
                                  // Send broadcast update
                                  Intent intent = new Intent("com.miletrackerpro.app.TRIP_UPDATE");
                                  sendBroadcast(intent);
                                  
                                  Log.d(TAG, "Completed trip saved with category: " + currentTrip.getCategory());
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setEndAddress("Unknown Location");
                                  tripStorage.saveTrip(currentTrip);
                                  
                                  // Sync to API if enabled
                                  if (tripStorage.isApiSyncEnabled()) {
                                      cloudBackupService.backupTrip(currentTrip);
                                  }
                                  
                                  // Send broadcast update
                                  Intent intent = new Intent("com.miletrackerpro.app.TRIP_UPDATE");
                                  sendBroadcast(intent);
                              }
                          });
                      }

                      tripStorage.clearCurrentTrip();
                      currentTrip = null;
                      stationaryCount = 0;
                      movingCount = 0;
                      pathPoints.clear();

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (!isTracking || location == null) return;

                  try {
                      float speed = location.getSpeed() * 2.237f;
                      long currentTime = System.currentTimeMillis();

                      if (currentTrip == null) {
                          if (speed >= SPEED_THRESHOLD_START) {
                              movingCount++;
                              stationaryCount = 0;
                              
                              if (movingCount >= START_CONFIRMATIONS) {
                                  startNewTrip(location, currentTime);
                              }
                          } else {
                              if (speed < 2.0) {
                                  movingCount = 0;
                              }
                          }
                      } else {
                          addPathPoint(location);
                          
                          if (speed <= SPEED_THRESHOLD_STOP) {
                              stationaryCount++;
                              movingCount = 0;

                              long timeSinceLastMovement = currentTime - lastMovementTime;

                              if (stationaryCount >= STOP_CONFIRMATIONS || 
                                  timeSinceLastMovement > MAX_STATIONARY_TIME) {
                                  endCurrentTrip();
                              }
                          } else {
                              stationaryCount = 0;
                              lastMovementTime = currentTime;
                          }
                      }

                      lastLocation = location;
                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location update", e);
                  }
              }

              private void addPathPoint(Location location) {
                  if (pathPoints.size() > 0) {
                      Location lastPoint = pathPoints.get(pathPoints.size() - 1);
                      float distance = lastPoint.distanceTo(location);
                      cumulativeDistance += distance * 0.000621371;
                  }
                  pathPoints.add(location);
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      channel.setDescription("Background trip detection");
                      NotificationManager manager = getSystemService(NotificationManager.class);
                      manager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String text) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(text)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setPriority(NotificationCompat.PRIORITY_LOW)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }

              private void stopAutoDetection() {
                  isTracking = false;
                  tripStorage.setAutoDetectionEnabled(false);
                  
                  if (locationManager != null) {
                      locationManager.removeUpdates(this);
                  }
                  
                  stopForeground(true);
                  stopSelf();
              }
          }
          EOF

          # Add remaining support files
          cat > android/app/src/main/java/com/miletrackerpro/app/models/Trip.java << 'EOF'
          package com.miletrackerpro.app.models;

          public class Trip {
              private long id;
              private long startTime;
              private long endTime;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private String startAddress;
              private String endAddress;
              private double distance;
              private long duration;
              private String category;
              private boolean autoDetected;
              private String notes;
              private String clientName;

              public Trip() {
                  this.category = "Uncategorized";
                  this.autoDetected = false;
              }

              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.miletrackerpro.app.models.Trip;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Comparator;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "miletracker_prefs";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              
              private SharedPreferences preferences;

              public TripStorage(Context context) {
                  this.preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public void saveTrip(Trip trip) {
                  try {
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(t -> t.getId() == trip.getId());
                      trips.add(trip);
                      
                      Collections.sort(trips, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t2.getStartTime(), t1.getStartTime());
                          }
                      });
                      
                      saveAllTrips(trips);
                      Log.d(TAG, "Trip saved: " + trip.getId() + " with category: " + trip.getCategory());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = preferences.getString(TRIPS_KEY, "[]");
                      JSONArray jsonArray = new JSONArray(tripsJson);
                      
                      for (int i = 0; i < jsonArray.length(); i++) {
                          JSONObject tripJson = jsonArray.getJSONObject(i);
                          Trip trip = jsonToTrip(tripJson);
                          if (trip != null) {
                              trips.add(trip);
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject tripJson = tripToJson(trip);
                          jsonArray.put(tripJson);
                      }
                      
                      preferences.edit().putString(TRIPS_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving all trips", e);
                  }
              }

              private JSONObject tripToJson(Trip trip) throws Exception {
                  JSONObject json = new JSONObject();
                  json.put("id", trip.getId());
                  json.put("startTime", trip.getStartTime());
                  json.put("endTime", trip.getEndTime());
                  json.put("startLatitude", trip.getStartLatitude());
                  json.put("startLongitude", trip.getStartLongitude());
                  json.put("endLatitude", trip.getEndLatitude());
                  json.put("endLongitude", trip.getEndLongitude());
                  json.put("startAddress", trip.getStartAddress());
                  json.put("endAddress", trip.getEndAddress());
                  json.put("distance", trip.getDistance());
                  json.put("duration", trip.getDuration());
                  json.put("category", trip.getCategory());
                  json.put("autoDetected", trip.isAutoDetected());
                  json.put("notes", trip.getNotes());
                  json.put("clientName", trip.getClientName());
                  return json;
              }

              private Trip jsonToTrip(JSONObject json) {
                  try {
                      Trip trip = new Trip();
                      trip.setId(json.getLong("id"));
                      trip.setStartTime(json.getLong("startTime"));
                      trip.setEndTime(json.optLong("endTime", 0));
                      trip.setStartLatitude(json.getDouble("startLatitude"));
                      trip.setStartLongitude(json.getDouble("startLongitude"));
                      trip.setEndLatitude(json.optDouble("endLatitude", 0));
                      trip.setEndLongitude(json.optDouble("endLongitude", 0));
                      trip.setStartAddress(json.optString("startAddress", "Unknown"));
                      trip.setEndAddress(json.optString("endAddress", "Unknown"));
                      trip.setDistance(json.optDouble("distance", 0));
                      trip.setDuration(json.optLong("duration", 0));
                      trip.setCategory(json.optString("category", "Uncategorized"));
                      trip.setAutoDetected(json.optBoolean("autoDetected", false));
                      trip.setNotes(json.optString("notes", ""));
                      trip.setClientName(json.optString("clientName", ""));
                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error converting JSON to trip", e);
                      return null;
                  }
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip != null) {
                          JSONObject json = tripToJson(trip);
                          preferences.edit().putString(CURRENT_TRIP_KEY, json.toString()).apply();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String tripJson = preferences.getString(CURRENT_TRIP_KEY, null);
                      if (tripJson != null) {
                          JSONObject json = new JSONObject(tripJson);
                          return jsonToTrip(json);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                  }
                  return null;
              }

              public void clearCurrentTrip() {
                  preferences.edit().remove(CURRENT_TRIP_KEY).apply();
              }

              public boolean isAutoDetectionEnabled() {
                  return preferences.getBoolean(AUTO_DETECTION_KEY, false);
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  preferences.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
              }

              public boolean isApiSyncEnabled() {
                  return preferences.getBoolean(API_SYNC_KEY, false);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  preferences.edit().putBoolean(API_SYNC_KEY, enabled).apply();
              }
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;

          public class UserAuthManager {
              private static final String PREFS_NAME = "auth_prefs";
              private static final String AUTH_TOKEN_KEY = "auth_token";
              private static final String USER_EMAIL_KEY = "user_email";
              private static final String USER_TIER_KEY = "user_tier";

              private SharedPreferences preferences;

              public UserAuthManager(Context context) {
                  this.preferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public boolean isAuthenticated() {
                  String token = preferences.getString(AUTH_TOKEN_KEY, null);
                  return token != null && !token.isEmpty();
              }

              public void saveAuthToken(String token) {
                  preferences.edit().putString(AUTH_TOKEN_KEY, token).apply();
              }

              public String getAuthToken() {
                  return preferences.getString(AUTH_TOKEN_KEY, null);
              }

              public void saveUserEmail(String email) {
                  preferences.edit().putString(USER_EMAIL_KEY, email).apply();
              }

              public String getUserEmail() {
                  return preferences.getString(USER_EMAIL_KEY, null);
              }

              public void saveUserTier(String tier) {
                  preferences.edit().putString(USER_TIER_KEY, tier).apply();
              }

              public String getUserTier() {
                  return preferences.getString(USER_TIER_KEY, "free");
              }

              public void logout() {
                  preferences.edit().clear().apply();
              }
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/api/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app.api;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.models.Trip;
          import java.io.OutputStreamWriter;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              
              private Context context;
              private UserAuthManager authManager;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.authManager = new UserAuthManager(context);
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void backupTrip(Trip trip) {
                  executor.execute(() -> {
                      try {
                          String token = authManager.getAuthToken();
                          String email = authManager.getUserEmail();
                          
                          if (token == null || email == null) {
                              Log.d(TAG, "No auth credentials for backup");
                              return;
                          }

                          URL url = new URL(API_BASE_URL + "/api/trips");
                          HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                          connection.setRequestMethod("POST");
                          connection.setRequestProperty("Content-Type", "application/json");
                          connection.setRequestProperty("Authorization", "Bearer " + token);
                          connection.setRequestProperty("X-User-Email", email);
                          connection.setDoOutput(true);

                          JSONObject tripJson = new JSONObject();
                          tripJson.put("device_id", trip.getId());
                          tripJson.put("start_time", trip.getStartTime());
                          tripJson.put("end_time", trip.getEndTime());
                          tripJson.put("start_latitude", trip.getStartLatitude());
                          tripJson.put("start_longitude", trip.getStartLongitude());
                          tripJson.put("end_latitude", trip.getEndLatitude());
                          tripJson.put("end_longitude", trip.getEndLongitude());
                          tripJson.put("start_location", trip.getStartAddress());
                          tripJson.put("end_location", trip.getEndAddress());
                          tripJson.put("distance", trip.getDistance());
                          tripJson.put("duration", trip.getDuration());
                          tripJson.put("category", trip.getCategory());
                          tripJson.put("auto_detected", trip.isAutoDetected());
                          tripJson.put("notes", trip.getNotes());
                          tripJson.put("client_name", trip.getClientName());

                          OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
                          writer.write(tripJson.toString());
                          writer.flush();
                          writer.close();

                          int responseCode = connection.getResponseCode();
                          Log.d(TAG, "Backup response: " + responseCode);

                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip", e);
                      }
                  });
              }
          }
          EOF

          # Build configuration files
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext.kotlin_version = '1.9.24'
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath 'com.android.tools.build:gradle:8.1.0'
                  classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

          cat > android/app/build.gradle << 'EOF'
          apply plugin: 'com.android.application'

          android {
              compileSdkVersion 34
              buildToolsVersion "34.0.0"

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdkVersion 21
                  targetSdkVersion 34
                  versionCode ${{ github.event.inputs.version_code }}
                  versionName "4.9.116"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
              implementation 'com.google.android.material:material:1.11.0'
          }
          EOF

          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.miletrackerpro.app">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />

              <application
                  android:allowBackup="true"
                  android:icon="@mipmap/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme">
                  
                  <activity
                      android:name=".MainActivity"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false" />

              </application>
          </manifest>
          EOF

          # Add gradle wrapper and resources
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.0-bin.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

          mkdir -p android/app/src/main/res/values
          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <resources>
              <string name="app_name">MileTracker Pro</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a67d8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          # Create basic icons
          mkdir -p android/app/src/main/res/mipmap-mdpi
          mkdir -p android/app/src/main/res/mipmap-hdpi
          mkdir -p android/app/src/main/res/mipmap-xhdpi
          mkdir -p android/app/src/main/res/mipmap-xxhdpi
          mkdir -p android/app/src/main/res/mipmap-xxxhdpi

          echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > android/app/src/main/res/mipmap-mdpi/ic_launcher.png

      - name: Make gradlew executable
        run: chmod +x android/gradlew

      - name: Build APK  
        run: |
          cd android
          ./gradlew assembleRelease --stacktrace --no-daemon

      - name: Upload APK
        uses: actions/upload-artifact@v3
        with:
          name: MileTracker-Pro-APK
          path: android/app/build/outputs/apk/release/app-release.apk
