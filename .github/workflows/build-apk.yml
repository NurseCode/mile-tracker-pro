ICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      long currentTime = System.currentTimeMillis();

                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setEndAddress(address);
                              saveTrip();
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setEndAddress("Unknown Location");
                              saveTrip();
                          }
                      });
                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private void saveTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }

                      sendBroadcast("completed", currentTrip.getDistance(), currentTrip.getDuration());
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                  }
              }



              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip == null) return;

                      if (startLocation == null) {
                          startLocation = location;
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());

                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                              }
                          });
                      }

                      lastLocation = location;

                      if (startLocation != null) {
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  try {
                      Intent intent = new Intent("MANUAL_TRIP_UPDATE");
                      intent.putExtra("status", status);
                      intent.putExtra("distance", distance);
                      intent.putExtra("duration", duration);
                      sendBroadcast(intent);
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending broadcast: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Build Android APK with STABLE DEVICE ID + USER LINKING
        run: |
          cd android
          echo "BUILDING v4.9.55 - FIXED TRIP SAVING + ENHANCED FEATURES"
          echo "✅ ENHANCED: Refresh button with visual loading feedback"
          echo "✅ ENHANCED: Complete edit dialog for ALL trip fields (date, time, duration, locations, category, client, notes, auto-detect)"
          echo "✅ ENHANCED: Edit buttons on every trip in full view"
          echo "✅ ENHANCED: Immediate API sync for all edits and refreshes"
          echo "✅ PRESERVED: Complete authentication system and all working features"
          echo "✅ PRESERVED: Stable device ID + user linking"
          ./gradlew clean assembleRelease --no-daemon --stacktrace

      - name: Upload APK - Enhanced API Sync + All Editable Fields
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.64-Compilation-Errors-Fixed
          path: android/app/build/outputs/apk/release/*.apk
