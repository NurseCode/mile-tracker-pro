name: Build Android APK
on:
  workflow_dispatch:
    inputs:
      version_code:
        description: 'Version code for the APK'
        required: true
        default: '49142'
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
        with:
          api-level: 33
          build-tools: 33.0.1
          
      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Clean any existing project
        run: |
          rm -rf android

      - name: Create Android project structure
        run: |
          mkdir -p android/app/src/main/java/com/miletrackerpro/app
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/res/drawable
          mkdir -p android/app/src/main/res/values
          mkdir -p android/app/src/main/res/xml
          mkdir -p android/gradle/wrapper

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTracker Pro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m
          android.useAndroidX=true
          android.enableJetifier=true
          EOF

      - name: Create build.gradle (project level)
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  compileSdkVersion = 33
                  targetSdkVersion = 33
                  minSdkVersion = 21
                  buildToolsVersion = "33.0.1"
              }
              dependencies {
                  classpath 'com.android.tools.build:gradle:8.1.4'
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
                  gradlePluginPortal()
              }
          }

          task clean(type: Delete) {
              delete rootProject.buildDir
          }
          EOF

      - name: Create gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create build.gradle (app level)
        run: |
          cat > android/app/build.gradle << 'EOF'
          apply plugin: 'com.android.application'

          android {
              namespace 'com.miletrackerpro.app'
              compileSdkVersion 33
              buildToolsVersion "33.0.1"

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdkVersion 21
                  targetSdkVersion 33
                  versionCode ${{ github.event.inputs.version_code }}
                  versionName "4.9.142"
                  testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                  }
              }
              
              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }
              
              packagingOptions {
                  pickFirst '**/libc++_shared.so'
                  pickFirst '**/libjsc.so'
              }
              
              lintOptions {
                  abortOnError false
                  checkReleaseBuilds false
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'com.google.android.material:material:1.9.0'
              implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
              implementation 'androidx.recyclerview:recyclerview:1.3.1'
              implementation 'androidx.cardview:cardview:1.0.0'
              implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.1.0'
              implementation 'androidx.viewpager2:viewpager2:1.0.0'
              implementation 'androidx.fragment:fragment:1.6.1'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              testImplementation 'junit:junit:4.13.2'
              androidTestImplementation 'androidx.test.ext:junit:1.1.5'
              androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.miletrackerpro.app">

              <!-- Location permissions for GPS tracking -->
              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              
              <!-- Foreground service permission for background tracking -->
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              
              <!-- System permissions for app functionality -->
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
              <uses-permission android:name="android.permission.VIBRATE" />
              <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />
              
              <!-- Legacy Bluetooth permissions for Android 11 and below -->
              <uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
              
              <!-- New Android 12+ Bluetooth permissions -->
              <uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation" />
              <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
              
              <!-- Bluetooth hardware feature requirements -->
              <uses-feature android:name="android.hardware.bluetooth" android:required="false"/>
              <uses-feature android:name="android.hardware.bluetooth_le" android:required="false"/>

              <application
                  android:allowBackup="true"
                  android:icon="@mipmap/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:usesCleartextTraffic="true">
                  
                  <!-- Main Activity -->
                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:theme="@style/AppTheme">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>
                  
                  <!-- Authentication Activity -->
                  <activity
                      android:name=".AuthActivity"
                      android:exported="false"
                      android:theme="@style/AppTheme" />
                  
                  <!-- Data Recovery Activity -->
                  <activity
                      android:name=".DataRecoveryActivity"
                      android:exported="false"
                      android:theme="@style/AppTheme" />
                  
                  <!-- Auto Detection Service -->
                  <service
                      android:name=".services.AutoDetectionService"
                      android:exported="false"
                      android:foregroundServiceType="location" />
                  
                  <!-- Manual Trip Service -->
                  <service
                      android:name=".services.ManualTripService"
                      android:exported="false"
                      android:foregroundServiceType="location" />
                  
                  <!-- File Provider for sharing files -->
                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="com.miletrackerpro.app.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

                  <!-- Bluetooth Discovery BroadcastReceiver -->
                  <receiver android:name=".BluetoothDiscoveryReceiver" android:exported="false">
                      <intent-filter>
                          <action android:name="android.bluetooth.device.action.FOUND" />
                          <action android:name="android.bluetooth.adapter.action.DISCOVERY_STARTED" />
                          <action android:name="android.bluetooth.adapter.action.DISCOVERY_FINISHED" />
                      </intent-filter>
                  </receiver>

              </application>
          </manifest>
          EOF

      - name: Create string resources
        run: |
          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <resources>
              <string name="app_name">MileTracker Pro</string>
          </resources>
          EOF

      - name: Create styles
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

      - name: Create file provider paths
        run: |
          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths>
              <external-path name="external_files" path="."/>
          </paths>
          EOF

      - name: Create app icon
        run: |
          mkdir -p android/app/src/main/res/mipmap-mdpi
          mkdir -p android/app/src/main/res/mipmap-hdpi
          mkdir -p android/app/src/main/res/mipmap-xhdpi
          mkdir -p android/app/src/main/res/mipmap-xxhdpi
          mkdir -p android/app/src/main/res/mipmap-xxxhdpi
          
          # Create a simple colored square for the app icon
          cat > android/app/src/main/res/mipmap-mdpi/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="48dp"
              android:height="48dp"
              android:viewportWidth="48"
              android:viewportHeight="48">
              <path
                  android:fillColor="#667eea"
                  android:pathData="M0,0h48v48h-48z" />
              <path
                  android:fillColor="#ffffff"
                  android:pathData="M12,16h24v4h-24z" />
              <path
                  android:fillColor="#ffffff"
                  android:pathData="M12,24h24v4h-24z" />
              <path
                  android:fillColor="#ffffff"
                  android:pathData="M12,32h16v4h-16z" />
          </vector>
          EOF

      - name: Create UserAuthManager with OkHttp and multi-device support
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.os.Build;
          import android.util.Log;
          import okhttp3.MediaType;
          import okhttp3.OkHttpClient;
          import okhttp3.Request;
          import okhttp3.RequestBody;
          import okhttp3.Response;
          import okhttp3.logging.HttpLoggingInterceptor;
          import org.json.JSONObject;
          import java.util.UUID;
          import java.util.concurrent.TimeUnit;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_AUTH_TOKEN = "auth_token";
              private static final String KEY_USER_ID = "user_id";
              private static final String KEY_DEVICE_EMAIL = "device_email";
              private static final String KEY_DEVICE_NAME = "device_name";
              private static final String KEY_SESSION_TOKEN = "session_token";
              
              // Use consistent base URL for all API calls
              private static final String API_BASE_URL = "https://mile-tracker-pro.replit.app";
              private static final String LOGIN_ENDPOINT = "/api/auth/login";
              private static final String REGISTER_ENDPOINT = "/api/auth/register";
              
              private Context context;
              private SharedPreferences prefs;
              private OkHttpClient okHttpClient;
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Initialize OkHttp client with logging
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
                  logging.setLevel(HttpLoggingInterceptor.Level.BODY);
                  
                  this.okHttpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(30, TimeUnit.SECONDS)
                      .readTimeout(30, TimeUnit.SECONDS)
                      .writeTimeout(30, TimeUnit.SECONDS)
                      .build();
              }
              
              public boolean isLoggedIn() {
                  String email = prefs.getString(KEY_USER_EMAIL, "");
                  String token = prefs.getString(KEY_AUTH_TOKEN, "");
                  boolean loggedIn = !email.isEmpty() && !token.isEmpty();
                  Log.d(TAG, "isLoggedIn check - Email: '" + email + "', Token present: " + (!token.isEmpty()) + ", Result: " + loggedIn);
                  return loggedIn;
              }
              
              public String getUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }
              
              public String getAuthToken() {
                  return prefs.getString(KEY_AUTH_TOKEN, "");
              }
              
              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }
              
              public void logout() {
                  prefs.edit().clear().apply();
                  Log.d(TAG, "User logged out - SharedPreferences cleared");
              }
              
              public boolean loginWithOkHttp(String email, String password) {
                  Log.d(TAG, "ðŸ” OKHTTP login for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          loginData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + LOGIN_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      Log.d(TAG, "OKHTTP request URL: " + request.url());
                      Log.d(TAG, "OKHTTP request headers: " + request.headers());
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "OKHTTP response code: " + response.code());
                          Log.d(TAG, "OKHTTP response headers: " + response.headers());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "OKHTTP login response: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              if (responseJson.optBoolean("success", false)) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  // Multi-device family sharing - generate device info
                                  String deviceEmail = email; // Use login email as device identifier
                                  String deviceName = buildDeviceName();
                                  String sessionToken = generateSessionToken();
                                  
                                  Log.d(TAG, "Multi-device info - Email: " + deviceEmail + ", Device: " + deviceName);
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .putString(KEY_DEVICE_EMAIL, deviceEmail)
                                       .putString(KEY_DEVICE_NAME, deviceName)
                                       .putString(KEY_SESSION_TOKEN, sessionToken)
                                       .apply();
                                  
                                  Log.d(TAG, "âœ… OKHTTP login successful for: " + email);
                                  return true;
                              } else {
                                  String message = responseJson.optString("message", "Unknown error");
                                  Log.d(TAG, "âŒ OKHTTP login failed - success=false, message: " + message);
                              }
                          } else {
                              String errorBody = "";
                              try {
                                  errorBody = response.body().string();
                              } catch (Exception ex) {
                                  Log.d(TAG, "Could not read OkHttp error response: " + ex.getMessage());
                              }
                              Log.d(TAG, "âŒ OKHTTP login failed - HTTP " + response.code() + ", Error body: " + errorBody);
                          }
                      }
                      
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP login exception: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean registerWithOkHttp(String email, String password, String name) {
                  Log.d(TAG, "ðŸ“ OKHTTP registration for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("name", name);
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          registerData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + REGISTER_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "OKHTTP registration response code: " + response.code());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "OKHTTP registration response: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              if (responseJson.optBoolean("success", false)) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  JSONObject userObj = responseJson.optJSONObject("user");
                                  String userId = userObj != null ? userObj.optString("id", "") : "";
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .apply();
                                  
                                  Log.d(TAG, "âœ… OKHTTP registration successful for: " + email);
                                  return true;
                              }
                          }
                          
                          Log.d(TAG, "âŒ OKHTTP registration failed - HTTP " + response.code());
                          return false;
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP registration error: " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public String getNetworkDiagnostics() {
                  StringBuilder info = new StringBuilder();
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          info.append("Network Type: ").append(activeNetwork.getTypeName()).append("\n");
                          info.append("Connected: ").append(activeNetwork.isConnected()).append("\n");
                          info.append("Available: ").append(activeNetwork.isAvailable()).append("\n");
                          info.append("HTTP Stack: OkHttp enabled\n");
                      } else {
                          info.append("No active network");
                      }
                  } catch (Exception e) {
                      info.append("Network check failed: ").append(e.getMessage());
                  }
                  return info.toString();
              }
              
              // Multi-device family sharing helper methods
              private String buildDeviceName() {
                  String manufacturer = Build.MANUFACTURER;
                  String model = Build.MODEL;
                  if (model.startsWith(manufacturer)) {
                      return model;
                  } else {
                      return manufacturer + " " + model;
                  }
              }
              
              private String generateSessionToken() {
                  return "session_" + UUID.randomUUID().toString().replace("-", "");
              }
              
              public String getDeviceEmail() {
                  return prefs.getString(KEY_DEVICE_EMAIL, "");
              }
              
              public String getDeviceName() {
                  return prefs.getString(KEY_DEVICE_NAME, buildDeviceName());
              }
              
              public String getSessionToken() {
                  return prefs.getString(KEY_SESSION_TOKEN, "");
              }
              
              public void showDeviceManagementDialog() {
                  // TODO: Implement device management dialog for Professional tier users
                  // Shows list of active devices when limit is reached
              }
              
              // TODO: Implement methods for AuthActivity and DataRecoveryActivity compatibility
              public boolean register(String email, String password, String name) {
                  return registerWithOkHttp(email, password, name);
              }
              
              public boolean recoverDataWithCredentials(String email, String password) {
                  return loginWithOkHttp(email, password);
              }
          }
          EOF

      - name: Create AuthActivity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Intent;
          import android.os.Bundle;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import android.util.Log;
          import com.miletrackerpro.app.MainActivity;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private UserAuthManager authManager;
              private LinearLayout mainLayout;
              private boolean isLoginMode = true;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);

                  // If already logged in, go to main app
                  if (authManager.isLoggedIn()) {
                      goToMainApp();
                      return;
                  }

                  createAuthLayout();
              }

              private void createAuthLayout() {
                  ScrollView scrollView = new ScrollView(this);
                  
                  mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  showAuthForm();
                  
                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void showAuthForm() {
                  mainLayout.removeAllViews();

                  // Title
                  TextView title = new TextView(this);
                  title.setText("ðŸš— MileTracker Pro");
                  title.setTextSize(28);
                  title.setTextColor(0xFF333333);
                  title.setTypeface(null, android.graphics.Typeface.BOLD);
                  LinearLayout.LayoutParams titleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  titleParams.setMargins(0, 20, 0, 10);
                  title.setLayoutParams(titleParams);
                  title.setGravity(android.view.Gravity.CENTER);
                  mainLayout.addView(title);

                  // Subtitle
                  TextView subtitle = new TextView(this);
                  subtitle.setText("Professional Mileage Tracking");
                  subtitle.setTextSize(16);
                  subtitle.setTextColor(0xFF666666);
                  LinearLayout.LayoutParams subtitleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  subtitleParams.setMargins(0, 0, 0, 40);
                  subtitle.setLayoutParams(subtitleParams);
                  subtitle.setGravity(android.view.Gravity.CENTER);
                  mainLayout.addView(subtitle);

                  // Mode title
                  TextView modeTitle = new TextView(this);
                  modeTitle.setText(isLoginMode ? "Login to Your Account" : "Create New Account");
                  modeTitle.setTextSize(20);
                  modeTitle.setTextColor(0xFF333333);
                  modeTitle.setTypeface(null, android.graphics.Typeface.BOLD);
                  LinearLayout.LayoutParams modeTitleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  modeTitleParams.setMargins(0, 0, 0, 20);
                  modeTitle.setLayoutParams(modeTitleParams);
                  modeTitle.setGravity(android.view.Gravity.CENTER);
                  mainLayout.addView(modeTitle);

                  // Email field
                  EditText emailField = new EditText(this);
                  emailField.setHint("Email address");
                  emailField.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(20, 15, 20, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Password");
                  passwordField.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(20, 15, 20, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 15);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Name field (only for registration)
                  EditText nameField = null;
                  if (!isLoginMode) {
                      nameField = new EditText(this);
                      nameField.setHint("Full name");
                      nameField.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_PERSON_NAME);
                      nameField.setTextSize(16);
                      nameField.setPadding(20, 15, 20, 15);
                      nameField.setBackgroundColor(0xFFFFFFFF);
                      LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      nameParams.setMargins(0, 0, 0, 15);
                      nameField.setLayoutParams(nameParams);
                      mainLayout.addView(nameField);
                  }

                  // Primary action button
                  Button primaryButton = new Button(this);
                  primaryButton.setText(isLoginMode ? "Login" : "Create Account");
                  primaryButton.setBackgroundColor(0xFF667eea);
                  primaryButton.setTextColor(0xFFFFFFFF);
                  primaryButton.setTextSize(18);
                  primaryButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams primaryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  primaryParams.setMargins(0, 10, 0, 15);
                  primaryButton.setLayoutParams(primaryParams);

                  EditText finalNameField = nameField;
                  primaryButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      if (isLoginMode) {
                          handleLogin(email, password);
                      } else {
                          String name = finalNameField != null ? finalNameField.getText().toString().trim() : "";
                          if (name.isEmpty()) {
                              Toast.makeText(this, "Please enter your name", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          handleRegistration(email, password, name);
                      }
                  });
                  mainLayout.addView(primaryButton);

                  // Mode toggle button
                  Button toggleButton = new Button(this);
                  toggleButton.setText(isLoginMode ? "Need an account? Sign up" : "Already have an account? Login");
                  toggleButton.setBackgroundColor(0x00000000);
                  toggleButton.setTextColor(0xFF667eea);
                  toggleButton.setTextSize(16);
                  LinearLayout.LayoutParams toggleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  toggleParams.setMargins(0, 10, 0, 20);
                  toggleButton.setLayoutParams(toggleParams);
                  toggleButton.setOnClickListener(v -> {
                      isLoginMode = !isLoginMode;
                      showAuthForm();
                  });
                  mainLayout.addView(toggleButton);

                  // Data recovery link
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("ðŸ”„ Lost device? Recover your data");
                  recoveryButton.setBackgroundColor(0x00000000);
                  recoveryButton.setTextColor(0xFF28a745);
                  recoveryButton.setTextSize(14);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoveryParams.setMargins(0, 20, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "OkHttp login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== OKHTTP LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread using OkHttp
                  new Thread(() -> {
                      Log.d(TAG, "Starting OkHttp login thread...");
                      boolean loginResult = authManager.loginWithOkHttp(email, password);
                      Log.d(TAG, "OkHttp login result: " + loginResult);
                      
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Log.d(TAG, "SUCCESS: Login successful, going to main app");
                              Toast.makeText(this, "SUCCESS!!!!!!!!!", Toast.LENGTH_LONG).show();
                              goToMainApp();
                          } else {
                              Log.d(TAG, "FAILURE: Login failed");
                              Toast.makeText(this, "Login failed. Please check your credentials.", Toast.LENGTH_LONG).show();
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  // Show loading message
                  Toast.makeText(this, "Creating account...", Toast.LENGTH_SHORT).show();
                  
                  // Run registration in background thread using OkHttp
                  new Thread(() -> {
                      boolean registerResult = authManager.registerWithOkHttp(email, password, name);
                      
                      runOnUiThread(() -> {
                          if (registerResult) {
                              Toast.makeText(this, "Account created successfully!", Toast.LENGTH_LONG).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                          }
                      });
                  }).start();
              }

              private void goToDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create DataRecoveryActivity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Intent;
          import android.os.Bundle;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);
                  createRecoveryLayout();
              }

              private void createRecoveryLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Title
                  TextView title = new TextView(this);
                  title.setText("ðŸ”„ Data Recovery");
                  title.setTextSize(24);
                  title.setTextColor(0xFF333333);
                  title.setTypeface(null, android.graphics.Typeface.BOLD);
                  LinearLayout.LayoutParams titleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  titleParams.setMargins(0, 20, 0, 20);
                  title.setLayoutParams(titleParams);
                  title.setGravity(android.view.Gravity.CENTER);
                  mainLayout.addView(title);

                  // Instructions
                  TextView instructions = new TextView(this);
                  instructions.setText("If you lost your device or got a new phone, enter your account credentials to recover your trip data from the cloud.");
                  instructions.setTextSize(16);
                  instructions.setTextColor(0xFF666666);
                  LinearLayout.LayoutParams instructionsParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  instructionsParams.setMargins(0, 0, 0, 30);
                  instructions.setLayoutParams(instructionsParams);
                  mainLayout.addView(instructions);

                  // Email field
                  EditText emailField = new EditText(this);
                  emailField.setHint("Email address");
                  emailField.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(20, 15, 20, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Password");
                  passwordField.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(20, 15, 20, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Recover button
                  Button recoverButton = new Button(this);
                  recoverButton.setText("Recover My Data");
                  recoverButton.setBackgroundColor(0xFF28a745);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setTextSize(18);
                  recoverButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams recoverParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoverParams.setMargins(0, 10, 0, 15);
                  recoverButton.setLayoutParams(recoverParams);
                  recoverButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      handleDataRecovery(email, password);
                  });
                  mainLayout.addView(recoverButton);

                  // Back button
                  Button backButton = new Button(this);
                  backButton.setText("Back to Login");
                  backButton.setBackgroundColor(0x00000000);
                  backButton.setTextColor(0xFF667eea);
                  backButton.setTextSize(16);
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backParams.setMargins(0, 20, 0, 0);
                  backButton.setLayoutParams(backParams);
                  backButton.setOnClickListener(v -> finish());
                  mainLayout.addView(backButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void handleDataRecovery(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "Recovering data...", Toast.LENGTH_SHORT).show();
                  
                  // Run recovery in background thread
                  new Thread(() -> {
                      boolean recoveryResult = authManager.recoverDataWithCredentials(email, password);
                      
                      runOnUiThread(() -> {
                          if (recoveryResult) {
                              Toast.makeText(this, "Data recovered successfully!", Toast.LENGTH_LONG).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Recovery failed. Please check your credentials.", Toast.LENGTH_LONG).show();
                          }
                      });
                  }).start();
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create main activities and copy them to project
        run: |
          cp MainActivity.java android/app/src/main/java/com/miletrackerpro/app/MainActivity.java
          

      - name: Create BluetoothDiscoveryReceiver for device scanning
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/BluetoothDiscoveryReceiver.java << 'EOF'
          package com.miletrackerpro.app;

          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothDevice;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.util.Log;

          public class BluetoothDiscoveryReceiver extends BroadcastReceiver {
              private static final String TAG = "BluetoothDiscovery";

              @Override
              public void onReceive(Context context, Intent intent) {
                  String action = intent.getAction();
                  
                  if (BluetoothDevice.ACTION_FOUND.equals(action)) {
                      // Discovery has found a device
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      if (device != null) {
                          String deviceName = device.getName();
                          String deviceAddress = device.getAddress();
                          
                          Log.d(TAG, "Bluetooth device found: " + deviceName + " (" + deviceAddress + ")");
                          
                          // Check if this is a vehicle-related device
                          if (isVehicleDevice(deviceName)) {
                              Log.d(TAG, "Vehicle device detected: " + deviceName);
                              
                              // Broadcast to MainActivity and BluetoothVehicleService
                              Intent vehicleIntent = new Intent("com.miletrackerpro.app.VEHICLE_DETECTED");
                              vehicleIntent.putExtra("device_name", deviceName);
                              vehicleIntent.putExtra("device_address", deviceAddress);
                              context.sendBroadcast(vehicleIntent);
                          }
                      }
                  } else if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)) {
                      Log.d(TAG, "Bluetooth discovery started");
                  } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {
                      Log.d(TAG, "Bluetooth discovery finished");
                  }
              }

              private boolean isVehicleDevice(String deviceName) {
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  
                  // Exclude common non-vehicle devices first
                  if (name.contains("watch") || name.contains("buds") || name.contains("earbuds") ||
                      name.contains("headphones") || name.contains("speaker") || name.contains("mouse") ||
                      name.contains("keyboard") || name.contains("tablet") || name.contains("phone") ||
                      name.contains("galaxy") || name.contains("iphone") || name.contains("airpods") ||
                      name.contains("beats") || name.contains("jbl") || name.contains("bose")) {
                      return false;
                  }
                  
                  // Vehicle infotainment systems (like Uconnect, SYNC, Entune)
                  if (name.contains("uconnect") || name.contains("sync") || name.contains("entune") ||
                      name.contains("infotainment") || name.contains("multimedia") || name.contains("hmi") ||
                      name.contains("carplay") || name.contains("android auto")) {
                      return true;
                  }
                  
                  // Common vehicle-related terms
                  if (name.contains("car") || name.contains("vehicle") || name.contains("auto") ||
                      name.contains("truck") || name.contains("suv") || name.contains("van")) {
                      return true;
                  }
                  
                  // Vehicle brand names
                  return name.contains("honda") || name.contains("toyota") || name.contains("ford") ||
                         name.contains("chevy") || name.contains("bmw") || name.contains("audi") ||
                         name.contains("mazda") || name.contains("nissan") || name.contains("hyundai") ||
                         name.contains("kia") || name.contains("mercedes") || name.contains("lexus") ||
                         name.contains("acura") || name.contains("infiniti") || name.contains("cadillac") ||
                         name.contains("buick") || name.contains("gmc") || name.contains("jeep") ||
                         name.contains("dodge") || name.contains("chrysler") || name.contains("ram") ||
                         name.contains("lincoln") || name.contains("volvo") || name.contains("subaru") ||
                         name.contains("mitsubishi") || name.contains("jaguar") || name.contains("land rover") ||
                         name.contains("porsche") || name.contains("ferrari") || name.contains("lamborghini") ||
                         name.contains("maserati") || name.contains("bentley") || name.contains("rolls royce") ||
                         name.contains("tesla") || name.contains("prius");
              }
          }
          EOF

      - name: Copy AddressLookup and services exactly from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          Log.e(TAG, "Error getting address", e);
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder sb = new StringBuilder();
                  
                  // Street number and name
                  if (address.getSubThoroughfare() != null) {
                      sb.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      sb.append(address.getThoroughfare()).append(", ");
                  }
                  
                  // City
                  if (address.getLocality() != null) {
                      sb.append(address.getLocality()).append(", ");
                  }
                  
                  // State
                  if (address.getAdminArea() != null) {
                      sb.append(address.getAdminArea()).append(" ");
                  }
                  
                  // ZIP code
                  if (address.getPostalCode() != null) {
                      sb.append(address.getPostalCode());
                  }
                  
                  return sb.toString().trim();
              }

              public void destroy() {
                  if (executor != null) {
                      executor.shutdown();
                  }
              }
          }
          EOF

      - name: Create BluetoothVehicleService
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BluetoothVehicleService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothDevice;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.os.Handler;
          import android.os.Looper;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import java.util.HashMap;
          import java.util.Map;

          public class BluetoothVehicleService {
              private static final String TAG = "BluetoothVehicleService";
              private Context context;
              private BluetoothAdapter bluetoothAdapter;
              private Map<String, VehicleInfo> vehicleRegistry;
              private VehicleInfo currentVehicle;
              private VehicleConnectionCallback callback;
              private Handler mainHandler;
              private boolean autoDetectionEnabled = false;

              public static class VehicleInfo {
                  public String deviceName;
                  public String macAddress;
                  public String vehicleType;
                  public long registrationTime;
                  public boolean isRental;
                  public boolean isBorrowed;
                  public long expirationTime;

                  public VehicleInfo(String deviceName, String macAddress, String vehicleType) {
                      this.deviceName = deviceName;
                      this.macAddress = macAddress;
                      this.vehicleType = vehicleType;
                      this.registrationTime = System.currentTimeMillis();
                      
                      // Handle rental cars (7 days)
                      if ("Rental".equals(vehicleType)) {
                          this.isRental = true;
                          this.expirationTime = registrationTime + (7 * 24 * 60 * 60 * 1000);
                      }
                      
                      // Handle borrowed vehicles (3 days)
                      if ("Borrowed".equals(vehicleType)) {
                          this.isBorrowed = true;
                          this.expirationTime = registrationTime + (3 * 24 * 60 * 60 * 1000);
                      }
                  }
              }

              public interface VehicleConnectionCallback {
                  void onVehicleConnected(VehicleInfo vehicle);
                  void onVehicleDisconnected(VehicleInfo vehicle);
                  void onNewVehicleDetected(String deviceName, String macAddress);
              }

              public BluetoothVehicleService(Context context) {
                  this.context = context;
                  this.bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                  this.vehicleRegistry = new HashMap<>();
                  this.mainHandler = new Handler(Looper.getMainLooper());
                  
                  loadVehicleRegistry();
                  registerBluetoothReceiver();
              }

              private void loadVehicleRegistry() {
                  SharedPreferences prefs = context.getSharedPreferences("VehicleRegistry", Context.MODE_PRIVATE);
                  // Load registered vehicles from SharedPreferences
                  // Implementation for loading saved vehicles
              }

              private void registerBluetoothReceiver() {
                  IntentFilter filter = new IntentFilter();
                  filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
                  filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
                  context.registerReceiver(bluetoothReceiver, filter);
              }

              private final BroadcastReceiver bluetoothReceiver = new BroadcastReceiver() {
                  @Override
                  public void onReceive(Context context, Intent intent) {
                      String action = intent.getAction();
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      
                      if (device != null && vehicleRegistry.containsKey(device.getAddress())) {
                          VehicleInfo vehicle = vehicleRegistry.get(device.getAddress());
                          
                          if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
                              handleVehicleConnected(vehicle);
                          } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                              handleVehicleDisconnected(vehicle);
                          }
                      } else if (device != null && !vehicleRegistry.containsKey(device.getAddress())) {
                          // New vehicle detected
                          String deviceName = device.getName();
                          if (deviceName != null && callback != null) {
                              callback.onNewVehicleDetected(deviceName, device.getAddress());
                          }
                      }
                  }
              };

              private void handleVehicleConnected(VehicleInfo vehicle) {
                  currentVehicle = vehicle;
                  Log.d(TAG, "Vehicle connected: " + vehicle.deviceName);
                  
                  if (callback != null) {
                      mainHandler.post(() -> callback.onVehicleConnected(vehicle));
                  }
              }

              private void handleVehicleDisconnected(VehicleInfo vehicle) {
                  if (currentVehicle != null && currentVehicle.equals(vehicle)) {
                      currentVehicle = null;
                      Log.d(TAG, "Vehicle disconnected: " + vehicle.deviceName);
                      
                      if (callback != null) {
                          mainHandler.post(() -> callback.onVehicleDisconnected(vehicle));
                      }
                  }
              }

              public void registerVehicle(String deviceName, String macAddress, String vehicleType) {
                  VehicleInfo vehicle = new VehicleInfo(deviceName, macAddress, vehicleType);
                  vehicleRegistry.put(macAddress, vehicle);
                  Log.d(TAG, "Vehicle registered: " + deviceName);
                  
                  // Save to SharedPreferences
                  saveVehicleRegistry();
              }

              public void unregisterVehicle(String macAddress) {
                  VehicleInfo vehicle = vehicleRegistry.remove(macAddress);
                  if (vehicle != null) {
                      Log.d(TAG, "Vehicle unregistered: " + vehicle.deviceName);
                      saveVehicleRegistry();
                  }
              }

              private void saveVehicleRegistry() {
                  SharedPreferences prefs = context.getSharedPreferences("VehicleRegistry", Context.MODE_PRIVATE);
                  // Save registered vehicles to SharedPreferences
                  // Implementation for saving vehicles
              }

              public VehicleInfo getCurrentVehicle() {
                  return currentVehicle;
              }

              public void destroy() {
                  try {
                      context.unregisterReceiver(bluetoothReceiver);
                  } catch (IllegalArgumentException e) {
                      Log.w(TAG, "Bluetooth receiver already unregistered");
                  }
              }

              public void setCallbacks(VehicleConnectionCallback callback, Context context) {
                  this.callback = callback;
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  this.autoDetectionEnabled = enabled;
              }
          }
          EOF

      - name: Create CloudBackupService
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.models.Trip;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import java.util.List;
          import java.util.ArrayList;
          import okhttp3.MediaType;
          import okhttp3.OkHttpClient;
          import okhttp3.Request;
          import okhttp3.RequestBody;
          import okhttp3.Response;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mile-tracker-pro.replit.app";
              private Context context;
              private OkHttpClient okHttpClient;
              private UserAuthManager authManager;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.okHttpClient = new OkHttpClient();
                  this.authManager = new UserAuthManager(context);
              }

              public void backupTrip(Trip trip) {
                  if (!authManager.isLoggedIn()) {
                      Log.d(TAG, "User not logged in, skipping backup");
                      return;
                  }

                  new Thread(() -> {
                      try {
                          JSONObject tripJson = new JSONObject();
                          tripJson.put("startTime", trip.getStartTime());
                          tripJson.put("endTime", trip.getEndTime());
                          tripJson.put("distance", trip.getDistance());
                          tripJson.put("startAddress", trip.getStartAddress());
                          tripJson.put("endAddress", trip.getEndAddress());
                          tripJson.put("category", trip.getCategory());
                          tripJson.put("notes", trip.getNotes());

                          RequestBody body = RequestBody.create(
                              tripJson.toString(),
                              MediaType.get("application/json; charset=utf-8")
                          );

                          Request request = new Request.Builder()
                              .url(API_BASE_URL + "/api/trips")
                              .post(body)
                              .addHeader("Authorization", "Bearer " + authManager.getAuthToken())
                              .addHeader("Content-Type", "application/json")
                              .build();

                          try (Response response = okHttpClient.newCall(request).execute()) {
                              if (response.isSuccessful()) {
                                  Log.d(TAG, "Trip backed up successfully");
                              } else {
                                  Log.e(TAG, "Failed to backup trip: " + response.code());
                              }
                          }
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip", e);
                      }
                  }).start();
              }

              public void restoreTrips(RestoreCallback callback) {
                  if (!authManager.isLoggedIn()) {
                      Log.d(TAG, "User not logged in, cannot restore");
                      callback.onRestoreComplete(new ArrayList<>());
                      return;
                  }

                  new Thread(() -> {
                      try {
                          Request request = new Request.Builder()
                              .url(API_BASE_URL + "/api/trips")
                              .get()
                              .addHeader("Authorization", "Bearer " + authManager.getAuthToken())
                              .build();

                          try (Response response = okHttpClient.newCall(request).execute()) {
                              if (response.isSuccessful()) {
                                  String responseBody = response.body().string();
                                  JSONArray tripsArray = new JSONArray(responseBody);
                                  
                                  List<Trip> trips = new ArrayList<>();
                                  for (int i = 0; i < tripsArray.length(); i++) {
                                      JSONObject tripJson = tripsArray.getJSONObject(i);
                                      Trip trip = new Trip();
                                      trip.setStartTime(tripJson.optLong("startTime", 0));
                                      trip.setEndTime(tripJson.optLong("endTime", 0));
                                      trip.setDistance(tripJson.optDouble("distance", 0));
                                      trip.setStartAddress(tripJson.optString("startAddress", ""));
                                      trip.setEndAddress(tripJson.optString("endAddress", ""));
                                      trip.setCategory(tripJson.optString("category", "Business"));
                                      trip.setNotes(tripJson.optString("notes", ""));
                                      trips.add(trip);
                                  }
                                  
                                  callback.onRestoreComplete(trips);
                              } else {
                                  Log.e(TAG, "Failed to restore trips: " + response.code());
                                  callback.onRestoreComplete(new ArrayList<>());
                              }
                          }
                      } catch (Exception e) {
                          Log.e(TAG, "Error restoring trips", e);
                          callback.onRestoreComplete(new ArrayList<>());
                      }
                  }).start();
              }

              public interface RestoreCallback {
                  void onRestoreComplete(List<Trip> trips);
              }
          }
          EOF

      - name: Create AutoDetectionService
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.models.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AutoDetectionChannel";
              private static final int NOTIFICATION_ID = 1;
              private static final long MIN_TIME_BETWEEN_UPDATES = 5000; // 5 seconds
              private static final float MIN_DISTANCE_CHANGE_FOR_UPDATES = 10; // 10 meters
              private static final double SPEED_THRESHOLD = 5.0; // mph
              private static final int START_CONFIRMATIONS = 3;
              private static final int STOP_CONFIRMATIONS = 4;
              private static final long MAX_STATIONARY_TIME = 120000;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();

                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      isCurrentlyTracking = true;
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
              }

              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;
              private LocationManager locationManager;
              private Location lastLocation;
              private Trip currentTrip;
              private boolean isCurrentlyTracking = false;
              private int movingConfirmations = 0;
              private int stationaryConfirmations = 0;
              private long lastStationaryTime = 0;
              private Handler mainHandler = new Handler();

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          startAutoDetection();
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopAutoDetection();
                      }
                  }
                  return START_STICKY;
              }

              public void startAutoDetection() {
                  if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                      Log.e(TAG, "Location permission not granted");
                      return;
                  }

                  try {
                      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, MIN_TIME_BETWEEN_UPDATES, MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
                      locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, MIN_TIME_BETWEEN_UPDATES, MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
                      
                      startForeground(NOTIFICATION_ID, createNotification("Auto Detection Active", "Monitoring for trips"));
                      Log.d(TAG, "Auto detection started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              public void stopAutoDetection() {
                  try {
                      locationManager.removeUpdates(this);
                      if (isCurrentlyTracking && currentTrip != null) {
                          forceEndTrip();
                      }
                      stopForeground(true);
                      Log.d(TAG, "Auto detection stopped");
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto detection", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (location == null) return;

                  double speed = 0;
                  if (lastLocation != null) {
                      float distance = location.distanceTo(lastLocation);
                      long timeDelta = location.getTime() - lastLocation.getTime();
                      if (timeDelta > 0) {
                          speed = (distance / timeDelta) * 2.237; // Convert m/s to mph
                      }
                  }

                  processAutoDetection(speed, location.getLatitude(), location.getLongitude(), location.getTime());
                  lastLocation = location;
              }

              private void processAutoDetection(double speed, double latitude, double longitude, long timestamp) {
                  if (speed > SPEED_THRESHOLD) {
                      movingConfirmations++;
                      stationaryConfirmations = 0;
                      
                      if (!isCurrentlyTracking && movingConfirmations >= START_CONFIRMATIONS) {
                          startTrip(latitude, longitude, speed, timestamp);
                          movingConfirmations = 0;
                      }
                  } else {
                      stationaryConfirmations++;
                      movingConfirmations = 0;
                      
                      if (isCurrentlyTracking) {
                          if (lastStationaryTime == 0) {
                              lastStationaryTime = timestamp;
                          }
                          
                          if (stationaryConfirmations >= STOP_CONFIRMATIONS || 
                              (timestamp - lastStationaryTime) > MAX_STATIONARY_TIME) {
                              endTrip(latitude, longitude, timestamp);
                              stationaryConfirmations = 0;
                              lastStationaryTime = 0;
                          }
                      }
                  }
              }

              private void startTrip(double latitude, double longitude, double speed, long timestamp) {
                  currentTrip = new Trip();
                  currentTrip.setId(timestamp);
                  currentTrip.setStartTime(timestamp);
                  currentTrip.setStartLatitude(latitude);
                  currentTrip.setStartLongitude(longitude);
                  currentTrip.setDetectionMethod("Auto");
                  currentTrip.setCategory("Business");
                  isCurrentlyTracking = true;
                  
                  // Get start address
                  addressLookup.getAddressFromLocation(latitude, longitude, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          currentTrip.setStartAddress(address);
                          tripStorage.saveCurrentTrip(currentTrip);
                      }
                      
                      @Override
                      public void onAddressError(String error) {
                          currentTrip.setStartAddress("Unknown Location");
                          tripStorage.saveCurrentTrip(currentTrip);
                      }
                  });
                  
                  updateNotification("Trip Started", "Currently tracking your trip");
                  Log.d(TAG, "Trip started: " + currentTrip.getId());
              }

              private void endTrip(double latitude, double longitude, long timestamp) {
                  if (currentTrip == null) return;
                  
                  currentTrip.setEndTime(timestamp);
                  currentTrip.setEndLatitude(latitude);
                  currentTrip.setEndLongitude(longitude);
                  
                  // Calculate distance
                  double distance = calculateDistance(
                      currentTrip.getStartLatitude(), 
                      currentTrip.getStartLongitude(),
                      latitude, 
                      longitude
                  );
                  currentTrip.setDistance(distance);
                  
                  // Get end address
                  addressLookup.getAddressFromLocation(latitude, longitude, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          currentTrip.setEndAddress(address);
                          finalizeTripSave();
                      }
                      
                      @Override
                      public void onAddressError(String error) {
                          currentTrip.setEndAddress("Unknown Location");
                          finalizeTripSave();
                      }
                  });
              }

              private void finalizeTripSave() {
                  if (currentTrip != null && currentTrip.getDistance() > 0.1) {
                      tripStorage.saveTrip(currentTrip);
                      cloudBackupService.backupTrip(currentTrip);
                      
                      // Clear current trip
                      tripStorage.clearCurrentTrip();
                      currentTrip = null;
                      isCurrentlyTracking = false;
                      
                      updateNotification("Trip Completed", String.format("%.1f miles saved", currentTrip.getDistance()));
                      Log.d(TAG, "Trip completed and saved: " + currentTrip.getId());
                  }
              }

              private void forceEndTrip() {
                  if (currentTrip != null && lastLocation != null) {
                      endTrip(lastLocation.getLatitude(), lastLocation.getLongitude(), System.currentTimeMillis());
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Earth's radius in kilometers
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c; // Distance in kilometers
                  return distance * 0.621371; // Convert to miles
              }

              private void updateNotification(String title, String content) {
                  NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
                  notificationManager.notify(NOTIFICATION_ID, createNotification(title, content));
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.widget.Toast;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.models.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import com.miletrackerpro.app.services.BluetoothVehicleService;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "ManualTripChannel";
              private static final int NOTIFICATION_ID = 2;
              private static final long MIN_TIME_BETWEEN_UPDATES = 10000; // 10 seconds
              private static final float MIN_DISTANCE_CHANGE_FOR_UPDATES = 10; // 10 meters

              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;
              private LocationManager locationManager;
              private Location lastLocation;
              private Trip currentTrip;
              private boolean isCurrentlyTracking = false;
              private double totalDistance = 0;
              private BluetoothVehicleService bluetoothVehicleService;
              private boolean autoDetectionEnabled = false;
              private Handler blinkHandler;
              private Runnable speedRunnable;
              private Runnable blinkRunnable;

              @Override
              public void onCreate() {
                  super.onCreate();

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();
                  
                  // Initialize Bluetooth service
                  try {
                      bluetoothVehicleService = new BluetoothVehicleService(this);
                      bluetoothVehicleService.setCallbacks(new BluetoothVehicleService.VehicleConnectionCallback() {
                          @Override
                          public void onVehicleConnected(BluetoothVehicleService.VehicleInfo vehicle) {
                              // Send broadcast to update UI in MainActivity
                              Intent updateIntent = new Intent("com.miletrackerpro.VEHICLE_CONNECTED");
                              updateIntent.putExtra("deviceName", vehicle.deviceName);
                              updateIntent.putExtra("vehicleType", vehicle.vehicleType);
                              sendBroadcast(updateIntent);
                              
                              // Handle vehicle connection
                              if (autoDetectionEnabled && !isCurrentlyTracking) {
                                  startAutoTrip();
                              }
                          }

                          @Override
                          public void onVehicleDisconnected(BluetoothVehicleService.VehicleInfo vehicle) {
                              // Send broadcast to update UI in MainActivity
                              Intent updateIntent = new Intent("com.miletrackerpro.VEHICLE_DISCONNECTED");
                              updateIntent.putExtra("deviceName", vehicle.deviceName);
                              sendBroadcast(updateIntent);
                              
                              // Handle vehicle disconnection
                              if (isCurrentlyTracking) {
                                  endAutoTrip();
                              }
                          }

                          @Override
                          public void onNewVehicleDetected(String deviceName, String macAddress) {
                              // Send broadcast to MainActivity to show vehicle registration dialog
                              Intent newVehicleIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                              newVehicleIntent.putExtra("deviceName", deviceName);
                              newVehicleIntent.putExtra("macAddress", macAddress);
                              sendBroadcast(newVehicleIntent);
                          }
                      }, null);
                      bluetoothVehicleService.setAutoDetectionEnabled(autoDetectionEnabled);
                  } catch (Exception e) {
                      Log.e(TAG, "Error initializing bluetooth service", e);
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      } else if ("REGISTER_VEHICLE".equals(intent.getAction())) {
                          String deviceName = intent.getStringExtra("deviceName");
                          String macAddress = intent.getStringExtra("macAddress");
                          String vehicleType = intent.getStringExtra("vehicleType");
                          registerVehicle(deviceName, macAddress, vehicleType);
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setDetectionMethod("Manual");
                      currentTrip.setCategory("Business");
                      
                      locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, MIN_TIME_BETWEEN_UPDATES, MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
                      locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, MIN_TIME_BETWEEN_UPDATES, MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
                      
                      isCurrentlyTracking = true;
                      totalDistance = 0;
                      
                      startForeground(NOTIFICATION_ID, createNotification("Manual Trip Started", "Tap to view progress"));
                      Log.d(TAG, "Manual trip started: " + currentTrip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip", e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (currentTrip != null && isCurrentlyTracking) {
                          long currentTime = System.currentTimeMillis();
                          currentTrip.setEndTime(currentTime);
                          currentTrip.setDistance(totalDistance);
                          
                          if (lastLocation != null) {
                              currentTrip.setEndLatitude(lastLocation.getLatitude());
                              currentTrip.setEndLongitude(lastLocation.getLongitude());
                              
                              addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                                  @Override
                                  public void onAddressFound(String address) {
                                      currentTrip.setEndAddress(address);
                                      finalizeTripSave();
                                  }
                                  
                                  @Override
                                  public void onAddressError(String error) {
                                      currentTrip.setEndAddress("Unknown Location");
                                      finalizeTripSave();
                                  }
                              });
                          } else {
                              finalizeTripSave();
                          }
                          
                          locationManager.removeUpdates(this);
                          isCurrentlyTracking = false;
                          stopForeground(true);
                          
                          Log.d(TAG, "Manual trip stopped: " + currentTrip.getId());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip", e);
                  }
              }

              private void registerVehicle(String deviceName, String macAddress, String vehicleType) {
                  if (bluetoothVehicleService != null) {
                      bluetoothVehicleService.registerVehicle(deviceName, macAddress, vehicleType);
                      Log.d(TAG, "Vehicle registered: " + deviceName + " (" + vehicleType + ")");
                      
                      // Send confirmation broadcast
                      Intent confirmIntent = new Intent("com.miletrackerpro.VEHICLE_REGISTERED");
                      confirmIntent.putExtra("deviceName", deviceName);
                      confirmIntent.putExtra("vehicleType", vehicleType);
                      sendBroadcast(confirmIntent);
                  }
              }

              private void startAutoTrip() {
                  if (!isCurrentlyTracking) {
                      startManualTrip();
                  }
              }

              private void endAutoTrip() {
                  if (isCurrentlyTracking) {
                      stopManualTrip();
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (location == null || !isCurrentlyTracking) return;

                  if (currentTrip != null) {
                      if (currentTrip.getStartLatitude() == 0 && currentTrip.getStartLongitude() == 0) {
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());
                          
                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                                  tripStorage.saveCurrentTrip(currentTrip);
                              }
                              
                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                                  tripStorage.saveCurrentTrip(currentTrip);
                              }
                          });
                      }
                      
                      if (lastLocation != null) {
                          float distance = location.distanceTo(lastLocation);
                          totalDistance += distance * 0.000621371; // Convert meters to miles
                          
                          updateNotification("Trip in Progress", String.format("Distance: %.1f miles", totalDistance));
                      }
                  }
                  
                  lastLocation = location;
              }

              private void finalizeTripSave() {
                  if (currentTrip != null && totalDistance > 0.1) {
                      tripStorage.saveTrip(currentTrip);
                      cloudBackupService.backupTrip(currentTrip);
                      
                      tripStorage.clearCurrentTrip();
                      currentTrip = null;
                      
                      Log.d(TAG, "Manual trip completed and saved");
                  }
              }

              private void updateNotification(String title, String content) {
                  NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
                  notificationManager.notify(NOTIFICATION_ID, createNotification(title, content));
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Create Trip model
        run: |
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/models
          cat > android/app/src/main/java/com/miletrackerpro/app/models/Trip.java << 'EOF'
          package com.miletrackerpro.app.models;

          public class Trip {
              private long id;
              private long startTime;
              private long endTime;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private String startAddress;
              private String endAddress;
              private double distance;
              private String category;
              private String notes;
              private String detectionMethod;

              public Trip() {
                  this.category = "Business";
                  this.notes = "";
                  this.detectionMethod = "Manual";
              }

              // Getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getDetectionMethod() { return detectionMethod; }
              public void setDetectionMethod(String detectionMethod) { this.detectionMethod = detectionMethod; }
          }
          EOF

      - name: Create TripStorage
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import com.miletrackerpro.app.models.Trip;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import java.util.ArrayList;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerTrips";
              private static final String KEY_TRIPS = "trips";
              private static final String KEY_CURRENT_TRIP = "current_trip";
              private Context context;
              private SharedPreferences prefs;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public void saveTrip(Trip trip) {
                  try {
                      List<Trip> trips = getAllTrips();
                      trips.add(trip);
                      saveAllTrips(trips);
                      Log.d(TAG, "Trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      JSONObject tripJson = tripToJson(trip);
                      prefs.edit().putString(KEY_CURRENT_TRIP, tripJson.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String tripJson = prefs.getString(KEY_CURRENT_TRIP, null);
                      if (tripJson != null) {
                          JSONObject jsonObject = new JSONObject(tripJson);
                          return jsonToTrip(jsonObject);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                  }
                  return null;
              }

              public void clearCurrentTrip() {
                  prefs.edit().remove(KEY_CURRENT_TRIP).apply();
                  Log.d(TAG, "Current trip cleared");
              }

              public List<Trip> getAllTrips() {
                  try {
                      String tripsJson = prefs.getString(KEY_TRIPS, "[]");
                      JSONArray jsonArray = new JSONArray(tripsJson);
                      
                      List<Trip> trips = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          JSONObject tripJson = jsonArray.getJSONObject(i);
                          trips.add(jsonToTrip(tripJson));
                      }
                      
                      return trips;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                      return new ArrayList<>();
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (Trip trip : trips) {
                          jsonArray.put(tripToJson(trip));
                      }
                      
                      prefs.edit().putString(KEY_TRIPS, jsonArray.toString()).apply();
                      Log.d(TAG, "All trips saved: " + trips.size());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving all trips", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              private JSONObject tripToJson(Trip trip) throws Exception {
                  JSONObject json = new JSONObject();
                  json.put("id", trip.getId());
                  json.put("startTime", trip.getStartTime());
                  json.put("endTime", trip.getEndTime());
                  json.put("startLatitude", trip.getStartLatitude());
                  json.put("startLongitude", trip.getStartLongitude());
                  json.put("endLatitude", trip.getEndLatitude());
                  json.put("endLongitude", trip.getEndLongitude());
                  json.put("startAddress", trip.getStartAddress());
                  json.put("endAddress", trip.getEndAddress());
                  json.put("distance", trip.getDistance());
                  json.put("category", trip.getCategory());
                  json.put("notes", trip.getNotes());
                  json.put("detectionMethod", trip.getDetectionMethod());
                  return json;
              }

              private Trip jsonToTrip(JSONObject json) throws Exception {
                  Trip trip = new Trip();
                  trip.setId(json.optLong("id", 0));
                  trip.setStartTime(json.optLong("startTime", 0));
                  trip.setEndTime(json.optLong("endTime", 0));
                  trip.setStartLatitude(json.optDouble("startLatitude", 0));
                  trip.setStartLongitude(json.optDouble("startLongitude", 0));
                  trip.setEndLatitude(json.optDouble("endLatitude", 0));
                  trip.setEndLongitude(json.optDouble("endLongitude", 0));
                  trip.setStartAddress(json.optString("startAddress", ""));
                  trip.setEndAddress(json.optString("endAddress", ""));
                  trip.setDistance(json.optDouble("distance", 0));
                  trip.setCategory(json.optString("category", "Business"));
                  trip.setNotes(json.optString("notes", ""));
                  trip.setDetectionMethod(json.optString("detectionMethod", "Manual"));
                  return trip;
              }
          }
          EOF

      - name: Create Gradle wrapper
        run: |
          cat > android/gradlew << 'EOF'
          #!/usr/bin/env sh
          ./gradlew "$@"
          EOF
          chmod +x android/gradlew

      - name: Build APK
        run: |
          cd android
          ./gradlew assembleRelease

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v${{ github.event.inputs.version_code }}
          path: android/app/build/outputs/apk/release/app-release.apk
