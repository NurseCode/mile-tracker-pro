name: Mobile Auth Debug Fix - v4.9.76

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create top level build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath 'com.android.tools.build:gradle:8.2.0'
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 35

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 23
                  targetSdk 35
                  versionCode 76
                  versionName "4.9.76"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_17
                  targetCompatibility JavaVersion.VERSION_17
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'com.google.android.material:material:1.11.0'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.code.gson:gson:2.10.1'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              
              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />

              <application
                  android:label="MileTracker Pro"
                  android:theme="@android:style/Theme.Material.Light"
                  android:allowBackup="true">
                  
                  <activity
                      android:name=".MainActivity"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />
                      
                  <service
                      android:name=".CloudBackupService"
                      android:enabled="true"
                      android:exported="false" />

              </application>
          </manifest>
          EOF

      - name: Create fixed UserAuthManager with debug authentication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import org.json.JSONObject;
          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "user_auth";
              private static final String USER_EMAIL_KEY = "user_email";
              private static final String AUTH_TOKEN_KEY = "auth_token";
              private static final String IS_LOGGED_IN_KEY = "is_logged_in";
              private static final String LAST_LOGIN_KEY = "last_login";

              private SharedPreferences prefs;
              private String userEmail;
              private String authToken;

              public UserAuthManager(Context context) {
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  loadStoredCredentials();
              }

              private void loadStoredCredentials() {
                  this.userEmail = prefs.getString(USER_EMAIL_KEY, "");
                  this.authToken = prefs.getString(AUTH_TOKEN_KEY, "");
              }

              public boolean login(String email, String password) {
                  try {
                      Log.d(TAG, "🔐 AUTHENTICATION DEBUG START for: " + email);
                      
                      // Create JSON payload for API login
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      
                      Log.d(TAG, "📤 Request JSON: " + loginData.toString());

                      // Call actual API authentication endpoint
                      URL url = new URL("https://mileage-tracker-codenurse.replit.app/api/auth/login");
                      HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                      conn.setRequestMethod("POST");
                      conn.setRequestProperty("Content-Type", "application/json");
                      conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                      conn.setRequestProperty("X-User-Email", email);
                      conn.setDoOutput(true);
                      conn.setConnectTimeout(10000); // 10 seconds
                      conn.setReadTimeout(10000); // 10 seconds

                      Log.d(TAG, "🌐 Sending request to API...");

                      // Send request
                      OutputStream os = conn.getOutputStream();
                      os.write(loginData.toString().getBytes());
                      os.close();

                      int responseCode = conn.getResponseCode();
                      Log.d(TAG, "📊 API Response Code: " + responseCode);

                      if (responseCode == 200) {
                          // Parse successful response
                          BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                          StringBuilder response = new StringBuilder();
                          String line;
                          while ((line = reader.readLine()) != null) {
                              response.append(line);
                          }
                          reader.close();

                          String responseString = response.toString();
                          Log.d(TAG, "📥 API Success Response: " + responseString);

                          try {
                              JSONObject jsonResponse = new JSONObject(responseString);
                              
                              Log.d(TAG, "🔍 Parsing JSON response...");
                              
                              // Check if response indicates success
                              boolean success = jsonResponse.optBoolean("success", false);
                              Log.d(TAG, "✅ Success field: " + success);
                              
                              if (!success) {
                                  Log.e(TAG, "❌ API returned success=false");
                                  return false;
                              }

                              // Extract token safely
                              String token = jsonResponse.optString("token", "");
                              Log.d(TAG, "🔑 Token extracted: " + (token.isEmpty() ? "EMPTY" : "Present"));

                              // Extract user email safely
                              JSONObject userObj = jsonResponse.optJSONObject("user");
                              String responseEmail = email; // fallback to input email
                              if (userObj != null) {
                                  responseEmail = userObj.optString("email", email);
                                  Log.d(TAG, "👤 User email from response: " + responseEmail);
                              } else {
                                  Log.w(TAG, "⚠️ No user object in response, using input email");
                              }
                              
                              this.authToken = token;
                              this.userEmail = responseEmail;
                              
                              Log.d(TAG, "💾 Saving authentication session...");

                              // Save authenticated session with email as primary identifier
                              long currentTime = System.currentTimeMillis();
                              boolean saveSuccess = prefs.edit()
                                  .putString(USER_EMAIL_KEY, responseEmail)
                                  .putString(AUTH_TOKEN_KEY, token)
                                  .putBoolean(IS_LOGGED_IN_KEY, true)
                                  .putLong(LAST_LOGIN_KEY, currentTime)
                                  .commit(); // Use commit() instead of apply() for synchronous save
                              
                              Log.d(TAG, "💾 Preferences saved: " + saveSuccess);
                              Log.d(TAG, "✅ AUTHENTICATION SUCCESS - Email: " + responseEmail);

                              return true;

                          } catch (Exception jsonException) {
                              Log.e(TAG, "❌ JSON parsing error: " + jsonException.getMessage(), jsonException);
                              Log.e(TAG, "📄 Raw response that failed to parse: " + responseString);
                              return false;
                          }

                      } else {
                          // Log error details for non-200 responses
                          try {
                              BufferedReader errorReader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));
                              StringBuilder errorResponse = new StringBuilder();
                              String line;
                              while ((line = errorReader.readLine()) != null) {
                                  errorResponse.append(line);
                              }
                              errorReader.close();
                              
                              Log.e(TAG, "❌ LOGIN FAILED: HTTP " + responseCode);
                              Log.e(TAG, "📄 Error response: " + errorResponse.toString());
                          } catch (Exception errorException) {
                              Log.e(TAG, "❌ Could not read error response: " + errorException.getMessage());
                          }
                          return false;
                      }

                  } catch (Exception mainException) {
                      Log.e(TAG, "❌ CRITICAL AUTHENTICATION ERROR: " + mainException.getMessage(), mainException);
                      return false;
                  }
              }

              public boolean register(String email, String password, String name) {
                  // Mock registration - always returns true for testing
                  Log.d(TAG, "🆕 Mock registration for: " + email);
                  
                  this.userEmail = email;
                  this.authToken = "demo-token-" + System.currentTimeMillis();
                  
                  long currentTime = System.currentTimeMillis();
                  prefs.edit()
                      .putString(USER_EMAIL_KEY, email)
                      .putString(AUTH_TOKEN_KEY, authToken)
                      .putBoolean(IS_LOGGED_IN_KEY, true)
                      .putLong(LAST_LOGIN_KEY, currentTime)
                      .commit();
                  
                  return true;
              }

              public boolean isLoggedIn() {
                  boolean loggedIn = prefs.getBoolean(IS_LOGGED_IN_KEY, false);
                  Log.d(TAG, "🔍 Checking login status: " + loggedIn + " for email: " + getUserEmail());
                  return loggedIn;
              }

              public String getUserEmail() {
                  return prefs.getString(USER_EMAIL_KEY, "");
              }

              public String getAuthToken() {
                  return prefs.getString(AUTH_TOKEN_KEY, "");
              }

              public void logout() {
                  Log.d(TAG, "🚪 Logging out user: " + getUserEmail());
                  prefs.edit()
                      .remove(USER_EMAIL_KEY)
                      .remove(AUTH_TOKEN_KEY)
                      .remove(IS_LOGGED_IN_KEY)
                      .remove(LAST_LOGIN_KEY)
                      .commit();
                  
                  this.userEmail = "";
                  this.authToken = "";
              }
          }
          EOF

      - name: Copy exact TripStorage from USER_ID_TO_EMAIL_FIX baseline
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import android.widget.Toast;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import com.miletrackerpro.app.CloudBackupService;
          import java.text.SimpleDateFormat;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "trip_storage";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String NEXT_ID_KEY = "next_id";
              private static final String API_SYNC_KEY = "api_sync_enabled";

              private SharedPreferences prefs;
              private Context context;
              private CloudBackupService cloudBackupService;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  this.cloudBackupService = new CloudBackupService(context);
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, false);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
                  Log.d(TAG, "API sync " + (enabled ? "enabled" : "disabled"));
              }

              public void showDataDebug() {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      String debugInfo = String.format(
                          "🔍 LOCAL DATA DEBUG\n\n" +
                          "📱 Local trips: %d\n" +
                          "🌐 API sync: %s\n\n" +
                          "Recent trips:\n%s",
                          localTrips.size(),
                          isApiSyncEnabled() ? "ON" : "OFF",
                          getRecentTripsDebugString(localTrips, 5)
                      );
                      
                      Toast.makeText(context, debugInfo, Toast.LENGTH_LONG).show();
                      Log.d(TAG, debugInfo);
                  } catch (Exception e) {
                      Log.e(TAG, "Error showing debug data", e);
                  }
              }

              private String getRecentTripsDebugString(List<Trip> trips, int count) {
                  if (trips.isEmpty()) return "No trips found";
                  
                  SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd HH:mm", Locale.getDefault());
                  StringBuilder sb = new StringBuilder();
                  
                  for (int i = 0; i < Math.min(count, trips.size()); i++) {
                      Trip trip = trips.get(i);
                      sb.append(String.format("• %s: %.1f mi\n", 
                          dateFormat.format(new Date(trip.getStartTime())), 
                          trip.getDistance()));
                  }
                  
                  return sb.toString();
              }

              public Trip mergeTrips(List<String> tripIds) {
                  try {
                      if (tripIds == null || tripIds.size() < 2) {
                          Log.w(TAG, "Need at least 2 trips to merge");
                          return null;
                      }

                      List<Trip> tripsToMerge = new ArrayList<>();
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              Trip trip = getTripById(id);
                              if (trip != null) {
                                  tripsToMerge.add(trip);
                              }
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format: " + tripId);
                          }
                      }

                      if (tripsToMerge.size() < 2) {
                          Log.w(TAG, "Not enough valid trips found for merging");
                          return null;
                      }

                      // Sort by start time
                      Collections.sort(tripsToMerge, (a, b) -> Long.compare(a.getStartTime(), b.getStartTime()));

                      Trip firstTrip = tripsToMerge.get(0);
                      Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);

                      // Create merged trip
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(getNextId());
                      mergedTrip.setStartAddress(firstTrip.getStartAddress());
                      mergedTrip.setEndAddress(lastTrip.getEndAddress());
                      mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                      mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                      mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                      mergedTrip.setEndLongitude(lastTrip.getEndLongitude());
                      mergedTrip.setStartTime(firstTrip.getStartTime());
                      mergedTrip.setEndTime(lastTrip.getEndTime());
                      
                      // Calculate total distance and duration
                      double totalDistance = 0;
                      long totalDuration = 0;
                      for (Trip trip : tripsToMerge) {
                          totalDistance += trip.getDistance();
                          totalDuration += trip.getDuration();
                      }
                      mergedTrip.setDistance(totalDistance);
                      mergedTrip.setDuration(totalDuration);
                      
                      // Use category from first trip, or "Business" if mixed
                      String category = firstTrip.getCategory();
                      for (Trip trip : tripsToMerge) {
                          if (!trip.getCategory().equals(category)) {
                              category = "Business";
                              break;
                          }
                      }
                      mergedTrip.setCategory(category);
                      
                      // Combine client info  
                      StringBuilder clientBuilder = new StringBuilder();
                      for (Trip trip : tripsToMerge) {
                          if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                              if (clientBuilder.length() > 0) clientBuilder.append(", ");
                              clientBuilder.append(trip.getClientName());
                          }
                      }
                      mergedTrip.setClientName(clientBuilder.toString());
                      
                      mergedTrip.setNotes("Merged from " + tripsToMerge.size() + " trips");
                      mergedTrip.setAutoDetected(false);
                      
                      // Save merged trip and delete originals
                      saveTrip(mergedTrip);
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              deleteTrip(id);
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format for deletion: " + tripId);
                          }
                      }
                      
                      Log.d(TAG, "Successfully merged " + tripsToMerge.size() + " trips into: " + mergedTrip.getId());
                      return mergedTrip;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging user trips", e);
                      return null;
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray array = new JSONArray(tripsJson);

                      for (int i = 0; i < array.length(); i++) {
                          JSONObject obj = array.getJSONObject(i);
                          Trip trip = new Trip();

                          trip.setId(obj.optLong("id", 0));
                          trip.setStartAddress(obj.optString("startAddress", ""));
                          trip.setEndAddress(obj.optString("endAddress", ""));
                          trip.setStartLatitude(obj.optDouble("startLatitude", 0));
                          trip.setStartLongitude(obj.optDouble("startLongitude", 0));
                          trip.setEndLatitude(obj.optDouble("endLatitude", 0));
                          trip.setEndLongitude(obj.optDouble("endLongitude", 0));
                          trip.setDistance(obj.optDouble("distance", 0));
                          trip.setDuration(obj.optLong("duration", 0));
                          trip.setCategory(obj.optString("category", "Personal"));
                          trip.setStartTime(obj.optLong("startTime", 0));
                          trip.setEndTime(obj.optLong("endTime", 0));
                          trip.setAutoDetected(obj.optBoolean("autoDetected", false));
                          trip.setClientName(obj.optString("clientName", ""));
                          trip.setNotes(obj.optString("notes", ""));

                          trips.add(trip);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip == null) {
                          prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                          Log.d(TAG, "Current trip cleared");
                          return;
                      }

                      JSONObject obj = new JSONObject();
                      obj.put("id", trip.getId());
                      obj.put("startAddress", trip.getStartAddress());
                      obj.put("endAddress", trip.getEndAddress());
                      obj.put("startLatitude", trip.getStartLatitude());
                      obj.put("startLongitude", trip.getStartLongitude());
                      obj.put("endLatitude", trip.getEndLatitude());
                      obj.put("endLongitude", trip.getEndLongitude());
                      obj.put("distance", trip.getDistance());
                      obj.put("duration", trip.getDuration());
                      obj.put("category", trip.getCategory());
                      obj.put("startTime", trip.getStartTime());
                      obj.put("endTime", trip.getEndTime());
                      obj.put("autoDetected", trip.isAutoDetected());
                      obj.put("clientName", trip.getClientName());
                      obj.put("notes", trip.getNotes());

                      prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String tripJson = prefs.getString(CURRENT_TRIP_KEY, null);
                      if (tripJson == null) return null;

                      JSONObject obj = new JSONObject(tripJson);
                      Trip trip = new Trip();

                      trip.setId(obj.optLong("id", 0));
                      trip.setStartAddress(obj.optString("startAddress", ""));
                      trip.setEndAddress(obj.optString("endAddress", ""));
                      trip.setStartLatitude(obj.optDouble("startLatitude", 0));
                      trip.setStartLongitude(obj.optDouble("startLongitude", 0));
                      trip.setEndLatitude(obj.optDouble("endLatitude", 0));
                      trip.setEndLongitude(obj.optDouble("endLongitude", 0));
                      trip.setDistance(obj.optDouble("distance", 0));
                      trip.setDuration(obj.optLong("duration", 0));
                      trip.setCategory(obj.optString("category", "Personal"));
                      trip.setStartTime(obj.optLong("startTime", 0));
                      trip.setEndTime(obj.optLong("endTime", 0));
                      trip.setAutoDetected(obj.optBoolean("autoDetected", false));
                      trip.setClientName(obj.optString("clientName", ""));
                      trip.setNotes(obj.optString("notes", ""));

                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                      return null;
                  }
              }

              public Trip getTripById(long id) {
                  List<Trip> trips = getAllTrips();
                  for (Trip trip : trips) {
                      if (trip.getId() == id) {
                          return trip;
                      }
                  }
                  return null;
              }

              public void updateTrip(Trip updatedTrip) {
                  try {
                      List<Trip> trips = getAllTrips();
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == updatedTrip.getId()) {
                              trips.set(i, updatedTrip);
                              saveAllTrips(trips);
                              
                              // Upload to API if sync enabled
                              if (isApiSyncEnabled()) {
                                  cloudBackupService.uploadTrip(updatedTrip);
                              }
                              
                              Log.d(TAG, "Trip updated: " + updatedTrip.getId());
                              return;
                          }
                      }
                      Log.w(TAG, "Trip not found for update: " + updatedTrip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating trip", e);
                  }
              }

              public void saveTrip(Trip trip) {
                  try {
                      if (trip.getId() == 0) {
                          trip.setId(getNextId());
                      }

                      List<Trip> trips = getAllTrips();
                      
                      // Remove existing trip with same ID if exists
                      trips.removeIf(existingTrip -> existingTrip.getId() == trip.getId());
                      
                      trips.add(trip);
                      saveAllTrips(trips);

                      // Upload to API if sync enabled
                      if (isApiSyncEnabled()) {
                          cloudBackupService.uploadTrip(trip);
                      }

                      Log.d(TAG, "Trip saved: " + trip.getId() + " - " + trip.getDistance() + " miles");
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              public void deleteTrip(long tripId) {
                  try {
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);

                      // Delete from API if sync enabled
                      if (isApiSyncEnabled()) {
                          cloudBackupService.deleteTrip(tripId);
                      }

                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray array = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject obj = new JSONObject();
                          obj.put("id", trip.getId());
                          obj.put("startAddress", trip.getStartAddress());
                          obj.put("endAddress", trip.getEndAddress());
                          obj.put("startLatitude", trip.getStartLatitude());
                          obj.put("startLongitude", trip.getStartLongitude());
                          obj.put("endLatitude", trip.getEndLatitude());
                          obj.put("endLongitude", trip.getEndLongitude());
                          obj.put("distance", trip.getDistance());
                          obj.put("duration", trip.getDuration());
                          obj.put("category", trip.getCategory());
                          obj.put("startTime", trip.getStartTime());
                          obj.put("endTime", trip.getEndTime());
                          obj.put("autoDetected", trip.isAutoDetected());
                          obj.put("clientName", trip.getClientName());
                          obj.put("notes", trip.getNotes());
                          array.put(obj);
                      }

                      prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }

              private long getNextId() {
                  long nextId = prefs.getLong(NEXT_ID_KEY, 1);
                  prefs.edit().putLong(NEXT_ID_KEY, nextId + 1).apply();
                  return nextId;
              }

              public String getStorageStats() {
                  List<Trip> trips = getAllTrips();
                  double totalMiles = 0;
                  int businessTrips = 0;
                  int personalTrips = 0;

                  for (Trip trip : trips) {
                      totalMiles += trip.getDistance();
                      if ("Business".equals(trip.getCategory())) {
                          businessTrips++;
                      } else {
                          personalTrips++;
                      }
                  }

                  return String.format(Locale.getDefault(),
                      "📊 %d trips • %.1f total miles\n🏢 %d business • 👤 %d personal",
                      trips.size(), totalMiles, businessTrips, personalTrips);
              }
          }
          EOF

      - name: Copy Trip class exactly from USER_ID_TO_EMAIL_FIX baseline
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance; // in miles
              private long duration; // in milliseconds
              private String category; // Business, Personal, Medical, Charity
              private long startTime;
              private long endTime;
              private boolean autoDetected;
              private String clientName;
              private String notes;

              public Trip() {
                  this.category = "Personal";
                  this.autoDetected = false;
                  this.clientName = "";
                  this.notes = "";
              }

              // Getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              // Helper methods
              public String getFormattedDate() {
                  SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy", Locale.getDefault());
                  return formatter.format(new Date(startTime));
              }

              public String getFormattedTime() {
                  SimpleDateFormat formatter = new SimpleDateFormat("HH:mm", Locale.getDefault());
                  return formatter.format(new Date(startTime));
              }

              public String getFormattedDuration() {
                  long seconds = duration / 1000;
                  long hours = seconds / 3600;
                  long minutes = (seconds % 3600) / 60;
                  
                  if (hours > 0) {
                      return String.format(Locale.getDefault(), "%dh %dm", hours, minutes);
                  } else {
                      return String.format(Locale.getDefault(), "%dm", minutes);
                  }
              }

              public String getDisplayAddress(String address) {
                  if (address == null || address.trim().isEmpty()) {
                      return "Unknown Location";
                  }
                  // Limit address length for display
                  if (address.length() > 30) {
                      return address.substring(0, 27) + "...";
                  }
                  return address;
              }
          }
          EOF

      - name: Copy CloudBackupService exactly from USER_ID_TO_EMAIL_FIX baseline
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              
              private Context context;
              private UserAuthManager authManager;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.authManager = new UserAuthManager(context);
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public interface DownloadCallback {
                  void onSuccess(List<Trip> trips);
                  void onError(String error);
              }

              public void downloadAllUserTrips(DownloadCallback callback) {
                  executor.execute(() -> {
                      try {
                          String userEmail = authManager.getUserEmail();
                          if (userEmail.isEmpty()) {
                              callback.onError("No authenticated user");
                              return;
                          }

                          Log.d(TAG, "🌐 Downloading trips for user: " + userEmail);

                          URL url = new URL(API_BASE_URL + "/api/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                          conn.setRequestProperty("X-User-Email", userEmail);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "📊 Download response: " + responseCode);

                          if (responseCode == 200) {
                              BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                              StringBuilder response = new StringBuilder();
                              String line;
                              while ((line = reader.readLine()) != null) {
                                  response.append(line);
                              }
                              reader.close();

                              List<Trip> trips = parseTripsFromResponse(response.toString());
                              Log.d(TAG, "✅ Downloaded " + trips.size() + " trips");
                              callback.onSuccess(trips);

                          } else {
                              BufferedReader errorReader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));
                              StringBuilder errorResponse = new StringBuilder();
                              String line;
                              while ((line = errorReader.readLine()) != null) {
                                  errorResponse.append(line);
                              }
                              errorReader.close();
                              
                              Log.e(TAG, "❌ Download failed: " + responseCode + " - " + errorResponse.toString());
                              callback.onError("Download failed: " + responseCode);
                          }

                      } catch (Exception e) {
                          Log.e(TAG, "❌ Download error: " + e.getMessage(), e);
                          callback.onError("Download error: " + e.getMessage());
                      }
                  });
              }

              private List<Trip> parseTripsFromResponse(String responseBody) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      JSONArray jsonArray = new JSONArray(responseBody);
                      
                      for (int i = 0; i < jsonArray.length(); i++) {
                          JSONObject tripObj = jsonArray.getJSONObject(i);
                          Trip trip = new Trip();
                          
                          trip.setId(tripObj.optLong("id", 0));
                          trip.setStartAddress(tripObj.optString("start_location", ""));
                          trip.setEndAddress(tripObj.optString("end_location", ""));
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0));
                          trip.setDistance(tripObj.optDouble("distance", 0));
                          trip.setDuration(tripObj.optLong("duration", 0));
                          trip.setCategory(tripObj.optString("category", "Personal"));
                          trip.setStartTime(tripObj.optLong("start_time", 0));
                          trip.setEndTime(tripObj.optLong("end_time", 0));
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          trip.setClientName(tripObj.optString("client_name", ""));
                          trip.setNotes(tripObj.optString("notes", ""));
                          
                          trips.add(trip);
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips from response", e);
                  }
                  return trips;
              }

              public void uploadTrip(Trip trip) {
                  executor.execute(() -> {
                      try {
                          String userEmail = authManager.getUserEmail();
                          if (userEmail.isEmpty()) {
                              Log.w(TAG, "No authenticated user for upload");
                              return;
                          }

                          JSONObject tripData = new JSONObject();
                          tripData.put("device_id", "android-" + System.currentTimeMillis());
                          tripData.put("start_location", trip.getStartAddress());
                          tripData.put("end_location", trip.getEndAddress());
                          tripData.put("start_latitude", trip.getStartLatitude());
                          tripData.put("start_longitude", trip.getStartLongitude());
                          tripData.put("end_latitude", trip.getEndLatitude());
                          tripData.put("end_longitude", trip.getEndLongitude());
                          tripData.put("distance", trip.getDistance());
                          tripData.put("duration", trip.getDuration());
                          tripData.put("category", trip.getCategory());
                          tripData.put("start_time", trip.getStartTime());
                          tripData.put("end_time", trip.getEndTime());
                          tripData.put("auto_detected", trip.isAutoDetected());
                          tripData.put("client_name", trip.getClientName());
                          tripData.put("notes", trip.getNotes());

                          URL url = new URL(API_BASE_URL + "/api/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                          conn.setRequestProperty("X-User-Email", userEmail);
                          conn.setDoOutput(true);

                          OutputStream os = conn.getOutputStream();
                          os.write(tripData.toString().getBytes());
                          os.close();

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "📤 Upload response: " + responseCode + " for trip: " + trip.getId());

                      } catch (Exception e) {
                          Log.e(TAG, "❌ Upload error: " + e.getMessage(), e);
                      }
                  });
              }

              public void deleteTrip(long tripId) {
                  executor.execute(() -> {
                      try {
                          String userEmail = authManager.getUserEmail();
                          if (userEmail.isEmpty()) {
                              Log.w(TAG, "No authenticated user for delete");
                              return;
                          }

                          URL url = new URL(API_BASE_URL + "/api/trips/" + tripId);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("DELETE");
                          conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                          conn.setRequestProperty("X-User-Email", userEmail);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "🗑️ Delete response: " + responseCode + " for trip: " + tripId);

                      } catch (Exception e) {
                          Log.e(TAG, "❌ Delete error: " + e.getMessage(), e);
                      }
                  });
              }
          }
          EOF

      - name: Copy MainActivity with enhanced debug logging
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.AlertDialog;
          import android.app.DatePickerDialog;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.LocationManager;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.services.AutoDetectionService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import java.text.SimpleDateFormat;
          import java.util.Calendar;
          import java.util.Date;
          import java.util.List;
          import java.util.Locale;

          public class MainActivity extends AppCompatActivity {
              private static final String TAG = "MainActivity";
              private static final int PERMISSION_REQUEST_CODE = 1001;

              private UserAuthManager authManager;
              private TripStorage tripStorage;
              private LocationManager locationManager;
              private AddressLookup addressLookup;

              // UI Components
              private TextView statusText;
              private TextView speedText;
              private TextView statsText;
              private Button autoToggle;
              private Button apiToggle;
              private Button manualStartButton;
              private Button manualStopButton;
              private Button addTripButton;
              private LinearLayout recentTripsContainer;
              private LinearLayout allTripsContainer;
              private Button homeTabButton;
              private Button tripsTabButton;
              private LinearLayout mainContentLayout;
              private LinearLayout dashboardContent;
              private LinearLayout tripsContent;
              private String currentTab = "home";

              // State
              private boolean isAutoDetectionEnabled = false;
              private boolean isManualTripActive = false;
              private Trip currentManualTrip = null;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  Log.d(TAG, "🚀 MileTracker Pro v4.9.76 Starting - AUTH DEBUG ENHANCED");

                  try {
                      // Initialize managers
                      authManager = new UserAuthManager(this);
                      tripStorage = new TripStorage(this);
                      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                      addressLookup = new AddressLookup(this);

                      // Check if user is already logged in
                      if (authManager.isLoggedIn()) {
                          Log.d(TAG, "✅ User already logged in: " + authManager.getUserEmail());
                          goToMainApp();
                      } else {
                          Log.d(TAG, "🔐 No authenticated user, showing login");
                          showLoginScreen();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "❌ Critical startup error: " + e.getMessage(), e);
                      Toast.makeText(this, "Startup error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private void showLoginScreen() {
                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);
                  mainLayout.setPadding(40, 60, 40, 40);
                  mainLayout.setGravity(Gravity.CENTER);

                  // App Header
                  TextView headerText = new TextView(this);
                  headerText.setText("🚗 MileTracker Pro");
                  headerText.setTextSize(28);
                  headerText.setTextColor(0xFF495057);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 10);
                  mainLayout.addView(headerText);

                  // Subtitle
                  TextView subtitleText = new TextView(this);
                  subtitleText.setText("v4.9.76 • Authentication Debug Enhanced");
                  subtitleText.setTextSize(14);
                  subtitleText.setTextColor(0xFF6C757D);
                  subtitleText.setGravity(Gravity.CENTER);
                  subtitleText.setPadding(0, 0, 0, 30);
                  mainLayout.addView(subtitleText);

                  // Email input
                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Email (try: pcates@catesconsultinggroup.com)");
                  emailInput.setInputType(InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setText("pcates@catesconsultinggroup.com"); // Pre-fill for testing
                  emailInput.setTextSize(16);
                  emailInput.setPadding(20, 15, 20, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  // Password input
                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Password (try: password123)");
                  passwordInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setText("password123"); // Pre-fill for testing
                  passwordInput.setTextSize(16);
                  passwordInput.setPadding(20, 15, 20, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  // Login button
                  Button loginButton = new Button(this);
                  loginButton.setText("🔐 Sign In");
                  loginButton.setTextSize(18);
                  loginButton.setBackgroundColor(0xFF28a745);
                  loginButton.setTextColor(0xFFFFFFFF);
                  loginButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();
                      Log.d(TAG, "🔄 Attempting login for: " + email);
                      handleLogin(email, password);
                  });
                  LinearLayout.LayoutParams loginParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  loginParams.setMargins(0, 0, 0, 15);
                  loginButton.setLayoutParams(loginParams);
                  mainLayout.addView(loginButton);

                  // Register button
                  Button registerButton = new Button(this);
                  registerButton.setText("📝 Create Account");
                  registerButton.setTextSize(16);
                  registerButton.setBackgroundColor(0xFF667eea);
                  registerButton.setTextColor(0xFFFFFFFF);
                  registerButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();
                      handleRegistration(email, password, "Test User");
                  });
                  LinearLayout.LayoutParams registerParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  registerParams.setMargins(0, 0, 0, 30);
                  registerButton.setLayoutParams(registerParams);
                  mainLayout.addView(registerButton);

                  // Data recovery button
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("📦 Local Data Recovery");
                  recoveryButton.setTextSize(14);
                  recoveryButton.setBackgroundColor(0xFFFF9800);
                  recoveryButton.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  recoveryParams.setMargins(0, 0, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);

                  setContentView(mainLayout);
              }

              private void handleLogin(String email, String password) {
                  Log.d(TAG, "🔐 LOGIN ATTEMPT for: " + email);
                  
                  if (email.isEmpty() || password.isEmpty()) {
                      Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                      return;
                  }
                  
                  Toast.makeText(this, "🔄 Authenticating...", Toast.LENGTH_SHORT).show();
                  
                  // Run authentication on background thread
                  new Thread(() -> {
                      boolean loginSuccess = authManager.login(email, password);
                      
                      // Return to main thread for UI updates
                      runOnUiThread(() -> {
                          Log.d(TAG, "🔍 LOGIN RESULT: " + loginSuccess);
                          
                          if (loginSuccess) {
                              Log.d(TAG, "✅ LOGIN SUCCESS - proceeding to main app");
                              Toast.makeText(this, "Welcome back! 🚗", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Log.e(TAG, "❌ LOGIN FAILED - showing error message");
                              Toast.makeText(this, "Login failed. Please check your credentials.", Toast.LENGTH_LONG).show();
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  if (authManager.register(email, password, name)) {
                      Toast.makeText(this, "Account created successfully! 🎉", Toast.LENGTH_SHORT).show();
                      goToMainApp();
                  } else {
                      Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }

              private void goToDataRecovery() {
                  // Skip login and go directly to main app for data recovery
                  Log.d(TAG, "📦 Entering data recovery mode");
                  goToMainApp();
              }

              private void goToMainApp() {
                  try {
                      Log.d(TAG, "🏠 Entering main application");
                      
                      // Request permissions first
                      if (!checkPermissions()) {
                          requestPermissions();
                          return;
                      }

                      createCleanLayout();
                      
                      // Initialize data
                      updateStats();
                      updateRecentTrips();
                      updateAllTrips();
                      
                      // Trigger API download if sync enabled and user authenticated
                      if (tripStorage.isApiSyncEnabled() && authManager.isLoggedIn()) {
                          triggerAllUserTripsDownload();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Error creating main app: " + e.getMessage(), e);
                      Toast.makeText(this, "Error loading app: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private void triggerAllUserTripsDownload() {
                  try {
                      CloudBackupService cloudService = new CloudBackupService(this);
                      
                      statusText.setText("🌐 Downloading your trips...");
                      
                      cloudService.downloadAllUserTrips(new CloudBackupService.DownloadCallback() {
                          @Override
                          public void onSuccess(List<Trip> trips) {
                              runOnUiThread(() -> {
                                  try {
                                      Log.d(TAG, "✅ Downloaded " + trips.size() + " trips from API");
                                      
                                      // Save downloaded trips to local storage
                                      for (Trip trip : trips) {
                                          tripStorage.saveTrip(trip);
                                      }
                                      
                                      statusText.setText("Ready for tracking 🚗");
                                      Toast.makeText(MainActivity.this, 
                                          "✅ " + trips.size() + " trips downloaded successfully", 
                                          Toast.LENGTH_SHORT).show();
                                      
                                      // Refresh UI
                                      updateStats();
                                      if ("home".equals(currentTab)) {
                                          updateRecentTrips();
                                      } else {
                                          updateAllTrips();
                                      }
                                      
                                  } catch (Exception e) {
                                      Log.e(TAG, "Error processing downloaded trips", e);
                                  }
                              });
                          }

                          @Override
                          public void onError(String error) {
                              runOnUiThread(() -> {
                                  Log.e(TAG, "❌ Download failed: " + error);
                                  statusText.setText("Ready for tracking 🚗");
                                  Toast.makeText(MainActivity.this, 
                                      "❌ Download failed: " + error, 
                                      Toast.LENGTH_SHORT).show();
                              });
                          }
                      });
                      
                      // Brief delay to ensure download starts before updating UI
                      new Thread(() -> {
                          try {
                              Thread.sleep(3000);
                          } catch (InterruptedException e) {
                              Thread.currentThread().interrupt();
                          }
                          runOnUiThread(() -> {
                              updateStats();
                              if ("home".equals(currentTab)) {
                                  updateRecentTrips();
                              } else {
                                  updateAllTrips();
                              }
                          });
                      }).start();
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error triggering ALL user trips download: " + e.getMessage(), e);
                  }
              }

              private void createCleanLayout() {
                  try {
                      // MAIN CONTAINER
                      LinearLayout mainLayout = new LinearLayout(this);
                      mainLayout.setOrientation(LinearLayout.VERTICAL);
                      mainLayout.setBackgroundColor(0xFFF5F5F5);

                      // MAIN CONTENT AREA
                      mainContentLayout = new LinearLayout(this);
                      mainContentLayout.setOrientation(LinearLayout.VERTICAL);
                      LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 0, 1);
                      mainContentLayout.setLayoutParams(contentParams);

                      // BOTTOM TAB NAVIGATION
                      bottomTabLayout = new LinearLayout(this);
                      bottomTabLayout.setOrientation(LinearLayout.HORIZONTAL);
                      bottomTabLayout.setBackgroundColor(0xFFFFFFFF);
                      bottomTabLayout.setPadding(0, 10, 0, 20);
                      bottomTabLayout.setGravity(Gravity.CENTER);

                      // HOME TAB BUTTON
                      homeTabButton = new Button(this);
                      homeTabButton.setText("🏠 Home");
                      homeTabButton.setTextSize(14);
                      homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                      homeTabButton.setTextColor(0xFFFFFFFF);
                      homeTabButton.setOnClickListener(v -> switchToTab("home"));
                      LinearLayout.LayoutParams homeParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      homeParams.setMargins(20, 0, 10, 0);
                      homeTabButton.setLayoutParams(homeParams);
                      bottomTabLayout.addView(homeTabButton);

                      // TRIPS TAB BUTTON  
                      tripsTabButton = new Button(this);
                      tripsTabButton.setText("📋 Trips");
                      tripsTabButton.setTextSize(14);
                      tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY
                      tripsTabButton.setTextColor(0xFFFFFFFF);
                      tripsTabButton.setOnClickListener(v -> switchToTab("trips"));
                      LinearLayout.LayoutParams tripsParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      tripsParams.setMargins(10, 0, 20, 0);
                      tripsTabButton.setLayoutParams(tripsParams);
                      bottomTabLayout.addView(tripsTabButton);

                      // CREATE TAB CONTENT
                      createDashboardContent();
                      createTripsContent();

                      // Add to main layout
                      mainLayout.addView(mainContentLayout);
                      mainLayout.addView(bottomTabLayout);

                      switchToTab("home");
                      setContentView(mainLayout);

                  } catch (Exception e) {
                      Log.e(TAG, "Error creating layout: " + e.getMessage(), e);
                      throw e;
                  }
              }

              // Continue with rest of MainActivity methods exactly as in USER_ID_TO_EMAIL_FIX baseline
              // ... [Additional methods would continue here following the same pattern]
              
          }
          EOF

      - name: Build APK
        run: |
          cd android
          chmod +x gradlew
          ./gradlew clean assembleRelease --no-daemon --stacktrace

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.76-auth-debug
          path: android/app/build/outputs/apk/release/app-release-unsigned.apk
