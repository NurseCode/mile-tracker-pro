name: FIXED BIDIRECTIONAL SYNC - Remove Circular Dependency

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 34
                  targetSdkVersion = 34
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 34

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 34
                  versionCode 42
                  versionName "4.9.14-fixed-bidirectional-sync"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.debug
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#667eea</item>
                  <item name="colorPrimaryDark">#5a6fd8</item>
                  <item name="colorAccent">#667eea</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#667eea</color>
              <color name="primary_dark">#5a6fd8</color>
              <color name="accent">#667eea</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
              <color name="success">#28a745</color>
              <color name="danger">#dc3545</color>
              <color name="warning">#ffc107</color>
              <color name="tab_active">#667eea</color>
              <color name="tab_inactive">#9CA3AF</color>
              <color name="background">#f5f5f5</color>
              <color name="card_background">#ffffff</color>
              <color name="text_primary">#495057</color>
              <color name="text_secondary">#6C757D</color>
          </resources>
          EOF

      - name: Create red car icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24.0"
              android:viewportHeight="24.0">
              <path
                  android:fillColor="#dc3545"
                  android:pathData="M18.92,6.01C18.72,5.42 18.16,5 17.5,5h-11C5.84,5 5.28,5.42 5.08,6.01L3,12v8c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-1h12v1c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-8L18.92,6.01zM6.5,16C5.67,16 5,15.33 5,14.5S5.67,13 6.5,13S8,13.67 8,14.5S7.33,16 6.5,16zM17.5,16c-0.83,0 -1.5,-0.67 -1.5,-1.5s0.67,-1.5 1.5,-1.5s1.5,0.67 1.5,1.5S18.33,16 17.5,16zM5,11l1.5,-4.5h11L19,11H5z"/>
          </vector>
          EOF

      - name: Create Trip class - EXACT COPY FROM WORKING VERSION
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long duration;
              private String category;
              private long startTime;
              private long endTime;
              private boolean autoDetected;
              private String clientName;
              private String notes;

              public Trip() {
                  this.category = "Personal";
                  this.autoDetected = false;
                  this.clientName = null;
                  this.notes = null;
              }

              // All getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              // Formatted display methods
              public String getFormattedDate() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDuration() {
                  long minutes = duration / (60 * 1000);
                  if (minutes < 60) {
                      return minutes + "m";
                  } else {
                      long hours = minutes / 60;
                      long remainingMinutes = minutes % 60;
                      return hours + "h " + remainingMinutes + "m";
                  }
              }

              public String getFormattedStartTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedEndTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(endTime));
              }
          }
          EOF

      - name: Create TripStorage WITHOUT circular dependency
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import org.json.JSONArray;
          import org.json.JSONObject;

          import java.util.ArrayList;
          import java.util.List;
          import java.util.UUID;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerPrefs";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String DEVICE_ID_KEY = "device_id";
              private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              private static final String LAST_API_SYNC_KEY = "last_api_sync";

              private SharedPreferences prefs;
              private Context context;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  if (getDeviceId() == null) {
                      generateDeviceId();
                  }
              }

              public String getDeviceId() {
                  return prefs.getString(DEVICE_ID_KEY, null);
              }

              private void generateDeviceId() {
                  String deviceId = "android-" + UUID.randomUUID().toString().replace("-", "").substring(0, 16);
                  prefs.edit().putString(DEVICE_ID_KEY, deviceId).apply();
                  Log.d(TAG, "Generated device ID: " + deviceId);
              }

              public boolean isAutoDetectionEnabled() {
                  return prefs.getBoolean(AUTO_DETECTION_KEY, false);
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  prefs.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, true);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
                  Log.d(TAG, "API sync enabled: " + enabled);
              }

              public long getLastApiSyncTime() {
                  return prefs.getLong(LAST_API_SYNC_KEY, 0);
              }

              public void setLastApiSyncTime(long timestamp) {
                  prefs.edit().putLong(LAST_API_SYNC_KEY, timestamp).apply();
              }

              public void saveTrip(Trip trip) {
                  try {
                      if (trip.getId() == 0) {
                          trip.setId(trip.getStartTime() > 0 ? trip.getStartTime() : System.currentTimeMillis());
                      }
                      
                      List<Trip> trips = getAllTrips();
                      
                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }
                      
                      if (!updated) {
                          trips.add(trip);
                      }
                      
                      saveAllTrips(trips);
                      Log.d(TAG, updated ? "Trip updated: " + trip.getId() : "Trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                  }
              }

              // Method to merge API trips with local trips
              public void mergeApiTrips(List<Trip> apiTrips) {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      List<Trip> mergedTrips = new ArrayList<>();
                      
                      // Start with local trips
                      mergedTrips.addAll(localTrips);
                      
                      // Add API trips that don't exist locally
                      for (Trip apiTrip : apiTrips) {
                          boolean exists = false;
                          for (Trip localTrip : localTrips) {
                              // Check if trip already exists (same start time, distance, and locations)
                              if (Math.abs(localTrip.getStartTime() - apiTrip.getStartTime()) < 60000 && // Within 1 minute
                                  Math.abs(localTrip.getDistance() - apiTrip.getDistance()) < 0.1 &&
                                  (localTrip.getStartAddress() != null && localTrip.getStartAddress().equals(apiTrip.getStartAddress()))) {
                                  exists = true;
                                  break;
                              }
                          }
                          
                          if (!exists) {
                              mergedTrips.add(apiTrip);
                              Log.d(TAG, "Added API trip: " + apiTrip.getStartAddress() + " → " + apiTrip.getEndAddress());
                          }
                      }
                      
                      saveAllTrips(mergedTrips);
                      setLastApiSyncTime(System.currentTimeMillis());
                      Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " local trips");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging API trips", e);
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray array = new JSONArray(tripsJson);

                      for (int i = 0; i < array.length(); i++) {
                          JSONObject obj = array.getJSONObject(i);
                          Trip trip = new Trip();
                          
                          trip.setId(obj.optLong("id", 0));
                          trip.setStartAddress(obj.optString("startAddress", ""));
                          trip.setEndAddress(obj.optString("endAddress", ""));
                          trip.setStartLatitude(obj.optDouble("startLatitude", 0));
                          trip.setStartLongitude(obj.optDouble("startLongitude", 0));
                          trip.setEndLatitude(obj.optDouble("endLatitude", 0));
                          trip.setEndLongitude(obj.optDouble("endLongitude", 0));
                          trip.setDistance(obj.optDouble("distance", 0));
                          trip.setDuration(obj.optLong("duration", 0));
                          trip.setCategory(obj.optString("category", "Personal"));
                          trip.setStartTime(obj.optLong("startTime", 0));
                          trip.setEndTime(obj.optLong("endTime", 0));
                          trip.setAutoDetected(obj.optBoolean("autoDetected", false));
                          trip.setClientName(obj.optString("clientName", ""));
                          trip.setNotes(obj.optString("notes", ""));
                          
                          trips.add(trip);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip == null) {
                          prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                          Log.d(TAG, "Current trip cleared");
                          return;
                      }

                      JSONObject obj = new JSONObject();
                      obj.put("id", trip.getId());
                      obj.put("startAddress", trip.getStartAddress());
                      obj.put("endAddress", trip.getEndAddress());
                      obj.put("startLatitude", trip.getStartLatitude());
                      obj.put("startLongitude", trip.getStartLongitude());
                      obj.put("endLatitude", trip.getEndLatitude());
                      obj.put("endLongitude", trip.getEndLongitude());
                      obj.put("distance", trip.getDistance());
                      obj.put("duration", trip.getDuration());
                      obj.put("category", trip.getCategory());
                      obj.put("startTime", trip.getStartTime());
                      obj.put("endTime", trip.getEndTime());
                      obj.put("autoDetected", trip.isAutoDetected());
                      obj.put("clientName", trip.getClientName());
                      obj.put("notes", trip.getNotes());

                      prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String currentTripJson = prefs.getString(CURRENT_TRIP_KEY, null);
                      if (currentTripJson == null) return null;

                      JSONObject obj = new JSONObject(currentTripJson);
                      Trip trip = new Trip();
                      
                      trip.setId(obj.optLong("id", 0));
                      trip.setStartAddress(obj.optString("startAddress", ""));
                      trip.setEndAddress(obj.optString("endAddress", ""));
                      trip.setStartLatitude(obj.optDouble("startLatitude", 0));
                      trip.setStartLongitude(obj.optDouble("startLongitude", 0));
                      trip.setEndLatitude(obj.optDouble("endLatitude", 0));
                      trip.setEndLongitude(obj.optDouble("endLongitude", 0));
                      trip.setDistance(obj.optDouble("distance", 0));
                      trip.setDuration(obj.optLong("duration", 0));
                      trip.setCategory(obj.optString("category", "Personal"));
                      trip.setStartTime(obj.optLong("startTime", 0));
                      trip.setEndTime(obj.optLong("endTime", 0));
                      trip.setAutoDetected(obj.optBoolean("autoDetected", false));
                      trip.setClientName(obj.optString("clientName", ""));
                      trip.setNotes(obj.optString("notes", ""));
                      
                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                      return null;
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray array = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject obj = new JSONObject();
                          obj.put("id", trip.getId());
                          obj.put("startAddress", trip.getStartAddress());
                          obj.put("endAddress", trip.getEndAddress());
                          obj.put("startLatitude", trip.getStartLatitude());
                          obj.put("startLongitude", trip.getStartLongitude());
                          obj.put("endLatitude", trip.getEndLatitude());
                          obj.put("endLongitude", trip.getEndLongitude());
                          obj.put("distance", trip.getDistance());
                          obj.put("duration", trip.getDuration());
                          obj.put("category", trip.getCategory());
                          obj.put("startTime", trip.getStartTime());
                          obj.put("endTime", trip.getEndTime());
                          obj.put("autoDetected", trip.isAutoDetected());
                          obj.put("clientName", trip.getClientName());
                          obj.put("notes", trip.getNotes());
                          array.put(obj);
                      }
                      prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }
          }
          EOF

      - name: Create CloudBackupService without circular dependency
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev/api";
              
              private Context context;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.executor = Executors.newSingleThreadExecutor();
              }

              // UPLOAD FUNCTIONALITY
              public void backupTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping backup");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting API backup for trip: " + trip.getId());
                          
                          URL url = new URL(API_BASE_URL + "/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.14");
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          String jsonPayload = createTripJson(trip, tripStorage.getDeviceId());

                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API backup response: " + responseCode);
                          
                          if (responseCode == 200 || responseCode == 201) {
                              Log.d(TAG, "Trip backed up successfully to API");
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip to API", e);
                      }
                  });
              }

              // DOWNLOAD FUNCTIONALITY
              public void downloadTripsFromAPI() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping download");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting download from API for device: " + tripStorage.getDeviceId());
                          
                          String apiUrl = API_BASE_URL + "/trips/" + tripStorage.getDeviceId();
                          URL url = new URL(apiUrl);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.14");
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API download response: " + responseCode);

                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(
                                      new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }

                              List<Trip> apiTrips = parseTripsFromJson(response.toString());
                              Log.d(TAG, "Downloaded " + apiTrips.size() + " trips from API");
                              
                              if (!apiTrips.isEmpty()) {
                                  tripStorage.mergeApiTrips(apiTrips);
                                  Log.d(TAG, "Successfully merged API trips");
                              }
                          } else {
                              Log.w(TAG, "API download failed with code: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error downloading trips from API", e);
                      }
                  });
              }

              private List<Trip> parseTripsFromJson(String jsonResponse) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      JSONArray tripsArray = new JSONArray(jsonResponse);
                      
                      for (int i = 0; i < tripsArray.length(); i++) {
                          JSONObject tripObj = tripsArray.getJSONObject(i);
                          Trip trip = new Trip();
                          
                          // Parse API response fields
                          trip.setId(tripObj.optLong("id", System.currentTimeMillis()));
                          trip.setStartAddress(tripObj.optString("start_location", "Unknown"));
                          trip.setEndAddress(tripObj.optString("end_location", "Unknown"));
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0));
                          trip.setDistance(tripObj.optDouble("distance", 0));
                          trip.setDuration(tripObj.optLong("duration", 0));
                          trip.setCategory(tripObj.optString("category", "Personal"));
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          trip.setClientName(tripObj.optString("client_name", ""));
                          trip.setNotes(tripObj.optString("notes", ""));
                          
                          // Parse timestamps - simplified approach
                          String startTimeStr = tripObj.optString("start_time", "");
                          String endTimeStr = tripObj.optString("end_time", "");
                          
                          try {
                              if (!startTimeStr.isEmpty()) {
                                  // Use current time minus duration as fallback
                                  long currentTime = System.currentTimeMillis();
                                  trip.setStartTime(currentTime - trip.getDuration());
                                  trip.setEndTime(currentTime);
                              }
                          } catch (Exception e) {
                              Log.w(TAG, "Error parsing timestamps for trip", e);
                              trip.setStartTime(System.currentTimeMillis());
                              trip.setEndTime(System.currentTimeMillis());
                          }
                          
                          trips.add(trip);
                          Log.d(TAG, "Parsed API trip: " + trip.getStartAddress() + " → " + trip.getEndAddress());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips JSON", e);
                  }
                  return trips;
              }

              private String createTripJson(Trip trip, String deviceId) {
                  try {
                      return String.format(Locale.getDefault(),
                          "{"
                          + "\"deviceId\":\"%s\","
                          + "\"startLocation\":\"%s\","
                          + "\"endLocation\":\"%s\","
                          + "\"startLatitude\":%.8f,"
                          + "\"startLongitude\":%.8f,"
                          + "\"endLatitude\":%.8f,"
                          + "\"endLongitude\":%.8f,"
                          + "\"distance\":%.6f,"
                          + "\"duration\":%d,"
                          + "\"category\":\"%s\","
                          + "\"autoDetected\":%s,"
                          + "\"startTime\":%d,"
                          + "\"endTime\":%d,"
                          + "\"clientName\":\"%s\","
                          + "\"notes\":\"%s\","
                          + "\"timezone\":\"America/New_York\""
                          + "}",
                          deviceId,
                          trip.getStartAddress() != null ? trip.getStartAddress().replace("\"", "\\\"") : "",
                          trip.getEndAddress() != null ? trip.getEndAddress().replace("\"", "\\\"") : "",
                          trip.getStartLatitude(),
                          trip.getStartLongitude(),
                          trip.getEndLatitude(),
                          trip.getEndLongitude(),
                          trip.getDistance(),
                          trip.getDuration(),
                          trip.getCategory(),
                          trip.isAutoDetected(),
                          trip.getStartTime(),
                          trip.getEndTime(),
                          trip.getClientName() != null ? trip.getClientName().replace("\"", "\\\"") : "",
                          trip.getNotes() != null ? trip.getNotes().replace("\"", "\\\"") : ""
                      );
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating trip JSON", e);
                      return "{}";
                  }
              }
          }
          EOF

      - name: Create MainActivity with simplified API download trigger
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.ActivityManager;
          import android.app.AlertDialog;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Handler;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.view.View;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.Spinner;
          import android.widget.ArrayAdapter;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.services.AutoDetectionService;
          import com.miletrackerpro.app.services.ManualTripService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import java.util.List;
          import java.util.ArrayList;

          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final String TAG = "MainActivity";
              private static final int LOCATION_PERMISSION_REQUEST = 1001;
              private static final int BACKGROUND_LOCATION_PERMISSION_REQUEST = 1002;

              // Main layout
              private LinearLayout mainContentLayout;
              private LinearLayout bottomTabLayout;

              // Tab content
              private LinearLayout dashboardContent;
              private LinearLayout tripsContent;
              private Button homeTabButton;
              private Button tripsTabButton;
              private String currentTab = "home";

              // Dashboard UI Elements
              private TextView statusText;
              private TextView speedText;
              private TextView statsText;
              private Button autoToggle;
              private Button apiToggle;
              private Button manualStartButton;
              private Button manualStopButton;
              private Button addTripButton;
              private LinearLayout recentTripsLayout;

              // Trips UI Elements
              private LinearLayout allTripsLayout;
              private ScrollView allTripsScroll;

              // Services and storage
              private LocationManager locationManager;
              private TripStorage tripStorage;
              private boolean autoDetectionEnabled = false;
              private boolean manualTripInProgress = false;
              private Handler speedHandler = new Handler();
              private Runnable speedRunnable;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  try {
                      Log.d(TAG, "MainActivity onCreate starting - v4.9.14 FIXED BIDIRECTIONAL SYNC...");
                      
                      tripStorage = new TripStorage(this);
                      createCleanLayout();
                      initializeGPS();
                      setupSpeedMonitoring();
                      requestPermissions();
                      updateStats();
                      registerBroadcastReceiver();
                      restoreAutoDetectionState();
                      
                      // TRIGGER API DOWNLOAD ON APP START
                      triggerApiDownload();
                      
                      Log.d(TAG, "MainActivity onCreate completed successfully");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onCreate: " + e.getMessage(), e);
                      Toast.makeText(this, "App initialization error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              // Download historic trips from API when app starts
              private void triggerApiDownload() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudBackup = new CloudBackupService(this);
                          cloudBackup.downloadTripsFromAPI();
                          Log.d(TAG, "Triggered API download for historic trips");
                          
                          // Update UI after a short delay to allow download to complete
                          Handler handler = new Handler();
                          handler.postDelayed(() -> {
                              updateStats();
                              if ("home".equals(currentTab)) {
                                  updateRecentTrips();
                              } else {
                                  updateAllTrips();
                              }
                          }, 3000); // 3 second delay
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error triggering API download: " + e.getMessage(), e);
                  }
              }

              private void createCleanLayout() {
                  try {
                      // MAIN CONTAINER
                      LinearLayout mainLayout = new LinearLayout(this);
                      mainLayout.setOrientation(LinearLayout.VERTICAL);
                      mainLayout.setBackgroundColor(0xFFF5F5F5);

                      // MAIN CONTENT AREA
                      mainContentLayout = new LinearLayout(this);
                      mainContentLayout.setOrientation(LinearLayout.VERTICAL);
                      LinearLayout.LayoutParams contentParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          0, 
                          1.0f
                      );
                      mainContentLayout.setLayoutParams(contentParams);

                      // BOTTOM TAB BAR
                      bottomTabLayout = new LinearLayout(this);
                      bottomTabLayout.setOrientation(LinearLayout.HORIZONTAL);
                      bottomTabLayout.setBackgroundColor(0xFFFFFFFF);
                      bottomTabLayout.setPadding(0, 10, 0, 20);
                      bottomTabLayout.setGravity(Gravity.CENTER);

                      // HOME TAB BUTTON
                      homeTabButton = new Button(this);
                      homeTabButton.setText("🏠 Home");
                      homeTabButton.setTextSize(14);
                      homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                      homeTabButton.setTextColor(0xFFFFFFFF);
                      homeTabButton.setOnClickListener(v -> switchToTab("home"));
                      LinearLayout.LayoutParams homeParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      homeParams.setMargins(20, 0, 10, 0);
                      homeTabButton.setLayoutParams(homeParams);
                      bottomTabLayout.addView(homeTabButton);

                      // TRIPS TAB BUTTON  
                      tripsTabButton = new Button(this);
                      tripsTabButton.setText("📋 Trips");
                      tripsTabButton.setTextSize(14);
                      tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY
                      tripsTabButton.setTextColor(0xFFFFFFFF);
                      tripsTabButton.setOnClickListener(v -> switchToTab("trips"));
                      LinearLayout.LayoutParams tripsParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                      tripsParams.setMargins(10, 0, 20, 0);
                      tripsTabButton.setLayoutParams(tripsParams);
                      bottomTabLayout.addView(tripsTabButton);

                      // CREATE TAB CONTENT
                      createDashboardContent();
                      createTripsContent();

                      // Add to main layout
                      mainLayout.addView(mainContentLayout);
                      mainLayout.addView(bottomTabLayout);

                      switchToTab("home");
                      setContentView(mainLayout);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating layout: " + e.getMessage(), e);
                      throw e;
                  }
              }

              private void createDashboardContent() {
                  dashboardContent = new LinearLayout(this);
                  dashboardContent.setOrientation(LinearLayout.VERTICAL);
                  dashboardContent.setPadding(20, 20, 20, 20);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("🚗 MileTracker Pro");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF495057);
                  headerText.setPadding(0, 0, 0, 10);
                  dashboardContent.addView(headerText);

                  // Subtitle
                  TextView subtitleText = new TextView(this);
                  subtitleText.setText("v4.9.14-fixed-bidirectional-sync • Professional Business Tracking");
                  subtitleText.setTextSize(12);
                  subtitleText.setTextColor(0xFF6C757D);
                  subtitleText.setPadding(0, 0, 0, 15);
                  dashboardContent.addView(subtitleText);

                  // Status
                  statusText = new TextView(this);
                  statusText.setText("Initializing...");
                  statusText.setTextSize(14);
                  statusText.setTextColor(0xFF495057);
                  statusText.setPadding(15, 15, 15, 15);
                  statusText.setBackgroundColor(0xFFe3f2fd);
                  dashboardContent.addView(statusText);

                  // Speed
                  speedText = new TextView(this);
                  speedText.setText("Speed: -- mph");
                  speedText.setTextSize(12);
                  speedText.setTextColor(0xFF6C757D);
                  speedText.setPadding(15, 5, 15, 10);
                  dashboardContent.addView(speedText);

                  // API SYNC SECTION
                  TextView apiSectionHeader = new TextView(this);
                  apiSectionHeader.setText("🌐 API Sync");
                  apiSectionHeader.setTextSize(16);
                  apiSectionHeader.setTextColor(0xFF495057);
                  apiSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(apiSectionHeader);

                  apiToggle = new Button(this);
                  updateApiToggleUI();
                  apiToggle.setTextSize(14);
                  apiToggle.setOnClickListener(v -> toggleApiSync());
                  dashboardContent.addView(apiToggle);

                  // AUTO DETECTION SECTION
                  TextView autoSectionHeader = new TextView(this);
                  autoSectionHeader.setText("🤖 Auto Detection");
                  autoSectionHeader.setTextSize(16);
                  autoSectionHeader.setTextColor(0xFF495057);
                  autoSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(autoSectionHeader);

                  autoToggle = new Button(this);
                  autoToggle.setText("🔄 Auto OFF");
                  autoToggle.setTextSize(14);
                  autoToggle.setBackgroundColor(0xFF9CA3AF);
                  autoToggle.setTextColor(0xFFFFFFFF);
                  autoToggle.setOnClickListener(v -> toggleAutoDetection());
                  dashboardContent.addView(autoToggle);

                  // MANUAL CONTROLS SECTION
                  TextView manualSectionHeader = new TextView(this);
                  manualSectionHeader.setText("✋ Manual Controls");
                  manualSectionHeader.setTextSize(16);
                  manualSectionHeader.setTextColor(0xFF495057);
                  manualSectionHeader.setPadding(0, 10, 0, 5);
                  dashboardContent.addView(manualSectionHeader);

                  LinearLayout manualButtonLayout = new LinearLayout(this);
                  manualButtonLayout.setOrientation(LinearLayout.HORIZONTAL);

                  manualStartButton = new Button(this);
                  manualStartButton.setText("▶️ START");
                  manualStartButton.setTextSize(12);
                  manualStartButton.setBackgroundColor(0xFF28a745);
                  manualStartButton.setTextColor(0xFFFFFFFF);
                  manualStartButton.setOnClickListener(v -> startManualTrip());
                  LinearLayout.LayoutParams startParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                  startParams.setMargins(0, 0, 5, 0);
                  manualStartButton.setLayoutParams(startParams);
                  manualButtonLayout.addView(manualStartButton);

                  manualStopButton = new Button(this);
                  manualStopButton.setText("⏹️ STOP");
                  manualStopButton.setTextSize(12);
                  manualStopButton.setBackgroundColor(0xFFdc3545);
                  manualStopButton.setTextColor(0xFFFFFFFF);
                  manualStopButton.setEnabled(false);
                  manualStopButton.setOnClickListener(v -> stopManualTrip());
                  LinearLayout.LayoutParams stopParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1);
                  stopParams.setMargins(5, 0, 0, 0);
                  manualStopButton.setLayoutParams(stopParams);
                  manualButtonLayout.addView(manualStopButton);

                  dashboardContent.addView(manualButtonLayout);

                  // ADD TRIP MANUALLY
                  addTripButton = new Button(this);
                  addTripButton.setText("➕ Add Trip with Duration & Client");
                  addTripButton.setTextSize(14);
                  addTripButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE
                  addTripButton.setTextColor(0xFFFFFFFF);
                  addTripButton.setOnClickListener(v -> showAddTripDialog());
                  LinearLayout.LayoutParams addParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  addParams.setMargins(0, 10, 0, 0);
                  addTripButton.setLayoutParams(addParams);
                  dashboardContent.addView(addTripButton);

                  // Stats
                  statsText = new TextView(this);
                  statsText.setText("Loading stats...");
                  statsText.setTextSize(12);
                  statsText.setTextColor(0xFF495057);
                  statsText.setPadding(15, 10, 15, 10);
                  statsText.setBackgroundColor(0xFFfafafa);
                  LinearLayout.LayoutParams statsParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  statsParams.setMargins(0, 10, 0, 0);
                  statsText.setLayoutParams(statsParams);
                  dashboardContent.addView(statsText);

                  // Recent Trips
                  TextView recentTripsHeader = new TextView(this);
                  recentTripsHeader.setText("📍 Recent Trips");
                  recentTripsHeader.setTextSize(16);
                  recentTripsHeader.setTextColor(0xFF495057);
                  recentTripsHeader.setPadding(0, 15, 0, 5);
                  dashboardContent.addView(recentTripsHeader);

                  ScrollView recentTripsScroll = new ScrollView(this);
                  recentTripsLayout = new LinearLayout(this);
                  recentTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  recentTripsScroll.addView(recentTripsLayout);
                  
                  LinearLayout.LayoutParams recentScrollParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      200
                  );
                  recentTripsScroll.setLayoutParams(recentScrollParams);
                  dashboardContent.addView(recentTripsScroll);
              }

              private void createTripsContent() {
                  tripsContent = new LinearLayout(this);
                  tripsContent.setOrientation(LinearLayout.VERTICAL);
                  tripsContent.setPadding(20, 20, 20, 20);

                  TextView headerText = new TextView(this);
                  headerText.setText("📋 All Trips");
                  headerText.setTextSize(20);
                  headerText.setTextColor(0xFF495057);
                  headerText.setPadding(0, 0, 0, 15);
                  tripsContent.addView(headerText);

                  allTripsScroll = new ScrollView(this);
                  allTripsLayout = new LinearLayout(this);
                  allTripsLayout.setOrientation(LinearLayout.VERTICAL);
                  allTripsScroll.addView(allTripsLayout);
                  
                  LinearLayout.LayoutParams allTripsParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      0,
                      1.0f
                  );
                  allTripsScroll.setLayoutParams(allTripsParams);
                  tripsContent.addView(allTripsScroll);
              }

              private void toggleApiSync() {
                  try {
                      boolean currentState = tripStorage.isApiSyncEnabled();
                      tripStorage.setApiSyncEnabled(!currentState);
                      updateApiToggleUI();
                      updateStats();
                      
                      String message = tripStorage.isApiSyncEnabled() ? 
                          "API sync ON - downloading historic trips..." : 
                          "API sync OFF - local storage only";
                      Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
                      
                      // Trigger download when API sync is turned ON
                      if (tripStorage.isApiSyncEnabled()) {
                          triggerApiDownload();
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling API sync: " + e.getMessage(), e);
                  }
              }

              private void updateApiToggleUI() {
                  try {
                      if (tripStorage.isApiSyncEnabled()) {
                          apiToggle.setText("🌐 API ON");
                          apiToggle.setBackgroundColor(0xFF28a745);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      } else {
                          apiToggle.setText("🌐 API OFF");
                          apiToggle.setBackgroundColor(0xFF9CA3AF);
                          apiToggle.setTextColor(0xFFFFFFFF);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating API toggle UI: " + e.getMessage(), e);
                  }
              }

              private void switchToTab(String tabName) {
                  try {
                      currentTab = tabName;
                      mainContentLayout.removeAllViews();
                      
                      if ("home".equals(tabName)) {
                          mainContentLayout.addView(dashboardContent);
                          homeTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          tripsTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          updateRecentTrips();
                      } else if ("trips".equals(tabName)) {
                          mainContentLayout.addView(tripsContent);
                          homeTabButton.setBackgroundColor(0xFF9CA3AF); // MUTED GRAY INACTIVE
                          tripsTabButton.setBackgroundColor(0xFF667eea); // MUTED PERIWINKLE ACTIVE
                          updateAllTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error switching tabs: " + e.getMessage(), e);
                  }
              }

              private void updateRecentTrips() {
                  try {
                      recentTripsLayout.removeAllViews();
                      List<Trip> trips = tripStorage.getAllTrips();

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips yet. API sync will download your historic trips!");
                          noTripsText.setTextSize(12);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(10, 10, 10, 10);
                          recentTripsLayout.addView(noTripsText);
                      } else {
                          int maxTrips = Math.min(2, trips.size());
                          for (int i = trips.size() - maxTrips; i < trips.size(); i++) {
                              Trip trip = trips.get(i);
                              addTripCard(recentTripsLayout, trip, true);
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
                  }
              }

              private void updateAllTrips() {
                  try {
                      allTripsLayout.removeAllViews();
                      List<Trip> trips = tripStorage.getAllTrips();

                      if (trips.isEmpty()) {
                          TextView noTripsText = new TextView(this);
                          noTripsText.setText("No trips recorded yet.\n\n✅ NEW FEATURE v4.9.14:\n• FIXED BIDIRECTIONAL API SYNC\n• Downloads your historic trips from API\n• Merges with local trips automatically\n• Duration input field for manual entries\n\nTurn ON API sync to see your historic trips!");
                          noTripsText.setTextSize(14);
                          noTripsText.setTextColor(0xFF6C757D);
                          noTripsText.setPadding(15, 30, 15, 15);
                          allTripsLayout.addView(noTripsText);
                      } else {
                          for (int i = trips.size() - 1; i >= 0; i--) {
                              Trip trip = trips.get(i);
                              addTripCard(allTripsLayout, trip, false);
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating all trips: " + e.getMessage(), e);
                  }
              }

              private void addTripCard(LinearLayout parentLayout, Trip trip, boolean compact) {
                  try {
                      TextView tripView = new TextView(this);
                      String tripType = trip.isAutoDetected() ? "🤖 Auto" : "✋ Manual";
                      String apiStatus = tripStorage.isApiSyncEnabled() ? "📤 API" : "💾 Local";
                      
                      if (compact) {
                          String clientInfo = trip.getClientName() != null ? " • " + trip.getClientName() : "";
                          tripView.setText(String.format(
                              "%s %s • %.1f mi • %s%s",
                              tripType,
                              apiStatus,
                              trip.getDistance(),
                              trip.getCategory(),
                              clientInfo
                          ));
                          tripView.setTextSize(11);
                      } else {
                          StringBuilder tripDetails = new StringBuilder();
                          tripDetails.append(String.format(
                              "%s %s • %s\n%.2f miles • %s • %s\nFrom: %s\nTo: %s",
                              tripType,
                              apiStatus,
                              trip.getFormattedDate(),
                              trip.getDistance(),
                              trip.getFormattedDuration(),
                              trip.getCategory(),
                              trip.getStartAddress() != null ? trip.getStartAddress() : "Unknown",
                              trip.getEndAddress() != null ? trip.getEndAddress() : "Unknown"
                          ));
                          
                          // ADD CLIENT AND NOTES TO TRIP DISPLAY
                          if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                              tripDetails.append("\nClient: ").append(trip.getClientName());
                          }
                          if (trip.getNotes() != null && !trip.getNotes().trim().isEmpty()) {
                              tripDetails.append("\nNotes: ").append(trip.getNotes());
                          }
                          
                          tripView.setText(tripDetails.toString());
                          tripView.setTextSize(12);
                      }
                      
                      tripView.setTextColor(0xFF495057);
                      tripView.setPadding(10, 10, 10, 10);
                      tripView.setBackgroundColor(0xFFffffff);

                      LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT,
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      params.setMargins(0, 0, 0, 5);
                      tripView.setLayoutParams(params);

                      parentLayout.addView(tripView);
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding trip card: " + e.getMessage(), e);
                  }
              }

              // ENHANCED ADD TRIP DIALOG WITH DURATION INPUT FIELD
              private void showAddTripDialog() {
                  try {
                      AlertDialog.Builder builder = new AlertDialog.Builder(this);
                      builder.setTitle("Add Trip with Duration & Client");

                      ScrollView scrollView = new ScrollView(this);
                      LinearLayout layout = new LinearLayout(this);
                      layout.setOrientation(LinearLayout.VERTICAL);
                      layout.setPadding(40, 15, 40, 15);

                      EditText startLocationInput = new EditText(this);
                      startLocationInput.setHint("Start location (e.g., Home)");
                      layout.addView(startLocationInput);

                      EditText endLocationInput = new EditText(this);
                      endLocationInput.setHint("End location (e.g., Client Office)");
                      layout.addView(endLocationInput);

                      EditText distanceInput = new EditText(this);
                      distanceInput.setHint("Distance in miles (e.g., 12.5)");
                      distanceInput.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
                      layout.addView(distanceInput);

                      // DURATION INPUT FIELD
                      TextView durationLabel = new TextView(this);
                      durationLabel.setText("Duration (enter your own time):");
                      durationLabel.setTextSize(14);
                      durationLabel.setTextColor(0xFF495057);
                      durationLabel.setPadding(0, 10, 0, 5);
                      layout.addView(durationLabel);

                      EditText durationInput = new EditText(this);
                      durationInput.setHint("Duration in minutes (e.g., 25)");
                      durationInput.setInputType(InputType.TYPE_CLASS_NUMBER);
                      layout.addView(durationInput);

                      Spinner categorySpinner = new Spinner(this);
                      String[] categories = {"Personal", "Business", "Medical", "Charity"};
                      ArrayAdapter<String> categoryAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, categories);
                      categoryAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                      categorySpinner.setAdapter(categoryAdapter);
                      layout.addView(categorySpinner);

                      // CLIENT DROPDOWN
                      TextView clientLabel = new TextView(this);
                      clientLabel.setText("Client (Optional):");
                      clientLabel.setTextSize(14);
                      clientLabel.setTextColor(0xFF495057);
                      clientLabel.setPadding(0, 10, 0, 5);
                      layout.addView(clientLabel);

                      Spinner clientSpinner = new Spinner(this);
                      List<String> clientOptions = getClientOptions();
                      ArrayAdapter<String> clientAdapter = new ArrayAdapter<>(this, android.R.layout.simple_spinner_item, clientOptions);
                      clientAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
                      clientSpinner.setAdapter(clientAdapter);
                      layout.addView(clientSpinner);

                      // NOTES FIELD
                      TextView notesLabel = new TextView(this);
                      notesLabel.setText("Notes/Description (Optional):");
                      notesLabel.setTextSize(14);
                      notesLabel.setTextColor(0xFF495057);
                      notesLabel.setPadding(0, 10, 0, 5);
                      layout.addView(notesLabel);

                      EditText notesInput = new EditText(this);
                      notesInput.setHint("Purpose, meeting details, project notes, etc.");
                      notesInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE);
                      notesInput.setMinLines(2);
                      notesInput.setMaxLines(4);
                      layout.addView(notesInput);

                      scrollView.addView(layout);
                      builder.setView(scrollView);

                      builder.setPositiveButton("Save Trip", (dialog, which) -> {
                          String startLocation = startLocationInput.getText().toString().trim();
                          String endLocation = endLocationInput.getText().toString().trim();
                          String distanceStr = distanceInput.getText().toString().trim();
                          String durationStr = durationInput.getText().toString().trim();
                          String category = categorySpinner.getSelectedItem().toString();
                          String selectedClient = clientSpinner.getSelectedItem().toString();
                          String notes = notesInput.getText().toString().trim();

                          if (startLocation.isEmpty() || endLocation.isEmpty() || distanceStr.isEmpty() || durationStr.isEmpty()) {
                              Toast.makeText(this, "Please fill all required fields including duration", Toast.LENGTH_SHORT).show();
                              return;
                          }

                          try {
                              double distance = Double.parseDouble(distanceStr);
                              int durationMinutes = Integer.parseInt(durationStr);
                              
                              // Process client selection
                              String clientName = null;
                              if (!"None".equals(selectedClient) && !"+ Add New Client".equals(selectedClient)) {
                                  clientName = selectedClient;
                              } else if ("+ Add New Client".equals(selectedClient)) {
                                  // Show add new client dialog
                                  showAddClientDialog(startLocation, endLocation, distance, durationMinutes, category, notes);
                                  return;
                              }
                              
                              saveManualTripWithDuration(startLocation, endLocation, distance, durationMinutes, category, clientName, notes);
                              
                          } catch (NumberFormatException e) {
                              Toast.makeText(this, "Invalid distance or duration format", Toast.LENGTH_SHORT).show();
                          }
                      });

                      builder.setNegativeButton("Cancel", null);
                      builder.show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error showing add trip dialog: " + e.getMessage(), e);
                  }
              }

              private List<String> getClientOptions() {
                  List<String> options = new ArrayList<>();
                  options.add("None");
                  
                  // Get existing clients from trips
                  List<Trip> trips = tripStorage.getAllTrips();
                  List<String> existingClients = new ArrayList<>();
                  for (Trip trip : trips) {
                      if (trip.getClientName() != null && !trip.getClientName().trim().isEmpty()) {
                          String clientName = trip.getClientName().trim();
                          if (!existingClients.contains(clientName)) {
                              existingClients.add(clientName);
                          }
                      }
                  }
                  
                  options.addAll(existingClients);
                  options.add("+ Add New Client");
                  
                  return options;
              }

              private void showAddClientDialog(String startLocation, String endLocation, double distance, int durationMinutes, String category, String notes) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("Add New Client");

                  EditText clientInput = new EditText(this);
                  clientInput.setHint("Client name (e.g., ABC Company)");
                  builder.setView(clientInput);

                  builder.setPositiveButton("Add Client", (dialog, which) -> {
                      String newClientName = clientInput.getText().toString().trim();
                      if (!newClientName.isEmpty()) {
                          saveManualTripWithDuration(startLocation, endLocation, distance, durationMinutes, category, newClientName, notes);
                      } else {
                          Toast.makeText(this, "Client name cannot be empty", Toast.LENGTH_SHORT).show();
                      }
                  });

                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              // Use user-entered duration instead of calculated
              private void saveManualTripWithDuration(String startLocation, String endLocation, double distance, int durationMinutes, String category, String clientName, String notes) {
                  try {
                      Trip trip = new Trip();
                      trip.setStartAddress(startLocation);
                      trip.setEndAddress(endLocation);
                      trip.setDistance(distance);
                      trip.setCategory(category);
                      trip.setAutoDetected(false);
                      
                      // SET CLIENT AND NOTES
                      trip.setClientName(clientName);
                      trip.setNotes(notes);
                      
                      // Set approximate coordinates
                      trip.setStartLatitude(40.7128);
                      trip.setStartLongitude(-74.0060);
                      trip.setEndLatitude(40.7589);
                      trip.setEndLongitude(-73.9851);
                      
                      // USE USER-ENTERED DURATION
                      long userDuration = durationMinutes * 60 * 1000; // Convert minutes to milliseconds
                      long currentTime = System.currentTimeMillis();
                      trip.setStartTime(currentTime - userDuration);
                      trip.setEndTime(currentTime);
                      trip.setDuration(userDuration);

                      // Generate unique ID
                      trip.setId(currentTime);

                      Log.d(TAG, String.format("Manual trip with USER duration: %.2f miles, %d minutes", distance, durationMinutes));

                      // Save locally
                      tripStorage.saveTrip(trip);

                      // Save to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          CloudBackupService cloudBackup = new CloudBackupService(this);
                          cloudBackup.backupTrip(trip);
                          String clientInfo = clientName != null ? " for " + clientName : "";
                          String notesInfo = notes != null && !notes.isEmpty() ? " with notes" : "";
                          Toast.makeText(this, String.format("Trip saved (%dm)%s%s and synced!", durationMinutes, clientInfo, notesInfo), Toast.LENGTH_SHORT).show();
                      } else {
                          Toast.makeText(this, String.format("Trip saved locally (%dm)!", durationMinutes), Toast.LENGTH_SHORT).show();
                      }

                      updateStats();
                      
                      if ("home".equals(currentTab)) {
                          updateRecentTrips();
                      } else {
                          updateAllTrips();
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving manual trip with duration: " + e.getMessage(), e);
                  }
              }

              // Rest of methods - copy exactly from working version (no changes)
              private void startManualTrip() {
                  try {
                      if (manualTripInProgress) {
                          Toast.makeText(this, "Manual trip already in progress", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      Intent serviceIntent = new Intent(this, ManualTripService.class);
                      serviceIntent.setAction("START_MANUAL_TRIP");
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                          startForegroundService(serviceIntent);
                      } else {
                          startService(serviceIntent);
                      }

                      manualTripInProgress = true;
                      manualStartButton.setEnabled(false);
                      manualStopButton.setEnabled(true);
                      statusText.setText("Manual trip recording...");
                      
                      String apiStatus = tripStorage.isApiSyncEnabled() ? " with API sync" : " (local only)";
                      Toast.makeText(this, "Manual trip started" + apiStatus, Toast.LENGTH_SHORT).show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (!manualTripInProgress) {
                          Toast.makeText(this, "No manual trip in progress", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      Intent serviceIntent = new Intent(this, ManualTripService.class);
                      serviceIntent.setAction("STOP_MANUAL_TRIP");
                      startService(serviceIntent);

                      manualTripInProgress = false;
                      manualStartButton.setEnabled(true);
                      manualStopButton.setEnabled(false);
                      statusText.setText("Manual trip completed");
                      
                      String apiStatus = tripStorage.isApiSyncEnabled() ? " and synced!" : " (saved locally)!";
                      Toast.makeText(this, "Trip saved" + apiStatus, Toast.LENGTH_SHORT).show();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void toggleAutoDetection() {
                  try {
                      autoDetectionEnabled = !autoDetectionEnabled;
                      
                      if (autoDetectionEnabled) {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                              startForegroundService(serviceIntent);
                          } else {
                              startService(serviceIntent);
                          }
                          
                          autoToggle.setText("🤖 Auto ON");
                          autoToggle.setBackgroundColor(0xFF28a745);
                          statusText.setText("Auto detection active - Monitoring for trips");
                          
                          String apiStatus = tripStorage.isApiSyncEnabled() ? " with API sync" : " (local only)";
                          Toast.makeText(this, "Auto detection started" + apiStatus, Toast.LENGTH_SHORT).show();
                      } else {
                          Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                          serviceIntent.setAction("STOP_AUTO_DETECTION");
                          startService(serviceIntent);
                          
                          autoToggle.setText("🔄 Auto OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Auto detection stopped");
                          Toast.makeText(this, "Auto detection stopped", Toast.LENGTH_SHORT).show();
                      }
                      
                      updateStats();
                  } catch (Exception e) {
                      Log.e(TAG, "Error toggling auto detection: " + e.getMessage(), e);
                  }
              }

              private void updateStats() {
                  try {
                      List<Trip> trips = tripStorage.getAllTrips();
                      double totalMiles = 0;
                      double businessMiles = 0;
                      double personalMiles = 0;
                      double medicalMiles = 0;
                      double charityMiles = 0;
                      
                      for (Trip trip : trips) {
                          totalMiles += trip.getDistance();
                          
                          if ("Business".equals(trip.getCategory())) {
                              businessMiles += trip.getDistance();
                          } else if ("Personal".equals(trip.getCategory())) {
                              personalMiles += trip.getDistance();
                          } else if ("Medical".equals(trip.getCategory())) {
                              medicalMiles += trip.getDistance();
                          } else if ("Charity".equals(trip.getCategory())) {
                              charityMiles += trip.getDistance();
                          }
                      }
                      
                      double businessDeduction = businessMiles * 0.70;
                      double personalDeduction = personalMiles * 0.21;
                      double medicalDeduction = medicalMiles * 0.21;
                      double charityDeduction = charityMiles * 0.14;
                      double totalDeduction = businessDeduction + personalDeduction + medicalDeduction + charityDeduction;

                      String apiStatus = tripStorage.isApiSyncEnabled() ? "API ON" : "API OFF";
                      String autoStatus = autoDetectionEnabled ? "Auto ON" : "Auto OFF";
                      
                      String stats = String.format(
                          "📊 Total: %.1f miles (%d trips)\n💼 Business: %.1f mi ($%.2f)\n🏠 Personal: %.1f mi ($%.2f)\n🏥 Medical: %.1f mi ($%.2f)\n❤️ Charity: %.1f mi ($%.2f)\n💰 Total Deduction: $%.2f\n\n🌐 %s • 🤖 %s\n📱 Device: %s\n\n✅ FIXED BIDIRECTIONAL SYNC!\nDownloads your historic trips automatically",
                          totalMiles, trips.size(),
                          businessMiles, businessDeduction,
                          personalMiles, personalDeduction,
                          medicalMiles, medicalDeduction,
                          charityMiles, charityDeduction,
                          totalDeduction,
                          apiStatus, autoStatus,
                          tripStorage.getDeviceId()
                      );

                      if (statsText != null) {
                          statsText.setText(stats);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                  }
              }

              private void initializeGPS() {
                  try {
                      locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                      if (locationManager != null && ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                          statusText.setText("GPS ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error initializing GPS: " + e.getMessage(), e);
                  }
              }

              private void setupSpeedMonitoring() {
                  try {
                      speedRunnable = new Runnable() {
                          @Override
                          public void run() {
                              if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED && locationManager != null) {
                                  try {
                                      android.location.Location lastKnownLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                                      if (lastKnownLocation != null && speedText != null) {
                                          float speed = lastKnownLocation.getSpeed() * 2.237f; // Convert m/s to mph
                                          speedText.setText(String.format("Speed: %.1f mph", speed));
                                      }
                                  } catch (Exception e) {
                                      Log.w(TAG, "Error getting speed: " + e.getMessage());
                                  }
                              }
                              speedHandler.postDelayed(this, 5000); // Update every 5 seconds
                          }
                      };
                      speedHandler.post(speedRunnable);
                  } catch (Exception e) {
                      Log.e(TAG, "Error setting up speed monitoring: " + e.getMessage(), e);
                  }
              }

              private void registerBroadcastReceiver() {
                  try {
                      BroadcastReceiver manualTripReceiver = new BroadcastReceiver() {
                          @Override
                          public void onReceive(Context context, Intent intent) {
                              String status = intent.getStringExtra("status");
                              double distance = intent.getDoubleExtra("distance", 0);
                              long duration = intent.getLongExtra("duration", 0);
                              
                              if ("started".equals(status)) {
                                  statusText.setText("Manual trip recording...");
                              } else if ("recording".equals(status)) {
                                  statusText.setText(String.format("Recording: %.2f miles", distance));
                              } else if ("completed".equals(status)) {
                                  statusText.setText("Manual trip completed");
                                  updateStats();
                                  if ("home".equals(currentTab)) {
                                      updateRecentTrips();
                                  } else {
                                      updateAllTrips();
                                  }
                              }
                          }
                      };
                      
                      IntentFilter filter = new IntentFilter("MANUAL_TRIP_UPDATE");
                      registerReceiver(manualTripReceiver, filter);
                  } catch (Exception e) {
                      Log.e(TAG, "Error registering broadcast receiver: " + e.getMessage(), e);
                  }
              }

              private void restoreAutoDetectionState() {
                  try {
                      autoDetectionEnabled = tripStorage.isAutoDetectionEnabled();
                      if (autoDetectionEnabled) {
                          autoToggle.setText("🤖 Auto ON");
                          autoToggle.setBackgroundColor(0xFF28a745);
                          statusText.setText("Auto detection active");
                      } else {
                          autoToggle.setText("🔄 Auto OFF");
                          autoToggle.setBackgroundColor(0xFF9CA3AF);
                          statusText.setText("Ready");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error restoring auto detection state: " + e.getMessage(), e);
                  }
              }

              private void requestPermissions() {
                  try {
                      if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this, 
                              new String[]{
                                  Manifest.permission.ACCESS_FINE_LOCATION,
                                  Manifest.permission.ACCESS_COARSE_LOCATION
                              }, 
                              LOCATION_PERMISSION_REQUEST);
                      } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && 
                                 ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          ActivityCompat.requestPermissions(this,
                              new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION},
                              BACKGROUND_LOCATION_PERMISSION_REQUEST);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error requesting permissions: " + e.getMessage(), e);
                  }
              }

              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  
                  if (requestCode == LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Location permission granted", Toast.LENGTH_SHORT).show();
                          initializeGPS();
                          
                          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                              requestPermissions();
                          }
                      } else {
                          Toast.makeText(this, "Location permission required for trip tracking", Toast.LENGTH_LONG).show();
                      }
                  } else if (requestCode == BACKGROUND_LOCATION_PERMISSION_REQUEST) {
                      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                          Toast.makeText(this, "Background location permission granted", Toast.LENGTH_SHORT).show();
                      } else {
                          Toast.makeText(this, "Background location permission recommended for auto detection", Toast.LENGTH_LONG).show();
                      }
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  // Handle location updates if needed
              }

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  if (speedHandler != null && speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
              }
          }
          EOF

      - name: Copy AddressLookup and services exactly from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder addressText = new StringBuilder();
                  
                  if (address.getSubThoroughfare() != null) {
                      addressText.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      addressText.append(address.getThoroughfare()).append(", ");
                  }
                  if (address.getLocality() != null) {
                      addressText.append(address.getLocality()).append(", ");
                  }
                  if (address.getAdminArea() != null) {
                      addressText.append(address.getAdminArea());
                  }

                  String result = addressText.toString().trim();
                  if (result.endsWith(",")) {
                      result = result.substring(0, result.length() - 1);
                  }
                  
                  return result.isEmpty() ? "Unknown Location" : result;
              }
          }
          EOF

          # Services (exact copy from working)
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              private static final int NOTIFICATION_ID = 1001;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private boolean isTracking = false;
              private Trip currentTrip = null;
              private Location lastLocation = null;
              private int stationaryCount = 0;
              private int movingCount = 0;
              private long lastMovementTime = 0;

              private static final double SPEED_THRESHOLD_START = 8.0;
              private static final double SPEED_THRESHOLD_STOP = 3.0;
              private static final int START_CONFIRMATIONS = 3;
              private static final int STOP_CONFIRMATIONS = 4;
              private static final long MAX_STATIONARY_TIME = 120000;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");
                  
                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                  
                  createNotificationChannel();
                  
                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          startAutoDetection();
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopAutoDetection();
                      }
                  }
                  return START_STICKY;
              }

              private void startAutoDetection() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      isTracking = true;
                      tripStorage.setAutoDetectionEnabled(true);
                      
                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          10000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (!isTracking || location == null) return;

                  try {
                      float speed = location.getSpeed() * 2.237f;
                      long currentTime = System.currentTimeMillis();

                      if (currentTrip == null) {
                          if (speed >= SPEED_THRESHOLD_START) {
                              movingCount++;
                              stationaryCount = 0;
                              
                              if (movingCount >= START_CONFIRMATIONS) {
                                  startNewTrip(location, currentTime);
                              }
                          } else {
                              movingCount = 0;
                          }
                      } else {
                          if (speed <= SPEED_THRESHOLD_STOP) {
                              stationaryCount++;
                              movingCount = 0;
                              
                              long timeSinceLastMovement = currentTime - lastMovementTime;
                              
                              if (stationaryCount >= STOP_CONFIRMATIONS || 
                                  timeSinceLastMovement > MAX_STATIONARY_TIME) {
                                  endCurrentTrip();
                              }
                          } else {
                              stationaryCount = 0;
                              lastMovementTime = currentTime;
                          }
                      }

                      lastLocation = location;
                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location update", e);
                  }
              }

              private void startNewTrip(Location location, long currentTime) {
                  try {
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(true);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());

                      addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setStartAddress(address);
                              tripStorage.saveCurrentTrip(currentTrip);
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setStartAddress("Unknown Location");
                              tripStorage.saveCurrentTrip(currentTrip);
                          }
                      });

                      movingCount = 0;
                      lastMovementTime = currentTime;
                      
                      Notification notification = createNotification("Trip in progress", "Recording your trip");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting trip", e);
                  }
              }

              private void endCurrentTrip() {
                  if (currentTrip == null) return;

                  try {
                      long currentTime = System.currentTimeMillis();
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      if (distance >= 0.5) {
                          addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  saveCompletedTrip();
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setEndAddress("Unknown Location");
                                  saveCompletedTrip();
                              }
                          });
                      } else {
                          tripStorage.saveCurrentTrip(null);
                          currentTrip = null;
                      }

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip: " + e.getMessage(), e);
                  }
              }

              private void saveCompletedTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      cloudBackupService.backupTrip(currentTrip);
                      tripStorage.saveCurrentTrip(null);
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving completed trip: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void stopAutoDetection() {
                  try {
                      isTracking = false;
                      tripStorage.setAutoDetectionEnabled(false);
                      
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }
                      
                      if (currentTrip != null && lastLocation != null) {
                          endCurrentTrip();
                      }
                      
                      stopForeground(true);
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto detection", e);
                  }
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Auto Detection",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      
                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "MANUAL_TRIP_CHANNEL";
              private static final int NOTIFICATION_ID = 1002;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private Trip currentTrip = null;
              private Location startLocation = null;
              private Location lastLocation = null;

              @Override
              public void onCreate() {
                  super.onCreate();
                  
                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);
                  
                  createNotificationChannel();
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);
                      
                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      long currentTime = System.currentTimeMillis();

                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setEndAddress(address);
                              saveTrip();
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setEndAddress("Unknown Location");
                              saveTrip();
                          }
                      });
                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private void saveTrip() {
                  try {
                      tripStorage.saveTrip(currentTrip);
                      cloudBackupService.backupTrip(currentTrip);
                      
                      sendBroadcast("completed", currentTrip.getDistance(), currentTrip.getDuration());
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip == null) return;

                      if (startLocation == null) {
                          startLocation = location;
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());

                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                              }
                          });
                      }

                      lastLocation = location;

                      if (startLocation != null) {
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  try {
                      Intent intent = new Intent("MANUAL_TRIP_UPDATE");
                      intent.putExtra("status", status);
                      intent.putExtra("distance", distance);
                      intent.putExtra("duration", duration);
                      sendBroadcast(intent);
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending broadcast: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959;
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      
                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Build Android APK with FIXED BIDIRECTIONAL SYNC
        run: |
          cd android
          echo "BUILDING v4.9.14 - FIXED BIDIRECTIONAL SYNC"
          echo "✅ FIXED: Circular dependency issue resolved"
          echo "✅ Downloads historic trips from API to app"
          echo "✅ Bidirectional sync: app ↔ API (both directions)"
          echo "✅ Triggers download on app start and API toggle"
          echo "✅ Duration input field preserved"
          echo "✅ All working features preserved"
          ./gradlew clean assembleRelease --no-daemon --stacktrace

      - name: Upload APK - Fixed Bidirectional Sync
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.14-Fixed-Bidirectional-Sync
          path: android/app/build/outputs/apk/release/*.apk
