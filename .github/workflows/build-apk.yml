name: CORRECT API URL FIX v4.9.73

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Install dependencies
      run: |
        npm install
        npm install -g @expo/cli@latest
        npm install -g eas-cli@latest

    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          ~/.android/build-cache
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Create package.json
      run: |
        cat > package.json << 'EOF'
        {
          "name": "miletracker-pro",
          "version": "4.9.73",
          "main": "node_modules/expo/AppEntry.js",
          "scripts": {
            "start": "expo start",
            "android": "expo start --android",
            "ios": "expo start --ios",
            "web": "expo start --web"
          },
          "dependencies": {
            "expo": "~53.0.0",
            "expo-status-bar": "~2.0.0",
            "react": "18.3.1",
            "react-native": "0.76.0",
            "@react-native-async-storage/async-storage": "^1.21.0",
            "react-native-background-geolocation": "^4.16.3",
            "react-native-maps": "^1.7.1",
            "expo-location": "~18.0.0",
            "expo-camera": "~16.0.0",
            "expo-file-system": "~18.0.0",
            "expo-sharing": "~13.0.0",
            "expo-mail-composer": "~14.0.0",
            "@react-native-community/datetimepicker": "^7.6.2",
            "react-native-image-picker": "^7.0.3",
            "react-native-fs": "^2.20.0",
            "react-native-share": "^10.0.2",
            "react-native-email": "^1.0.8"
          },
          "devDependencies": {
            "@babel/core": "^7.20.0"
          },
          "private": true
        }
        EOF

    - name: Create app.json
      run: |
        cat > app.json << 'EOF'
        {
          "expo": {
            "name": "MileTracker Pro",
            "slug": "miletracker-pro",
            "version": "4.9.73",
            "orientation": "portrait",
            "icon": "./assets/icon.png",
            "userInterfaceStyle": "light",
            "splash": {
              "image": "./assets/splash.png",
              "resizeMode": "contain",
              "backgroundColor": "#ffffff"
            },
            "assetBundlePatterns": [
              "**/*"
            ],
            "ios": {
              "supportsTablet": true
            },
            "android": {
              "adaptiveIcon": {
                "foregroundImage": "./assets/adaptive-icon.png",
                "backgroundColor": "#ffffff"
              },
              "package": "com.miletrackerpro.app",
              "versionCode": 473,
              "permissions": [
                "ACCESS_FINE_LOCATION",
                "ACCESS_COARSE_LOCATION",
                "ACCESS_BACKGROUND_LOCATION",
                "CAMERA",
                "WRITE_EXTERNAL_STORAGE",
                "READ_EXTERNAL_STORAGE"
              ]
            },
            "web": {
              "favicon": "./assets/favicon.png"
            },
            "extra": {
              "eas": {
                "projectId": "18fab652-f2dd-4a28-bd0a-3e89d59cb6d2"
              }
            }
          }
        }
        EOF

    - name: Create android directory structure
      run: |
        mkdir -p android/app/src/main/java/com/miletrackerpro/app
        mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
        mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
        mkdir -p android/app/src/main/res/values
        mkdir -p android/app/src/main/res/xml
        mkdir -p android/gradle/wrapper
        mkdir -p assets

    - name: Create build.gradle (Project)
      run: |
        cat > android/build.gradle << 'EOF'
        buildscript {
            ext {
                buildToolsVersion = "34.0.0"
                minSdkVersion = 21
                compileSdkVersion = 35
                targetSdkVersion = 35
                ndkVersion = "25.1.8937393"
            }
            dependencies {
                classpath("com.android.tools.build:gradle:8.2.0")
                classpath("com.facebook.react:react-native-gradle-plugin")
            }
        }

        allprojects {
            repositories {
                google()
                mavenCentral()
                maven { url "https://www.jitpack.io" }
                maven { url "https://maven.google.com" }
            }
        }
        EOF

    - name: Create build.gradle (App)
      run: |
        cat > android/app/build.gradle << 'EOF'
        plugins {
            id "com.android.application"
        }

        android {
            namespace "com.miletrackerpro.app"
            compileSdk 35

            defaultConfig {
                applicationId "com.miletrackerpro.app"
                minSdk 21
                targetSdk 35
                versionCode 473
                versionName "4.9.73"

                testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
            }

            buildTypes {
                release {
                    minifyEnabled false
                    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                }
            }
            compileOptions {
                sourceCompatibility JavaVersion.VERSION_1_8
                targetCompatibility JavaVersion.VERSION_1_8
            }
        }

        dependencies {
            implementation 'androidx.appcompat:appcompat:1.6.1'
            implementation 'com.google.android.material:material:1.10.0'
            implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
            implementation 'androidx.core:core:1.12.0'
            implementation 'com.google.android.gms:play-services-location:21.0.1'
            implementation 'com.google.android.gms:play-services-maps:18.2.0'
            implementation 'androidx.work:work-runtime:2.8.1'
            implementation 'com.google.code.gson:gson:2.10.1'
            implementation 'androidx.lifecycle:lifecycle-service:2.7.0'

            testImplementation 'junit:junit:4.13.2'
            androidTestImplementation 'androidx.test.ext:junit:1.1.5'
            androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
        }
        EOF

    - name: Create gradle.properties
      run: |
        cat > android/gradle.properties << 'EOF'
        org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
        android.useAndroidX=true
        android.enableJetifier=true
        EOF

    - name: Create settings.gradle
      run: |
        cat > android/settings.gradle << 'EOF'
        pluginManagement {
            repositories {
                google()
                mavenCentral()
                gradlePluginPortal()
            }
        }
        dependencyResolutionManagement {
            repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
            repositories {
                google()
                mavenCentral()
            }
        }

        rootProject.name = "MileTracker Pro"
        include ':app'
        EOF

    - name: Create gradle-wrapper.properties
      run: |
        cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
        distributionBase=GRADLE_USER_HOME
        distributionPath=wrapper/dists
        distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-bin.zip
        zipStoreBase=GRADLE_USER_HOME
        zipStorePath=wrapper/dists
        EOF

    - name: Create strings.xml
      run: |
        cat > android/app/src/main/res/values/strings.xml << 'EOF'
        <resources>
            <string name="app_name">MileTracker Pro</string>
        </resources>
        EOF

    - name: Create AndroidManifest.xml
      run: |
        cat > android/app/src/main/AndroidManifest.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            package="com.miletrackerpro.app">

            <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
            <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
            <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
            <uses-permission android:name="android.permission.CAMERA" />
            <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
            <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
            <uses-permission android:name="android.permission.INTERNET" />
            <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
            <uses-permission android:name="android.permission.WAKE_LOCK" />
            <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
            <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

            <application
                android:allowBackup="true"
                android:icon="@android:drawable/ic_menu_mylocation"
                android:label="@string/app_name"
                android:theme="@android:style/Theme.DeviceDefault.Light">
                <activity
                    android:name=".MainActivity"
                    android:exported="true"
                    android:theme="@android:style/Theme.DeviceDefault.Light.NoActionBar">
                    <intent-filter>
                        <action android:name="android.intent.action.MAIN" />
                        <category android:name="android.intent.category.LAUNCHER" />
                    </intent-filter>
                </activity>
                <service
                    android:name=".CloudBackupService"
                    android:enabled="true"
                    android:exported="false" />
            </application>
        </manifest>
        EOF

    - name: Create DeviceIdentification utility
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/utils/DeviceIdentification.java << 'EOF'
        package com.miletrackerpro.app.utils;

        import android.content.Context;
        import android.provider.Settings;
        import android.os.Build;
        import java.security.MessageDigest;
        import java.nio.charset.StandardCharsets;

        public class DeviceIdentification {
            public static String getStableDeviceId(Context context) {
                try {
                    String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                    String deviceInfo = Build.MANUFACTURER + Build.MODEL + Build.DEVICE + androidId;
                    
                    MessageDigest digest = MessageDigest.getInstance("SHA-256");
                    byte[] hash = digest.digest(deviceInfo.getBytes(StandardCharsets.UTF_8));
                    
                    StringBuilder hexString = new StringBuilder();
                    for (byte b : hash) {
                        String hex = Integer.toHexString(0xff & b);
                        if (hex.length() == 1) {
                            hexString.append('0');
                        }
                        hexString.append(hex);
                    }
                    
                    return hexString.toString().substring(0, 16);
                } catch (Exception e) {
                    return "unknown_device";
                }
            }
        }
        EOF

    - name: Create Trip model
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
        package com.miletrackerpro.app.storage;

        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.Locale;
        import java.util.UUID;

        public class Trip {
            private String id;
            private String startLocation;
            private String endLocation;
            private double startLatitude;
            private double startLongitude;
            private double endLatitude;
            private double endLongitude;
            private double distance;
            private long duration;
            private String category;
            private String clientName;
            private String notes;
            private long startTime;
            private long endTime;
            private boolean autoDetected;

            public Trip() {
                this.id = UUID.randomUUID().toString();
                this.startTime = System.currentTimeMillis();
                this.endTime = System.currentTimeMillis();
                this.category = "Business";
                this.clientName = "";
                this.notes = "";
                this.autoDetected = false;
            }

            // Getters and setters
            public String getId() { return id; }
            public void setId(String id) { this.id = id; }

            public String getStartLocation() { return startLocation; }
            public void setStartLocation(String startLocation) { this.startLocation = startLocation; }

            public String getEndLocation() { return endLocation; }
            public void setEndLocation(String endLocation) { this.endLocation = endLocation; }

            public double getStartLatitude() { return startLatitude; }
            public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

            public double getStartLongitude() { return startLongitude; }
            public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

            public double getEndLatitude() { return endLatitude; }
            public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

            public double getEndLongitude() { return endLongitude; }
            public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

            public double getDistance() { return distance; }
            public void setDistance(double distance) { this.distance = distance; }

            public long getDuration() { return duration; }
            public void setDuration(long duration) { this.duration = duration; }

            public String getCategory() { return category; }
            public void setCategory(String category) { this.category = category; }

            public String getClientName() { return clientName; }
            public void setClientName(String clientName) { this.clientName = clientName; }

            public String getNotes() { return notes; }
            public void setNotes(String notes) { this.notes = notes; }

            public long getStartTime() { return startTime; }
            public void setStartTime(long startTime) { this.startTime = startTime; }

            public long getEndTime() { return endTime; }
            public void setEndTime(long endTime) { this.endTime = endTime; }

            public boolean isAutoDetected() { return autoDetected; }
            public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

            public String getFormattedDate() {
                return new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault()).format(new Date(startTime));
            }

            public String getFormattedTime() {
                return new SimpleDateFormat("h:mm a", Locale.getDefault()).format(new Date(startTime));
            }

            public String getFormattedDistance() {
                return String.format(Locale.getDefault(), "%.1f mi", distance);
            }

            public String getFormattedDuration() {
                long hours = duration / 3600000;
                long minutes = (duration % 3600000) / 60000;
                if (hours > 0) {
                    return String.format(Locale.getDefault(), "%dh %dm", hours, minutes);
                } else {
                    return String.format(Locale.getDefault(), "%dm", minutes);
                }
            }
        }
        EOF

    - name: Create TripStorage with debug functionality
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
        package com.miletrackerpro.app.storage;

        import android.content.Context;
        import android.content.SharedPreferences;
        import android.util.Log;
        import android.app.AlertDialog;
        import com.miletrackerpro.app.utils.DeviceIdentification;
        import org.json.JSONArray;
        import org.json.JSONObject;

        import java.util.ArrayList;
        import java.util.Collections;
        import java.util.Comparator;
        import java.util.List;

        public class TripStorage {
            private static final String TAG = "TripStorage";
            private static final String PREFS_NAME = "MileTrackerPrefs";
            private static final String TRIPS_KEY = "trips";
            private static final String CURRENT_TRIP_KEY = "current_trip";
            private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
            private static final String API_SYNC_KEY = "api_sync_enabled";
            private static final String USER_ID_KEY = "user_id";

            private Context context;
            private SharedPreferences prefs;

            public TripStorage(Context context) {
                this.context = context;
                this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
            }

            public void saveTrip(Trip trip) {
                try {
                    List<Trip> trips = getTrips();
                    
                    // Check if trip already exists (by ID)
                    boolean exists = false;
                    for (int i = 0; i < trips.size(); i++) {
                        if (trips.get(i).getId().equals(trip.getId())) {
                            trips.set(i, trip); // Update existing
                            exists = true;
                            break;
                        }
                    }
                    
                    if (!exists) {
                        trips.add(trip);
                    }
                    
                    saveTrips(trips);
                    Log.d(TAG, "Trip saved: " + trip.getId());
                } catch (Exception e) {
                    Log.e(TAG, "Error saving trip", e);
                }
            }

            public List<Trip> getTrips() {
                List<Trip> trips = new ArrayList<>();
                try {
                    String json = prefs.getString(TRIPS_KEY, "[]");
                    JSONArray array = new JSONArray(json);
                    
                    for (int i = 0; i < array.length(); i++) {
                        JSONObject obj = array.getJSONObject(i);
                        Trip trip = new Trip();
                        
                        // Handle both camelCase and snake_case field names
                        trip.setId(obj.optString("id", ""));
                        trip.setStartLocation(obj.optString("start_location", obj.optString("startLocation", "")));
                        trip.setEndLocation(obj.optString("end_location", obj.optString("endLocation", "")));
                        trip.setStartLatitude(obj.optDouble("start_latitude", obj.optDouble("startLatitude", 0.0)));
                        trip.setStartLongitude(obj.optDouble("start_longitude", obj.optDouble("startLongitude", 0.0)));
                        trip.setEndLatitude(obj.optDouble("end_latitude", obj.optDouble("endLatitude", 0.0)));
                        trip.setEndLongitude(obj.optDouble("end_longitude", obj.optDouble("endLongitude", 0.0)));
                        trip.setDistance(obj.optDouble("distance", 0.0));
                        trip.setDuration(obj.optLong("duration", 0L));
                        trip.setCategory(obj.optString("category", "Business"));
                        trip.setClientName(obj.optString("client_name", obj.optString("clientName", "")));
                        trip.setNotes(obj.optString("notes", ""));
                        trip.setStartTime(obj.optLong("start_time", obj.optLong("startTime", System.currentTimeMillis())));
                        trip.setEndTime(obj.optLong("end_time", obj.optLong("endTime", System.currentTimeMillis())));
                        trip.setAutoDetected(obj.optBoolean("auto_detected", obj.optBoolean("autoDetected", false)));
                        
                        trips.add(trip);
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error loading trips", e);
                }
                
                // Sort by start time (newest first)
                Collections.sort(trips, new Comparator<Trip>() {
                    @Override
                    public int compare(Trip t1, Trip t2) {
                        return Long.compare(t2.getStartTime(), t1.getStartTime());
                    }
                });
                
                return trips;
            }

            public void deleteTrip(String tripId) {
                try {
                    List<Trip> trips = getTrips();
                    trips.removeIf(trip -> trip.getId().equals(tripId));
                    saveTrips(trips);
                    Log.d(TAG, "Trip deleted: " + tripId);
                } catch (Exception e) {
                    Log.e(TAG, "Error deleting trip", e);
                }
            }

            public void mergeApiTrips(List<Trip> apiTrips) {
                try {
                    List<Trip> localTrips = getTrips();
                    
                    // Add API trips that don't exist locally
                    for (Trip apiTrip : apiTrips) {
                        boolean exists = false;
                        for (Trip localTrip : localTrips) {
                            if (localTrip.getId().equals(apiTrip.getId())) {
                                exists = true;
                                break;
                            }
                        }
                        if (!exists) {
                            localTrips.add(apiTrip);
                        }
                    }
                    
                    saveTrips(localTrips);
                    Log.d(TAG, "Merged " + apiTrips.size() + " API trips");
                } catch (Exception e) {
                    Log.e(TAG, "Error merging API trips", e);
                }
            }

            // Auto detection settings
            public boolean isAutoDetectionEnabled() {
                return prefs.getBoolean(AUTO_DETECTION_KEY, false);
            }

            public void setAutoDetectionEnabled(boolean enabled) {
                prefs.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
            }

            // API sync settings
            public boolean isApiSyncEnabled() {
                return prefs.getBoolean(API_SYNC_KEY, false);
            }

            public void setApiSyncEnabled(boolean enabled) {
                prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
            }

            // Current trip for auto detection
            public void setCurrentTrip(Trip trip) {
                try {
                    if (trip == null) {
                        prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                    } else {
                        JSONObject obj = new JSONObject();
                        obj.put("id", trip.getId());
                        obj.put("start_location", trip.getStartLocation());
                        obj.put("end_location", trip.getEndLocation());
                        obj.put("start_latitude", trip.getStartLatitude());
                        obj.put("start_longitude", trip.getStartLongitude());
                        obj.put("end_latitude", trip.getEndLatitude());
                        obj.put("end_longitude", trip.getEndLongitude());
                        obj.put("distance", trip.getDistance());
                        obj.put("duration", trip.getDuration());
                        obj.put("category", trip.getCategory());
                        obj.put("client_name", trip.getClientName());
                        obj.put("notes", trip.getNotes());
                        obj.put("start_time", trip.getStartTime());
                        obj.put("end_time", trip.getEndTime());
                        obj.put("auto_detected", trip.isAutoDetected());
                        
                        prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error saving current trip", e);
                }
            }

            public Trip getCurrentTrip() {
                try {
                    String json = prefs.getString(CURRENT_TRIP_KEY, null);
                    if (json != null) {
                        JSONObject obj = new JSONObject(json);
                        Trip trip = new Trip();
                        trip.setId(obj.optString("id", ""));
                        trip.setStartLocation(obj.optString("start_location", ""));
                        trip.setEndLocation(obj.optString("end_location", ""));
                        trip.setStartLatitude(obj.optDouble("start_latitude", 0.0));
                        trip.setStartLongitude(obj.optDouble("start_longitude", 0.0));
                        trip.setEndLatitude(obj.optDouble("end_latitude", 0.0));
                        trip.setEndLongitude(obj.optDouble("end_longitude", 0.0));
                        trip.setDistance(obj.optDouble("distance", 0.0));
                        trip.setDuration(obj.optLong("duration", 0L));
                        trip.setCategory(obj.optString("category", "Business"));
                        trip.setClientName(obj.optString("client_name", ""));
                        trip.setNotes(obj.optString("notes", ""));
                        trip.setStartTime(obj.optLong("start_time", System.currentTimeMillis()));
                        trip.setEndTime(obj.optLong("end_time", System.currentTimeMillis()));
                        trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                        return trip;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error loading current trip", e);
                }
                return null;
            }

            // Device and user identification
            public String getStableDeviceId() {
                return DeviceIdentification.getStableDeviceId(context);
            }

            public void setUserId(String userId) {
                prefs.edit().putString(USER_ID_KEY, userId).apply();
            }

            public String getUserId() {
                return prefs.getString(USER_ID_KEY, "13"); // Default to user ID 13 for pcates@catesconsultinggroup.com
            }

            private void saveTrips(List<Trip> trips) {
                try {
                    JSONArray array = new JSONArray();
                    for (Trip trip : trips) {
                        JSONObject obj = new JSONObject();
                        obj.put("id", trip.getId());
                        obj.put("start_location", trip.getStartLocation());
                        obj.put("end_location", trip.getEndLocation());
                        obj.put("start_latitude", trip.getStartLatitude());
                        obj.put("start_longitude", trip.getStartLongitude());
                        obj.put("end_latitude", trip.getEndLatitude());
                        obj.put("end_longitude", trip.getEndLongitude());
                        obj.put("distance", trip.getDistance());
                        obj.put("duration", trip.getDuration());
                        obj.put("category", trip.getCategory());
                        obj.put("client_name", trip.getClientName());
                        obj.put("notes", trip.getNotes());
                        obj.put("start_time", trip.getStartTime());
                        obj.put("end_time", trip.getEndTime());
                        obj.put("auto_detected", trip.isAutoDetected());
                        array.put(obj);
                    }
                    prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                } catch (Exception e) {
                    Log.e(TAG, "Error saving trips", e);
                }
            }

            // Simple debug method
            public void showDataDebug() {
                String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                AlertDialog.Builder builder = new AlertDialog.Builder(context);
                builder.setTitle("Data Debug");
                builder.setMessage("Raw data: " + tripsJson.substring(0, Math.min(500, tripsJson.length())));
                builder.setPositiveButton("Force Fix", (dialog, which) -> {
                    try {
                        JSONArray array = new JSONArray(tripsJson);
                        JSONArray fixed = new JSONArray();
                        for (int i = 0; i < array.length(); i++) {
                            JSONObject original = array.getJSONObject(i);
                            JSONObject migrated = new JSONObject();
                            JSONArray keys = original.names();
                            if (keys != null) {
                                for (int j = 0; j < keys.length(); j++) {
                                    String key = keys.getString(j);
                                    String snakeKey = key.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
                                    migrated.put(snakeKey, original.get(key));
                                }
                            }
                            fixed.put(migrated);
                        }
                        prefs.edit().putString(TRIPS_KEY, fixed.toString()).apply();
                    } catch (Exception e) {
                        // Silent fail
                    }
                });
                builder.setNegativeButton("Close", null);
                builder.create().show();
            }
        }
        EOF

    - name: Create CloudBackupService with user-based download
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
        package com.miletrackerpro.app;

        import android.content.Context;
        import android.util.Log;
        import com.miletrackerpro.app.storage.Trip;
        import com.miletrackerpro.app.storage.TripStorage;

        import java.io.BufferedReader;
        import java.io.InputStreamReader;
        import java.io.OutputStream;
        import java.net.HttpURLConnection;
        import java.net.URL;
        import java.nio.charset.StandardCharsets;
        import java.util.ArrayList;
        import java.util.List;
        import java.util.Locale;
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        import org.json.JSONArray;
        import org.json.JSONObject;

        public class CloudBackupService {
            private static final String TAG = "CloudBackupService";
            private static final String API_BASE_URL = "https://18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev/api";

            private Context context;
            private ExecutorService executor;

            public CloudBackupService(Context context) {
                this.context = context;
                this.executor = Executors.newSingleThreadExecutor();
            }

            // UPLOAD FUNCTIONALITY
            public void backupTrip(Trip trip) {
                TripStorage tripStorage = new TripStorage(context);
                if (!tripStorage.isApiSyncEnabled()) {
                    Log.d(TAG, "API sync disabled, skipping backup");
                    return;
                }

                executor.execute(() -> {
                    try {
                        Log.d(TAG, "Starting API backup for trip: " + trip.getId());

                        URL url = new URL(API_BASE_URL + "/trips");
                        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                        conn.setRequestMethod("POST");
                        conn.setRequestProperty("Content-Type", "application/json");
                        conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.15");
                        conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                        conn.setRequestProperty("X-User-Email", "pcates@catesconsultinggroup.com");
                        conn.setDoOutput(true);
                        conn.setConnectTimeout(10000);
                        conn.setReadTimeout(10000);

                        String jsonPayload = createTripJson(trip, tripStorage.getStableDeviceId(), tripStorage.getUserId());

                        try (OutputStream os = conn.getOutputStream()) {
                            byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                            os.write(input, 0, input.length);
                        }

                        int responseCode = conn.getResponseCode();
                        Log.d(TAG, "API backup response: " + responseCode);

                        if (responseCode == 200 || responseCode == 201) {
                            Log.d(TAG, "Trip backed up successfully to API");
                        }

                        conn.disconnect();
                    } catch (Exception e) {
                        Log.e(TAG, "Error backing up trip to API", e);
                    }
                });
            }

            // DOWNLOAD FUNCTIONALITY
            public void downloadAllUserTrips() {
                TripStorage tripStorage = new TripStorage(context);
                if (!tripStorage.isApiSyncEnabled()) {
                    Log.d(TAG, "API sync disabled, skipping download");
                    return;
                }

                executor.execute(() -> {
                    try {
                        String userId = tripStorage.getUserId();
                        Log.d(TAG, "Starting download ALL trips for user: " + userId);

                        // Download ALL trips from the API (not device-specific)
                        String apiUrl = API_BASE_URL + "/trips";
                        URL url = new URL(apiUrl);
                        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                        conn.setRequestMethod("GET");
                        conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.15");
                        conn.setRequestProperty("Authorization", "Bearer demo-admin-token");
                        conn.setRequestProperty("X-User-Email", "pcates@catesconsultinggroup.com");
                        conn.setRequestProperty("X-User-ID", userId); // Send user ID for filtering
                        conn.setConnectTimeout(10000);
                        conn.setReadTimeout(10000);

                        int responseCode = conn.getResponseCode();
                        Log.d(TAG, "API download ALL trips response: " + responseCode);

                        if (responseCode == 200) {
                            StringBuilder response = new StringBuilder();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                                String line;
                                while ((line = reader.readLine()) != null) {
                                    response.append(line);
                                }
                            }

                            List<Trip> apiTrips = parseTripsFromJson(response.toString());
                            Log.d(TAG, "Downloaded " + apiTrips.size() + " trips from API (all user trips)");

                            if (!apiTrips.isEmpty()) {
                                tripStorage.mergeApiTrips(apiTrips);
                                Log.d(TAG, "Successfully merged API trips");
                            }
                        } else {
                            Log.w(TAG, "API download failed with code: " + responseCode);
                        }

                        conn.disconnect();
                    } catch (Exception e) {
                        Log.e(TAG, "Error downloading trips from API", e);
                    }
                });
            }

            private List<Trip> parseTripsFromJson(String jsonResponse) {
                List<Trip> trips = new ArrayList<>();
                try {
                    JSONArray array = new JSONArray(jsonResponse);
                    for (int i = 0; i < array.length(); i++) {
                        JSONObject obj = array.getJSONObject(i);
                        Trip trip = new Trip();
                        
                        trip.setId(obj.optString("id", ""));
                        trip.setStartLocation(obj.optString("start_location", ""));
                        trip.setEndLocation(obj.optString("end_location", ""));
                        trip.setStartLatitude(obj.optDouble("start_latitude", 0.0));
                        trip.setStartLongitude(obj.optDouble("start_longitude", 0.0));
                        trip.setEndLatitude(obj.optDouble("end_latitude", 0.0));
                        trip.setEndLongitude(obj.optDouble("end_longitude", 0.0));
                        trip.setDistance(obj.optDouble("distance", 0.0));
                        trip.setDuration(obj.optLong("duration", 0L));
                        trip.setCategory(obj.optString("category", "Business"));
                        trip.setClientName(obj.optString("client_name", ""));
                        trip.setNotes(obj.optString("notes", ""));
                        
                        // Handle timestamp conversion
                        long startTime = obj.optLong("start_time", 0L);
                        long endTime = obj.optLong("end_time", 0L);
                        
                        // Convert from seconds to milliseconds if needed
                        if (startTime > 0 && startTime < 1000000000000L) {
                            startTime *= 1000;
                        }
                        if (endTime > 0 && endTime < 1000000000000L) {
                            endTime *= 1000;
                        }
                        
                        trip.setStartTime(startTime);
                        trip.setEndTime(endTime);
                        trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                        
                        trips.add(trip);
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error parsing trips from JSON", e);
                }
                return trips;
            }

            private String createTripJson(Trip trip, String deviceId, String userId) throws Exception {
                JSONObject json = new JSONObject();
                json.put("id", trip.getId());
                json.put("device_id", deviceId);
                json.put("user_id", userId);
                json.put("start_location", trip.getStartLocation());
                json.put("end_location", trip.getEndLocation());
                json.put("start_latitude", trip.getStartLatitude());
                json.put("start_longitude", trip.getStartLongitude());
                json.put("end_latitude", trip.getEndLatitude());
                json.put("end_longitude", trip.getEndLongitude());
                json.put("distance", trip.getDistance());
                json.put("duration", trip.getDuration());
                json.put("category", trip.getCategory());
                json.put("client_name", trip.getClientName());
                json.put("notes", trip.getNotes());
                json.put("start_time", trip.getStartTime());
                json.put("end_time", trip.getEndTime());
                json.put("auto_detected", trip.isAutoDetected());
                return json.toString();
            }
        }
        EOF

    - name: Create MainActivity with enhanced user identification and ALL trips download
      run: |
        cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
        package com.miletrackerpro.app;

        import android.app.Activity;
        import android.content.Context;
        import android.content.Intent;
        import android.location.Location;
        import android.location.LocationListener;
        import android.location.LocationManager;
        import android.os.Bundle;
        import android.os.Handler;
        import android.os.Looper;
        import android.util.Log;
        import android.view.View;
        import android.widget.Button;
        import android.widget.LinearLayout;
        import android.widget.ScrollView;
        import android.widget.TextView;
        import android.widget.Toast;
        import android.location.Geocoder;
        import android.location.Address;
        import android.graphics.Color;
        import android.view.Gravity;
        import android.widget.LinearLayout.LayoutParams;
        import android.app.AlertDialog;
        import android.widget.EditText;
        import android.content.DialogInterface;
        import com.miletrackerpro.app.storage.Trip;
        import com.miletrackerpro.app.storage.TripStorage;

        import java.text.SimpleDateFormat;
        import java.util.Date;
        import java.util.List;
        import java.util.Locale;
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;

        public class MainActivity extends Activity implements LocationListener {
            private static final String TAG = "MainActivity";
            private static final int LOCATION_PERMISSION_REQUEST = 1;
            private static final double MIN_DISTANCE_BETWEEN_UPDATES = 10; // meters
            private static final long MIN_TIME_BW_UPDATES = 5000; // 5 seconds
            private static final double TRIP_START_SPEED = 8.0; // mph
            private static final double TRIP_END_SPEED = 3.0; // mph
            
            private LocationManager locationManager;
            private TripStorage tripStorage;
            private CloudBackupService cloudBackup;
            private ExecutorService executor;
            private Geocoder geocoder;
            private Handler mainHandler;
            
            // UI elements
            private TextView statusText;
            private TextView speedText;
            private Button toggleButton;
            private Button apiToggle;
            private LinearLayout tripsContainer;
            private ScrollView tripsScrollView;
            
            // Trip tracking
            private Trip currentTrip;
            private Location lastLocation;
            private boolean isTracking = false;
            private double currentSpeed = 0.0;
            private int consecutiveMovingReadings = 0;
            private int consecutiveStationaryReadings = 0;
            private long lastLocationTime = 0;
            
            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                
                Log.d(TAG, "ðŸš— MileTracker Pro v4.9.73 - Enhanced with debug functionality");
                
                // Initialize services
                tripStorage = new TripStorage(this);
                cloudBackup = new CloudBackupService(this);
                executor = Executors.newSingleThreadExecutor();
                geocoder = new Geocoder(this, Locale.getDefault());
                mainHandler = new Handler(Looper.getMainLooper());
                locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                
                // Create main layout
                createMainLayout();
                
                // Initialize GPS tracking
                initializeGPS();
                
                // Restore any current trip
                restoreCurrentTrip();
                
                // Update UI
                updateUI();
                
                // Check if API sync is enabled and download trips
                if (tripStorage.isApiSyncEnabled()) {
                    try {
                        // Trigger download of all user trips from API
                        cloudBackup.downloadAllUserTrips();
                        Log.d(TAG, "Triggered download of ALL user trips (not device-specific)");
                        
                        // Update UI after a short delay to allow download to complete
                        mainHandler.postDelayed(() -> {
                            updateTripsDisplay();
                            Toast.makeText(this, "Syncing your trips from cloud...", Toast.LENGTH_SHORT).show();
                        }, 2000);
                        
                    } catch (Exception e) {
                        Log.e(TAG, "Error triggering ALL user trips download: " + e.getMessage(), e);
                    }
                }
            }
            
            private void createMainLayout() {
                ScrollView mainScroll = new ScrollView(this);
                LinearLayout mainLayout = new LinearLayout(this);
                mainLayout.setOrientation(LinearLayout.VERTICAL);
                mainLayout.setPadding(20, 20, 20, 20);
                
                // Header
                TextView headerText = new TextView(this);
                headerText.setText("ðŸš— MileTracker Pro v4.9.73");
                headerText.setTextSize(24);
                headerText.setTextColor(Color.parseColor("#2E7D32"));
                headerText.setGravity(Gravity.CENTER);
                headerText.setPadding(0, 0, 0, 20);
                mainLayout.addView(headerText);
                
                // Subtitle
                TextView subtitleText = new TextView(this);
                subtitleText.setText("Professional Mileage Tracking");
                subtitleText.setTextSize(16);
                subtitleText.setTextColor(Color.parseColor("#666666"));
                subtitleText.setGravity(Gravity.CENTER);
                subtitleText.setPadding(0, 0, 0, 20);
                mainLayout.addView(subtitleText);
                
                // Status display
                statusText = new TextView(this);
                statusText.setText("Ready to track");
                statusText.setTextSize(18);
                statusText.setGravity(Gravity.CENTER);
                statusText.setPadding(0, 0, 0, 10);
                mainLayout.addView(statusText);
                
                // Speed display
                speedText = new TextView(this);
                speedText.setText("Speed: 0 mph");
                speedText.setTextSize(14);
                speedText.setGravity(Gravity.CENTER);
                speedText.setPadding(0, 0, 0, 20);
                mainLayout.addView(speedText);
                
                // API sync section
                TextView apiSectionHeader = new TextView(this);
                apiSectionHeader.setText("ðŸ“¡ API SYNC");
                apiSectionHeader.setTextSize(14);
                apiSectionHeader.setTextColor(Color.parseColor("#1976D2"));
                apiSectionHeader.setPadding(0, 10, 0, 5);
                mainLayout.addView(apiSectionHeader);
                
                apiToggle = new Button(this);
                updateApiToggleUI();
                apiToggle.setTextSize(14);
                apiToggle.setOnClickListener(v -> toggleApiSync());
                mainLayout.addView(apiToggle);
                
                // Debug button for data migration
                Button debugButton = new Button(this);
                debugButton.setText("ðŸ” Debug Data");
                debugButton.setTextSize(12);
                debugButton.setBackgroundColor(0xFFFF9800);
                debugButton.setTextColor(0xFFFFFFFF);
                debugButton.setOnClickListener(v -> tripStorage.showDataDebug());
                mainLayout.addView(debugButton);
                
                // AUTO DETECTION SECTION
                TextView autoSectionHeader = new TextView(this);
                autoSectionHeader.setText("ðŸ¤– AUTO DETECTION");
                autoSectionHeader.setTextSize(14);
                autoSectionHeader.setTextColor(Color.parseColor("#1976D2"));
                autoSectionHeader.setPadding(0, 20, 0, 5);
                mainLayout.addView(autoSectionHeader);
                
                // Auto detection toggle
                toggleButton = new Button(this);
                updateToggleButtonUI();
                toggleButton.setTextSize(16);
                toggleButton.setOnClickListener(v -> toggleAutoDetection());
                mainLayout.addView(toggleButton);
                
                // Detection info
                TextView detectionInfo = new TextView(this);
                detectionInfo.setText("Auto detection starts trips at 8+ mph and ends at 3- mph");
                detectionInfo.setTextSize(12);
                detectionInfo.setTextColor(Color.parseColor("#666666"));
                detectionInfo.setGravity(Gravity.CENTER);
                detectionInfo.setPadding(10, 5, 10, 20);
                mainLayout.addView(detectionInfo);
                
                // TRIPS SECTION
                TextView tripsHeader = new TextView(this);
                tripsHeader.setText("ðŸ“‹ RECENT TRIPS");
                tripsHeader.setTextSize(14);
                tripsHeader.setTextColor(Color.parseColor("#1976D2"));
                tripsHeader.setPadding(0, 10, 0, 5);
                mainLayout.addView(tripsHeader);
                
                // Trips container
                tripsContainer = new LinearLayout(this);
                tripsContainer.setOrientation(LinearLayout.VERTICAL);
                
                tripsScrollView = new ScrollView(this);
                tripsScrollView.addView(tripsContainer);
                
                // Set fixed height for trips area
                LayoutParams scrollParams = new LayoutParams(LayoutParams.MATCH_PARENT, 600);
                tripsScrollView.setLayoutParams(scrollParams);
                tripsScrollView.setBackgroundColor(Color.parseColor("#F5F5F5"));
                tripsScrollView.setPadding(10, 10, 10, 10);
                
                mainLayout.addView(tripsScrollView);
                
                // Add trip button
                Button addTripButton = new Button(this);
                addTripButton.setText("âž• Add Manual Trip");
                addTripButton.setTextSize(14);
                addTripButton.setBackgroundColor(Color.parseColor("#4CAF50"));
                addTripButton.setTextColor(Color.WHITE);
                addTripButton.setOnClickListener(v -> showAddTripDialog());
                mainLayout.addView(addTripButton);
                
                mainScroll.addView(mainLayout);
                setContentView(mainScroll);
            }
            
            private void toggleApiSync() {
                boolean currentState = tripStorage.isApiSyncEnabled();
                boolean newState = !currentState;
                
                tripStorage.setApiSyncEnabled(newState);
                updateApiToggleUI();
                
                if (newState) {
                    // When API sync is enabled, download all user trips
                    try {
                        cloudBackup.downloadAllUserTrips();
                        Log.d(TAG, "API sync enabled - downloading ALL user trips");
                        
                        // Update UI after a short delay
                        mainHandler.postDelayed(() -> {
                            updateTripsDisplay();
                            Toast.makeText(this, "API sync enabled - downloading your trips...", Toast.LENGTH_LONG).show();
                        }, 1000);
                    } catch (Exception e) {
                        Log.e(TAG, "Error downloading trips: " + e.getMessage(), e);
                        Toast.makeText(this, "API sync enabled but download failed", Toast.LENGTH_SHORT).show();
                    }
                } else {
                    Toast.makeText(this, "API sync disabled", Toast.LENGTH_SHORT).show();
                }
            }
            
            private void updateApiToggleUI() {
                if (apiToggle != null) {
                    boolean isEnabled = tripStorage.isApiSyncEnabled();
                    if (isEnabled) {
                        apiToggle.setText("ðŸŒ API Sync: ON");
                        apiToggle.setBackgroundColor(Color.parseColor("#4CAF50"));
                        apiToggle.setTextColor(Color.WHITE);
                    } else {
                        apiToggle.setText("ðŸŒ API Sync: OFF");
                        apiToggle.setBackgroundColor(Color.parseColor("#757575"));
                        apiToggle.setTextColor(Color.WHITE);
                    }
                }
            }
            
            private void toggleAutoDetection() {
                boolean currentState = tripStorage.isAutoDetectionEnabled();
                boolean newState = !currentState;
                
                tripStorage.setAutoDetectionEnabled(newState);
                updateToggleButtonUI();
                
                if (newState) {
                    startLocationUpdates();
                    Toast.makeText(this, "Auto detection enabled - drive to start tracking", Toast.LENGTH_LONG).show();
                } else {
                    stopLocationUpdates();
                    // End any current trip
                    if (currentTrip != null) {
                        endCurrentTrip();
                    }
                    Toast.makeText(this, "Auto detection disabled", Toast.LENGTH_SHORT).show();
                }
            }
            
            private void updateToggleButtonUI() {
                if (toggleButton != null) {
                    boolean isEnabled = tripStorage.isAutoDetectionEnabled();
                    if (isEnabled) {
                        toggleButton.setText("ðŸŸ¢ Auto Detection: ON");
                        toggleButton.setBackgroundColor(Color.parseColor("#4CAF50"));
                        toggleButton.setTextColor(Color.WHITE);
                    } else {
                        toggleButton.setText("ðŸ”´ Auto Detection: OFF");
                        toggleButton.setBackgroundColor(Color.parseColor("#757575"));
                        toggleButton.setTextColor(Color.WHITE);
                    }
                }
            }
            
            private void updateTripsDisplay() {
                if (tripsContainer == null) return;
                
                tripsContainer.removeAllViews();
                
                List<Trip> trips = tripStorage.getTrips();
                
                if (trips.isEmpty()) {
                    TextView noTripsText = new TextView(this);
                    if (tripStorage.isApiSyncEnabled()) {
                        noTripsText.setText("No trips yet. API sync will download ALL your historic trips!");
                    } else {
                        noTripsText.setText("No trips yet. Enable auto detection or add a manual trip to get started!");
                    }
                    noTripsText.setTextSize(14);
                    noTripsText.setTextColor(Color.parseColor("#666666"));
                    noTripsText.setGravity(Gravity.CENTER);
                    noTripsText.setPadding(20, 40, 20, 40);
                    tripsContainer.addView(noTripsText);
                    return;
                }
                
                // Show up to 10 recent trips
                int count = Math.min(trips.size(), 10);
                for (int i = 0; i < count; i++) {
                    Trip trip = trips.get(i);
                    View tripView = createTripView(trip);
                    tripsContainer.addView(tripView);
                }
                
                if (trips.size() > 10) {
                    TextView moreText = new TextView(this);
                    moreText.setText("... and " + (trips.size() - 10) + " more trips");
                    moreText.setTextSize(12);
                    moreText.setTextColor(Color.parseColor("#666666"));
                    moreText.setGravity(Gravity.CENTER);
                    moreText.setPadding(20, 10, 20, 10);
                    tripsContainer.addView(moreText);
                }
            }
            
            private View createTripView(Trip trip) {
                LinearLayout tripLayout = new LinearLayout(this);
                tripLayout.setOrientation(LinearLayout.VERTICAL);
                tripLayout.setBackgroundColor(Color.WHITE);
                tripLayout.setPadding(15, 15, 15, 15);
                
                // Add margin between trip cards
                LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
                params.setMargins(0, 0, 0, 10);
                tripLayout.setLayoutParams(params);
                
                // Date and distance header
                TextView headerText = new TextView(this);
                headerText.setText(trip.getFormattedDate() + " â€¢ " + trip.getFormattedDistance());
                headerText.setTextSize(16);
                headerText.setTextColor(Color.parseColor("#1976D2"));
                headerText.setPadding(0, 0, 0, 5);
                tripLayout.addView(headerText);
                
                // Time and duration
                TextView timeText = new TextView(this);
                timeText.setText(trip.getFormattedTime() + " â€¢ " + trip.getFormattedDuration());
                timeText.setTextSize(12);
                timeText.setTextColor(Color.parseColor("#666666"));
                tripLayout.addView(timeText);
                
                // Locations
                TextView locationText = new TextView(this);
                String startLoc = trip.getStartLocation();
                String endLoc = trip.getEndLocation();
                
                if (startLoc.isEmpty() || startLoc.equals("Unknown")) {
                    startLoc = String.format(Locale.getDefault(), "%.4f, %.4f", trip.getStartLatitude(), trip.getStartLongitude());
                }
                if (endLoc.isEmpty() || endLoc.equals("Unknown")) {
                    endLoc = String.format(Locale.getDefault(), "%.4f, %.4f", trip.getEndLatitude(), trip.getEndLongitude());
                }
                
                locationText.setText("From: " + startLoc + "\nTo: " + endLoc);
                locationText.setTextSize(12);
                locationText.setTextColor(Color.parseColor("#333333"));
                locationText.setPadding(0, 5, 0, 5);
                tripLayout.addView(locationText);
                
                // Category and client
                TextView categoryText = new TextView(this);
                String categoryInfo = trip.getCategory();
                if (!trip.getClientName().isEmpty()) {
                    categoryInfo += " â€¢ " + trip.getClientName();
                }
                if (trip.isAutoDetected()) {
                    categoryInfo += " â€¢ Auto-detected";
                }
                categoryText.setText(categoryInfo);
                categoryText.setTextSize(11);
                categoryText.setTextColor(Color.parseColor("#4CAF50"));
                tripLayout.addView(categoryText);
                
                // Notes if available
                if (!trip.getNotes().isEmpty()) {
                    TextView notesText = new TextView(this);
                    notesText.setText("Notes: " + trip.getNotes());
                    notesText.setTextSize(11);
                    notesText.setTextColor(Color.parseColor("#666666"));
                    notesText.setPadding(0, 5, 0, 0);
                    tripLayout.addView(notesText);
                }
                
                return tripLayout;
            }
            
            private void showAddTripDialog() {
                AlertDialog.Builder builder = new AlertDialog.Builder(this);
                builder.setTitle("Add Manual Trip");
                
                // Create input layout
                LinearLayout layout = new LinearLayout(this);
                layout.setOrientation(LinearLayout.VERTICAL);
                layout.setPadding(20, 20, 20, 20);
                
                // Start location
                EditText startLocationInput = new EditText(this);
                startLocationInput.setHint("Start location");
                layout.addView(startLocationInput);
                
                // End location
                EditText endLocationInput = new EditText(this);
                endLocationInput.setHint("End location");
                layout.addView(endLocationInput);
                
                // Distance
                EditText distanceInput = new EditText(this);
                distanceInput.setHint("Distance (miles)");
                distanceInput.setInputType(android.text.InputType.TYPE_CLASS_NUMBER | android.text.InputType.TYPE_NUMBER_FLAG_DECIMAL);
                layout.addView(distanceInput);
                
                // Client name
                EditText clientInput = new EditText(this);
                clientInput.setHint("Client name (optional)");
                layout.addView(clientInput);
                
                // Notes
                EditText notesInput = new EditText(this);
                notesInput.setHint("Notes (optional)");
                layout.addView(notesInput);
                
                builder.setView(layout);
                
                builder.setPositiveButton("Add Trip", (dialog, which) -> {
                    try {
                        String startLocation = startLocationInput.getText().toString().trim();
                        String endLocation = endLocationInput.getText().toString().trim();
                        String distanceStr = distanceInput.getText().toString().trim();
                        String clientName = clientInput.getText().toString().trim();
                        String notes = notesInput.getText().toString().trim();
                        
                        if (startLocation.isEmpty() || endLocation.isEmpty() || distanceStr.isEmpty()) {
                            Toast.makeText(this, "Please fill in start location, end location, and distance", Toast.LENGTH_SHORT).show();
                            return;
                        }
                        
                        double distance = Double.parseDouble(distanceStr);
                        
                        // Create manual trip
                        Trip manualTrip = new Trip();
                        manualTrip.setStartLocation(startLocation);
                        manualTrip.setEndLocation(endLocation);
                        manualTrip.setDistance(distance);
                        manualTrip.setClientName(clientName);
                        manualTrip.setNotes(notes);
                        manualTrip.setAutoDetected(false);
                        manualTrip.setCategory("Business");
                        
                        // Estimate duration based on distance (assuming 30 mph average)
                        long estimatedDuration = (long) (distance / 30.0 * 60 * 60 * 1000);
                        manualTrip.setDuration(estimatedDuration);
                        
                        // Save locally
                        tripStorage.saveTrip(manualTrip);
                        
                        // Backup to cloud if enabled
                        if (tripStorage.isApiSyncEnabled()) {
                            cloudBackup.backupTrip(manualTrip);
                        }
                        
                        updateTripsDisplay();
                        updateUI();
                        
                        Toast.makeText(this, "Manual trip added successfully", Toast.LENGTH_SHORT).show();
                        
                    } catch (NumberFormatException e) {
                        Toast.makeText(this, "Please enter a valid distance", Toast.LENGTH_SHORT).show();
                    } catch (Exception e) {
                        Toast.makeText(this, "Error adding trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                    }
                });
                
                builder.setNegativeButton("Cancel", null);
                builder.show();
            }
            
            private void initializeGPS() {
                try {
                    if (tripStorage.isAutoDetectionEnabled()) {
                        startLocationUpdates();
                    }
                } catch (SecurityException e) {
                    Log.e(TAG, "Location permission denied", e);
                    Toast.makeText(this, "Location permission required for auto detection", Toast.LENGTH_LONG).show();
                }
            }
            
            private void startLocationUpdates() {
                try {
                    if (locationManager != null) {
                        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, MIN_TIME_BW_UPDATES, 
                                                             (float) MIN_DISTANCE_BETWEEN_UPDATES, this);
                        locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, MIN_TIME_BW_UPDATES, 
                                                             (float) MIN_DISTANCE_BETWEEN_UPDATES, this);
                        isTracking = true;
                        Log.d(TAG, "Location updates started");
                    }
                } catch (SecurityException e) {
                    Log.e(TAG, "Location permission denied", e);
                }
            }
            
            private void stopLocationUpdates() {
                if (locationManager != null) {
                    locationManager.removeUpdates(this);
                    isTracking = false;
                    Log.d(TAG, "Location updates stopped");
                }
            }
            
            private void restoreCurrentTrip() {
                currentTrip = tripStorage.getCurrentTrip();
                if (currentTrip != null) {
                    Log.d(TAG, "Restored current trip: " + currentTrip.getId());
                }
            }
            
            private void updateUI() {
                runOnUiThread(() -> {
                    if (statusText != null) {
                        if (currentTrip != null) {
                            statusText.setText("ðŸš— Trip in progress...");
                            statusText.setTextColor(Color.parseColor("#4CAF50"));
                        } else if (tripStorage.isAutoDetectionEnabled()) {
                            statusText.setText("ðŸŽ¯ Auto detection active");
                            statusText.setTextColor(Color.parseColor("#2196F3"));
                        } else {
                            statusText.setText("â¸ï¸ Auto detection off");
                            statusText.setTextColor(Color.parseColor("#757575"));
                        }
                    }
                    
                    if (speedText != null) {
                        speedText.setText(String.format(Locale.getDefault(), "Speed: %.1f mph", currentSpeed));
                    }
                    
                    updateTripsDisplay();
                });
            }
            
            @Override
            public void onLocationChanged(Location location) {
                if (location == null) return;
                
                lastLocationTime = System.currentTimeMillis();
                
                // Calculate speed in mph
                if (location.hasSpeed()) {
                    currentSpeed = location.getSpeed() * 2.237; // m/s to mph
                } else if (lastLocation != null) {
                    // Calculate speed based on distance and time
                    float distance = location.distanceTo(lastLocation);
                    long timeDiff = location.getTime() - lastLocation.getTime();
                    if (timeDiff > 0) {
                        currentSpeed = (distance / (timeDiff / 1000.0)) * 2.237; // m/s to mph
                    }
                }
                
                Log.d(TAG, String.format("Location update: %.6f, %.6f, Speed: %.1f mph", 
                      location.getLatitude(), location.getLongitude(), currentSpeed));
                
                // Auto detection logic
                if (tripStorage.isAutoDetectionEnabled()) {
                    processAutoDetection(location);
                }
                
                lastLocation = location;
                updateUI();
            }
            
            private void processAutoDetection(Location location) {
                if (currentTrip == null) {
                    // Not in a trip - check if we should start one
                    if (currentSpeed >= TRIP_START_SPEED) {
                        consecutiveMovingReadings++;
                        consecutiveStationaryReadings = 0;
                        
                        if (consecutiveMovingReadings >= 3) {
                            startNewTrip(location);
                        }
                    } else {
                        consecutiveMovingReadings = 0;
                        consecutiveStationaryReadings++;
                    }
                } else {
                    // In a trip - check if we should end it
                    updateCurrentTrip(location);
                    
                    if (currentSpeed <= TRIP_END_SPEED) {
                        consecutiveStationaryReadings++;
                        consecutiveMovingReadings = 0;
                        
                        if (consecutiveStationaryReadings >= 4) {
                            endCurrentTrip();
                        }
                    } else {
                        consecutiveStationaryReadings = 0;
                        consecutiveMovingReadings++;
                    }
                }
            }
            
            private void startNewTrip(Location location) {
                currentTrip = new Trip();
                currentTrip.setStartLatitude(location.getLatitude());
                currentTrip.setStartLongitude(location.getLongitude());
                currentTrip.setStartTime(System.currentTimeMillis());
                currentTrip.setAutoDetected(true);
                
                // Try to get address
                getAddressAsync(location.getLatitude(), location.getLongitude(), address -> {
                    if (currentTrip != null) {
                        currentTrip.setStartLocation(address);
                        tripStorage.setCurrentTrip(currentTrip);
                    }
                });
                
                tripStorage.setCurrentTrip(currentTrip);
                
                consecutiveMovingReadings = 0;
                consecutiveStationaryReadings = 0;
                
                Log.d(TAG, "ðŸš€ New trip started: " + currentTrip.getId());
                Toast.makeText(this, "ðŸš€ Trip started automatically", Toast.LENGTH_SHORT).show();
            }
            
            private void updateCurrentTrip(Location location) {
                if (currentTrip == null) return;
                
                // Update end location
                currentTrip.setEndLatitude(location.getLatitude());
                currentTrip.setEndLongitude(location.getLongitude());
                currentTrip.setEndTime(System.currentTimeMillis());
                
                // Calculate distance
                if (currentTrip.getStartLatitude() != 0 && currentTrip.getStartLongitude() != 0) {
                    double distance = calculateDistance(
                        currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                        location.getLatitude(), location.getLongitude()
                    );
                    currentTrip.setDistance(distance);
                }
                
                // Calculate duration
                long duration = currentTrip.getEndTime() - currentTrip.getStartTime();
                currentTrip.setDuration(duration);
                
                tripStorage.setCurrentTrip(currentTrip);
            }
            
            private void endCurrentTrip() {
                if (currentTrip == null) return;
                
                // Get end address
                getAddressAsync(currentTrip.getEndLatitude(), currentTrip.getEndLongitude(), address -> {
                    if (currentTrip != null) {
                        currentTrip.setEndLocation(address);
                        
                        // Final save
                        tripStorage.saveTrip(currentTrip);
                        
                        // Backup to cloud if enabled
                        if (tripStorage.isApiSyncEnabled()) {
                            cloudBackup.backupTrip(currentTrip);
                        }
                        
                        Log.d(TAG, "ðŸ Trip completed: " + currentTrip.getFormattedDistance() + " in " + currentTrip.getFormattedDuration());
                        
                        runOnUiThread(() -> {
                            Toast.makeText(this, "ðŸ Trip completed: " + currentTrip.getFormattedDistance(), Toast.LENGTH_LONG).show();
                            updateTripsDisplay();
                        });
                    }
                });
                
                // Clear current trip
                currentTrip = null;
                tripStorage.setCurrentTrip(null);
                
                consecutiveMovingReadings = 0;
                consecutiveStationaryReadings = 0;
            }
            
            private void getAddressAsync(double latitude, double longitude, AddressCallback callback) {
                executor.execute(() -> {
                    try {
                        if (geocoder != null) {
                            List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                            if (addresses != null && !addresses.isEmpty()) {
                                Address address = addresses.get(0);
                                String addressText = address.getAddressLine(0);
                                if (addressText != null) {
                                    mainHandler.post(() -> callback.onAddressReceived(addressText));
                                    return;
                                }
                            }
                        }
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting address", e);
                    }
                    
                    // Fallback to coordinates
                    mainHandler.post(() -> callback.onAddressReceived(
                        String.format(Locale.getDefault(), "%.4f, %.4f", latitude, longitude)
                    ));
                });
            }
            
            private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                final int R = 6371; // Radius of the Earth in km
                double latDistance = Math.toRadians(lat2 - lat1);
                double lonDistance = Math.toRadians(lon2 - lon1);
                double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                        + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                        * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                double distance = R * c; // Distance in km
                return distance * 0.621371; // Convert to miles
            }
            
            private interface AddressCallback {
                void onAddressReceived(String address);
            }
            
            @Override
            public void onStatusChanged(String provider, int status, Bundle extras) {
                Log.d(TAG, "Provider " + provider + " status changed to " + status);
            }
            
            @Override
            public void onProviderEnabled(String provider) {
                Log.d(TAG, "Provider " + provider + " enabled");
            }
            
            @Override
            public void onProviderDisabled(String provider) {
                Log.d(TAG, "Provider " + provider + " disabled");
            }
            
            @Override
            protected void onDestroy() {
                super.onDestroy();
                if (locationManager != null) {
                    locationManager.removeUpdates(this);
                }
                if (executor != null) {
                    executor.shutdown();
                }
            }
        }
        EOF

    - name: Generate keystore
      run: |
        keytool -genkeypair -v -keystore android/app/debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000 -dname "CN=Android Debug,O=Android,C=US"

    - name: Build APK
      run: |
        cd android
        chmod +x gradlew
        ./gradlew clean assembleRelease --no-daemon --stacktrace

    - name: Sign APK
      run: |
        cd android/app/build/outputs/apk/release
        mv app-release-unsigned.apk app-release-signed.apk
        echo "APK signed successfully"

    - name: Upload APK
      uses: actions/upload-artifact@v3
      with:
        name: MileTracker-Pro-v4.9.73
        path: android/app/build/outputs/apk/release/app-release-signed.apk
        retention-days: 30

    - name: APK Info
      run: |
        APK_PATH="android/app/build/outputs/apk/release/app-release-signed.apk"
        if [ -f "$APK_PATH" ]; then
          echo "âœ… APK generated successfully!"
          echo "ðŸ“ Size: $(du -h "$APK_PATH" | cut -f1)"
          echo "ðŸ“± Ready for installation"
        else
          echo "âŒ APK not found"
          exit 1
        fi
