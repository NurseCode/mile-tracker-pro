name: Build AAB for Google Play Store

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create Gradle wrapper
        run: |
          cat > android/gradle/wrapper/gradle-wrapper.properties << 'EOF'
          distributionBase=GRADLE_USER_HOME
          distributionPath=wrapper/dists
          distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-all.zip
          zipStoreBase=GRADLE_USER_HOME
          zipStorePath=wrapper/dists
          EOF

      - name: Create Gradle wrapper JAR
        run: |
          mkdir -p android/gradle/wrapper
          curl -L https://github.com/gradle/gradle/raw/v8.6.0/gradle/wrapper/gradle-wrapper.jar -o android/gradle/wrapper/gradle-wrapper.jar

      - name: Create gradlew script
        run: |
          cat > android/gradlew << 'EOF'
          #!/bin/sh

          APP_NAME="Gradle"
          APP_BASE_NAME=`basename "$0"`

          DEFAULT_JVM_OPTS="-Xmx1024m -Xms256m"

          die () {
              echo
              echo "$*"
              echo
              exit 1
          }

          if [ -n "$JAVA_HOME" ] ; then
              if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
                  JAVACMD="$JAVA_HOME/jre/sh/java"
              else
                  JAVACMD="$JAVA_HOME/bin/java"
              fi
              if [ ! -x "$JAVACMD" ] ; then
                  die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME"
              fi
          else
              JAVACMD="java"
              which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH."
          fi

          SAVED="`pwd`"
          cd "`dirname \"$0\"`/" >/dev/null
          APP_HOME="`pwd -P`"
          cd "$SAVED" >/dev/null

          CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

          exec "$JAVACMD" $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS -Dorg.gradle.appname=$APP_BASE_NAME -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
          EOF

          chmod +x android/gradlew

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create gradle.properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.enableR8.fullMode=false
          EOF

      - name: Create root build.gradle
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              ext {
                  buildToolsVersion = "34.0.0"
                  minSdkVersion = 24
                  compileSdkVersion = 35
                  targetSdkVersion = 35
              }
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath("com.android.tools.build:gradle:8.1.4")
              }
          }

          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create consistent signing keystore
        run: |
          cd android/app
          # Remove existing keystore if it exists
          rm -f miletracker.keystore
          # Create new keystore with consistent credentials and date
          keytool -genkey -v -keystore miletracker.keystore -alias miletracker -keyalg RSA -keysize 2048 -validity 10000 -storepass miletracker123 -keypass miletracker123 -dname "CN=MileTracker Pro, OU=Development, O=MileTracker Pro LLC, L=Charlotte, S=NC, C=US"

      - name: Create app/build.gradle
        run: |
          cat > android/app/build.gradle << 'EOF'
          plugins {
              id 'com.android.application'
          }

          android {
              namespace 'com.miletrackerpro.app'
              compileSdk 35

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdk 24
                  targetSdk 35
                  versionCode 49156
                  versionName "4.9.156"
              }

              signingConfigs {
                  release {
                      storeFile file("miletracker.keystore")
                      storePassword "miletracker123"
                      keyAlias "miletracker"
                      keyPassword "miletracker123"
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      debuggable false
                      signingConfig signingConfigs.release
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_1_8
                  targetCompatibility JavaVersion.VERSION_1_8
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }
          }

          configurations.all {
              resolutionStrategy {
                  force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                  force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core:1.12.0'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'com.android.billingclient:billing:6.1.0'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
              implementation 'org.json:json:20231013'
              implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
              implementation 'com.itextpdf:itext7-core:7.2.5'
              implementation 'androidx.work:work-runtime:2.8.1'
          }
          EOF

      - name: Create AndroidManifest.xml
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
              <uses-permission android:name="android.permission.READ_PHONE_STATE" />
              
              <!-- Legacy Bluetooth permissions for Android 11 and below -->
              <uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
              
              <!-- New Android 12+ Bluetooth permissions -->
              <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
              <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
              <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
              <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES" android:usesPermissionFlags="neverForLocation" />
              
              <!-- Boot and battery optimization permissions for persistent GPS service -->
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
              <uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
              
              <!-- Bluetooth hardware feature requirements -->
              <uses-feature android:name="android.hardware.bluetooth" android:required="false"/>
              <uses-feature android:name="android.hardware.bluetooth_le" android:required="false"/>

              <application
                  android:allowBackup="true"
                  android:icon="@drawable/ic_launcher"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:networkSecurityConfig="@xml/network_security_config"
                  android:usesCleartextTraffic="true">

                  <activity
                      android:name=".auth.AuthActivity"
                      android:exported="true"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <activity
                      android:name=".MainActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <activity
                      android:name=".auth.DataRecoveryActivity"
                      android:exported="false"
                      android:launchMode="singleTop"
                      android:screenOrientation="portrait">
                  </activity>

                  <service
                      android:name=".services.AutoDetectionService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.ManualTripService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <provider
                      android:name="androidx.core.content.FileProvider"
                      android:authorities="${applicationId}.fileprovider"
                      android:exported="false"
                      android:grantUriPermissions="true">
                      <meta-data
                          android:name="android.support.FILE_PROVIDER_PATHS"
                          android:resource="@xml/file_paths" />
                  </provider>

                  <!-- Bluetooth Discovery BroadcastReceiver -->
                  <receiver android:name=".BluetoothDiscoveryReceiver" android:exported="false">
                      <intent-filter>
                          <action android:name="android.bluetooth.device.action.FOUND" />
                          <action android:name="android.bluetooth.adapter.action.DISCOVERY_STARTED" />
                          <action android:name="android.bluetooth.adapter.action.DISCOVERY_FINISHED" />
                      </intent-filter>
                  </receiver>

                  <!-- Boot Completed Receiver to restart GPS service after phone restart -->
                  <receiver android:name=".BootCompletedReceiver" android:exported="true" android:enabled="true">
                      <intent-filter>
                          <action android:name="android.intent.action.BOOT_COMPLETED" />
                          <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED" />
                          <action android:name="android.intent.action.QUICKBOOT_POWERON" />
                      </intent-filter>
                  </receiver>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">mileage-tracker-codenurse.replit.app</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
              </domain-config>
              <base-config cleartextTrafficPermitted="false">
                  <trust-anchors>
                      <certificates src="system"/>
                  </trust-anchors>
              </base-config>
          </network-security-config>
          EOF

          cat > android/app/src/main/res/xml/file_paths.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <paths xmlns:android="http://schemas.android.com/apk/res/android">
              <files-path name="files" path="." />
              <cache-path name="cache" path="." />
              <external-files-path name="external_files" path="." />
              <external-cache-path name="external_cache" path="." />
          </paths>
          EOF

      - name: Create app resources
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">#1A365D</item>
                  <item name="colorPrimaryDark">#0F1F3D</item>
                  <item name="colorAccent">#1A365D</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="auto_detection_notification">Auto trip detection active</string>
              <string name="trip_in_progress_notification">Trip in progress</string>
              <string name="manual_trip_notification">Manual trip recording</string>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <resources>
              <color name="primary">#1A365D</color>
              <color name="primary_dark">#0F1F3D</color>
              <color name="accent">#1A365D</color>
              <color name="white">#FFFFFF</color>
              <color name="black">#000000</color>
              <color name="success">#27AE60</color>
              <color name="danger">#E74C3C</color>
              <color name="warning">#F39C12</color>
              <color name="tab_active">#1A365D</color>
              <color name="tab_inactive">#9CA3AF</color>
              <color name="background">#f5f5f5</color>
              <color name="card_background">#ffffff</color>
              <color name="text_primary">#495057</color>
              <color name="text_secondary">#6C757D</color>
          </resources>
          EOF

      - name: Create BluetoothVehicleService as Android Background Service
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BluetoothVehicleService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.PendingIntent;
          import android.app.Service;
          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothClass;
          import android.bluetooth.BluetoothDevice;
          import android.bluetooth.BluetoothManager;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.os.Handler;
          import android.os.IBinder;
          import android.os.Looper;
          import android.util.Log;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.MainActivity;
          import org.json.JSONException;
          import org.json.JSONObject;
          import java.util.HashMap;
          import java.util.Iterator;
          import java.util.Map;
          import java.util.Set;

          public class BluetoothVehicleService extends Service {
              private static final String TAG = "BluetoothVehicleService";
              private static final String PREFS_NAME = "BluetoothVehiclePrefs";
              private static final String VEHICLE_REGISTRY_KEY = "vehicle_registry";
              private static final String CHANNEL_ID = "BluetoothVehicleService";
              private static final int NOTIFICATION_ID = 1001;
              
              private BluetoothAdapter bluetoothAdapter;
              private SharedPreferences prefs;
              private Handler handler;
              private Map<String, VehicleInfo> vehicleRegistry = new HashMap<>();
              private VehicleInfo currentVehicle;
              private boolean isScanning = false;
              private boolean autoDetectionEnabled = false;
              private BroadcastReceiver bluetoothReceiver;
              
              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }
              
              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "BluetoothVehicleService onCreate");
                  
                  // Debug: Service created
                  Intent createIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  createIntent.putExtra("message", "🔵 BluetoothVehicleService created");
                  sendBroadcast(createIntent);
                  
                  handler = new Handler(Looper.getMainLooper());
                  prefs = getSharedPreferences(PREFS_NAME, MODE_PRIVATE);
                  loadVehicleRegistry();
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
                  if (bluetoothManager != null) {
                      bluetoothAdapter = bluetoothManager.getAdapter();
                  }
                  
                  createNotificationChannel();
                  registerBluetoothReceiver();
              }
              
              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  Log.d(TAG, "BluetoothVehicleService onStartCommand");
                  
                  // Debug: Service command received
                  Intent cmdIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  cmdIntent.putExtra("message", "🔵 BluetoothVehicleService onStartCommand received");
                  sendBroadcast(cmdIntent);
                  
                  if (intent != null) {
                      String action = intent.getAction();
                      
                      // Debug: Action received
                      Intent actionIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                      actionIntent.putExtra("message", "🔵 Action received: " + action);
                      sendBroadcast(actionIntent);
                      
                      if ("START_BLUETOOTH_MONITORING".equals(action)) {
                          startForeground(NOTIFICATION_ID, createNotification("Monitoring for vehicle connections..."));
                          startBluetoothMonitoring();
                      } else if ("STOP_BLUETOOTH_MONITORING".equals(action)) {
                          stopBluetoothMonitoring();
                          stopForeground(true);
                          stopSelf();
                      } else if ("REGISTER_VEHICLE".equals(action)) {
                          String deviceName = intent.getStringExtra("deviceName");
                          String macAddress = intent.getStringExtra("macAddress");
                          String vehicleType = intent.getStringExtra("vehicleType");
                          registerVehicle(deviceName, macAddress, vehicleType);
                      }
                  }
                  
                  return START_STICKY;
              }
              
              @Override
              public void onDestroy() {
                  Log.d(TAG, "BluetoothVehicleService onDestroy");
                  stopBluetoothMonitoring();
                  unregisterBluetoothReceiver();
                  super.onDestroy();
              }
              
              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel serviceChannel = new NotificationChannel(
                          CHANNEL_ID, "Bluetooth Vehicle Service", NotificationManager.IMPORTANCE_LOW);
                      serviceChannel.setDescription("Monitors Bluetooth connections for automatic trip detection");
                      
                      NotificationManager manager = getSystemService(NotificationManager.class);
                      if (manager != null) {
                          manager.createNotificationChannel(serviceChannel);
                      }
                  }
              }
              
              private Notification createNotification(String contentText) {
                  Intent notificationIntent = new Intent(this, MainActivity.class);
                  PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent,
                      PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
                  
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle("MileTracker Pro - Vehicle Monitor")
                      .setContentText(contentText)
                      .setSmallIcon(android.R.drawable.ic_dialog_info)
                      .setContentIntent(pendingIntent)
                      .setOngoing(true)
                      .build();
              }
              
              private void startBluetoothMonitoring() {
                  Log.d(TAG, "Starting Bluetooth monitoring");
                  
                  // Send debug toast to MainActivity
                  Intent debugIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  debugIntent.putExtra("message", "🔵 Bluetooth Discovery: Starting...");
                  sendBroadcast(debugIntent);
                  
                  if (bluetoothAdapter == null) {
                      Log.w(TAG, "Bluetooth adapter is null");
                      Intent errorIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                      errorIntent.putExtra("message", "🔴 Bluetooth adapter is null");
                      sendBroadcast(errorIntent);
                      return;
                  }
                  
                  if (!bluetoothAdapter.isEnabled()) {
                      Log.w(TAG, "Bluetooth is disabled");
                      Intent errorIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                      errorIntent.putExtra("message", "🔴 Bluetooth is disabled");
                      sendBroadcast(errorIntent);
                      return;
                  }
                  
                  autoDetectionEnabled = true;
                  
                  // Confirm successful start
                  Log.d(TAG, "Bluetooth monitoring started successfully");
                  Intent successIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  successIntent.putExtra("message", "🟢 Bluetooth Discovery: Started successfully");
                  sendBroadcast(successIntent);
                  
                  startPeriodicScanning();
              }
              
              private void stopBluetoothMonitoring() {
                  Log.d(TAG, "Stopping Bluetooth monitoring");
                  autoDetectionEnabled = false;
                  isScanning = false;
                  
                  if (handler != null) {
                      handler.removeCallbacksAndMessages(null);
                  }
              }
              
              private void startPeriodicScanning() {
                  if (!autoDetectionEnabled || isScanning) return;
                  
                  isScanning = true;
                  Log.d(TAG, "Starting periodic Bluetooth scanning");
                  
                  // Debug: Confirm scanning started
                  Intent scanIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                  scanIntent.putExtra("message", "🔍 Bluetooth scanning started");
                  sendBroadcast(scanIntent);
                  
                  handler.postDelayed(() -> {
                      if (autoDetectionEnabled) {
                          Intent checkIntent = new Intent("com.miletrackerpro.DEBUG_MESSAGE");
                          checkIntent.putExtra("message", "🔍 Checking Bluetooth connections...");
                          sendBroadcast(checkIntent);
                          
                          checkBluetoothConnections();
                          isScanning = false;
                          startPeriodicScanning();
                      }
                  }, 30 * 1000); // 30 seconds for more frequent checking
              }
              
              private void registerBluetoothReceiver() {
                  bluetoothReceiver = new BroadcastReceiver() {
                      @Override
                      public void onReceive(Context context, Intent intent) {
                          String action = intent.getAction();
                          Log.d(TAG, "Bluetooth broadcast received: " + action);
                          
                          if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
                              BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                              if (device != null) {
                                  onDeviceConnected(device);
                              }
                          } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                              BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                              if (device != null) {
                                  onDeviceDisconnected(device);
                              }
                          }
                      }
                  };
                  
                  IntentFilter filter = new IntentFilter();
                  filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
                  filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
                  registerReceiver(bluetoothReceiver, filter);
              }
              
              private void unregisterBluetoothReceiver() {
                  if (bluetoothReceiver != null) {
                      try {
                          unregisterReceiver(bluetoothReceiver);
                      } catch (IllegalArgumentException e) {
                          Log.d(TAG, "Bluetooth receiver already unregistered");
                      }
                  }
              }
              
              private void checkBluetoothConnections() {
                  Log.d(TAG, "Checking Bluetooth connections");
                  
                  if (bluetoothAdapter == null || !bluetoothAdapter.isEnabled()) {
                      Log.d(TAG, "Bluetooth not available or disabled");
                      return;
                  }
                  
                  // Declare toast intent once for reuse
                  Intent toastIntent;
                  
                  Set<BluetoothDevice> bondedDevices = bluetoothAdapter.getBondedDevices();
                  Log.d(TAG, "Found " + bondedDevices.size() + " bonded devices");
                  
                  for (BluetoothDevice device : bondedDevices) {
                      String deviceName = device.getName();
                      String macAddress = device.getAddress();
                      
                      Log.d(TAG, "Checking device: " + deviceName + " (" + macAddress + ")");
                      
                      // UConnect debug logging
                      if (deviceName != null && deviceName.toLowerCase().contains("uconnect")) {
                          Log.d(TAG, "🚗 UCONNECT DEVICE FOUND: " + deviceName + " (" + macAddress + ")");
                          // CRITICAL DIAGNOSTIC: Toast notification for UConnect detection
                          toastIntent = new Intent("com.miletrackerpro.SHOW_TOAST");
                          toastIntent.putExtra("message", "🚗 UConnect detected: " + deviceName);
                          sendBroadcast(toastIntent);
                      }
                      
                      if (vehicleRegistry.containsKey(device.getAddress())) {
                          // Handle registered vehicles
                          try {
                              boolean isConnected = (boolean) device.getClass().getMethod("isConnected").invoke(device);
                              Log.d(TAG, "Registered vehicle " + deviceName + " connected: " + isConnected);
                              if (isConnected && currentVehicle == null) {
                                  onDeviceConnected(device);
                              }
                          } catch (Exception e) {
                              Log.d(TAG, "Could not check connection status for registered vehicle");
                          }
                      } else {
                          // Handle potential new vehicles
                          if (deviceName != null && isLikelyVehicleDevice(device)) {
                              Log.d(TAG, "Found potential new vehicle: " + deviceName);
                              // CRITICAL DIAGNOSTIC: Toast notification for vehicle detection
                              toastIntent = new Intent("com.miletrackerpro.SHOW_TOAST");
                              toastIntent.putExtra("message", "🚗 Vehicle detected: " + deviceName);
                              sendBroadcast(toastIntent);
                              try {
                                  boolean isConnected = (boolean) device.getClass().getMethod("isConnected").invoke(device);
                                  Log.d(TAG, "New vehicle " + deviceName + " connected: " + isConnected);
                                  
                                  if (isConnected) {
                                      Log.d(TAG, "New vehicle device connected and bonded: " + deviceName);
                                      
                                      // Send broadcast intent to trigger registration dialog
                                      Log.d(TAG, "Sending NEW_VEHICLE_DETECTED broadcast for: " + deviceName);
                                      Intent broadcastIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                                      broadcastIntent.putExtra("deviceName", deviceName);
                                      broadcastIntent.putExtra("macAddress", macAddress);
                                      sendBroadcast(broadcastIntent);
                                      Log.d(TAG, "NEW_VEHICLE_DETECTED broadcast sent for: " + deviceName);
                                      // CRITICAL DIAGNOSTIC: Toast notification for broadcast sent
                                      toastIntent = new Intent("com.miletrackerpro.SHOW_TOAST");
                                      toastIntent.putExtra("message", "📡 Registration broadcast sent for: " + deviceName);
                                      sendBroadcast(toastIntent);
                                  }
                              } catch (Exception e) {
                                  Log.d(TAG, "Could not check connection status for new vehicle, treating as connected");
                                  // If we can't check connection status, assume it's connected since it's bonded
                                  Log.d(TAG, "New vehicle device assumed connected: " + deviceName);
                                  // CRITICAL DIAGNOSTIC: Toast notification for connection check failure
                                  toastIntent = new Intent("com.miletrackerpro.SHOW_TOAST");
                                  toastIntent.putExtra("message", "⚠️ Connection check failed, assuming connected: " + deviceName);
                                  sendBroadcast(toastIntent);
                                  
                                  Log.d(TAG, "Sending NEW_VEHICLE_DETECTED broadcast for: " + deviceName);
                                  Intent broadcastIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                                  broadcastIntent.putExtra("deviceName", deviceName);
                                  broadcastIntent.putExtra("macAddress", macAddress);
                                  sendBroadcast(broadcastIntent);
                                  Log.d(TAG, "NEW_VEHICLE_DETECTED broadcast sent for: " + deviceName);
                              }
                          } else {
                              Log.d(TAG, "Non-vehicle device ignored: " + deviceName);
                          }
                      }
                  }
              }
              
              private void onDeviceConnected(BluetoothDevice device) {
                  Log.d(TAG, "Device connected: " + device.getName());
                  
                  if (vehicleRegistry.containsKey(device.getAddress())) {
                      VehicleInfo vehicle = vehicleRegistry.get(device.getAddress());
                      currentVehicle = vehicle;
                      
                      updateNotification("Connected to " + vehicle.deviceName);
                      
                      Intent intent = new Intent("com.miletrackerpro.VEHICLE_CONNECTED");
                      intent.putExtra("deviceName", vehicle.deviceName);
                      intent.putExtra("vehicleType", vehicle.vehicleType);
                      sendBroadcast(intent);
                      
                      startAutoDetectionService(vehicle);
                  } else {
                      // Check for new vehicle devices when bonded/paired
                      String deviceName = device.getName();
                      String macAddress = device.getAddress();
                      
                      if (deviceName != null && isLikelyVehicleDevice(device)) {
                          // For new vehicles, check if device is bonded/paired
                          if (device.getBondState() == BluetoothDevice.BOND_BONDED) {
                              Log.d(TAG, "New vehicle device detected: " + deviceName);
                              
                              // Send broadcast intent to trigger registration dialog
                              Log.d(TAG, "Sending NEW_VEHICLE_DETECTED broadcast for: " + deviceName);
                              Intent broadcastIntent = new Intent("com.miletrackerpro.NEW_VEHICLE_DETECTED");
                              broadcastIntent.putExtra("deviceName", deviceName);
                              broadcastIntent.putExtra("macAddress", macAddress);
                              sendBroadcast(broadcastIntent);
                              Log.d(TAG, "NEW_VEHICLE_DETECTED broadcast sent for: " + deviceName);
                          } else {
                              Log.d(TAG, "New vehicle device not bonded, skipping registration: " + deviceName);
                          }
                      } else {
                          Log.d(TAG, "Non-vehicle device connected: " + deviceName);
                      }
                  }
              }
              
              private void onDeviceDisconnected(BluetoothDevice device) {
                  Log.d(TAG, "Device disconnected: " + device.getName());
                  
                  if (currentVehicle != null && device.getAddress().equals(currentVehicle.macAddress)) {
                      updateNotification("Monitoring for vehicle connections...");
                      
                      Intent intent = new Intent("com.miletrackerpro.VEHICLE_DISCONNECTED");
                      intent.putExtra("deviceName", currentVehicle.deviceName);
                      sendBroadcast(intent);
                      
                      // Transition AutoDetectionService to IDLE instead of stopping
                      transitionAutoDetectionToIdle(currentVehicle);
                      currentVehicle = null;
                  }
              }
              
              private void startAutoDetectionService(VehicleInfo vehicle) {
                  Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                  serviceIntent.setAction("START_AUTO_DETECTION");
                  serviceIntent.putExtra("trigger_source", "bluetooth_vehicle");
                  serviceIntent.putExtra("vehicle_name", vehicle.deviceName);
                  serviceIntent.putExtra("bluetooth_triggered", true);
                  
                  // Set Bluetooth trigger flag for trip creation
                  SharedPreferences prefs = getSharedPreferences("BluetoothTripPrefs", Context.MODE_PRIVATE);
                  prefs.edit().putBoolean("bluetooth_triggered", true).apply();
                  Log.d(TAG, "🔵 BLUETOOTH TRIGGER FLAG SET: Next trip will be marked as Bluetooth-triggered");
                  // CRITICAL DIAGNOSTIC: Toast notification for Bluetooth trigger
                  Intent toastIntent = new Intent("com.miletrackerpro.SHOW_TOAST");
                  toastIntent.putExtra("message", "🔵 Bluetooth trigger: Auto-detection starting");
                  sendBroadcast(toastIntent);
                  
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      startForegroundService(serviceIntent);
                  } else {
                      startService(serviceIntent);
                  }
              }
              
              private void transitionAutoDetectionToIdle(VehicleInfo vehicle) {
                  Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                  serviceIntent.setAction("TRANSITION_TO_IDLE");
                  serviceIntent.putExtra("trigger_source", "bluetooth_vehicle");
                  startService(serviceIntent);
              }
              
              private void stopAutoDetectionService(VehicleInfo vehicle) {
                  Intent serviceIntent = new Intent(this, AutoDetectionService.class);
                  serviceIntent.setAction("STOP_AUTO_DETECTION");
                  serviceIntent.putExtra("trigger_source", "bluetooth_vehicle");
                  startService(serviceIntent);
              }
              
              private void updateNotification(String text) {
                  NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
                  if (manager != null) {
                      manager.notify(NOTIFICATION_ID, createNotification(text));
                  }
              }
              
              private void registerVehicle(String deviceName, String macAddress, String vehicleType) {
                  Log.d(TAG, "Registering vehicle: " + deviceName + " (" + vehicleType + ")");
                  
                  VehicleInfo vehicle = new VehicleInfo();
                  vehicle.macAddress = macAddress;
                  vehicle.deviceName = deviceName;
                  vehicle.vehicleType = vehicleType;
                  vehicle.registrationTime = System.currentTimeMillis();
                  
                  vehicleRegistry.put(macAddress, vehicle);
                  saveVehicleRegistry();
                  
                  Intent intent = new Intent("com.miletrackerpro.VEHICLE_REGISTERED");
                  intent.putExtra("deviceName", deviceName);
                  intent.putExtra("macAddress", macAddress);
                  intent.putExtra("vehicleType", vehicleType);
                  sendBroadcast(intent);
                  
                  Log.d(TAG, "Vehicle registered successfully: " + deviceName);
              }
              
              private void loadVehicleRegistry() {
                  try {
                      String registryJson = prefs.getString(VEHICLE_REGISTRY_KEY, "{}");
                      JSONObject registry = new JSONObject(registryJson);
                      
                      Iterator<String> keys = registry.keys();
                      while (keys.hasNext()) {
                          String macAddress = keys.next();
                          JSONObject vehicleJson = registry.getJSONObject(macAddress);
                          VehicleInfo vehicle = new VehicleInfo();
                          vehicle.macAddress = macAddress;
                          vehicle.deviceName = vehicleJson.optString("deviceName", "Unknown");
                          vehicle.vehicleType = vehicleJson.optString("vehicleType", "Personal");
                          vehicle.registrationTime = vehicleJson.optLong("registrationTime", System.currentTimeMillis());
                          
                          vehicleRegistry.put(macAddress, vehicle);
                      }
                      
                      Log.d(TAG, "Vehicle registry loaded: " + vehicleRegistry.size() + " vehicles");
                  } catch (JSONException e) {
                      Log.e(TAG, "Error loading vehicle registry", e);
                  }
              }
              
              private void saveVehicleRegistry() {
                  try {
                      JSONObject registry = new JSONObject();
                      
                      for (Map.Entry<String, VehicleInfo> entry : vehicleRegistry.entrySet()) {
                          VehicleInfo vehicle = entry.getValue();
                          JSONObject vehicleJson = new JSONObject();
                          vehicleJson.put("deviceName", vehicle.deviceName);
                          vehicleJson.put("vehicleType", vehicle.vehicleType);
                          vehicleJson.put("registrationTime", vehicle.registrationTime);
                          
                          registry.put(entry.getKey(), vehicleJson);
                      }
                      
                      prefs.edit().putString(VEHICLE_REGISTRY_KEY, registry.toString()).apply();
                      Log.d(TAG, "Vehicle registry saved: " + vehicleRegistry.size() + " vehicles");
                  } catch (JSONException e) {
                      Log.e(TAG, "Error saving vehicle registry", e);
                  }
              }
              
              private boolean isLikelyVehicleDevice(BluetoothDevice device) {
                  if (device == null) return false;
                  
                  // PRIMARY METHOD: Check Bluetooth device class for car audio
                  if (device.getBluetoothClass() != null) {
                      int deviceClass = device.getBluetoothClass().getDeviceClass();
                      Log.d(TAG, "Device class for " + device.getName() + ": " + deviceClass);
                      
                      // Check for car audio device class (from Stack Overflow article)
                      if (deviceClass == BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO) {
                          Log.d(TAG, "Device " + device.getName() + " identified as car audio via device class");
                          return true;
                      }
                  }
                  
                  // FALLBACK METHOD: Check device name patterns
                  String deviceName = device.getName();
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  
                  // Vehicle infotainment systems
                  if (name.contains("uconnect") || name.contains("sync") || 
                      name.contains("carplay") || name.contains("android auto") ||
                      name.contains("infotainment") || name.contains("multimedia")) {
                      Log.d(TAG, "Device " + deviceName + " identified as vehicle via name pattern");
                      return true;
                  }
                  
                  // Car brand specific systems
                  if (name.contains("bmw") || name.contains("mercedes") || name.contains("audi") ||
                      name.contains("toyota") || name.contains("honda") || name.contains("nissan") ||
                      name.contains("ford") || name.contains("chevy") || name.contains("gm") ||
                      name.contains("volkswagen") || name.contains("hyundai") || name.contains("kia") ||
                      name.contains("lexus") || name.contains("acura") || name.contains("infiniti") ||
                      name.contains("cadillac") || name.contains("buick") || name.contains("lincoln") ||
                      name.contains("mazda") || name.contains("subaru") || name.contains("volvo") ||
                      name.contains("tesla") || name.contains("jeep") || name.contains("dodge") ||
                      name.contains("ram") || name.contains("chrysler")) {
                      Log.d(TAG, "Device " + deviceName + " identified as vehicle via brand name");
                      return true;
                  }
                  
                  // Generic vehicle terms
                  if (name.contains("car") || name.contains("vehicle") || name.contains("auto") ||
                      name.contains("stereo") || name.contains("radio") || name.contains("nav") ||
                      name.contains("navigation") || name.contains("dash") || name.contains("display")) {
                      Log.d(TAG, "Device " + deviceName + " identified as vehicle via generic term");
                      return true;
                  }
                  
                  // Filter out obvious non-vehicle devices
                  if (name.contains("phone") || name.contains("headset") || name.contains("speaker") ||
                      name.contains("buds") || name.contains("airpods") || name.contains("beats") ||
                      name.contains("mouse") || name.contains("keyboard") || name.contains("laptop") ||
                      name.contains("tablet") || name.contains("watch") || name.contains("tv")) {
                      Log.d(TAG, "Device " + deviceName + " excluded as non-vehicle device");
                      return false;
                  }
                  
                  Log.d(TAG, "Device " + deviceName + " does not match vehicle patterns");
                  return false;
              }
              
              public static class VehicleInfo {
                  public String macAddress;
                  public String deviceName;
                  public String vehicleType;
                  public long registrationTime;
                  
                  public boolean isExpired() {
                      if ("Rental".equals(vehicleType)) {
                          return (System.currentTimeMillis() - registrationTime) > (7 * 24 * 60 * 60 * 1000);
                      } else if ("Borrowed".equals(vehicleType)) {
                          return (System.currentTimeMillis() - registrationTime) > (3 * 24 * 60 * 60 * 1000);
                      }
                      return false;
                  }
              }
          }
          EOF

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "BluetoothVehicleService";
              private static final String PREFS_NAME = "bluetooth_vehicle_prefs";

              private Context context;
              private BluetoothAdapter bluetoothAdapter;
              private Map<String, VehicleInfo> vehicleRegistry;
              private VehicleInfo currentVehicle;

              public interface VehicleConnectionListener {
                  void onVehicleConnected(VehicleInfo vehicle);
                  void onVehicleDisconnected(VehicleInfo vehicle);
              }

              private VehicleConnectionListener connectionListener;

              public BluetoothVehicleService(Context context) {
                  this.context = context;
                  this.vehicleRegistry = new HashMap<>();
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
                  this.bluetoothAdapter = bluetoothManager.getAdapter();
                  
                  registerBluetoothReceiver();
              }

              public void setConnectionListener(VehicleConnectionListener listener) {
                  this.connectionListener = listener;
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              private void registerBluetoothReceiver() {
                  IntentFilter filter = new IntentFilter();
                  filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
                  filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
                  context.registerReceiver(bluetoothReceiver, filter);
              }

              private final BroadcastReceiver bluetoothReceiver = new BroadcastReceiver() {
                  @Override
                  public void onReceive(Context context, Intent intent) {
                      String action = intent.getAction();
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      
                      if (device != null && vehicleRegistry.containsKey(device.getAddress())) {
                          VehicleInfo vehicle = vehicleRegistry.get(device.getAddress());
                          
                          if (BluetoothDevice.ACTION_ACL_CONNECTED.equals(action)) {
                              handleVehicleConnected(vehicle);
                          } else if (BluetoothDevice.ACTION_ACL_DISCONNECTED.equals(action)) {
                              handleVehicleDisconnected(vehicle);
                          }
                      }
                  }
              };

              private void handleVehicleConnected(VehicleInfo vehicle) {
                  currentVehicle = vehicle;
                  Log.d(TAG, "Vehicle connected: " + vehicle.deviceName);
                  
                  if (connectionListener != null) {
                      connectionListener.onVehicleConnected(vehicle);
                  }
              }

              private void handleVehicleDisconnected(VehicleInfo vehicle) {
                  if (currentVehicle != null && currentVehicle.macAddress.equals(vehicle.macAddress)) {
                      currentVehicle = null;
                      Log.d(TAG, "Vehicle disconnected: " + vehicle.deviceName);
                      
                      if (connectionListener != null) {
                          connectionListener.onVehicleDisconnected(vehicle);
                      }
                  }
              }

              public void registerVehicle(String macAddress, String deviceName, String vehicleType) {
                  VehicleInfo vehicle = new VehicleInfo(macAddress, deviceName, vehicleType);
                  vehicleRegistry.put(macAddress, vehicle);
                  Log.d(TAG, "Vehicle registered: " + deviceName);
              }

              public void unregisterVehicle(String macAddress) {
                  VehicleInfo vehicle = vehicleRegistry.remove(macAddress);
                  if (vehicle != null) {
                      Log.d(TAG, "Vehicle unregistered: " + vehicle.deviceName);
                  }
              }

              public Map<String, VehicleInfo> getRegisteredVehicles() {
                  return new HashMap<>(vehicleRegistry);
              }

              public VehicleInfo getCurrentVehicle() {
                  return currentVehicle;
              }

              public void destroy() {
                  try {
                      context.unregisterReceiver(bluetoothReceiver);
                  } catch (IllegalArgumentException e) {
                      Log.w(TAG, "Bluetooth receiver already unregistered");
                  }
              }

              public static class VehicleInfo {
                  public String macAddress;
                  public String deviceName;
                  public String vehicleType;
                  public String suggestedCategory;

                  public VehicleInfo(String macAddress, String deviceName, String vehicleType) {
                      this.macAddress = macAddress;
                      this.deviceName = deviceName;
                      this.vehicleType = vehicleType;
                      this.suggestedCategory = "Business".equals(vehicleType) ? "Business" : "Personal";
                  }
              }
          }
          EOF

      - name: Create red car icon
        run: |
          mkdir -p android/app/src/main/res/drawable
          cat > android/app/src/main/res/drawable/ic_launcher.xml << 'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="24dp"
              android:height="24dp"
              android:viewportWidth="24.0"
              android:viewportHeight="24.0">
              <path
                  android:fillColor="#dc3545"
                  android:pathData="M18.92,6.01C18.72,5.42 18.16,5 17.5,5h-11C5.84,5 5.28,5.42 5.08,6.01L3,12v8c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-1h12v1c0,0.55 0.45,1 1,1h1c0.55,0 1,-0.45 1,-1v-8L18.92,6.01zM6.5,16C5.67,16 5,15.33 5,14.5S5.67,13 6.5,13S8,13.67 8,14.5S7.33,16 6.5,16zM17.5,16c-0.83,0 -1.5,-0.67 -1.5,-1.5s0.67,-1.5 1.5,-1.5s1.5,0.67 1.5,1.5S18.33,16 17.5,16zM5,11l1.5,-4.5h11L19,11H5z"/>
          </vector>
          EOF

      - name: Create DeviceIdentification utility for stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/DeviceIdentification.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;

          import java.security.MessageDigest;
          import java.util.UUID;

          public class DeviceIdentification {
              private static final String TAG = "DeviceIdentification";
              private static final String PREFS_NAME = "DeviceIdentificationPrefs";
              private static final String STABLE_DEVICE_ID_KEY = "stable_device_id";
              private static final String USER_ID_KEY = "user_id";

              public static String getStableDeviceId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String stableId = prefs.getString(STABLE_DEVICE_ID_KEY, null);

                  if (stableId == null) {
                      stableId = generateStableDeviceId(context);
                      prefs.edit().putString(STABLE_DEVICE_ID_KEY, stableId).apply();
                      Log.d(TAG, "Generated new stable device ID: " + stableId);
                  }

                  return stableId;
              }

              public static String getUserId(Context context) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String userId = prefs.getString(USER_ID_KEY, null);

                  if (userId == null) {
                      userId = generateUserId(context);
                      prefs.edit().putString(USER_ID_KEY, userId).apply();
                      Log.d(TAG, "Generated new user ID: " + userId);
                  }

                  return userId;
              }

              private static String generateStableDeviceId(Context context) {
                  try {
                      // Use Android ID (persists across app installs but not device resets)
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);

                      // Create a stable identifier using device characteristics
                      String deviceInfo = androidId + "-" + Build.MODEL + "-" + Build.MANUFACTURER;

                      // Hash it to create a consistent device ID
                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(deviceInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "device-" + hexString.toString().substring(0, 16);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating stable device ID", e);
                      // Fallback to random UUID if all else fails
                      return "device-" + UUID.randomUUID().toString().replace("-", "").substring(0, 16);
                  }
              }

              private static String generateUserId(Context context) {
                  try {
                      // Create a user ID that's stable across app installs
                      String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                      String userInfo = androidId + "-user-" + Build.MODEL;

                      MessageDigest digest = MessageDigest.getInstance("SHA-256");
                      byte[] hash = digest.digest(userInfo.getBytes());

                      StringBuilder hexString = new StringBuilder();
                      for (byte b : hash) {
                          String hex = Integer.toHexString(0xff & b);
                          if (hex.length() == 1) {
                              hexString.append('0');
                          }
                          hexString.append(hex);
                      }

                      return "user-" + hexString.toString().substring(0, 12);

                  } catch (Exception e) {
                      Log.e(TAG, "Error generating user ID", e);
                      return "user-" + UUID.randomUUID().toString().replace("-", "").substring(0, 12);
                  }
              }
          }
          EOF

      - name: Copy BillingManager for Google Play in-app purchases
        run: |
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          cp BillingManager.java android/app/src/main/java/com/miletrackerpro/app/utils/BillingManager.java
          echo "✅ Using BillingManager.java with Google Play Billing integration"
          echo "  - Monthly subscription: $4.99/month (premium_monthly)"
          echo "  - Yearly subscription: $50/year (premium_yearly)"
          echo "  - Backend sync with purchase verification endpoint"

      - name: Create OkHttp UserAuthManager for real API authentication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserAuthManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.net.ConnectivityManager;
          import android.net.NetworkInfo;
          import android.os.Build;
          import android.provider.Settings;
          import android.util.Log;
          import okhttp3.*;
          import okhttp3.logging.HttpLoggingInterceptor;
          import org.json.JSONObject;
          import java.io.IOException;
          import java.security.MessageDigest;
          import java.security.SecureRandom;
          import java.util.UUID;
          import java.util.concurrent.TimeUnit;

          public class UserAuthManager {
              private static final String TAG = "UserAuthManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String KEY_USER_EMAIL = "user_email";
              private static final String KEY_AUTH_TOKEN = "auth_token";
              private static final String KEY_USER_ID = "user_id";
              private static final String KEY_DEVICE_EMAIL = "device_email";
              private static final String KEY_DEVICE_NAME = "device_name";
              private static final String KEY_SESSION_TOKEN = "session_token";
              
              private Context context;
              private SharedPreferences prefs;
              private OkHttpClient okHttpClient;
              
              // API endpoints - corrected production URL
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app";
              private static final String LOGIN_ENDPOINT = "/api/auth/login";
              private static final String REGISTER_ENDPOINT = "/api/register";
              
              public UserAuthManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  
                  // Initialize OkHttp with logging (from working version)
                  HttpLoggingInterceptor logging = new HttpLoggingInterceptor(message -> {
                      Log.d(TAG, "OkHttp: " + message);
                  });
                  logging.setLevel(HttpLoggingInterceptor.Level.HEADERS);
                  
                  this.okHttpClient = new OkHttpClient.Builder()
                      .addInterceptor(logging)
                      .connectTimeout(15, TimeUnit.SECONDS)
                      .readTimeout(15, TimeUnit.SECONDS)
                      .writeTimeout(15, TimeUnit.SECONDS)
                      .build();
              }
              
              public boolean loginWithOkHttp(String email, String password) {
                  Log.d(TAG, "🔐 OKHTTP LOGIN for: '" + email + "'");
                  Log.d(TAG, "Password received: '" + password + "' (length: " + (password != null ? password.length() : "null") + ")");
                  Log.d(TAG, "Target URL: " + API_BASE_URL + LOGIN_ENDPOINT);
                  
                  // Log network state
                  logNetworkState();
                  
                  try {
                      // Create JSON payload
                      JSONObject loginData = new JSONObject();
                      loginData.put("email", email);
                      loginData.put("password", password);
                      Log.d(TAG, "JSON payload: " + loginData.toString());
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          loginData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + LOGIN_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      Log.d(TAG, "🌐 OkHttp Request URL: " + request.url());
                      Log.d(TAG, "🌐 OkHttp Request Headers: " + request.headers());
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "🌐 OkHttp Response code: " + response.code());
                          Log.d(TAG, "🌐 OkHttp Response message: " + response.message());
                          Log.d(TAG, "🌐 OkHttp Response headers: " + response.headers());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "🌐 OkHttp Response body: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              boolean success = responseJson.optBoolean("success", false);
                              Log.d(TAG, "OkHttp response success field: " + success);
                              
                              if (success) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  String userId = responseJson.optString("userId", "");
                                  
                                  Log.d(TAG, "OkHttp token received: " + (token.isEmpty() ? "empty" : "[" + token.length() + " chars]"));
                                  Log.d(TAG, "OkHttp user ID: '" + userId + "'");
                                  
                                  // Generate device information for family sharing
                                  String deviceEmail = email; // Use login email for device identification
                                  String deviceName = buildDeviceName();
                                  String sessionToken = generateSessionToken();
                                  
                                  Log.d(TAG, "Multi-device info - Email: " + deviceEmail + ", Device: " + deviceName);
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .putString(KEY_DEVICE_EMAIL, deviceEmail)
                                       .putString(KEY_DEVICE_NAME, deviceName)
                                       .putString(KEY_SESSION_TOKEN, sessionToken)
                                       .apply();
                                  
                                  Log.d(TAG, "✅ OKHTTP login successful for: " + email);
                                  return true;
                              } else {
                                  String message = responseJson.optString("message", "Unknown error");
                                  Log.d(TAG, "❌ OKHTTP login failed - success=false, message: " + message);
                              }
                          } else {
                              String errorBody = "";
                              try {
                                  errorBody = response.body().string();
                              } catch (Exception ex) {
                                  Log.d(TAG, "Could not read OkHttp error response: " + ex.getMessage());
                              }
                              Log.d(TAG, "❌ OKHTTP login failed - HTTP " + response.code() + ", Error body: " + errorBody);
                          }
                      }
                      
                      return false;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP login exception: " + e.getClass().getSimpleName() + ": " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public boolean registerWithOkHttp(String email, String password, String name) {
                  Log.d(TAG, "📝 OKHTTP registration for: " + email);
                  
                  try {
                      // Create JSON payload
                      JSONObject registerData = new JSONObject();
                      registerData.put("email", email);
                      registerData.put("password", password);
                      registerData.put("name", name);
                      
                      // Create request body
                      RequestBody body = RequestBody.create(
                          registerData.toString(), 
                          MediaType.get("application/json; charset=utf-8")
                      );
                      
                      // Build request
                      Request request = new Request.Builder()
                          .url(API_BASE_URL + REGISTER_ENDPOINT)
                          .post(body)
                          .addHeader("Content-Type", "application/json")
                          .addHeader("User-Agent", "MileTrackerPro-OkHttp/4.9.91 (Android)")
                          .addHeader("X-HTTP-Stack", "OkHttp")
                          .build();
                      
                      // Execute request
                      try (Response response = okHttpClient.newCall(request).execute()) {
                          Log.d(TAG, "OKHTTP registration response code: " + response.code());
                          
                          if (response.isSuccessful()) {
                              String responseString = response.body().string();
                              Log.d(TAG, "OKHTTP registration response: " + responseString);
                              
                              // Parse response
                              JSONObject responseJson = new JSONObject(responseString);
                              if (responseJson.optBoolean("success", false)) {
                                  // Save authentication data
                                  String token = responseJson.optString("token", "");
                                  String userId = responseJson.optString("userId", "");
                                  
                                  prefs.edit()
                                       .putString(KEY_USER_EMAIL, email)
                                       .putString(KEY_AUTH_TOKEN, token)
                                       .putString(KEY_USER_ID, userId)
                                       .apply();
                                  
                                  Log.d(TAG, "✅ OKHTTP registration successful for: " + email);
                                  return true;
                              }
                          }
                          
                          Log.d(TAG, "❌ OKHTTP registration failed - HTTP " + response.code());
                          return false;
                      }
                      
                  } catch (Exception e) {
                      Log.e(TAG, "OKHTTP registration error: " + e.getMessage(), e);
                      return false;
                  }
              }
              
              public String getNetworkDiagnostics() {
                  StringBuilder info = new StringBuilder();
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          info.append("Network Type: ").append(activeNetwork.getTypeName()).append("\n");
                          info.append("Connected: ").append(activeNetwork.isConnected()).append("\n");
                          info.append("Available: ").append(activeNetwork.isAvailable()).append("\n");
                          info.append("HTTP Stack: OkHttp enabled\n");
                      } else {
                          info.append("No active network");
                      }
                  } catch (Exception e) {
                      info.append("Network check failed: ").append(e.getMessage());
                  }
                  return info.toString();
              }
              
              // Multi-device family sharing helper methods
              private String buildDeviceName() {
                  String manufacturer = Build.MANUFACTURER;
                  String model = Build.MODEL;
                  if (model.startsWith(manufacturer)) {
                      return model;
                  } else {
                      return manufacturer + " " + model;
                  }
              }
              
              private String generateSessionToken() {
                  return "session_" + UUID.randomUUID().toString().replace("-", "");
              }
              
              public String getDeviceEmail() {
                  return prefs.getString(KEY_DEVICE_EMAIL, "");
              }
              
              public String getDeviceName() {
                  return prefs.getString(KEY_DEVICE_NAME, buildDeviceName());
              }
              
              public String getSessionToken() {
                  return prefs.getString(KEY_SESSION_TOKEN, "");
              }
              
              public void showDeviceManagementDialog() {
                  // TODO: Implement device management dialog for Professional tier users
                  // Shows list of active devices when limit is reached
                  Log.d(TAG, "Device management dialog - Professional tier feature");
              }
              
              private void logNetworkState() {
                  try {
                      ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                      NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                      
                      if (activeNetwork != null) {
                          Log.d(TAG, "🌐 Network Type: " + activeNetwork.getTypeName());
                          Log.d(TAG, "🌐 Network State: " + activeNetwork.getState());
                          Log.d(TAG, "🌐 Network Connected: " + activeNetwork.isConnected());
                          Log.d(TAG, "🌐 Network Available: " + activeNetwork.isAvailable());
                          Log.d(TAG, "🌐 HTTP Stack: OkHttp v4.12.0");
                      } else {
                          Log.d(TAG, "🌐 No active network detected");
                      }
                  } catch (Exception e) {
                      Log.d(TAG, "🌐 Network state check failed: " + e.getMessage());
                  }
              }
              
              public boolean isLoggedIn() {
                  String email = prefs.getString(KEY_USER_EMAIL, "");
                  String token = prefs.getString(KEY_AUTH_TOKEN, "");
                  boolean loggedIn = !email.isEmpty() && !token.isEmpty();
                  Log.d(TAG, "isLoggedIn check: email=" + (!email.isEmpty()) + ", token=" + (!token.isEmpty()) + " -> " + loggedIn);
                  return loggedIn;
              }
              
              public String getCurrentUserEmail() {
                  return prefs.getString(KEY_USER_EMAIL, "");
              }
              
              public String getAuthToken() {
                  return prefs.getString(KEY_AUTH_TOKEN, "");
              }
              
              public String getUserId() {
                  return prefs.getString(KEY_USER_ID, "");
              }
              
              public void logout() {
                  Log.d(TAG, "Logging out user");
                  prefs.edit().clear().apply();
              }

              // Add missing register method for AuthActivity compatibility
              public boolean register(String email, String password, String name) {
                  return registerWithOkHttp(email, password, name);
              }

              // Add missing recoverDataWithCredentials method for DataRecoveryActivity compatibility
              public boolean recoverDataWithCredentials(String email, String password) {
                  return loginWithOkHttp(email, password);
              }
          }
          EOF

      - name: Create BluetoothWorker for Background Vehicle Detection
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BluetoothWorker.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothDevice;
          import android.bluetooth.BluetoothManager;
          import android.content.Context;
          import android.content.Intent;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.os.Build;
          import android.util.Log;
          import androidx.annotation.NonNull;
          import androidx.core.app.ActivityCompat;
          import androidx.work.Worker;
          import androidx.work.WorkerParameters;
          import org.json.JSONObject;
          import java.util.Set;

          public class BluetoothWorker extends Worker {
              private static final String TAG = "BluetoothWorker";
              private static final String VEHICLE_PREFS = "vehicle_registry";
              private static final String REGISTERED_VEHICLES = "registered_vehicles";
              
              private BluetoothAdapter bluetoothAdapter;
              private SharedPreferences vehiclePrefs;
              private Context context;

              public BluetoothWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) {
                  super(context, workerParams);
                  this.context = context;
                  this.vehiclePrefs = context.getSharedPreferences(VEHICLE_PREFS, Context.MODE_PRIVATE);
                  
                  BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
                  if (bluetoothManager != null) {
                      this.bluetoothAdapter = bluetoothManager.getAdapter();
                  }
              }

              @NonNull
              @Override
              public Result doWork() {
                  Log.d(TAG, "WorkManager: Starting background Bluetooth vehicle check");
                  
                  if (bluetoothAdapter == null) {
                      Log.e(TAG, "WorkManager: Bluetooth adapter is null - device not supported");
                      return Result.success();
                  }
                  
                  if (!bluetoothAdapter.isEnabled()) {
                      Log.w(TAG, "WorkManager: Bluetooth is disabled - skipping check");
                      return Result.success();
                  }
                  
                  // Check Android 12+ permissions
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                      if (ActivityCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                          Log.w(TAG, "WorkManager: Missing BLUETOOTH_CONNECT permission - skipping check");
                          return Result.success();
                      }
                  }
                  
                  try {
                      checkForVehicleConnections();
                      return Result.success();
                  } catch (SecurityException e) {
                      Log.e(TAG, "WorkManager: SecurityException - missing Bluetooth permissions: " + e.getMessage());
                      return Result.failure();
                  } catch (Exception e) {
                      Log.e(TAG, "WorkManager: Exception during vehicle check: " + e.getMessage(), e);
                      return Result.retry();
                  }
              }

              private void checkForVehicleConnections() throws SecurityException {
                  Log.d(TAG, "WorkManager: Checking paired devices for vehicle connections");
                  
                  Set<BluetoothDevice> pairedDevices = bluetoothAdapter.getBondedDevices();
                  if (pairedDevices == null || pairedDevices.isEmpty()) {
                      Log.d(TAG, "WorkManager: No paired devices found");
                      return;
                  }
                  
                  Log.d(TAG, "WorkManager: Found " + pairedDevices.size() + " paired devices");
                  
                  for (BluetoothDevice device : pairedDevices) {
                      String deviceName = device.getName();
                      String deviceAddress = device.getAddress();
                      
                      if (deviceName == null || deviceAddress == null) {
                          continue;
                      }
                      
                      Log.d(TAG, "WorkManager: Checking device: " + deviceName + " (" + deviceAddress + ")");
                      
                      // Check if this is a vehicle device
                      if (isVehicleDevice(deviceName)) {
                          Log.d(TAG, "WorkManager: Vehicle device detected: " + deviceName);
                          
                          // Check if device is connected by attempting to get connection state
                          boolean isConnected = isDeviceConnected(device);
                          Log.d(TAG, "WorkManager: Device " + deviceName + " connected: " + isConnected);
                          
                          // Check if vehicle is registered
                          boolean isRegistered = isVehicleRegistered(deviceAddress);
                          
                          if (isConnected && isRegistered) {
                              Log.d(TAG, "WorkManager: Registered vehicle connected - starting trip detection");
                              startTripDetection(deviceAddress, deviceName);
                          } else if (isConnected && !isRegistered) {
                              Log.d(TAG, "WorkManager: New vehicle connected - triggering registration");
                              triggerVehicleRegistration(deviceAddress, deviceName);
                          }
                      }
                  }
              }

              private boolean isVehicleDevice(String deviceName) {
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  return name.contains("car") || name.contains("auto") || name.contains("ford") || 
                         name.contains("toyota") || name.contains("honda") || name.contains("bmw") || 
                         name.contains("mercedes") || name.contains("audi") || name.contains("volkswagen") || 
                         name.contains("nissan") || name.contains("hyundai") || name.contains("kia") || 
                         name.contains("mazda") || name.contains("subaru") || name.contains("lexus") || 
                         name.contains("infiniti") || name.contains("acura") || name.contains("cadillac") || 
                         name.contains("buick") || name.contains("gmc") || name.contains("chevrolet") || 
                         name.contains("dodge") || name.contains("ram") || name.contains("jeep") || 
                         name.contains("chrysler") || name.contains("lincoln") || name.contains("tesla") || 
                         name.contains("volvo") || name.contains("jaguar") || name.contains("landrover") || 
                         name.contains("porsche") || name.contains("maserati") || name.contains("ferrari") || 
                         name.contains("lamborghini") || name.contains("bentley") || name.contains("rollsroyce") || 
                         name.contains("uconnect") || name.contains("sync") || name.contains("entune") || 
                         name.contains("infotainment") || name.contains("carplay") || name.contains("androidauto") || 
                         name.contains("mylink") || name.contains("intellilink") || name.contains("cue") || 
                         name.contains("command") || name.contains("comand") || name.contains("mmi") || 
                         name.contains("idrive") || name.contains("navigation");
              }

              private boolean isDeviceConnected(BluetoothDevice device) {
                  try {
                      // Use reflection to check connection state since direct methods may not be available
                      java.lang.reflect.Method method = device.getClass().getMethod("isConnected");
                      return (Boolean) method.invoke(device);
                  } catch (Exception e) {
                      Log.d(TAG, "WorkManager: Cannot determine connection state for " + device.getName() + " - assuming disconnected");
                      return false;
                  }
              }

              private boolean isVehicleRegistered(String deviceAddress) {
                  String registeredVehicles = vehiclePrefs.getString(REGISTERED_VEHICLES, "{}");
                  try {
                      JSONObject vehicles = new JSONObject(registeredVehicles);
                      return vehicles.has(deviceAddress);
                  } catch (Exception e) {
                      Log.e(TAG, "WorkManager: Error checking vehicle registration: " + e.getMessage());
                      return false;
                  }
              }

              private void startTripDetection(String deviceAddress, String deviceName) {
                  Log.d(TAG, "WorkManager: Starting trip detection for vehicle: " + deviceName);
                  
                  // Send broadcast to MainActivity to start trip detection
                  Intent intent = new Intent("com.miletrackerpro.app.VEHICLE_CONNECTED");
                  intent.putExtra("device_address", deviceAddress);
                  intent.putExtra("device_name", deviceName);
                  intent.putExtra("source", "WorkManager");
                  context.sendBroadcast(intent);
              }

              private void triggerVehicleRegistration(String deviceAddress, String deviceName) {
                  Log.d(TAG, "WorkManager: Triggering vehicle registration for: " + deviceName);
                  
                  // Send broadcast to MainActivity to show registration dialog
                  Intent intent = new Intent("com.miletrackerpro.app.NEW_VEHICLE_DETECTED");
                  intent.putExtra("device_address", deviceAddress);
                  intent.putExtra("device_name", deviceName);
                  intent.putExtra("source", "WorkManager");
                  context.sendBroadcast(intent);
              }
          }
          EOF

      - name: Create Authentication Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/AuthActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;
          import android.graphics.Typeface;

          public class AuthActivity extends AppCompatActivity {
              private static final String TAG = "AuthActivity";

              private UserAuthManager authManager;
              private LinearLayout mainLayout;
              private boolean isLoginMode = true;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);

                  // If already logged in, go to main app
                  if (authManager.isLoggedIn()) {
                      goToMainApp();
                      return;
                  }

                  createAuthLayout();
              }

              private void createAuthLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(0, 0, 0, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // White header section with car icon and title
                  LinearLayout titleLayout = new LinearLayout(this);
                  titleLayout.setOrientation(LinearLayout.HORIZONTAL);
                  titleLayout.setBackgroundColor(0xFFFFFFFF);
                  titleLayout.setPadding(20, 40, 20, 20);
                  titleLayout.setGravity(Gravity.CENTER_VERTICAL);
                  
                  TextView titleText = new TextView(this);
                  titleText.setText("MileTracker Pro");
                  titleText.setTextSize(24);
                  titleText.setTextColor(0xFF2C3E50);
                  titleText.setTypeface(null, Typeface.BOLD);
                  titleLayout.addView(titleText);
                  
                  mainLayout.addView(titleLayout);

                  // Version text removed per user request

                  // Benefits explanation in white section
                  LinearLayout benefitsLayout = new LinearLayout(this);
                  benefitsLayout.setOrientation(LinearLayout.VERTICAL);
                  benefitsLayout.setBackgroundColor(0xFFFFFFFF);
                  benefitsLayout.setPadding(20, 0, 20, 30);
                  
                  TextView benefitsText = new TextView(this);
                  benefitsText.setText("• Keep your trips safe across all devices\n• Automatic backup and sync\n• Recover data if phone is lost/stolen\n• No constant sign-ins required");
                  benefitsText.setTextSize(14);
                  benefitsText.setTextColor(0xFF2C3E50);
                  benefitsText.setPadding(15, 15, 15, 15);
                  benefitsText.setBackgroundColor(0xFFF0F7F4);
                  benefitsLayout.addView(benefitsText);
                  
                  mainLayout.addView(benefitsLayout);

                  showAuthForm();

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void showAuthForm() {
                  // Clear form area (now accounting for 2 sections: white header, white benefits)
                  if (mainLayout.getChildCount() > 2) {
                      for (int i = mainLayout.getChildCount() - 1; i >= 2; i--) {
                          mainLayout.removeViewAt(i);
                      }
                  }

                  // Mode toggle
                  TextView modeText = new TextView(this);
                  modeText.setText(isLoginMode ? "Login to Your Account" : "Create New Account");
                  modeText.setTextSize(20);
                  modeText.setTextColor(0xFF495057);
                  modeText.setGravity(Gravity.CENTER);
                  modeText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(modeText);

                  // Email field
                  TextView emailLabel = new TextView(this);
                  emailLabel.setText("Email Address:");
                  emailLabel.setTextSize(16);
                  emailLabel.setTextColor(0xFF495057);
                  emailLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(emailLabel);

                  EditText emailField = new EditText(this);
                  emailField.setHint("your.email@example.com");
                  emailField.setText("pcates@catesconsultinggroup.com");
                  emailField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailField.setTextSize(16);
                  emailField.setPadding(15, 15, 15, 15);
                  emailField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailField.setLayoutParams(emailParams);
                  mainLayout.addView(emailField);

                  // Password field
                  TextView passwordLabel = new TextView(this);
                  passwordLabel.setText("Password:");
                  passwordLabel.setTextSize(16);
                  passwordLabel.setTextColor(0xFF495057);
                  passwordLabel.setPadding(0, 0, 0, 5);
                  mainLayout.addView(passwordLabel);

                  EditText passwordField = new EditText(this);
                  passwordField.setHint("Your secure password");
                  passwordField.setText("password123");
                  passwordField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordField.setTextSize(16);
                  passwordField.setPadding(15, 15, 15, 15);
                  passwordField.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 15);
                  passwordField.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordField);

                  // Name field (registration only)
                  EditText nameField = null;
                  if (!isLoginMode) {
                      TextView nameLabel = new TextView(this);
                      nameLabel.setText("Your Name:");
                      nameLabel.setTextSize(16);
                      nameLabel.setTextColor(0xFF495057);
                      nameLabel.setPadding(0, 0, 0, 5);
                      mainLayout.addView(nameLabel);

                      nameField = new EditText(this);
                      nameField.setHint("John Smith");
                      nameField.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PERSON_NAME);
                      nameField.setTextSize(16);
                      nameField.setPadding(15, 15, 15, 15);
                      nameField.setBackgroundColor(0xFFFFFFFF);
                      LinearLayout.LayoutParams nameParams = new LinearLayout.LayoutParams(
                          LinearLayout.LayoutParams.MATCH_PARENT, 
                          LinearLayout.LayoutParams.WRAP_CONTENT
                      );
                      nameParams.setMargins(0, 0, 0, 15);
                      nameField.setLayoutParams(nameParams);
                      mainLayout.addView(nameField);
                  }

                  // Primary action button
                  Button primaryButton = new Button(this);
                  primaryButton.setText(isLoginMode ? "Login" : "Create Account");
                  primaryButton.setBackgroundColor(0xFF2C3E50);
                  primaryButton.setTextColor(0xFFFFFFFF);
                  primaryButton.setTextSize(18);
                  primaryButton.setPadding(40, 20, 40, 20);
                  LinearLayout.LayoutParams primaryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  primaryParams.setMargins(0, 10, 0, 15);
                  primaryButton.setLayoutParams(primaryParams);

                  EditText finalNameField = nameField;
                  primaryButton.setOnClickListener(v -> {
                      String email = emailField.getText().toString().trim();
                      String password = passwordField.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please fill in all fields", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      if (isLoginMode) {
                          handleLogin(email, password);
                      } else {
                          String name = finalNameField != null ? finalNameField.getText().toString().trim() : "";
                          if (name.isEmpty()) {
                              Toast.makeText(this, "Please enter your name", Toast.LENGTH_SHORT).show();
                              return;
                          }
                          handleRegistration(email, password, name);
                      }
                  });
                  mainLayout.addView(primaryButton);

                  // Mode toggle button
                  Button toggleButton = new Button(this);
                  toggleButton.setText(isLoginMode ? "Need an account? Sign up" : "Already have an account? Login");
                  toggleButton.setBackgroundColor(0x00000000);
                  toggleButton.setTextColor(0xFF2C3E50);
                  toggleButton.setTextSize(16);
                  LinearLayout.LayoutParams toggleParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  toggleParams.setMargins(0, 10, 0, 20);
                  toggleButton.setLayoutParams(toggleParams);
                  toggleButton.setOnClickListener(v -> {
                      isLoginMode = !isLoginMode;
                      showAuthForm();
                  });
                  mainLayout.addView(toggleButton);

                  // Data recovery link
                  Button recoveryButton = new Button(this);
                  recoveryButton.setText("Lost device? Recover your data");
                  recoveryButton.setBackgroundColor(0x00000000);
                  recoveryButton.setTextColor(0xFF27AE60);
                  recoveryButton.setTextSize(14);
                  LinearLayout.LayoutParams recoveryParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  recoveryParams.setMargins(0, 20, 0, 0);
                  recoveryButton.setLayoutParams(recoveryParams);
                  recoveryButton.setOnClickListener(v -> goToDataRecovery());
                  mainLayout.addView(recoveryButton);
              }

              private void handleLogin(String email, String password) {
                  // Show loading message
                  Toast.makeText(this, "OkHttp login attempt...", Toast.LENGTH_SHORT).show();
                  Log.d(TAG, "=== OKHTTP LOGIN ATTEMPT ===");
                  Log.d(TAG, "Email from input: '" + email + "'");
                  Log.d(TAG, "Password from input: '" + password + "' (length: " + password.length() + ")");
                  
                  // Run login in background thread using OkHttp
                  new Thread(() -> {
                      Log.d(TAG, "Starting OkHttp login thread...");
                      boolean loginResult = authManager.loginWithOkHttp(email, password);
                      Log.d(TAG, "OkHttp login result: " + loginResult);
                      
                      // Update UI on main thread
                      runOnUiThread(() -> {
                          if (loginResult) {
                              Toast.makeText(this, "Welcome back! (OkHttp Success)", Toast.LENGTH_SHORT).show();
                              goToMainApp();
                          } else {
                              Toast.makeText(this, "Login failed. Check logs for OkHttp diagnostic info.", Toast.LENGTH_LONG).show();
                              Log.d(TAG, "OkHttp login failed - check connection routing");
                          }
                      });
                  }).start();
              }

              private void handleRegistration(String email, String password, String name) {
                  if (authManager.register(email, password, name)) {
                      Toast.makeText(this, "Account created successfully!", Toast.LENGTH_SHORT).show();
                      goToMainApp();
                  } else {
                      Toast.makeText(this, "Registration failed. Please try again.", Toast.LENGTH_LONG).show();
                  }
              }

              private void goToDataRecovery() {
                  Intent intent = new Intent(this, DataRecoveryActivity.class);
                  startActivity(intent);
              }

              private void goToMainApp() {
                  Intent intent = new Intent(this, MainActivity.class);
                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                  startActivity(intent);
                  finish();
              }
          }
          EOF

      - name: Create Data Recovery Activity
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/DataRecoveryActivity.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Intent;
          import android.os.Bundle;
          import android.text.InputType;
          import android.util.Log;
          import android.view.Gravity;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.LinearLayout;
          import android.widget.ScrollView;
          import android.widget.TextView;
          import android.widget.Toast;
          import androidx.appcompat.app.AppCompatActivity;
          import com.miletrackerpro.app.MainActivity;

          public class DataRecoveryActivity extends AppCompatActivity {
              private static final String TAG = "DataRecoveryActivity";

              private UserAuthManager authManager;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);

                  authManager = new UserAuthManager(this);
                  createRecoveryLayout();
              }

              private void createRecoveryLayout() {
                  ScrollView scrollView = new ScrollView(this);

                  LinearLayout mainLayout = new LinearLayout(this);
                  mainLayout.setOrientation(LinearLayout.VERTICAL);
                  mainLayout.setPadding(40, 40, 40, 40);
                  mainLayout.setBackgroundColor(0xFFF5F5F5);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("Data Recovery");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF2C3E50);
                  headerText.setGravity(Gravity.CENTER);
                  headerText.setPadding(0, 0, 0, 20);
                  mainLayout.addView(headerText);

                  // Explanation
                  TextView explanationText = new TextView(this);
                  explanationText.setText("Lost your phone, upgraded devices, or need to reinstall?\n\nEnter your email and password to recover ALL your trip data and mileage history.\n\nThis works even if your old device was stolen or broken.");
                  explanationText.setTextSize(14);
                  explanationText.setTextColor(0xFF6C757D);
                  explanationText.setPadding(15, 15, 15, 15);
                  explanationText.setBackgroundColor(0xFFfff3cd);
                  LinearLayout.LayoutParams explanationParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  explanationParams.setMargins(0, 0, 0, 30);
                  explanationText.setLayoutParams(explanationParams);
                  mainLayout.addView(explanationText);

                  TextView formTitle = new TextView(this);
                  formTitle.setText("Recover Your Trip Data");
                  formTitle.setTextSize(18);
                  formTitle.setTextColor(0xFF495057);
                  formTitle.setPadding(0, 0, 0, 15);
                  mainLayout.addView(formTitle);

                  EditText emailInput = new EditText(this);
                  emailInput.setHint("Your email address");
                  emailInput.setText("pcates@catesconsultinggroup.com");
                  emailInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
                  emailInput.setPadding(15, 15, 15, 15);
                  emailInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams emailParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  emailParams.setMargins(0, 0, 0, 15);
                  emailInput.setLayoutParams(emailParams);
                  mainLayout.addView(emailInput);

                  EditText passwordInput = new EditText(this);
                  passwordInput.setHint("Your password");
                  passwordInput.setText("password123");
                  passwordInput.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
                  passwordInput.setPadding(15, 15, 15, 15);
                  passwordInput.setBackgroundColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams passwordParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  passwordParams.setMargins(0, 0, 0, 20);
                  passwordInput.setLayoutParams(passwordParams);
                  mainLayout.addView(passwordInput);

                  Button recoverButton = new Button(this);
                  recoverButton.setText("Recover My Trip Data");
                  recoverButton.setTextSize(16);
                  recoverButton.setBackgroundColor(0xFF27AE60);
                  recoverButton.setTextColor(0xFFFFFFFF);
                  recoverButton.setOnClickListener(v -> {
                      String email = emailInput.getText().toString().trim();
                      String password = passwordInput.getText().toString().trim();

                      if (email.isEmpty() || password.isEmpty()) {
                          Toast.makeText(this, "Please enter both email and password", Toast.LENGTH_SHORT).show();
                          return;
                      }

                      performDataRecovery(email, password);
                  });
                  mainLayout.addView(recoverButton);

                  // Back button
                  Button backButton = new Button(this);
                  backButton.setText("← Back to Sign In");
                  backButton.setTextSize(14);
                  backButton.setBackgroundColor(0xFF2C3E50);
                  backButton.setTextColor(0xFFFFFFFF);
                  LinearLayout.LayoutParams backParams = new LinearLayout.LayoutParams(
                      LinearLayout.LayoutParams.MATCH_PARENT, 
                      LinearLayout.LayoutParams.WRAP_CONTENT
                  );
                  backParams.setMargins(0, 15, 0, 0);
                  backButton.setLayoutParams(backParams);
                  backButton.setOnClickListener(v -> {
                      finish(); // Go back to AuthActivity
                  });
                  mainLayout.addView(backButton);

                  scrollView.addView(mainLayout);
                  setContentView(scrollView);
              }

              private void performDataRecovery(String email, String password) {
                  try {
                      // Show progress
                      Toast.makeText(this, "Recovering your data...", Toast.LENGTH_SHORT).show();

                      boolean success = authManager.recoverDataWithCredentials(email, password);

                      if (success) {
                          // Success message
                          Toast.makeText(this, "SUCCESS! Your trip data is being restored. This includes ALL your historical trips, even from previous devices.", Toast.LENGTH_LONG).show();

                          // Go to main app
                          Intent intent = new Intent(this, MainActivity.class);
                          intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                          startActivity(intent);
                          finish();

                      } else {
                          Toast.makeText(this, "Recovery failed. Please check your email and password, or create a new account if you're a new user.", Toast.LENGTH_LONG).show();
                      }

                  } catch (Exception e) {
                      Log.e(TAG, "Data recovery error", e);
                      Toast.makeText(this, "Recovery error: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }
          }
          EOF

      - name: Create Trip class - EXACT COPY FROM WORKING VERSION
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;

          public class Trip {
              private long id;
              private String uniqueTripId;  // UUID for offline sync
              private String syncStatus;    // "local", "queued", "synced"
              private int syncAttempts;     // Retry counter for failed syncs
              private String startAddress;
              private String startDisplayName;
              private String endAddress;
              private String endDisplayName;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private long duration;
              private String category;
              private long startTime;
              private long endTime;
              private boolean autoDetected;
              private String clientName;
              private String notes;
              private String roundTripGroupId;
              private boolean isRoundTrip;
              private int roundTripSegment; // 1=outbound, 2=return, 0=not part of round trip
              private String vehicleName;
              private String vehicleType;
              private String vehicleDeviceAddress;
              private boolean bluetoothTriggered;

              public Trip() {
                  this.category = "Uncategorized";
                  this.autoDetected = false;
                  this.clientName = null;
                  this.notes = null;
                  this.roundTripGroupId = null;
                  this.isRoundTrip = false;
                  this.roundTripSegment = 0;
                  // Initialize new offline sync fields
                  this.uniqueTripId = java.util.UUID.randomUUID().toString();
                  this.syncStatus = "local";
                  this.syncAttempts = 0;
                  // Initialize timestamps to current time to prevent 1969 dates
                  long currentTime = System.currentTimeMillis();
                  this.startTime = currentTime;
                  this.endTime = currentTime;
              }

              // All getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getStartDisplayName() { return startDisplayName; }
              public void setStartDisplayName(String startDisplayName) { this.startDisplayName = startDisplayName; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public String getEndDisplayName() { return endDisplayName; }
              public void setEndDisplayName(String endDisplayName) { this.endDisplayName = endDisplayName; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public long getDuration() { return duration; }
              public void setDuration(long duration) { this.duration = duration; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public String getClientName() { return clientName; }
              public void setClientName(String clientName) { this.clientName = clientName; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public String getRoundTripGroupId() { return roundTripGroupId; }
              public void setRoundTripGroupId(String roundTripGroupId) { this.roundTripGroupId = roundTripGroupId; }

              public boolean isRoundTrip() { return isRoundTrip; }
              public void setRoundTrip(boolean roundTrip) { isRoundTrip = roundTrip; }

              public int getRoundTripSegment() { return roundTripSegment; }
              public void setRoundTripSegment(int roundTripSegment) { this.roundTripSegment = roundTripSegment; }

              public String getVehicleName() { return vehicleName; }
              public void setVehicleName(String vehicleName) { this.vehicleName = vehicleName; }

              public String getVehicleType() { return vehicleType; }
              public void setVehicleType(String vehicleType) { this.vehicleType = vehicleType; }

              public String getVehicleDeviceAddress() { return vehicleDeviceAddress; }
              public void setVehicleDeviceAddress(String vehicleDeviceAddress) { this.vehicleDeviceAddress = vehicleDeviceAddress; }

              public boolean isBluetoothTriggered() { return bluetoothTriggered; }
              public void setBluetoothTriggered(boolean bluetoothTriggered) { this.bluetoothTriggered = bluetoothTriggered; }

              // Offline sync field getters and setters
              public String getUniqueTripId() { return uniqueTripId; }
              public void setUniqueTripId(String uniqueTripId) { this.uniqueTripId = uniqueTripId; }

              public String getSyncStatus() { return syncStatus; }
              public void setSyncStatus(String syncStatus) { this.syncStatus = syncStatus; }

              public int getSyncAttempts() { return syncAttempts; }
              public void setSyncAttempts(int syncAttempts) { this.syncAttempts = syncAttempts; }

              // Formatted display methods
              public String getFormattedDate() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDuration() {
                  long minutes = duration / (60 * 1000);
                  if (minutes < 60) {
                      return minutes + "m";
                  } else {
                      long hours = minutes / 60;
                      long remainingMinutes = minutes % 60;
                      return hours + "h " + remainingMinutes + "m";
                  }
              }

              public String getFormattedStartTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getCompactDateTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yy h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedDateTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("MMM dd, yyyy h:mm a", Locale.getDefault());
                  return sdf.format(new Date(startTime));
              }

              public String getFormattedEndTime() {
                  SimpleDateFormat sdf = new SimpleDateFormat("h:mm a", Locale.getDefault());
                  return sdf.format(new Date(endTime));
              }
          }
          EOF

      - name: Create TripStorage with stable device ID
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.os.Build;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.utils.DeviceIdentification;
          import org.json.JSONArray;
          import org.json.JSONObject;

          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Comparator;
          import java.util.List;

          public class TripStorage {
              private static final String TAG = "TripStorage";
              private static final String PREFS_NAME = "MileTrackerPrefs";
              private static final String TRIPS_KEY = "trips";
              private static final String CURRENT_TRIP_KEY = "current_trip";
              private static final String AUTO_DETECTION_KEY = "auto_detection_enabled";
              private static final String API_SYNC_KEY = "api_sync_enabled";
              private static final String LAST_API_SYNC_KEY = "last_api_sync";
              private static final String CUSTOM_CATEGORIES_KEY = "custom_categories";
              private static final String HOME_ADDRESS_KEY = "home_address";
              private static final String HOME_LATITUDE_KEY = "home_latitude";
              private static final String HOME_LONGITUDE_KEY = "home_longitude";
              private static final String SUBSCRIPTION_TIER_KEY = "subscription_tier";
              private static final String PURCHASE_TOKEN_KEY = "purchase_token";
              private static final int FREE_TIER_TRIP_LIMIT = 40;

              private SharedPreferences prefs;
              private Context context;

              public TripStorage(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              public String getStableDeviceId() {
                  return DeviceIdentification.getStableDeviceId(context);
              }

              public String getUserId() {
                  // Use authenticated user's database ID, not device ID
                  UserAuthManager authManager = new UserAuthManager(context);
                  String authUserId = authManager.getUserId();
                  if (!authUserId.isEmpty()) {
                      return authUserId;
                  }
                  // Fallback to device ID only if not authenticated
                  return DeviceIdentification.getUserId(context);
              }

              public boolean isAutoDetectionEnabled() {
                  return prefs.getBoolean(AUTO_DETECTION_KEY, false);
              }

              public void setAutoDetectionEnabled(boolean enabled) {
                  prefs.edit().putBoolean(AUTO_DETECTION_KEY, enabled).apply();
                  Log.d(TAG, "Auto detection enabled: " + enabled);
              }

              public boolean isApiSyncEnabled() {
                  return prefs.getBoolean(API_SYNC_KEY, true);
              }

              public void setApiSyncEnabled(boolean enabled) {
                  prefs.edit().putBoolean(API_SYNC_KEY, enabled).apply();
                  Log.d(TAG, "API sync enabled: " + enabled);
              }

              public long getLastApiSyncTime() {
                  return prefs.getLong(LAST_API_SYNC_KEY, 0);
              }

              public void setLastApiSyncTime(long timestamp) {
                  prefs.edit().putLong(LAST_API_SYNC_KEY, timestamp).apply();
              }

              // Home address management
              public void setHomeAddress(String address, double latitude, double longitude) {
                  prefs.edit()
                      .putString(HOME_ADDRESS_KEY, address)
                      .putFloat(HOME_LATITUDE_KEY, (float) latitude)
                      .putFloat(HOME_LONGITUDE_KEY, (float) longitude)
                      .apply();
                  Log.d(TAG, "Home address set: " + address);
              }

              public String getHomeAddress() {
                  return prefs.getString(HOME_ADDRESS_KEY, null);
              }

              public double getHomeLatitude() {
                  return prefs.getFloat(HOME_LATITUDE_KEY, 0.0f);
              }

              public double getHomeLongitude() {
                  return prefs.getFloat(HOME_LONGITUDE_KEY, 0.0f);
              }

              public boolean hasHomeAddress() {
                  return getHomeAddress() != null && !getHomeAddress().isEmpty();
              }

              public void clearHomeAddress() {
                  prefs.edit()
                      .remove(HOME_ADDRESS_KEY)
                      .remove(HOME_LATITUDE_KEY)
                      .remove(HOME_LONGITUDE_KEY)
                      .apply();
                  Log.d(TAG, "Home address cleared");
              }

              // Check if location is near home (within 100 meters)
              public boolean isNearHome(double latitude, double longitude) {
                  if (!hasHomeAddress()) {
                      return false;
                  }
                  
                  double homeLatitude = getHomeLatitude();
                  double homeLongitude = getHomeLongitude();
                  
                  // Calculate distance using Haversine formula
                  double distance = calculateDistance(latitude, longitude, homeLatitude, homeLongitude);
                  
                  // Consider within 100 meters as "home"
                  return distance <= 0.1; // 0.1 km = 100 meters
              }

              // Get home address if location is near home, otherwise return null
              public String getHomeAddressIfNear(double latitude, double longitude) {
                  if (isNearHome(latitude, longitude)) {
                      return getHomeAddress();
                  }
                  return null;
              }

              // Calculate distance between two coordinates (Haversine formula)
              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Radius of the Earth in km
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c;
                  return distance;
              }

              // Custom categories management
              public List<String> getCustomCategories() {
                  try {
                      String customCategoriesJson = prefs.getString(CUSTOM_CATEGORIES_KEY, "[]");
                      JSONArray jsonArray = new JSONArray(customCategoriesJson);
                      List<String> categories = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          categories.add(jsonArray.getString(i));
                      }
                      return categories;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting custom categories", e);
                      return new ArrayList<>();
                  }
              }

              public void addCustomCategory(String category) {
                  try {
                      List<String> categories = getCustomCategories();
                      if (!categories.contains(category) && !category.trim().isEmpty()) {
                          categories.add(category.trim());
                          saveCustomCategories(categories);
                          Log.d(TAG, "Added custom category: " + category);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding custom category", e);
                  }
              }

              public void removeCustomCategory(String category) {
                  try {
                      List<String> categories = getCustomCategories();
                      if (categories.remove(category)) {
                          saveCustomCategories(categories);
                          Log.d(TAG, "Removed custom category: " + category);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error removing custom category", e);
                  }
              }

              private void saveCustomCategories(List<String> categories) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (String category : categories) {
                          jsonArray.put(category);
                      }
                      prefs.edit().putString(CUSTOM_CATEGORIES_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving custom categories", e);
                  }
              }

              public List<String> getAllCategories() {
                  List<String> allCategories = new ArrayList<>();
                  // Add default categories
                  allCategories.add("Business");
                  allCategories.add("Personal");
                  allCategories.add("Medical");
                  allCategories.add("Charity");
                  // Add custom categories
                  allCategories.addAll(getCustomCategories());
                  return allCategories;
              }

              // Subscription Tier Management
              public String getSubscriptionTier() {
                  return prefs.getString(SUBSCRIPTION_TIER_KEY, "free");
              }

              public void setSubscriptionTier(String tier) {
                  prefs.edit().putString(SUBSCRIPTION_TIER_KEY, tier).apply();
                  Log.d(TAG, "Subscription tier set to: " + tier);
              }

              public void setPurchaseToken(String token) {
                  prefs.edit().putString(PURCHASE_TOKEN_KEY, token).apply();
              }

              public String getPurchaseToken() {
                  return prefs.getString(PURCHASE_TOKEN_KEY, "");
              }

              public boolean isPremiumUser() {
                  String tier = getSubscriptionTier();
                  return !tier.equals("free");
              }

              public int getMonthlyTripCount() {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      java.util.Calendar calendar = java.util.Calendar.getInstance();
                      int currentMonth = calendar.get(java.util.Calendar.MONTH);
                      int currentYear = calendar.get(java.util.Calendar.YEAR);
                      
                      int count = 0;
                      for (Trip trip : allTrips) {
                          calendar.setTimeInMillis(trip.getStartTime());
                          if (calendar.get(java.util.Calendar.MONTH) == currentMonth && 
                              calendar.get(java.util.Calendar.YEAR) == currentYear) {
                              count++;
                          }
                      }
                      return count;
                  } catch (Exception e) {
                      Log.e(TAG, "Error counting monthly trips", e);
                      return 0;
                  }
              }

              public boolean canCreateNewTrip() {
                  if (isPremiumUser()) {
                      return true; // Unlimited trips for premium users
                  }
                  
                  int monthlyCount = getMonthlyTripCount();
                  boolean canCreate = monthlyCount < FREE_TIER_TRIP_LIMIT;
                  
                  if (!canCreate) {
                      Log.w(TAG, "Free tier limit reached: " + monthlyCount + "/" + FREE_TIER_TRIP_LIMIT + " trips this month");
                  }
                  
                  return canCreate;
              }

              public int getRemainingTrips() {
                  if (isPremiumUser()) {
                      return -1; // Unlimited
                  }
                  int remaining = FREE_TIER_TRIP_LIMIT - getMonthlyTripCount();
                  return Math.max(0, remaining);
              }



              public boolean saveTrip(Trip trip) {
                  try {
                      boolean isNewTrip = trip.getId() == 0;
                      
                      if (trip.getId() == 0) {
                          trip.setId(trip.getStartTime() > 0 ? trip.getStartTime() : System.currentTimeMillis());
                      }

                      Log.d(TAG, "Saving trip: " + trip.getStartAddress() + " to " + trip.getEndAddress() + 
                            " (Distance: " + trip.getDistance() + " miles)");

                      List<Trip> trips = getAllTrips();

                      // Check for potential duplicates before saving new trips
                      boolean updated = false;
                      for (int i = 0; i < trips.size(); i++) {
                          if (trips.get(i).getId() == trip.getId()) {
                              trips.set(i, trip);
                              updated = true;
                              break;
                          }
                      }

                      if (!updated) {
                          // For new trips, check subscription limit
                          if (!canCreateNewTrip()) {
                              Log.w(TAG, "Cannot save trip - free tier limit reached (" + getMonthlyTripCount() + "/" + FREE_TIER_TRIP_LIMIT + ")");
                              return false;
                          }
                          
                          // Check for duplicates within 60 seconds and 100 meters
                          Trip duplicate = findDuplicateTrip(trips, trip);
                          if (duplicate != null) {
                              Log.w(TAG, "Duplicate trip detected - merging with existing trip " + duplicate.getId());
                              mergeTripData(duplicate, trip);
                              // Update the existing trip instead of adding new one
                              for (int i = 0; i < trips.size(); i++) {
                                  if (trips.get(i).getId() == duplicate.getId()) {
                                      trips.set(i, duplicate);
                                      updated = true;
                                      break;
                                  }
                              }
                          } else {
                              trips.add(trip);
                          }
                      }

                      saveAllTrips(trips);
                      Log.d(TAG, updated ? "Trip updated: " + trip.getId() : "Trip saved: " + trip.getId());
                      
                      // Send usage notifications for free users at 30, 35, and 40 trips
                      if (isNewTrip && !updated) {
                          checkAndSendUsageNotifications();
                      }
                      
                      return true;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip", e);
                      return false;
                  }
              }

              private Trip findDuplicateTrip(List<Trip> existingTrips, Trip newTrip) {
                  final long TIME_WINDOW_MS = 60 * 1000; // 60 seconds
                  final double LOCATION_RADIUS_METERS = 100; // 100 meters
                  
                  for (Trip existing : existingTrips) {
                      // Check time window (within 60 seconds)
                      long timeDiff = Math.abs(existing.getStartTime() - newTrip.getStartTime());
                      if (timeDiff <= TIME_WINDOW_MS) {
                          // Check location proximity (within 100 meters)
                          double distance = calculateDistanceInMeters(
                              existing.getStartLatitude(), existing.getStartLongitude(),
                              newTrip.getStartLatitude(), newTrip.getStartLongitude()
                          );
                          
                          if (distance <= LOCATION_RADIUS_METERS) {
                              Log.d(TAG, "Found duplicate: time diff=" + timeDiff + "ms, distance=" + distance + "m");
                              return existing;
                          }
                      }
                  }
                  return null;
              }

              private void mergeTripData(Trip existingTrip, Trip newTrip) {
                  // Keep the more complete trip data
                  // If new trip has more complete end data, use it
                  if (newTrip.getEndAddress() != null && !newTrip.getEndAddress().isEmpty() && 
                      !newTrip.getEndAddress().contains(",") && // Not coordinates
                      (existingTrip.getEndAddress() == null || existingTrip.getEndAddress().contains(","))) {
                      existingTrip.setEndAddress(newTrip.getEndAddress());
                      existingTrip.setEndLatitude(newTrip.getEndLatitude());
                      existingTrip.setEndLongitude(newTrip.getEndLongitude());
                      existingTrip.setEndTime(newTrip.getEndTime());
                  }
                  
                  // Use the longer distance if available
                  if (newTrip.getDistance() > existingTrip.getDistance()) {
                      existingTrip.setDistance(newTrip.getDistance());
                  }
                  
                  // Use the longer duration if available
                  if (newTrip.getDuration() > existingTrip.getDuration()) {
                      existingTrip.setDuration(newTrip.getDuration());
                  }
                  
                  Log.d(TAG, "Merged trip data - final distance: " + existingTrip.getDistance() + " miles");
              }

              private double calculateDistanceInMeters(double lat1, double lon1, double lat2, double lon2) {
                  final double R = 6371000; // Earth radius in meters
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              public void deleteTrip(long tripId) {
                  try {
                      // Remove from local storage
                      List<Trip> trips = getAllTrips();
                      trips.removeIf(trip -> trip.getId() == tripId);
                      saveAllTrips(trips);
                      
                      // Delete from API if available
                      new Thread(() -> {
                          try {
                              java.net.URL url = new java.net.URL("https://mileage-tracker-codenurse.replit.app/api/trips/" + tripId);
                              java.net.HttpURLConnection conn = (java.net.HttpURLConnection) url.openConnection();
                              conn.setRequestMethod("DELETE");
                              // Get current user email from SharedPreferences (same pattern as auth system)
                              SharedPreferences authPrefs = context.getSharedPreferences("MileTrackerAuth", Context.MODE_PRIVATE);
                              String userEmail = authPrefs.getString("user_email", "");
                              if (!userEmail.isEmpty()) {
                                  conn.setRequestProperty("X-User-Email", userEmail);
                              } else {
                                  Log.w(TAG, "No user email available for DELETE request");
                                  return;
                              }
                              conn.setRequestProperty("Content-Type", "application/json");
                              conn.setConnectTimeout(5000);
                              conn.setReadTimeout(5000);
                              
                              int responseCode = conn.getResponseCode();
                              Log.d(TAG, "Trip deleted from API: " + tripId + ", Response: " + responseCode);
                              conn.disconnect();
                          } catch (Exception e) {
                              Log.w(TAG, "Could not delete trip from API: " + e.getMessage());
                          }
                      }).start();
                      
                      Log.d(TAG, "Trip deleted: " + tripId);
                  } catch (Exception e) {
                      Log.e(TAG, "Error deleting trip", e);
                  }
              }

              // Method to merge API trips with local trips
              public void mergeApiTrips(List<Trip> apiTrips) {
                  try {
                      List<Trip> localTrips = getAllTrips();
                      List<Trip> mergedTrips = new ArrayList<>();

                      // Start with local trips
                      mergedTrips.addAll(localTrips);

                      // Add API trips that don't exist locally
                      for (Trip apiTrip : apiTrips) {
                          boolean exists = false;
                          for (Trip localTrip : localTrips) {
                              // Check if trip already exists (same start time, distance, and locations)
                              if (Math.abs(localTrip.getStartTime() - apiTrip.getStartTime()) < 60000 && // Within 1 minute
                                  Math.abs(localTrip.getDistance() - apiTrip.getDistance()) < 0.1 &&
                                  (localTrip.getStartAddress() != null && localTrip.getStartAddress().equals(apiTrip.getStartAddress()))) {
                                  exists = true;
                                  break;
                              }
                          }

                          if (!exists) {
                              mergedTrips.add(apiTrip);
                              Log.d(TAG, "Added API trip: " + apiTrip.getStartAddress() + " → " + apiTrip.getEndAddress());
                          }
                      }

                      saveAllTrips(mergedTrips);
                      setLastApiSyncTime(System.currentTimeMillis());
                      Log.d(TAG, "Merged " + apiTrips.size() + " API trips with " + localTrips.size() + " local trips");

                  } catch (Exception e) {
                      Log.e(TAG, "Error merging API trips", e);
                  }
              }

              // Migration method to ensure all existing trips have unique IDs
              public void migrateExistingTrips() {
                  try {
                      Log.d(TAG, "Starting trip migration to add unique IDs");
                      List<Trip> trips = getAllTrips();
                      boolean needsSave = false;
                      
                      for (Trip trip : trips) {
                          if (trip.getUniqueTripId() == null || trip.getUniqueTripId().isEmpty()) {
                              trip.setUniqueTripId(java.util.UUID.randomUUID().toString());
                              trip.setSyncStatus("local");
                              trip.setSyncAttempts(0);
                              needsSave = true;
                              Log.d(TAG, "Assigned UUID to trip " + trip.getId() + ": " + trip.getUniqueTripId());
                          }
                      }
                      
                      if (needsSave) {
                          saveAllTrips(trips);
                          Log.d(TAG, "Migration completed - all trips now have unique IDs");
                      } else {
                          Log.d(TAG, "Migration not needed - all trips already have unique IDs");
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error during trip migration", e);
                  }
              }

              // User trip merge functionality - combines selected trips into one
              public Trip mergeUserTrips(List<String> tripIds) {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      List<Trip> tripsToMerge = new ArrayList<>();
                      
                      // Find trips to merge by ID
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              for (Trip trip : allTrips) {
                                  if (trip.getId() == id) {
                                      tripsToMerge.add(trip);
                                      break;
                                  }
                              }
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format: " + tripId);
                          }
                      }
                      
                      if (tripsToMerge.size() < 2) {
                          Log.w(TAG, "Need at least 2 trips to merge");
                          return null;
                      }
                      
                      // Sort trips by start time
                      Collections.sort(tripsToMerge, new Comparator<Trip>() {
                          @Override
                          public int compare(Trip t1, Trip t2) {
                              return Long.compare(t1.getStartTime(), t2.getStartTime());
                          }
                      });
                      
                      // Create merged trip using existing Trip structure
                      Trip firstTrip = tripsToMerge.get(0);
                      Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);
                      
                      Trip mergedTrip = new Trip();
                      mergedTrip.setId(System.currentTimeMillis());
                      mergedTrip.setStartTime(firstTrip.getStartTime());
                      mergedTrip.setEndTime(lastTrip.getEndTime());
                      mergedTrip.setStartAddress(firstTrip.getStartAddress());
                      mergedTrip.setEndAddress(lastTrip.getEndAddress());
                      mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                      mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                      mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                      mergedTrip.setEndLongitude(lastTrip.getEndLongitude());

                      // Calculate total distance
                      double totalDistance = 0;
                      for (Trip trip : tripsToMerge) {
                          totalDistance += trip.getDistance();
                      }
                      mergedTrip.setDistance(totalDistance);
                      
                      // Calculate total duration
                      long totalDuration = lastTrip.getEndTime() - firstTrip.getStartTime();
                      mergedTrip.setDuration(totalDuration);
                      
                      // Use category from first trip, or "Business" if mixed
                      String category = firstTrip.getCategory();
                      for (Trip trip : tripsToMerge) {
                          if (!trip.getCategory().equals(category)) {
                              category = "Business";
                              break;
                          }
                      }
                      mergedTrip.setCategory(category);
                      
                      // Combine client info  
                      StringBuilder clientBuilder = new StringBuilder();
                      for (Trip trip : tripsToMerge) {
                          if (trip.getClientName() != null && !trip.getClientName().isEmpty()) {
                              if (clientBuilder.length() > 0) clientBuilder.append(", ");
                              clientBuilder.append(trip.getClientName());
                          }
                      }
                      mergedTrip.setClientName(clientBuilder.toString());
                      
                      mergedTrip.setNotes("Merged from " + tripsToMerge.size() + " trips");
                      mergedTrip.setAutoDetected(false);
                      
                      // Save merged trip and delete originals
                      saveTrip(mergedTrip);
                      for (String tripId : tripIds) {
                          try {
                              long id = Long.parseLong(tripId);
                              deleteTrip(id);
                          } catch (NumberFormatException e) {
                              Log.w(TAG, "Invalid trip ID format for deletion: " + tripId);
                          }
                      }
                      
                      Log.d(TAG, "Successfully merged " + tripsToMerge.size() + " trips into: " + mergedTrip.getId());
                      return mergedTrip;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error merging user trips", e);
                      return null;
                  }
              }

              public List<Trip> getAllTrips() {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      String tripsJson = prefs.getString(TRIPS_KEY, "[]");
                      JSONArray array = new JSONArray(tripsJson);

                      for (int i = 0; i < array.length(); i++) {
                          JSONObject obj = array.getJSONObject(i);
                          Trip trip = new Trip();

                          trip.setId(obj.optLong("id", 0));
                          trip.setStartAddress(obj.optString("start_location", ""));
                          trip.setEndAddress(obj.optString("end_location", ""));
                          trip.setStartDisplayName(obj.optString("start_display_name", null));
                          trip.setEndDisplayName(obj.optString("end_display_name", null));
                          trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                          trip.setDistance(obj.optDouble("distance", 0));
                          trip.setDuration(obj.optLong("duration", 0));
                          trip.setCategory(obj.optString("category", "Uncategorized"));
                          trip.setStartTime(obj.optLong("start_time", 0));
                          trip.setEndTime(obj.optLong("end_time", 0));
                          trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                          trip.setClientName(obj.optString("client_name", ""));
                          trip.setNotes(obj.optString("notes", ""));
                          trip.setVehicleName(obj.optString("vehicle_name", null));
                          trip.setVehicleType(obj.optString("vehicle_type", null));
                          trip.setVehicleDeviceAddress(obj.optString("vehicle_device_address", null));
                          trip.setBluetoothTriggered(obj.optBoolean("bluetooth_triggered", false));
                          
                          // Handle new offline sync fields with migration for existing trips
                          String uniqueTripId = obj.optString("unique_trip_id", null);
                          if (uniqueTripId == null || uniqueTripId.isEmpty()) {
                              // Generate UUID for existing trips that don't have one
                              uniqueTripId = java.util.UUID.randomUUID().toString();
                          }
                          trip.setUniqueTripId(uniqueTripId);
                          trip.setSyncStatus(obj.optString("sync_status", "local"));
                          trip.setSyncAttempts(obj.optInt("sync_attempts", 0));

                          trips.add(trip);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading trips", e);
                  }
                  return trips;
              }

              public void saveCurrentTrip(Trip trip) {
                  try {
                      if (trip == null) {
                          prefs.edit().remove(CURRENT_TRIP_KEY).apply();
                          Log.d(TAG, "Current trip cleared");
                          return;
                      }

                      JSONObject obj = new JSONObject();
                      obj.put("id", trip.getId());
                      obj.put("start_location", trip.getStartAddress());
                      obj.put("end_location", trip.getEndAddress());
                      obj.put("start_display_name", trip.getStartDisplayName());
                      obj.put("end_display_name", trip.getEndDisplayName());
                      obj.put("start_latitude", trip.getStartLatitude());
                      obj.put("start_longitude", trip.getStartLongitude());
                      obj.put("end_latitude", trip.getEndLatitude());
                      obj.put("end_longitude", trip.getEndLongitude());
                      obj.put("distance", trip.getDistance());
                      obj.put("duration", trip.getDuration());
                      obj.put("category", trip.getCategory());
                      obj.put("start_time", trip.getStartTime());
                      obj.put("end_time", trip.getEndTime());
                      obj.put("auto_detected", trip.isAutoDetected());
                      obj.put("client_name", trip.getClientName());
                      obj.put("notes", trip.getNotes());
                      obj.put("vehicle_name", trip.getVehicleName());
                      obj.put("vehicle_type", trip.getVehicleType());
                      obj.put("vehicle_device_address", trip.getVehicleDeviceAddress());
                      obj.put("bluetooth_triggered", trip.isBluetoothTriggered());
                      obj.put("unique_trip_id", trip.getUniqueTripId());
                      obj.put("sync_status", trip.getSyncStatus());
                      obj.put("sync_attempts", trip.getSyncAttempts());

                      prefs.edit().putString(CURRENT_TRIP_KEY, obj.toString()).apply();
                      Log.d(TAG, "Current trip saved: " + trip.getId());
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving current trip", e);
                  }
              }

              public Trip getCurrentTrip() {
                  try {
                      String currentTripJson = prefs.getString(CURRENT_TRIP_KEY, null);
                      if (currentTripJson == null) return null;

                      JSONObject obj = new JSONObject(currentTripJson);
                      Trip trip = new Trip();

                      trip.setId(obj.optLong("id", 0));
                      trip.setStartAddress(obj.optString("start_location", ""));
                      trip.setEndAddress(obj.optString("end_location", ""));
                      trip.setStartDisplayName(obj.optString("start_display_name", null));
                      trip.setEndDisplayName(obj.optString("end_display_name", null));
                      trip.setStartLatitude(obj.optDouble("start_latitude", 0));
                      trip.setStartLongitude(obj.optDouble("start_longitude", 0));
                      trip.setEndLatitude(obj.optDouble("end_latitude", 0));
                      trip.setEndLongitude(obj.optDouble("end_longitude", 0));
                      trip.setDistance(obj.optDouble("distance", 0));
                      trip.setDuration(obj.optLong("duration", 0));
                      trip.setCategory(obj.optString("category", "Uncategorized"));
                      trip.setStartTime(obj.optLong("start_time", 0));
                      trip.setEndTime(obj.optLong("end_time", 0));
                      trip.setAutoDetected(obj.optBoolean("auto_detected", false));
                      trip.setClientName(obj.optString("client_name", ""));
                      trip.setNotes(obj.optString("notes", ""));
                      trip.setVehicleName(obj.optString("vehicle_name", null));
                      trip.setVehicleType(obj.optString("vehicle_type", null));
                      trip.setVehicleDeviceAddress(obj.optString("vehicle_device_address", null));
                      trip.setBluetoothTriggered(obj.optBoolean("bluetooth_triggered", false));
                      
                      // Handle new offline sync fields for current trip
                      String uniqueTripId = obj.optString("unique_trip_id", null);
                      if (uniqueTripId == null || uniqueTripId.isEmpty()) {
                          uniqueTripId = java.util.UUID.randomUUID().toString();
                      }
                      trip.setUniqueTripId(uniqueTripId);
                      trip.setSyncStatus(obj.optString("sync_status", "local"));
                      trip.setSyncAttempts(obj.optInt("sync_attempts", 0));

                      return trip;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading current trip", e);
                      return null;
                  }
              }

              private void saveAllTrips(List<Trip> trips) {
                  try {
                      JSONArray array = new JSONArray();
                      for (Trip trip : trips) {
                          JSONObject obj = new JSONObject();
                          obj.put("id", trip.getId());
                          obj.put("start_location", trip.getStartAddress());
                          obj.put("end_location", trip.getEndAddress());
                          obj.put("start_display_name", trip.getStartDisplayName());
                          obj.put("end_display_name", trip.getEndDisplayName());
                          obj.put("start_latitude", trip.getStartLatitude());
                          obj.put("start_longitude", trip.getStartLongitude());
                          obj.put("end_latitude", trip.getEndLatitude());
                          obj.put("end_longitude", trip.getEndLongitude());
                          obj.put("distance", trip.getDistance());
                          obj.put("duration", trip.getDuration());
                          obj.put("category", trip.getCategory());
                          obj.put("start_time", trip.getStartTime());
                          obj.put("end_time", trip.getEndTime());
                          obj.put("auto_detected", trip.isAutoDetected());
                          obj.put("client_name", trip.getClientName());
                          obj.put("notes", trip.getNotes());
                          obj.put("vehicle_name", trip.getVehicleName());
                          obj.put("vehicle_type", trip.getVehicleType());
                          obj.put("vehicle_device_address", trip.getVehicleDeviceAddress());
                          obj.put("bluetooth_triggered", trip.isBluetoothTriggered());
                          obj.put("unique_trip_id", trip.getUniqueTripId());
                          obj.put("sync_status", trip.getSyncStatus());
                          obj.put("sync_attempts", trip.getSyncAttempts());
                          array.put(obj);
                      }
                      prefs.edit().putString(TRIPS_KEY, array.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trips", e);
                  }
              }
              
              // Work Hours Auto-Classification Methods
              private static final String WORK_HOURS_ENABLED_KEY = "work_hours_enabled";
              private static final String WORK_START_TIME_KEY = "work_start_time";
              private static final String WORK_END_TIME_KEY = "work_end_time";
              private static final String WORK_DAYS_KEY = "work_days";
              
              public boolean isWorkHoursEnabled() {
                  return prefs.getBoolean(WORK_HOURS_ENABLED_KEY, false);
              }
              
              public void setWorkHoursEnabled(boolean enabled) {
                  prefs.edit().putBoolean(WORK_HOURS_ENABLED_KEY, enabled).apply();
              }
              
              public String getWorkStartTime() {
                  return prefs.getString(WORK_START_TIME_KEY, "09:00");
              }
              
              public void setWorkStartTime(String startTime) {
                  prefs.edit().putString(WORK_START_TIME_KEY, startTime).apply();
              }
              
              public String getWorkEndTime() {
                  return prefs.getString(WORK_END_TIME_KEY, "17:00");
              }
              
              public void setWorkEndTime(String endTime) {
                  prefs.edit().putString(WORK_END_TIME_KEY, endTime).apply();
              }
              
              public List<Integer> getWorkDays() {
                  try {
                      String workDaysJson = prefs.getString(WORK_DAYS_KEY, "[2,3,4,5,6]"); // Default Mon-Fri
                      JSONArray jsonArray = new JSONArray(workDaysJson);
                      List<Integer> workDays = new ArrayList<>();
                      for (int i = 0; i < jsonArray.length(); i++) {
                          workDays.add(jsonArray.getInt(i));
                      }
                      return workDays;
                  } catch (Exception e) {
                      Log.e(TAG, "Error loading work days", e);
                      // Default to Monday-Friday
                      List<Integer> defaultDays = new ArrayList<>();
                      defaultDays.add(2); // Monday
                      defaultDays.add(3); // Tuesday
                      defaultDays.add(4); // Wednesday
                      defaultDays.add(5); // Thursday
                      defaultDays.add(6); // Friday
                      return defaultDays;
                  }
              }
              
              public void setWorkDays(List<Integer> workDays) {
                  try {
                      JSONArray jsonArray = new JSONArray();
                      for (Integer day : workDays) {
                          jsonArray.put(day);
                      }
                      prefs.edit().putString(WORK_DAYS_KEY, jsonArray.toString()).apply();
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving work days", e);
                  }
              }
              
              public boolean isWithinWorkHours(long timestamp) {
                  if (!isWorkHoursEnabled()) {
                      return false;
                  }
                  
                  try {
                      java.util.Calendar calendar = java.util.Calendar.getInstance();
                      calendar.setTimeInMillis(timestamp);
                      
                      // Check if it's a work day
                      int dayOfWeek = calendar.get(java.util.Calendar.DAY_OF_WEEK);
                      List<Integer> workDays = getWorkDays();
                      if (!workDays.contains(dayOfWeek)) {
                          return false;
                      }
                      
                      // Check if it's within work hours
                      int hour = calendar.get(java.util.Calendar.HOUR_OF_DAY);
                      int minute = calendar.get(java.util.Calendar.MINUTE);
                      int currentTimeMinutes = hour * 60 + minute;
                      
                      String startTime = getWorkStartTime();
                      String endTime = getWorkEndTime();
                      
                      String[] startParts = startTime.split(":");
                      int startHour = Integer.parseInt(startParts[0]);
                      int startMinute = Integer.parseInt(startParts[1]);
                      int startTimeMinutes = startHour * 60 + startMinute;
                      
                      String[] endParts = endTime.split(":");
                      int endHour = Integer.parseInt(endParts[0]);
                      int endMinute = Integer.parseInt(endParts[1]);
                      int endTimeMinutes = endHour * 60 + endMinute;
                      
                      return currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes;
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error checking work hours", e);
                      return false;
                  }
              }
              
              // Round-trip detection methods
              public List<List<Trip>> getRoundTripGroups() {
                  try {
                      List<List<Trip>> groups = new ArrayList<>();
                      List<Trip> allTrips = getAllTrips();
                      
                      for (Trip trip : allTrips) {
                          if (trip.isRoundTrip() && trip.getRoundTripGroupId() != null) {
                              String groupId = trip.getRoundTripGroupId();
                              boolean foundGroup = false;
                              
                              for (List<Trip> group : groups) {
                                  if (!group.isEmpty() && groupId.equals(group.get(0).getRoundTripGroupId())) {
                                      group.add(trip);
                                      foundGroup = true;
                                      break;
                                  }
                              }
                              
                              if (!foundGroup) {
                                  List<Trip> newGroup = new ArrayList<>();
                                  newGroup.add(trip);
                                  groups.add(newGroup);
                              }
                          }
                      }
                      
                      // Sort trips within each group by segment number
                      for (List<Trip> group : groups) {
                          Collections.sort(group, (t1, t2) -> Integer.compare(t1.getRoundTripSegment(), t2.getRoundTripSegment()));
                      }
                      
                      return groups;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting round trip groups", e);
                      return new ArrayList<>();
                  }
              }
              
              public void detectRoundTrips() {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      Collections.sort(allTrips, (t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));
                      
                      String groupId = String.valueOf(System.currentTimeMillis());
                      
                      // Level 1: Daily round-trips (A→B→A same day)
                      for (int i = 0; i < allTrips.size() - 1; i++) {
                          Trip trip1 = allTrips.get(i);
                          Trip trip2 = allTrips.get(i + 1);
                          
                          if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;
                          
                          double distance = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                  trip2.getEndLatitude(), trip2.getEndLongitude());
                          
                          long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                          
                          if (distance <= 0.5 && timeDiff <= 12 * 60 * 60 * 1000) { // 0.5 miles, 12 hours
                              trip1.setRoundTripGroupId(groupId);
                              trip1.setRoundTrip(true);
                              trip1.setRoundTripSegment(1);
                              
                              trip2.setRoundTripGroupId(groupId);
                              trip2.setRoundTrip(true);
                              trip2.setRoundTripSegment(2);
                              
                              saveTrip(trip1);
                              saveTrip(trip2);
                              
                              groupId = String.valueOf(System.currentTimeMillis() + 1);
                          }
                      }
                      
                      // Level 2: Multi-day business trips with airports
                      for (int i = 0; i < allTrips.size() - 2; i++) {
                          Trip trip1 = allTrips.get(i);
                          Trip trip2 = allTrips.get(i + 1);
                          Trip trip3 = allTrips.get(i + 2);
                          
                          if (trip1.isRoundTrip() || trip2.isRoundTrip() || trip3.isRoundTrip()) continue;
                          
                          boolean hasAirport = isAirportLocation(trip1.getEndAddress()) || 
                                             isAirportLocation(trip2.getStartAddress()) ||
                                             isAirportLocation(trip2.getEndAddress()) ||
                                             isAirportLocation(trip3.getStartAddress());
                          
                          if (hasAirport) {
                              double homeToAirport = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                      trip3.getEndLatitude(), trip3.getEndLongitude());
                              
                              long tripDuration = trip3.getEndTime() - trip1.getStartTime();
                              
                              if (homeToAirport <= 1.0 && tripDuration <= 7 * 24 * 60 * 60 * 1000) { // 1 mile, 7 days
                                  trip1.setRoundTripGroupId(groupId);
                                  trip1.setRoundTrip(true);
                                  trip1.setRoundTripSegment(1);
                                  
                                  trip2.setRoundTripGroupId(groupId);
                                  trip2.setRoundTrip(true);
                                  trip2.setRoundTripSegment(2);
                                  
                                  trip3.setRoundTripGroupId(groupId);
                                  trip3.setRoundTrip(true);
                                  trip3.setRoundTripSegment(3);
                                  
                                  saveTrip(trip1);
                                  saveTrip(trip2);
                                  saveTrip(trip3);
                                  
                                  groupId = String.valueOf(System.currentTimeMillis() + 2);
                              }
                          }
                      }
                      
                      Log.d(TAG, "Round-trip detection completed");
                  } catch (Exception e) {
                      Log.e(TAG, "Error in round-trip detection", e);
                  }
              }
              
              private boolean isAirportLocation(String address) {
                  if (address == null) return false;
                  String lowerAddress = address.toLowerCase();
                  return lowerAddress.contains("airport") || lowerAddress.contains("airfield") || 
                         lowerAddress.contains("international") || lowerAddress.contains("terminal");
              }
              

              
              // ==================== FREQUENT LOCATION MANAGEMENT ====================
              // Add or update a known location
              public void addKnownLocation(String name, String address, double latitude, double longitude, String defaultCategory) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      // Check if location already exists within 0.1 miles
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          double existingLat = location.getDouble("latitude");
                          double existingLon = location.getDouble("longitude");
                          
                          if (calculateDistance(latitude, longitude, existingLat, existingLon) <= 0.1) {
                              // Update existing location
                              location.put("name", name);
                              location.put("address", address);
                              location.put("defaultCategory", defaultCategory);
                              prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                              Log.d(TAG, "Updated known location: " + name);
                              return;
                          }
                      }
                      
                      // Add new location
                      JSONObject newLocation = new JSONObject();
                      newLocation.put("name", name);
                      newLocation.put("address", address);
                      newLocation.put("latitude", latitude);
                      newLocation.put("longitude", longitude);
                      newLocation.put("defaultCategory", defaultCategory);
                      newLocation.put("visitCount", 1);
                      newLocation.put("lastVisited", System.currentTimeMillis());
                      
                      locationsArray.put(newLocation);
                      prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                      Log.d(TAG, "Added known location: " + name + " (" + defaultCategory + ")");
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding known location", e);
                  }
              }
              
              // Get known location name if coordinates are near a known location
              public String getKnownLocationName(double latitude, double longitude) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          double locLat = location.getDouble("latitude");
                          double locLon = location.getDouble("longitude");
                          
                          // Within 0.1 miles (about 500 feet)
                          if (calculateDistance(latitude, longitude, locLat, locLon) <= 0.1) {
                              String name = location.getString("name");
                              String address = location.getString("address");
                              
                              // Update visit count
                              int visitCount = location.optInt("visitCount", 0) + 1;
                              location.put("visitCount", visitCount);
                              location.put("lastVisited", System.currentTimeMillis());
                              prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                              
                              Log.d(TAG, "Using known location: " + name + " (visit #" + visitCount + ")");
                              return name + " - " + address;
                          }
                      }
                      return null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting known location", e);
                      return null;
                  }
              }
              
              // Get default category for a known location
              public String getKnownLocationCategory(double latitude, double longitude) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          double locLat = location.getDouble("latitude");
                          double locLon = location.getDouble("longitude");
                          
                          if (calculateDistance(latitude, longitude, locLat, locLon) <= 0.1) {
                              return location.getString("defaultCategory");
                          }
                      }
                      return null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting known location category", e);
                      return null;
                  }
              }
              
              // Auto-detect frequently visited locations (3+ visits)
              public void detectFrequentLocations() {
                  try {
                      List<Trip> allTrips = getAllTrips();
                      java.util.Map<String, LocationData> locationMap = new java.util.HashMap<>();
                      
                      // Analyze all trip start/end locations
                      for (Trip trip : allTrips) {
                          processLocationForFrequency(trip.getStartLatitude(), trip.getStartLongitude(), 
                                                    trip.getStartAddress(), locationMap);
                          processLocationForFrequency(trip.getEndLatitude(), trip.getEndLongitude(), 
                                                    trip.getEndAddress(), locationMap);
                      }
                      
                      // Identify locations visited 3+ times
                      for (java.util.Map.Entry<String, LocationData> entry : locationMap.entrySet()) {
                          LocationData data = entry.getValue();
                          if (data.visitCount >= 3 && !isLocationAlreadyKnown(data.latitude, data.longitude)) {
                              String suggestedCategory = suggestCategoryFromAddress(data.address);
                              String suggestedName = suggestLocationName(data.address, suggestedCategory);
                              addKnownLocation(suggestedName, data.address, data.latitude, data.longitude, suggestedCategory);
                              Log.d(TAG, "Auto-detected frequent location: " + suggestedName + " (" + data.visitCount + " visits)");
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error detecting frequent locations", e);
                  }
              }
              
              // Helper methods for frequent location detection
              private void processLocationForFrequency(double latitude, double longitude, String address, java.util.Map<String, LocationData> locationMap) {
                  if (latitude == 0 && longitude == 0) return;
                  
                  // Round to ~100 meter precision for grouping
                  double roundedLat = Math.round(latitude * 1000.0) / 1000.0;
                  double roundedLon = Math.round(longitude * 1000.0) / 1000.0;
                  String locationKey = roundedLat + "," + roundedLon;
                  
                  LocationData data = locationMap.get(locationKey);
                  if (data == null) {
                      data = new LocationData(latitude, longitude, address);
                      locationMap.put(locationKey, data);
                  }
                  data.visitCount++;
              }
              
              private boolean isLocationAlreadyKnown(double latitude, double longitude) {
                  return getKnownLocationName(latitude, longitude) != null;
              }
              
              private String suggestCategoryFromAddress(String address) {
                  if (address == null) return "Personal";
                  
                  String lowerAddress = address.toLowerCase();
                  
                  // Business indicators
                  if (lowerAddress.contains("office") || lowerAddress.contains("corp") || 
                      lowerAddress.contains("company") || lowerAddress.contains("business") ||
                      lowerAddress.contains("po box") || lowerAddress.contains("p.o. box") ||
                      lowerAddress.contains("suite") || lowerAddress.contains("building") ||
                      lowerAddress.contains("plaza") || lowerAddress.contains("center")) {
                      return "Business";
                  }
                  
                  // Medical indicators
                  if (lowerAddress.contains("hospital") || lowerAddress.contains("clinic") ||
                      lowerAddress.contains("medical") || lowerAddress.contains("doctor") ||
                      lowerAddress.contains("health") || lowerAddress.contains("pharmacy")) {
                      return "Medical";
                  }
                  
                  // Charity indicators
                  if (lowerAddress.contains("church") || lowerAddress.contains("charity") ||
                      lowerAddress.contains("nonprofit") || lowerAddress.contains("foundation") ||
                      lowerAddress.contains("volunteer")) {
                      return "Charity";
                  }
                  
                  return "Personal";
              }
              
              private String suggestLocationName(String address, String category) {
                  if (address == null) return "Unknown Location";
                  
                  String lowerAddress = address.toLowerCase();
                  
                  // Extract meaningful parts of address
                  if (lowerAddress.contains("po box") || lowerAddress.contains("p.o. box")) {
                      return "PO Box";
                  }
                  if (lowerAddress.contains("office")) {
                      return "Office";
                  }
                  if (lowerAddress.contains("hospital")) {
                      return "Hospital";
                  }
                  if (lowerAddress.contains("clinic")) {
                      return "Clinic";
                  }
                  if (lowerAddress.contains("church")) {
                      return "Church";
                  }
                  
                  // Use category as fallback
                  return category + " Location";
              }
              
              // Enhanced trip classification using known locations
              public String getSmartCategoryForLocation(double latitude, double longitude) {
                  try {
                      // Check if it's home (always Personal)
                      if (isNearHome(latitude, longitude)) {
                          return "Personal";
                      }
                      
                      // Check known locations
                      String knownCategory = getKnownLocationCategory(latitude, longitude);
                      if (knownCategory != null) {
                          return knownCategory;
                      }
                      
                      // Fallback to default logic
                      return "Personal";
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting smart category", e);
                      return "Personal";
                  }
              }
              
              // Management methods for settings
              public java.util.List<String> getKnownLocationsList() {
                  try {
                      java.util.List<String> locationNames = new java.util.ArrayList<>();
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          String name = location.getString("name");
                          String category = location.getString("defaultCategory");
                          int visitCount = location.optInt("visitCount", 0);
                          locationNames.add(name + " (" + category + ", " + visitCount + " visits)");
                      }
                      return locationNames;
                  } catch (Exception e) {
                      Log.e(TAG, "Error getting known locations list", e);
                      return new java.util.ArrayList<>();
                  }
              }
              
              public void removeKnownLocation(String name) {
                  try {
                      String locations = prefs.getString("known_locations", "[]");
                      JSONArray locationsArray = new JSONArray(locations);
                      
                      for (int i = 0; i < locationsArray.length(); i++) {
                          JSONObject location = locationsArray.getJSONObject(i);
                          if (name.equals(location.getString("name"))) {
                              locationsArray.remove(i);
                              break;
                          }
                      }
                      
                      prefs.edit().putString("known_locations", locationsArray.toString()).apply();
                      Log.d(TAG, "Removed known location: " + name);
                  } catch (Exception e) {
                      Log.e(TAG, "Error removing known location", e);
                  }
              }
              
              // Helper class for location frequency tracking
              private static class LocationData {
                  double latitude;
                  double longitude;
                  String address;
                  int visitCount;
                  
                  LocationData(double lat, double lon, String addr) {
                      latitude = lat;
                      longitude = lon;
                      address = addr;
                      visitCount = 0;
                  }
              }
              // ==================== END FREQUENT LOCATION MANAGEMENT ====================
              
              // ==================== FREEMIUM NOTIFICATION SYSTEM ====================
              // Check monthly trip count and send notifications at 30, 35, and 40 trips
              private void checkAndSendUsageNotifications() {
                  if (isPremiumUser()) {
                      return; // No notifications for premium users
                  }
                  
                  int monthlyCount = getMonthlyTripCount();
                  
                  // Send notifications at specific milestones
                  if (monthlyCount == 30) {
                      sendTripUsageNotification(30, FREE_TIER_TRIP_LIMIT, 
                          "📊 30 of 40 trips used",
                          "You have 10 trips remaining this month. Upgrade to Premium for unlimited trips!");
                  } else if (monthlyCount == 35) {
                      sendTripUsageNotification(35, FREE_TIER_TRIP_LIMIT,
                          "⚠️ Only 5 trips left!",
                          "Upgrade to Premium for unlimited trips and cloud sync.");
                  } else if (monthlyCount >= FREE_TIER_TRIP_LIMIT) {
                      sendTripUsageNotification(FREE_TIER_TRIP_LIMIT, FREE_TIER_TRIP_LIMIT,
                          "🚫 Trip Limit Reached",
                          "You've used all 40 free trips this month. Upgrade to Premium for unlimited trips!");
                  }
              }
              
              // Send trip usage notification
              private void sendTripUsageNotification(int tripCount, int tripLimit, String title, String message) {
                  try {
                      createNotificationChannel();
                      
                      NotificationCompat.Builder builder = new NotificationCompat.Builder(context, "freemium_channel")
                          .setSmallIcon(android.R.drawable.ic_dialog_info)
                          .setContentTitle(title)
                          .setContentText(message)
                          .setStyle(new NotificationCompat.BigTextStyle().bigText(message))
                          .setPriority(NotificationCompat.PRIORITY_HIGH)
                          .setAutoCancel(true);
                      
                      NotificationManager notificationManager = 
                          (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
                      
                      if (notificationManager != null) {
                          // Use trip count as notification ID so we don't spam duplicates
                          notificationManager.notify(8000 + tripCount, builder.build());
                          Log.d(TAG, "Sent freemium notification: " + title);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending trip usage notification", e);
                  }
              }
              
              // Create notification channel for Android O+
              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      try {
                          NotificationChannel channel = new NotificationChannel(
                              "freemium_channel",
                              "Freemium Notifications",
                              NotificationManager.IMPORTANCE_HIGH
                          );
                          channel.setDescription("Trip usage and upgrade notifications");
                          
                          NotificationManager notificationManager = 
                              (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
                          
                          if (notificationManager != null) {
                              notificationManager.createNotificationChannel(channel);
                          }
                      } catch (Exception e) {
                          Log.e(TAG, "Error creating notification channel", e);
                      }
                  }
              }
              // ==================== END FREEMIUM NOTIFICATION SYSTEM ====================
          }
          EOF

      - name: Create CloudBackupService with user-based download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.auth.UserAuthManager;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;

          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.io.OutputStream;
          import java.net.HttpURLConnection;
          import java.net.URL;
          import java.nio.charset.StandardCharsets;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://mileage-tracker-codenurse.replit.app/api";

              private Context context;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.context = context;
                  this.executor = Executors.newSingleThreadExecutor();
              }

              // UPLOAD FUNCTIONALITY
              public void backupTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping backup");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting API backup for trip: " + trip.getId());

                          URL url = new URL(API_BASE_URL + "/trips");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          // Use authenticated user's email and token dynamically
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          String jsonPayload = createTripJson(trip, null, tripStorage.getUserId());

                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API backup response: " + responseCode);

                          if (responseCode == 200 || responseCode == 201) {
                              Log.d(TAG, "Trip backed up successfully to API");
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error backing up trip to API", e);
                      }
                  });
              }

              // DOWNLOAD ALL USER TRIPS (not just device-specific)
              public void downloadAllUserTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping download");
                      return;
                  }

                  executor.execute(() -> {
                      try {
                          String userId = tripStorage.getUserId();
                          Log.d(TAG, "Starting download ALL trips for user: " + userId);

                          // Download ALL trips from the API (not device-specific)
                          String apiUrl = API_BASE_URL + "/trips";
                          URL url = new URL(apiUrl);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("User-Agent", "MileTrackerPro-Android/4.9.63");
                          // Use authenticated user's email and token dynamically
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          int responseCode = conn.getResponseCode();
                          Log.d(TAG, "API download ALL trips response: " + responseCode);

                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(
                                      new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }

                              List<Trip> apiTrips = parseTripsFromJson(response.toString());
                              Log.d(TAG, "Downloaded " + apiTrips.size() + " trips from API (all user trips)");

                              if (!apiTrips.isEmpty()) {
                                  tripStorage.mergeApiTrips(apiTrips);
                                  Log.d(TAG, "Successfully merged API trips");
                              }
                          } else {
                              Log.w(TAG, "API download failed with code: " + responseCode);
                          }

                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error downloading trips from API", e);
                      }
                  });
              }

              private List<Trip> parseTripsFromJson(String jsonResponse) {
                  List<Trip> trips = new ArrayList<>();
                  try {
                      // Handle server response format: { trips: [...] }
                      JSONObject responseObj = new JSONObject(jsonResponse);
                      JSONArray tripsArray = responseObj.optJSONArray("trips");
                      
                      // Fallback to direct array if no "trips" property
                      if (tripsArray == null) {
                          tripsArray = new JSONArray(jsonResponse);
                      }

                      for (int i = 0; i < tripsArray.length(); i++) {
                          JSONObject tripObj = tripsArray.getJSONObject(i);
                          Trip trip = new Trip();

                          // Parse API response fields - handle actual database structure
                          trip.setId(tripObj.optLong("id", System.currentTimeMillis()));
                          
                          // Address fields - server returns start_location/end_location (encrypted)
                          String startAddr = tripObj.optString("start_location", "Unknown");
                          String endAddr = tripObj.optString("end_location", "Unknown");
                          
                          // If still encrypted (contains colons), show coordinates instead
                          if (startAddr.contains(":")) {
                              double lat = tripObj.optDouble("start_latitude", 0);
                              double lng = tripObj.optDouble("start_longitude", 0);
                              startAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          if (endAddr.contains(":")) {
                              double lat = tripObj.optDouble("end_latitude", 0);
                              double lng = tripObj.optDouble("end_longitude", 0);
                              endAddr = String.format("%.4f, %.4f", lat, lng);
                          }
                          
                          trip.setStartAddress(startAddr);
                          trip.setEndAddress(endAddr);
                          trip.setStartDisplayName(tripObj.optString("start_display_name", null));
                          trip.setEndDisplayName(tripObj.optString("end_display_name", null));
                          trip.setStartLatitude(tripObj.optDouble("start_latitude", 0));
                          trip.setStartLongitude(tripObj.optDouble("start_longitude", 0));
                          trip.setEndLatitude(tripObj.optDouble("end_latitude", 0));
                          trip.setEndLongitude(tripObj.optDouble("end_longitude", 0));
                          
                          // Distance
                          trip.setDistance(tripObj.optDouble("distance", 0));
                          
                          // Duration - keep in milliseconds (as expected by Trip class)
                          long durationMs = tripObj.optLong("duration", 0);
                          trip.setDuration(durationMs);
                          
                          // Parse timestamps properly - handle both string and long formats
                          String startTimeStr = tripObj.optString("start_time", "");
                          String endTimeStr = tripObj.optString("end_time", "");
                          
                          if (!startTimeStr.isEmpty()) {
                              long startTime = parseTimestamp(startTimeStr);
                              if (startTime > 0) {
                                  trip.setStartTime(startTime);
                              } else {
                                  Log.w(TAG, "Invalid start_time in API response for trip: " + tripObj.optLong("id", 0));
                              }
                          } else {
                              Log.w(TAG, "Missing start_time in API response for trip: " + tripObj.optLong("id", 0));
                          }
                          
                          if (!endTimeStr.isEmpty()) {
                              long endTime = parseTimestamp(endTimeStr);
                              if (endTime > 0) {
                                  trip.setEndTime(endTime);
                              } else {
                                  Log.w(TAG, "Invalid end_time in API response for trip: " + tripObj.optLong("id", 0));
                              }
                          } else {
                              Log.w(TAG, "Missing end_time in API response for trip: " + tripObj.optLong("id", 0));
                          }
                          
                          trip.setCategory(tripObj.optString("category", "Uncategorized"));
                          
                          // Auto detection status
                          trip.setAutoDetected(tripObj.optBoolean("auto_detected", false));
                          
                          // Client and notes - handle encrypted values
                          String clientName = tripObj.optString("client_name", "");
                          if (clientName.contains(":")) clientName = ""; // Skip encrypted values
                          trip.setClientName(clientName);
                          
                          String notes = tripObj.optString("notes", "");
                          if (notes.contains(":")) notes = ""; // Skip encrypted values
                          trip.setNotes(notes);

                          trips.add(trip);
                          Log.d(TAG, "Parsed API trip: " + trip.getStartAddress() + " → " + trip.getEndAddress());
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error parsing trips JSON", e);
                  }
                  return trips;
              }
              
              private long parseTimestamp(String timestampStr) {
                  try {
                      if (timestampStr == null || timestampStr.isEmpty()) return 0;
                      
                      // Handle ISO timestamp format from database
                      if (timestampStr.contains("T")) {
                          return java.time.Instant.parse(timestampStr).toEpochMilli();
                      }
                      
                      // Handle epoch milliseconds
                      return Long.parseLong(timestampStr);
                  } catch (Exception e) {
                      Log.w(TAG, "Failed to parse timestamp: " + timestampStr);
                      return 0;
                  }
              }

              private String createTripJson(Trip trip, String deviceId, String userId) {
                  try {
                      String method = trip.isAutoDetected() ? "auto_detection" : "manual";
                      
                      // Use actual display names from Trip object, fallback to home detection only if null
                      String startDisplayName = trip.getStartDisplayName();
                      String endDisplayName = trip.getEndDisplayName();
                      
                      // Only use home detection as fallback if no display names are set
                      if (startDisplayName == null || startDisplayName.trim().isEmpty()) {
                          TripStorage tripStorage = new TripStorage(context);
                          startDisplayName = tripStorage.getHomeAddressIfNear(trip.getStartLatitude(), trip.getStartLongitude());
                      }
                      if (endDisplayName == null || endDisplayName.trim().isEmpty()) {
                          TripStorage tripStorage = new TripStorage(context);
                          endDisplayName = tripStorage.getHomeAddressIfNear(trip.getEndLatitude(), trip.getEndLongitude());
                      }
                      
                      return String.format(Locale.getDefault(),
                          "{"
                          + "\"start_location\":\"%s\","
                          + "\"end_location\":\"%s\","
                          + "\"start_display_name\":\"%s\","
                          + "\"end_display_name\":\"%s\","
                          + "\"start_latitude\":%.8f,"
                          + "\"start_longitude\":%.8f,"
                          + "\"end_latitude\":%.8f,"
                          + "\"end_longitude\":%.8f,"
                          + "\"distance\":%.6f,"
                          + "\"duration\":%d,"
                          + "\"category\":\"%s\","
                          + "\"method\":\"%s\","
                          + "\"auto_detected\":%s,"
                          + "\"start_time\":%d,"
                          + "\"end_time\":%d,"
                          + "\"client_name\":\"%s\","
                          + "\"notes\":\"%s\","
                          + "\"vehicle_name\":\"%s\","
                          + "\"vehicle_type\":\"%s\","
                          + "\"vehicle_device_address\":\"%s\","
                          + "\"unique_trip_id\":\"%s\","
                          + "\"sync_status\":\"%s\","
                          + "\"sync_attempts\":%d,"
                          + "\"timezone\":\"America/New_York\""
                          + "}",
                          trip.getStartAddress() != null ? trip.getStartAddress().replace("\"", "\\\"") : "",
                          trip.getEndAddress() != null ? trip.getEndAddress().replace("\"", "\\\"") : "",
                          startDisplayName != null ? startDisplayName.replace("\"", "\\\"") : "",
                          endDisplayName != null ? endDisplayName.replace("\"", "\\\"") : "",
                          trip.getStartLatitude(),
                          trip.getStartLongitude(),
                          trip.getEndLatitude(),
                          trip.getEndLongitude(),
                          trip.getDistance(),
                          trip.getDuration(),
                          trip.getCategory(),
                          method,
                          trip.isAutoDetected(),
                          trip.getStartTime(),
                          trip.getEndTime(),
                          trip.getClientName() != null ? trip.getClientName().replace("\"", "\\\"") : "",
                          trip.getNotes() != null ? trip.getNotes().replace("\"", "\\\"") : "",
                          trip.getVehicleName() != null ? trip.getVehicleName().replace("\"", "\\\"") : "",
                          trip.getVehicleType() != null ? trip.getVehicleType().replace("\"", "\\\"") : "",
                          trip.getVehicleDeviceAddress() != null ? trip.getVehicleDeviceAddress().replace("\"", "\\\"") : "",
                          trip.getUniqueTripId() != null ? trip.getUniqueTripId().replace("\"", "\\\"") : "",
                          trip.getSyncStatus() != null ? trip.getSyncStatus().replace("\"", "\\\"") : "",
                          trip.getSyncAttempts()
                      );
                  } catch (Exception e) {
                      Log.e(TAG, "Error creating trip JSON", e);
                      return "{}";
                  }
              }

              // ADVANCED ROUND-TRIP DETECTION SYSTEM
              // Superior to MileIQ's primitive A->B->A detection
              
              /**
               * Detects potential round-trip patterns using multi-level clustering
               * Level 1: Daily round-trips (hotel->meeting->hotel)
               * Level 2: Trip segments (home->airport->destination)
               * Level 3: Complete trip groups (multi-day business trips)
               */
              public void detectRoundTrips() {
                  try {
                      List<Trip> recentTrips = getAllTrips();
                      if (recentTrips.size() < 2) return;

                      // Sort by start time for chronological analysis
                      Collections.sort(recentTrips, (t1, t2) -> Long.compare(t1.getStartTime(), t2.getStartTime()));

                      // Detect different types of round trips
                      detectDailyRoundTrips(recentTrips);
                      detectMultiDayRoundTrips(recentTrips);
                      detectComplexTripGroups(recentTrips);

                      Log.d(TAG, "Round-trip detection completed");
                  } catch (Exception e) {
                      Log.e(TAG, "Error detecting round trips", e);
                  }
              }

              /**
               * Detects same-day round trips (A->B->A within 2-12 hours)
               * Example: Hotel->Meeting->Hotel, Home->Office->Home
               */
              private void detectDailyRoundTrips(List<Trip> trips) {
                  for (int i = 0; i < trips.size() - 1; i++) {
                      Trip trip1 = trips.get(i);
                      Trip trip2 = trips.get(i + 1);

                      // Skip if already part of a round trip
                      if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;

                      // Check if trips are within 12 hours
                      long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                      if (timeDiff > 12 * 60 * 60 * 1000) continue; // 12 hours max

                      // Check if start/end locations form A->B->A pattern
                      if (isLocationMatch(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                        trip2.getEndLatitude(), trip2.getEndLongitude(), 200) &&
                          isLocationMatch(trip1.getEndLatitude(), trip1.getEndLongitude(),
                                        trip2.getStartLatitude(), trip2.getStartLongitude(), 200)) {

                          // Create round-trip group
                          String groupId = "RT_" + System.currentTimeMillis();
                          trip1.setRoundTripGroupId(groupId);
                          trip1.setRoundTrip(true);
                          trip1.setRoundTripSegment(1); // Outbound
                          
                          trip2.setRoundTripGroupId(groupId);
                          trip2.setRoundTrip(true);
                          trip2.setRoundTripSegment(2); // Return

                          // Save updated trips
                          saveTrip(trip1);
                          saveTrip(trip2);

                          Log.d(TAG, "Daily round-trip detected: " + trip1.getStartAddress() + " -> " + trip1.getEndAddress());
                      }
                  }
              }

              /**
               * Detects multi-day round trips (business travel patterns)
               * Example: Home->Airport->Client City, Client City->Airport->Home
               */
              private void detectMultiDayRoundTrips(List<Trip> trips) {
                  for (int i = 0; i < trips.size() - 1; i++) {
                      Trip trip1 = trips.get(i);
                      
                      // Look for return trip within 2-14 days
                      for (int j = i + 1; j < trips.size(); j++) {
                          Trip trip2 = trips.get(j);
                          
                          // Skip if already part of a round trip
                          if (trip1.isRoundTrip() || trip2.isRoundTrip()) continue;

                          // Check if trips are within 14 days
                          long timeDiff = trip2.getStartTime() - trip1.getEndTime();
                          if (timeDiff > 14 * 24 * 60 * 60 * 1000) break; // 14 days max

                          // Check for business travel pattern (airports, distant locations)
                          if (isBusinessTravelPattern(trip1, trip2)) {
                              String groupId = "BT_" + System.currentTimeMillis();
                              trip1.setRoundTripGroupId(groupId);
                              trip1.setRoundTrip(true);
                              trip1.setRoundTripSegment(1); // Outbound business travel
                              
                              trip2.setRoundTripGroupId(groupId);
                              trip2.setRoundTrip(true);
                              trip2.setRoundTripSegment(2); // Return business travel

                              // Auto-classify as Business if involving airports
                              if (isAirportLocation(trip1.getStartAddress()) || 
                                  isAirportLocation(trip1.getEndAddress()) ||
                                  isAirportLocation(trip2.getStartAddress()) || 
                                  isAirportLocation(trip2.getEndAddress())) {
                                  trip1.setCategory("Business");
                                  trip2.setCategory("Business");
                              }

                              saveTrip(trip1);
                              saveTrip(trip2);

                              Log.d(TAG, "Multi-day business trip detected: " + trip1.getStartAddress() + " -> " + trip2.getEndAddress());
                              break;
                          }
                      }
                  }
              }

              /**
               * Detects complex trip groups with mixed business/personal activities
               * Example: Multi-day business trip with personal activities in destination city
               */
              private void detectComplexTripGroups(List<Trip> trips) {
                  // Group trips by time periods and geographic clusters
                  List<List<Trip>> tripClusters = new ArrayList<>();
                  
                  for (Trip trip : trips) {
                      if (trip.isRoundTrip()) continue; // Skip already grouped trips
                      
                      boolean addedToCluster = false;
                      for (List<Trip> cluster : tripClusters) {
                          if (belongsToCluster(trip, cluster)) {
                              cluster.add(trip);
                              addedToCluster = true;
                              break;
                          }
                      }
                      
                      if (!addedToCluster) {
                          List<Trip> newCluster = new ArrayList<>();
                          newCluster.add(trip);
                          tripClusters.add(newCluster);
                      }
                  }
                  
                  // Analyze clusters for business travel patterns
                  for (List<Trip> cluster : tripClusters) {
                      if (cluster.size() >= 3) {
                          analyzeComplexTripGroup(cluster);
                      }
                  }
              }

              /**
               * Determines if a trip belongs to an existing cluster
               */
              private boolean belongsToCluster(Trip trip, List<Trip> cluster) {
                  if (cluster.isEmpty()) return false;
                  
                  // Check if trip is within time window of cluster
                  long clusterStart = cluster.get(0).getStartTime();
                  long clusterEnd = cluster.get(cluster.size() - 1).getEndTime();
                  
                  return (trip.getStartTime() >= clusterStart - 24 * 60 * 60 * 1000) && // 1 day before
                         (trip.getStartTime() <= clusterEnd + 24 * 60 * 60 * 1000);     // 1 day after
              }

              /**
               * Analyzes complex trip groups for business travel patterns
               */
              private void analyzeComplexTripGroup(List<Trip> cluster) {
                  // Check if cluster represents business travel with mixed activities
                  boolean hasBusinessIndicators = false;
                  boolean hasPersonalIndicators = false;
                  
                  for (Trip trip : cluster) {
                      if (isBusinessLocation(trip.getStartAddress()) || 
                          isBusinessLocation(trip.getEndAddress()) ||
                          isAirportLocation(trip.getStartAddress()) || 
                          isAirportLocation(trip.getEndAddress())) {
                          hasBusinessIndicators = true;
                      }
                      
                      if (isPersonalLocation(trip.getStartAddress()) || 
                          isPersonalLocation(trip.getEndAddress())) {
                          hasPersonalIndicators = true;
                      }
                  }
                  
                  if (hasBusinessIndicators && hasPersonalIndicators) {
                      // Mixed business trip - create group but don't auto-classify
                      String groupId = "MX_" + System.currentTimeMillis();
                      for (int i = 0; i < cluster.size(); i++) {
                          Trip trip = cluster.get(i);
                          trip.setRoundTripGroupId(groupId);
                          trip.setRoundTrip(true);
                          trip.setRoundTripSegment(i + 1);
                          saveTrip(trip);
                      }
                      Log.d(TAG, "Complex mixed business trip detected with " + cluster.size() + " segments");
                  }
              }

              /**
               * Checks if two locations are within the specified distance (meters)
               */
              private boolean isLocationMatch(double lat1, double lon1, double lat2, double lon2, double maxDistance) {
                  double distance = calculateDistance(lat1, lon1, lat2, lon2);
                  return distance <= maxDistance;
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 6371; // Radius of the Earth in km
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  double distance = R * c;
                  return distance;
              }

              /**
               * Determines if two trips form a business travel pattern
               */
              private boolean isBusinessTravelPattern(Trip trip1, Trip trip2) {
                  // Check for long-distance travel (>50 miles)
                  double distance = calculateDistance(trip1.getStartLatitude(), trip1.getStartLongitude(),
                                                    trip2.getEndLatitude(), trip2.getEndLongitude());
                  
                  if (distance < 50) return false; // Must be significant travel
                  
                  // Check for airport involvement
                  return isAirportLocation(trip1.getStartAddress()) || 
                         isAirportLocation(trip1.getEndAddress()) ||
                         isAirportLocation(trip2.getStartAddress()) || 
                         isAirportLocation(trip2.getEndAddress());
              }

              /**
               * Identifies airport locations for business travel classification
               */
              private boolean isAirportLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("airport") || lower.contains("terminal") || 
                         lower.contains("intl") || lower.contains("international");
              }

              /**
               * Identifies business locations
               */
              private boolean isBusinessLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("office") || lower.contains("corporate") || 
                         lower.contains("business") || lower.contains("company") ||
                         lower.contains("headquarters") || lower.contains("conference");
              }

              /**
               * Identifies personal/leisure locations
               */
              private boolean isPersonalLocation(String address) {
                  if (address == null) return false;
                  String lower = address.toLowerCase();
                  return lower.contains("park") || lower.contains("mall") || 
                         lower.contains("restaurant") || lower.contains("hotel") ||
                         lower.contains("theme") || lower.contains("entertainment") ||
                         lower.contains("shopping") || lower.contains("recreation");
              }

              /**
               * Gets all round-trip groups for display
               */
              public List<String> getRoundTripGroups() {
                  List<String> groups = new ArrayList<>();
                  List<Trip> trips = getAllTrips();
                  
                  for (Trip trip : trips) {
                      if (trip.isRoundTrip() && !groups.contains(trip.getRoundTripGroupId())) {
                          groups.add(trip.getRoundTripGroupId());
                      }
                  }
                  
                  return groups;
              }

              /**
               * Gets all trips in a specific round-trip group
               */
              public List<Trip> getTripsInGroup(String groupId) {
                  List<Trip> groupTrips = new ArrayList<>();
                  List<Trip> allTrips = getAllTrips();
                  
                  for (Trip trip : allTrips) {
                      if (groupId.equals(trip.getRoundTripGroupId())) {
                          groupTrips.add(trip);
                      }
                  }
                  
                  // Sort by segment number
                  Collections.sort(groupTrips, (t1, t2) -> Integer.compare(t1.getRoundTripSegment(), t2.getRoundTripSegment()));
                  
                  return groupTrips;
              }

              /**
               * Ungroups a round-trip, allowing individual classification
               */
              public void ungroupRoundTrip(String groupId) {
                  List<Trip> groupTrips = getTripsInGroup(groupId);
                  for (Trip trip : groupTrips) {
                      trip.setRoundTripGroupId(null);
                      trip.setRoundTrip(false);
                      trip.setRoundTripSegment(0);
                      saveTrip(trip);
                  }
                  Log.d(TAG, "Ungrouped round-trip: " + groupId);
              }

              /**
               * Classifies all trips in a round-trip group with the same category
               */
              public void classifyRoundTripGroup(String groupId, String category) {
                  List<Trip> groupTrips = getTripsInGroup(groupId);
                  for (Trip trip : groupTrips) {
                      trip.setCategory(category);
                      saveTrip(trip);
                  }
                  Log.d(TAG, "Classified round-trip group " + groupId + " as " + category);
              }
              
              // Helper methods for trip operations
              private List<Trip> getAllTrips() {
                  TripStorage tripStorage = new TripStorage(context);
                  return tripStorage.getAllTrips();
              }
              
              private void saveTrip(Trip trip) {
                  TripStorage tripStorage = new TripStorage(context);
                  tripStorage.saveTrip(trip);
              }
              

              
              // CUSTOM CATEGORIES API SYNC METHODS
              
              /**
               * Syncs custom categories with API - downloads from API and merges with local
               */
              public void syncCustomCategoriesWithAPI() {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, skipping category sync");
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Starting custom categories sync with API");
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Download categories from API
                          URL url = new URL(API_BASE_URL + "/categories");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("GET");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 200) {
                              StringBuilder response = new StringBuilder();
                              try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
                                  String line;
                                  while ((line = reader.readLine()) != null) {
                                      response.append(line);
                                  }
                              }
                              
                              // Parse and sync categories
                              JSONObject jsonResponse = new JSONObject(response.toString());
                              JSONArray categories = jsonResponse.getJSONArray("categories");
                              
                              for (int i = 0; i < categories.length(); i++) {
                                  String category = categories.getString(i);
                                  tripStorage.addCustomCategory(category);
                              }
                              
                              Log.d(TAG, "Successfully synced " + categories.length() + " categories from API");
                          } else {
                              Log.e(TAG, "Failed to sync categories from API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error syncing categories with API", e);
                      }
                  });
              }
              
              /**
               * Adds a custom category to the API
               */
              public void addCustomCategoryToAPI(String categoryName) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, adding category locally only");
                      tripStorage.addCustomCategory(categoryName);
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Adding custom category to API: " + categoryName);
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Add category to API
                          URL url = new URL(API_BASE_URL + "/categories");
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("POST");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setDoOutput(true);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          String jsonPayload = String.format("{\"name\":\"%s\"}", categoryName.replace("\"", "\\\""));
                          
                          try (OutputStream os = conn.getOutputStream()) {
                              byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                              os.write(input, 0, input.length);
                          }
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 201) {
                              // Add to local storage after successful API call
                              tripStorage.addCustomCategory(categoryName);
                              Log.d(TAG, "Successfully added category to API and local storage: " + categoryName);
                          } else {
                              Log.e(TAG, "Failed to add category to API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error adding category to API", e);
                      }
                  });
              }
              
              /**
               * Removes a custom category from the API
               */
              public void removeCustomCategoryFromAPI(String categoryName) {
                  TripStorage tripStorage = new TripStorage(context);
                  if (!tripStorage.isApiSyncEnabled()) {
                      Log.d(TAG, "API sync disabled, removing category locally only");
                      tripStorage.removeCustomCategory(categoryName);
                      return;
                  }
                  
                  executor.execute(() -> {
                      try {
                          Log.d(TAG, "Removing custom category from API: " + categoryName);
                          
                          // Get authentication
                          UserAuthManager authManager = new UserAuthManager(context);
                          String userEmail = authManager.getCurrentUserEmail();
                          String authToken = authManager.getAuthToken();
                          
                          // Remove category from API
                          URL url = new URL(API_BASE_URL + "/categories/" + java.net.URLEncoder.encode(categoryName, "UTF-8"));
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setRequestMethod("DELETE");
                          conn.setRequestProperty("Content-Type", "application/json");
                          conn.setRequestProperty("Authorization", "Bearer " + (authToken.isEmpty() ? "demo-admin-token" : authToken));
                          conn.setRequestProperty("X-User-Email", userEmail.isEmpty() ? "pcates@catesconsultinggroup.com" : userEmail);
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);
                          
                          int responseCode = conn.getResponseCode();
                          if (responseCode == 200) {
                              // Remove from local storage after successful API call
                              tripStorage.removeCustomCategory(categoryName);
                              Log.d(TAG, "Successfully removed category from API and local storage: " + categoryName);
                          } else {
                              Log.e(TAG, "Failed to remove category from API: " + responseCode);
                          }
                          
                          conn.disconnect();
                      } catch (Exception e) {
                          Log.e(TAG, "Error removing category from API", e);
                      }
                  });
              }

          }
          EOF

      - name: Copy enhanced MainActivity with consolidated Bluetooth functionality
        run: |
          cp MainActivity.java android/app/src/main/java/com/miletrackerpro/app/MainActivity.java
          echo "✅ Using enhanced MainActivity.java with consolidated Bluetooth functionality"
          echo "  - checkBluetoothConnections() method"
          echo "  - handleVehicleConnected() method"
          echo "  - startBluetoothTriggeredAutoDetection() method"
          echo "  - startPeriodicBluetoothConnectionCheck() method"
          echo "  - isLikelyVehicleDevice() method"
          echo "  - Enhanced UConnect detection"
          echo "  - Complete vehicle registration system"
          


      - name: Create BluetoothDiscoveryReceiver for device scanning
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/BluetoothDiscoveryReceiver.java << 'EOF'
          package com.miletrackerpro.app;

          import android.bluetooth.BluetoothAdapter;
          import android.bluetooth.BluetoothDevice;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.util.Log;

          public class BluetoothDiscoveryReceiver extends BroadcastReceiver {
              private static final String TAG = "BluetoothDiscovery";

              @Override
              public void onReceive(Context context, Intent intent) {
                  String action = intent.getAction();
                  
                  if (BluetoothDevice.ACTION_FOUND.equals(action)) {
                      // Discovery has found a device
                      BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                      if (device != null) {
                          String deviceName = device.getName();
                          String deviceAddress = device.getAddress();
                          
                          Log.d(TAG, "Bluetooth device found: " + deviceName + " (" + deviceAddress + ")");
                          
                          // Check if this is a vehicle-related device
                          if (isVehicleDevice(deviceName)) {
                              Log.d(TAG, "Vehicle device detected: " + deviceName);
                              
                              // Broadcast to MainActivity and BluetoothVehicleService
                              Intent vehicleIntent = new Intent("com.miletrackerpro.app.VEHICLE_DETECTED");
                              vehicleIntent.putExtra("device_name", deviceName);
                              vehicleIntent.putExtra("device_address", deviceAddress);
                              context.sendBroadcast(vehicleIntent);
                          }
                      }
                  } else if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)) {
                      Log.d(TAG, "Bluetooth discovery started");
                  } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {
                      Log.d(TAG, "Bluetooth discovery finished");
                  }
              }

              private boolean isVehicleDevice(String deviceName) {
                  if (deviceName == null) return false;
                  
                  String name = deviceName.toLowerCase();
                  
                  // Exclude common non-vehicle devices first
                  if (name.contains("watch") || name.contains("buds") || name.contains("earbuds") ||
                      name.contains("headphones") || name.contains("speaker") || name.contains("mouse") ||
                      name.contains("keyboard") || name.contains("tablet") || name.contains("phone") ||
                      name.contains("galaxy") || name.contains("iphone") || name.contains("airpods") ||
                      name.contains("beats") || name.contains("jbl") || name.contains("bose")) {
                      return false;
                  }
                  
                  // Vehicle infotainment systems (like Uconnect, SYNC, Entune)
                  if (name.contains("uconnect") || name.contains("sync") || name.contains("entune") ||
                      name.contains("infotainment") || name.contains("multimedia") || name.contains("hmi") ||
                      name.contains("carplay") || name.contains("android auto")) {
                      return true;
                  }
                  
                  // Common vehicle-related terms
                  if (name.contains("car") || name.contains("vehicle") || name.contains("auto") ||
                      name.contains("truck") || name.contains("suv") || name.contains("van")) {
                      return true;
                  }
                  
                  // Vehicle brand names
                  return name.contains("honda") || name.contains("toyota") || name.contains("ford") ||
                         name.contains("chevy") || name.contains("bmw") || name.contains("audi") ||
                         name.contains("mazda") || name.contains("nissan") || name.contains("hyundai") ||
                         name.contains("kia") || name.contains("mercedes") || name.contains("lexus") ||
                         name.contains("acura") || name.contains("infiniti") || name.contains("cadillac") ||
                         name.contains("buick") || name.contains("gmc") || name.contains("jeep") ||
                         name.contains("dodge") || name.contains("chrysler") || name.contains("ram") ||
                         name.contains("lincoln") || name.contains("volvo") || name.contains("subaru") ||
                         name.contains("mitsubishi") || name.contains("jaguar") || name.contains("land rover") ||
                         name.contains("porsche") || name.contains("ferrari") || name.contains("lamborghini") ||
                         name.contains("maserati") || name.contains("bentley") || name.contains("rolls royce") ||
                         name.contains("tesla") || name.contains("prius");
              }
          }
          EOF

      - name: Create BootCompletedReceiver to restart service after phone restart
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/BootCompletedReceiver.java << 'EOF'
          package com.miletrackerpro.app;

          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.SharedPreferences;
          import android.util.Log;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.services.AutoDetectionService;

          public class BootCompletedReceiver extends BroadcastReceiver {
              private static final String TAG = "BootCompletedReceiver";

              @Override
              public void onReceive(Context context, Intent intent) {
                  String action = intent.getAction();
                  if (Intent.ACTION_BOOT_COMPLETED.equals(action) || 
                      Intent.ACTION_LOCKED_BOOT_COMPLETED.equals(action) ||
                      "android.intent.action.QUICKBOOT_POWERON".equals(action)) {
                      
                      Log.d(TAG, "Boot completed (" + action + ") - checking if AutoDetectionService should start");
                      
                      // Check if auto-detection was enabled before reboot
                      SharedPreferences prefs = context.getSharedPreferences("TripPreferences", Context.MODE_PRIVATE);
                      boolean autoDetectionEnabled = prefs.getBoolean("auto_detection_enabled", false);
                      
                      if (autoDetectionEnabled) {
                          Log.d(TAG, "Auto-detection was enabled - starting AutoDetectionService in IDLE mode");
                          
                          Intent serviceIntent = new Intent(context, AutoDetectionService.class);
                          serviceIntent.setAction("START_AUTO_DETECTION");
                          
                          try {
                              ContextCompat.startForegroundService(context, serviceIntent);
                              Log.d(TAG, "AutoDetectionService started successfully after boot");
                          } catch (Exception e) {
                              Log.e(TAG, "Failed to start AutoDetectionService after boot", e);
                          }
                      } else {
                          Log.d(TAG, "Auto-detection was disabled - not starting service");
                      }
                  }
              }
          }
          EOF

      - name: Copy AddressLookup and services exactly from working version
        run: |
          # AddressLookup
          cat > android/app/src/main/java/com/miletrackerpro/app/utils/AddressLookup.java << 'EOF'
          package com.miletrackerpro.app.utils;

          import android.content.Context;
          import android.location.Address;
          import android.location.Geocoder;
          import android.util.Log;

          import java.util.List;
          import java.util.Locale;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class AddressLookup {
              private static final String TAG = "AddressLookup";
              private Context context;
              private Geocoder geocoder;
              private ExecutorService executor;

              public interface AddressCallback {
                  void onAddressFound(String address);
                  void onAddressError(String error);
              }

              public AddressLookup(Context context) {
                  this.context = context;
                  this.geocoder = new Geocoder(context, Locale.getDefault());
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public void getAddressFromLocation(double latitude, double longitude, AddressCallback callback) {
                  executor.execute(() -> {
                      try {
                          // Check for home address first
                          com.miletrackerpro.app.storage.TripStorage tripStorage = new com.miletrackerpro.app.storage.TripStorage(context);
                          String homeAddress = tripStorage.getHomeAddressIfNear(latitude, longitude);
                          if (homeAddress != null) {
                              Log.d(TAG, "Using home address: " + homeAddress);
                              callback.onAddressFound(homeAddress);
                              return;
                          }
                          
                          // Check for known locations second
                          String knownLocation = tripStorage.getKnownLocationName(latitude, longitude);
                          if (knownLocation != null) {
                              Log.d(TAG, "Using known location: " + knownLocation);
                              callback.onAddressFound(knownLocation);
                              return;
                          }
                          
                          if (!Geocoder.isPresent()) {
                              callback.onAddressError("Geocoder not available");
                              return;
                          }

                          List<Address> addresses = geocoder.getFromLocation(latitude, longitude, 1);
                          if (addresses != null && !addresses.isEmpty()) {
                              Address address = addresses.get(0);
                              String formattedAddress = formatAddress(address);
                              callback.onAddressFound(formattedAddress);
                          } else {
                              callback.onAddressError("No address found");
                          }
                      } catch (Exception e) {
                          callback.onAddressError("Error: " + e.getMessage());
                      }
                  });
              }

              private String formatAddress(Address address) {
                  StringBuilder addressText = new StringBuilder();

                  if (address.getSubThoroughfare() != null) {
                      addressText.append(address.getSubThoroughfare()).append(" ");
                  }
                  if (address.getThoroughfare() != null) {
                      addressText.append(address.getThoroughfare()).append(", ");
                  }
                  if (address.getLocality() != null) {
                      addressText.append(address.getLocality()).append(", ");
                  }
                  if (address.getAdminArea() != null) {
                      addressText.append(address.getAdminArea());
                  }

                  String result = addressText.toString().trim();
                  if (result.endsWith(",")) {
                      result = result.substring(0, result.length() - 1);
                  }

                  return result.isEmpty() ? "Unknown Location" : result;
              }
          }
          EOF

          # Services (exact copy from working)
          cat > android/app/src/main/java/com/miletrackerpro/app/services/AutoDetectionService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Context;
          import android.content.Intent;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.MainActivity;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;

          public class AutoDetectionService extends Service implements LocationListener {
              private static final String TAG = "AutoDetectionService";
              private static final String CHANNEL_ID = "AUTO_DETECTION_CHANNEL";
              private static final int NOTIFICATION_ID = 1001;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private boolean isTracking = false;
              private Trip currentTrip = null;
              private Location lastLocation = null;
              private int stationaryCount = 0;
              private int movingCount = 0;
              private long lastMovementTime = 0;
              private List<Location> pathPoints = new ArrayList<>();
              private double cumulativeDistance = 0.0;
              
              // Bluetooth vehicle information for trips
              private String bluetoothVehicleName = null;
              private String bluetoothTriggerSource = null;

              private static final double SPEED_THRESHOLD_START = 3.0;
              private static final double SPEED_THRESHOLD_STOP = 2.0;
              private static final int START_CONFIRMATIONS = 2;
              private static final int STOP_CONFIRMATIONS = 3;
              private static final long MAX_STATIONARY_TIME = 480000;
              
              // IDLE state GPS intervals for battery efficiency
              private static final long IDLE_GPS_INTERVAL = 30000; // 30 seconds when idle
              private static final long ACTIVE_GPS_INTERVAL = 5000; // 5 seconds when tracking
              
              // Service states
              private static final int STATE_IDLE = 0;
              private static final int STATE_ACTIVE = 1;
              private int serviceState = STATE_IDLE;

              @Override
              public void onCreate() {
                  super.onCreate();
                  Log.d(TAG, "AutoDetectionService created");

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();

                  currentTrip = tripStorage.getCurrentTrip();
                  if (currentTrip != null) {
                      Log.d(TAG, "Restored active trip: " + currentTrip.getId());
                  }
                  
                  // Start in IDLE mode for persistent monitoring
                  transitionToIdleMode();
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_AUTO_DETECTION".equals(intent.getAction())) {
                          // Check if this is Bluetooth-triggered with vehicle info
                          boolean bluetoothTriggered = intent.getBooleanExtra("bluetooth_triggered", false);
                          String vehicleName = intent.getStringExtra("vehicle_name");
                          String triggerSource = intent.getStringExtra("trigger_source");
                          
                          startLocationTracking(bluetoothTriggered, vehicleName, triggerSource);
                      } else if ("STOP_AUTO_DETECTION".equals(intent.getAction())) {
                          stopLocationTracking();
                      } else if ("TRANSITION_TO_IDLE".equals(intent.getAction())) {
                          transitionToIdleMode();
                      }
                  }
                  return START_STICKY;
              }

              private void startLocationTracking() {
                  startAutoDetection(false, null, null);
              }
              
              private void startLocationTracking(boolean bluetoothTriggered, String vehicleName, String triggerSource) {
                  startAutoDetection(bluetoothTriggered, vehicleName, triggerSource);
              }
              
              private void stopLocationTracking() {
                  stopAutoDetection();
              }

              private void startAutoDetection(boolean bluetoothTriggered, String vehicleName, String triggerSource) {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      isTracking = true;
                      tripStorage.setAutoDetectionEnabled(true);
                      
                      // If Bluetooth triggered, store vehicle information for trip creation
                      if (bluetoothTriggered && vehicleName != null) {
                          Log.d(TAG, "Bluetooth-triggered auto detection for vehicle: " + vehicleName);
                          this.bluetoothVehicleName = vehicleName;
                          this.bluetoothTriggerSource = triggerSource;
                      } else {
                          // Clear any previous Bluetooth vehicle info for non-Bluetooth trips
                          this.bluetoothVehicleName = null;
                          this.bluetoothTriggerSource = null;
                      }

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto detection", e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  if (location == null) return;

                  try {
                      float speed = location.getSpeed() * 2.237f;
                      long currentTime = System.currentTimeMillis();

                      // IDLE-to-ACTIVE transition: MUST check BEFORE isTracking guard
                      if (serviceState == STATE_IDLE && speed >= SPEED_THRESHOLD_START) {
                          Log.d(TAG, String.format("IDLE → ACTIVE: Movement detected! Speed %.1f mph >= %.1f threshold", 
                              speed, SPEED_THRESHOLD_START));
                          transitionToActiveMode();
                          // Enable tracking when transitioning to ACTIVE
                          isTracking = true;
                          tripStorage.setAutoDetectionEnabled(true);
                          // Continue to trip detection logic below
                      } else if (!isTracking) {
                          // Only return early if we're not tracking AND not transitioning from IDLE
                          return;
                      }

                      Log.d(TAG, String.format("Location update: Speed %.1f mph, Lat: %.6f, Lon: %.6f", 
                          speed, location.getLatitude(), location.getLongitude()));

                      if (currentTrip == null) {
                          // RETURN TRIP FIX: More aggressive detection after first trip
                          if (speed >= SPEED_THRESHOLD_START) {
                              movingCount++;
                              stationaryCount = 0;
                              
                              Log.d(TAG, String.format("TRIP START DETECTION: Speed %.1f mph >= %.1f threshold, Moving count: %d/%d", 
                                  speed, SPEED_THRESHOLD_START, movingCount, START_CONFIRMATIONS));

                              if (movingCount >= START_CONFIRMATIONS) {
                                  Log.d(TAG, "TRIP STARTING - Confirmations met, starting new trip");
                                  startNewTrip(location, currentTime);
                              }
                          } else {
                              // Reset moving count only if speed is really low
                              if (speed < 2.0) {
                                  movingCount = 0;
                              }
                              // Keep some moving count for gradual acceleration
                              Log.d(TAG, String.format("MONITORING: Speed %.1f mph < %.1f threshold, Moving count: %d", 
                                  speed, SPEED_THRESHOLD_START, movingCount));
                          }
                      } else {
                          // We're in an active trip - add path point
                          addPathPoint(location);
                          
                          if (speed <= SPEED_THRESHOLD_STOP) {
                              stationaryCount++;
                              movingCount = 0;

                              long timeSinceLastMovement = currentTime - lastMovementTime;

                              if (stationaryCount >= STOP_CONFIRMATIONS || 
                                  timeSinceLastMovement > MAX_STATIONARY_TIME) {
                                  endCurrentTrip();
                              }
                          } else {
                              stationaryCount = 0;
                              lastMovementTime = currentTime;
                          }
                      }

                      lastLocation = location;
                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location update", e);
                  }
              }

              private void startNewTrip(Location location, long currentTime) {
                  try {
                      Log.d(TAG, "=== STARTING NEW TRIP ===");
                      Log.d(TAG, "Location: " + location.getLatitude() + ", " + location.getLongitude());
                      Log.d(TAG, "Speed: " + (location.getSpeed() * 2.237f) + " mph");
                      Log.d(TAG, "Time: " + new java.util.Date(currentTime).toString());
                      
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(true);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());
                      
                      // Set Bluetooth trigger status from intent
                      boolean isBluetoothTriggered = false;
                      if (getApplicationContext() instanceof MainActivity) {
                          // Check if this trip was triggered by Bluetooth vehicle connection
                          SharedPreferences prefs = getApplicationContext().getSharedPreferences("BluetoothTripPrefs", Context.MODE_PRIVATE);
                          isBluetoothTriggered = prefs.getBoolean("bluetooth_triggered", false);
                          if (isBluetoothTriggered) {
                              // Clear the flag after use
                              prefs.edit().putBoolean("bluetooth_triggered", false).apply();
                              Log.d(TAG, "🔵 BLUETOOTH-TRIGGERED TRIP: Setting bluetoothTriggered=true");
                              // CRITICAL DIAGNOSTIC: Toast notification for Bluetooth trip creation
                              Intent toastIntent = new Intent("com.miletrackerpro.SHOW_TOAST");
                              toastIntent.putExtra("message", "🔵 Bluetooth triggered trip creation");
                              sendBroadcast(toastIntent);
                          }
                      }
                      currentTrip.setBluetoothTriggered(isBluetoothTriggered);
                      
                      // Set Bluetooth vehicle information if available
                      if (bluetoothVehicleName != null) {
                          currentTrip.setVehicleName(bluetoothVehicleName);
                          Log.d(TAG, "Trip assigned to Bluetooth vehicle: " + bluetoothVehicleName);
                          
                          // Auto-categorize based on common vehicle names
                          if (bluetoothVehicleName.toLowerCase().contains("work") || 
                              bluetoothVehicleName.toLowerCase().contains("company") ||
                              bluetoothVehicleName.toLowerCase().contains("business")) {
                              currentTrip.setCategory("Business");
                          } else {
                              currentTrip.setCategory("Personal");
                          }
                      }
                      
                      // Initialize path tracking
                      pathPoints.clear();
                      pathPoints.add(location);
                      cumulativeDistance = 0.0;

                      // IMPROVED START LOCATION - Use home area detection for better accuracy
                      getHomeAreaAddress(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setStartAddress(address);
                              tripStorage.saveCurrentTrip(currentTrip);
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setStartAddress("Unknown Location");
                              tripStorage.saveCurrentTrip(currentTrip);
                          }
                      });

                      movingCount = 0;
                      lastMovementTime = currentTime;

                      Log.d(TAG, "Trip created with ID: " + currentTrip.getId());
                      Log.d(TAG, "Starting notification and foreground service");

                      Notification notification = createNotification("Trip in progress", "Recording your trip");
                      startForeground(NOTIFICATION_ID, notification);
                      
                      Log.d(TAG, "=== TRIP STARTED SUCCESSFULLY ===");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting trip", e);
                  }
              }

              private void endCurrentTrip() {
                  if (currentTrip == null) return;

                  try {
                      long currentTime = System.currentTimeMillis();
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      // Use last movement time for accurate duration (excludes stationary wait time)
                      long effectiveEndTime = lastMovementTime > 0 ? lastMovementTime : currentTime;
                      long duration = effectiveEndTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      // Add final path point if needed
                      addPathPoint(lastLocation);
                      
                      // Use cumulative distance from path tracking instead of straight-line
                      currentTrip.setDistance(cumulativeDistance);

                      if (cumulativeDistance >= 0.5) {
                          // ENHANCED END LOCATION - Use area detection for better addresses
                          getEnhancedEndAddress(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setEndAddress(address);
                                  saveCompletedTrip();
                                  
                                  // CRITICAL FIX: Reset detection state for next trip
                                  resetDetectionState();
                              }

                              @Override
                              public void onAddressError(String error) {
                                  // FALLBACK: Use coordinates with city info as last resort
                                  String fallbackAddress = String.format("%.4f, %.4f", 
                                      lastLocation.getLatitude(), lastLocation.getLongitude());
                                  currentTrip.setEndAddress(fallbackAddress);
                                  saveCompletedTrip();
                                  
                                  // CRITICAL FIX: Reset detection state for next trip
                                  resetDetectionState();
                              }
                          });
                      } else {
                          // CRITICAL FIX: Trip too short, reset properly
                          Log.d(TAG, "Trip too short (" + cumulativeDistance + " mi), not saving");
                          tripStorage.saveCurrentTrip(null);
                          resetDetectionState();
                      }

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);
                  } catch (Exception e) {
                      Log.e(TAG, "Error ending trip: " + e.getMessage(), e);
                  }
              }
              
              // CRITICAL FIX: Ensure clean state for return trip detection
              private void resetDetectionState() {
                  try {
                      Log.d(TAG, "Resetting detection state for next trip");
                      
                      // Clear trip reference
                      currentTrip = null;
                      
                      // Reset all counters
                      stationaryCount = 0;
                      movingCount = 0;
                      lastMovementTime = 0;
                      
                      // Clear path tracking
                      pathPoints.clear();
                      cumulativeDistance = 0.0;
                      
                      // Clear trip storage
                      tripStorage.saveCurrentTrip(null);
                      
                      Log.d(TAG, "Detection state reset complete - ready for return trip");
                  } catch (Exception e) {
                      Log.e(TAG, "Error resetting detection state: " + e.getMessage(), e);
                  }
              }

              private void saveCompletedTrip() {
                  try {
                      Log.d(TAG, String.format("Saving completed trip: %.2f mi, %d minutes", 
                          currentTrip.getDistance(), currentTrip.getDuration() / 60000));
                          
                      boolean saved = tripStorage.saveTrip(currentTrip);
                      
                      if (!saved) {
                          // Trip limit reached - send broadcast to show upgrade prompt
                          Log.w(TAG, "Trip not saved - free tier limit reached");
                          Intent limitIntent = new Intent("com.miletrackerpro.TRIP_LIMIT_REACHED");
                          limitIntent.putExtra("trip_count", tripStorage.getMonthlyTripCount());
                          limitIntent.putExtra("trip_limit", 40);
                          sendBroadcast(limitIntent);
                          
                          // Clear current trip from storage
                          tripStorage.saveCurrentTrip(null);
                          currentTrip = null;
                          return;
                      }
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }
                      
                      // Clear current trip from storage
                      tripStorage.saveCurrentTrip(null);
                      
                      Log.d(TAG, "Trip saved successfully, ready for next detection");
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving completed trip: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959; // Radius of the Earth in miles
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void addPathPoint(Location location) {
                  try {
                      if (pathPoints.isEmpty()) {
                          pathPoints.add(location);
                          return;
                      }

                      Location lastPoint = pathPoints.get(pathPoints.size() - 1);
                      double segmentDistance = calculateDistance(
                          lastPoint.getLatitude(), lastPoint.getLongitude(),
                          location.getLatitude(), location.getLongitude()
                      );

                      // Only add point if we've moved a significant distance (about 50 feet)
                      if (segmentDistance >= 0.01) {
                          pathPoints.add(location);
                          cumulativeDistance += segmentDistance;
                          
                          Log.d(TAG, String.format("Path point added. Segment: %.3f mi, Total: %.3f mi", 
                              segmentDistance, cumulativeDistance));
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error adding path point", e);
                  }
              }

              // PRECISION HOME AREA DETECTION - Finds closest address to actual GPS location
              private void getHomeAreaAddress(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  try {
                      // DISTANCE-AWARE HOME DETECTION - Find the closest valid address
                      List<LocationCandidate> candidates = new ArrayList<>();
                      
                      // Test multiple precise locations around GPS coordinates
                      double[] offsets = {0.0, 0.0002, -0.0002, 0.0004, -0.0004, 0.0006, -0.0006}; // 0-70 meters
                      
                      findBestHomeAddress(latitude, longitude, offsets, 0, candidates, callback);
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in precision home area detection: " + e.getMessage());
                      callback.onAddressError("Precision home area detection failed");
                  }
              }
              
              private void findBestHomeAddress(double baseLat, double baseLon, double[] offsets, int index, 
                                             List<LocationCandidate> candidates, AddressLookup.AddressCallback callback) {
                  if (index >= offsets.length) {
                      // All searches complete - find best candidate
                      processBestHomeCandidate(baseLat, baseLon, candidates, callback);
                      return;
                  }
                  
                  // Try latitude offset
                  double testLat = baseLat + offsets[index];
                  addressLookup.getAddressFromLocation(testLat, baseLon, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          if (isValidHomeAddress(address)) {
                              double distance = calculateDistance(baseLat, baseLon, testLat, baseLon);
                              candidates.add(new LocationCandidate(address, distance, testLat, baseLon));
                              Log.d(TAG, "Home candidate: " + address + " (distance: " + String.format("%.3f", distance) + " mi)");
                          }
                          
                          // Try longitude offset for same index
                          double testLon = baseLon + offsets[index];
                          addressLookup.getAddressFromLocation(baseLat, testLon, new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address2) {
                                  if (isValidHomeAddress(address2)) {
                                      double distance2 = calculateDistance(baseLat, baseLon, baseLat, testLon);
                                      candidates.add(new LocationCandidate(address2, distance2, baseLat, testLon));
                                      Log.d(TAG, "Home candidate: " + address2 + " (distance: " + String.format("%.3f", distance2) + " mi)");
                                  }
                                  
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }

                              @Override
                              public void onAddressError(String error2) {
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }
                          });
                      }

                      @Override
                      public void onAddressError(String error) {
                          // Try longitude offset for same index
                          double testLon = baseLon + offsets[index];
                          addressLookup.getAddressFromLocation(baseLat, testLon, new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address2) {
                                  if (isValidHomeAddress(address2)) {
                                      double distance2 = calculateDistance(baseLat, baseLon, baseLat, testLon);
                                      candidates.add(new LocationCandidate(address2, distance2, baseLat, testLon));
                                      Log.d(TAG, "Home candidate: " + address2 + " (distance: " + String.format("%.3f", distance2) + " mi)");
                                  }
                                  
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }

                              @Override
                              public void onAddressError(String error2) {
                                  // Continue to next offset
                                  findBestHomeAddress(baseLat, baseLon, offsets, index + 1, candidates, callback);
                              }
                          });
                      }
                  });
              }
              
              private void processBestHomeCandidate(double baseLat, double baseLon, List<LocationCandidate> candidates, 
                                                  AddressLookup.AddressCallback callback) {
                  if (candidates.isEmpty()) {
                      Log.d(TAG, "No valid home candidates found, using fallback");
                      callback.onAddressError("No valid home address found");
                      return;
                  }
                  
                  // Sort by distance to find closest address
                  Collections.sort(candidates, (a, b) -> Double.compare(a.distance, b.distance));
                  
                  LocationCandidate best = candidates.get(0);
                  Log.d(TAG, "Best home address selected: " + best.address + " (distance: " + String.format("%.3f", best.distance) + " mi)");
                  
                  // If closest address is more than 1/8 mile away, something is wrong
                  if (best.distance > 0.125) {
                      Log.w(TAG, "Closest address is " + String.format("%.3f", best.distance) + " miles away - GPS accuracy issue?");
                  }
                  
                  callback.onAddressFound(best.address);
              }
              
              private boolean isValidHomeAddress(String address) {
                  if (address == null || address.isEmpty()) return false;
                  
                  String lower = address.toLowerCase();
                  
                  // Reject obviously bad addresses
                  if (lower.contains("unnamed") || lower.contains("unknown") || lower.contains("null")) {
                      return false;
                  }
                  
                  // Home addresses should have house numbers
                  if (!address.matches(".*\\d+.*")) {
                      return false;
                  }
                  
                  // Should be a residential street (not highway/interstate)
                  if (lower.contains("interstate") || lower.contains("highway") || lower.contains("i-")) {
                      return false;
                  }
                  
                  return true;
              }
              
              // Helper class for distance-aware address selection
              private static class LocationCandidate {
                  public String address;
                  public double distance;
                  public double lat;
                  public double lon;
                  
                  public LocationCandidate(String address, double distance, double lat, double lon) {
                      this.address = address;
                      this.distance = distance;
                      this.lat = lat;
                      this.lon = lon;
                  }
              }
              


              // ENHANCED END LOCATION DETECTION - Better destination address accuracy
              private void getEnhancedEndAddress(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  try {
                      // First try: Primary location with retries
                      tryAddressLookupWithRetries(latitude, longitude, 3, new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              if (isValidAddress(address)) {
                                  Log.d(TAG, "Found good end address: " + address);
                                  callback.onAddressFound(address);
                              } else {
                                  // Try nearby locations for better accuracy
                                  tryNearbyEndLocations(latitude, longitude, callback);
                              }
                          }

                          @Override
                          public void onAddressError(String error) {
                              // Try nearby locations if primary fails
                              tryNearbyEndLocations(latitude, longitude, callback);
                          }
                      });
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in enhanced end address detection: " + e.getMessage());
                      callback.onAddressError("Enhanced end address detection failed");
                  }
              }
              
              private void tryNearbyEndLocations(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  // Try a wider search area for end locations (businesses, destinations)
                  double[] offsets = {0.0, 0.0009, -0.0009, 0.0018, -0.0018}; // 0, 100m, 200m radius
                  
                  tryEndLocationWithOffsets(latitude, longitude, offsets, 0, callback);
              }
              
              private void tryEndLocationWithOffsets(double baseLat, double baseLon, double[] offsets, int index, AddressLookup.AddressCallback callback) {
                  if (index >= offsets.length) {
                      // All nearby locations failed, use coordinates with city lookup
                      getCityForCoordinates(baseLat, baseLon, callback);
                      return;
                  }
                  
                  double lat = baseLat + offsets[index];
                  double lon = baseLon + offsets[index];
                  
                  addressLookup.getAddressFromLocation(lat, lon, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          if (isValidAddress(address)) {
                              Log.d(TAG, "Found better end address at offset " + index + ": " + address);
                              callback.onAddressFound(address);
                          } else {
                              // Try next offset
                              tryEndLocationWithOffsets(baseLat, baseLon, offsets, index + 1, callback);
                          }
                      }

                      @Override
                      public void onAddressError(String error) {
                          // Try next offset
                          tryEndLocationWithOffsets(baseLat, baseLon, offsets, index + 1, callback);
                      }
                  });
              }
              
              private void getCityForCoordinates(double latitude, double longitude, AddressLookup.AddressCallback callback) {
                  try {
                      // Try to get at least city/state info for coordinates
                      addressLookup.getAddressFromLocation(latitude, longitude, new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              // Extract city/state from any address we get
                              String cityInfo = extractCityFromAddress(address);
                              if (cityInfo != null && !cityInfo.isEmpty()) {
                                  String formattedAddress = String.format("%.4f, %.4f (%s)", 
                                      latitude, longitude, cityInfo);
                                  callback.onAddressFound(formattedAddress);
                              } else {
                                  // Just coordinates if no city info
                                  callback.onAddressFound(String.format("%.4f, %.4f", latitude, longitude));
                              }
                          }

                          @Override
                          public void onAddressError(String error) {
                              // Last resort: just coordinates
                              callback.onAddressFound(String.format("%.4f, %.4f", latitude, longitude));
                          }
                      });
                  } catch (Exception e) {
                      callback.onAddressFound(String.format("%.4f, %.4f", latitude, longitude));
                  }
              }
              
              private String extractCityFromAddress(String address) {
                  try {
                      if (address == null || address.isEmpty()) return null;
                      
                      // Look for city, state pattern (e.g., "High Point, North Carolina")
                      String[] parts = address.split(",");
                      if (parts.length >= 2) {
                          String city = parts[parts.length - 2].trim();
                          String state = parts[parts.length - 1].trim();
                          return city + ", " + state;
                      }
                      
                      return null;
                  } catch (Exception e) {
                      return null;
                  }
              }
              
              private boolean isValidAddress(String address) {
                  if (address == null || address.isEmpty()) return false;
                  
                  // Valid addresses should have:
                  // - Street numbers OR business names
                  // - Not contain "unnamed" or "unknown"
                  // - Not be just coordinates
                  
                  String lower = address.toLowerCase();
                  if (lower.contains("unnamed") || lower.contains("unknown") || lower.contains("null")) {
                      return false;
                  }
                  
                  // Check if it's just coordinates (pattern like "35.1234, -80.1234")
                  if (address.matches("^-?\\d+\\.\\d+,\\s*-?\\d+\\.\\d+$")) {
                      return false;
                  }
                  
                  // Good address should have either numbers or common business words
                  return address.matches(".*\\d+.*") || 
                         lower.contains("street") || lower.contains("road") || lower.contains("avenue") ||
                         lower.contains("drive") || lower.contains("lane") || lower.contains("court") ||
                         lower.contains("center") || lower.contains("plaza") || lower.contains("mall");
              }
              
              private void tryAddressLookupWithRetries(double latitude, double longitude, int maxRetries, AddressLookup.AddressCallback callback) {
                  tryAddressLookupWithRetries(latitude, longitude, maxRetries, 0, callback);
              }
              
              private void tryAddressLookupWithRetries(double latitude, double longitude, int maxRetries, int currentTry, AddressLookup.AddressCallback callback) {
                  if (currentTry >= maxRetries) {
                      callback.onAddressError("Max retries exceeded");
                      return;
                  }
                  
                  addressLookup.getAddressFromLocation(latitude, longitude, new AddressLookup.AddressCallback() {
                      @Override
                      public void onAddressFound(String address) {
                          callback.onAddressFound(address);
                      }

                      @Override
                      public void onAddressError(String error) {
                          // Retry with small delay
                          try {
                              Thread.sleep(500);
                          } catch (InterruptedException e) {
                              Thread.currentThread().interrupt();
                          }
                          tryAddressLookupWithRetries(latitude, longitude, maxRetries, currentTry + 1, callback);
                      }
                  });
              }

              private void stopAutoDetection() {
                  try {
                      isTracking = false;
                      tripStorage.setAutoDetectionEnabled(false);

                      if (currentTrip != null && lastLocation != null) {
                          endCurrentTrip();
                      }

                      // Transition to IDLE mode instead of stopping completely
                      transitionToIdleMode();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto detection", e);
                  }
              }

              private void transitionToIdleMode() {
                  try {
                      Log.d(TAG, "Transitioning to IDLE mode - monitoring with reduced GPS");
                      serviceState = STATE_IDLE;
                      
                      // Remove active location updates
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }
                      
                      // Start IDLE monitoring with 30-second intervals
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                          locationManager.requestLocationUpdates(
                              LocationManager.GPS_PROVIDER,
                              IDLE_GPS_INTERVAL,  // 30 seconds
                              10,  // 10 meters minimum distance
                              this
                          );
                      }
                      
                      // Update notification to show IDLE state
                      Notification notification = createNotification(
                          "MileTracker Monitoring",
                          "Ready to detect trips (battery saving mode)"
                      );
                      startForeground(NOTIFICATION_ID, notification);
                      
                      Log.d(TAG, "IDLE mode active - GPS updates every 30 seconds");
                  } catch (Exception e) {
                      Log.e(TAG, "Error transitioning to IDLE mode", e);
                  }
              }

              private void transitionToActiveMode() {
                  try {
                      Log.d(TAG, "Transitioning to ACTIVE mode - high-frequency GPS tracking");
                      serviceState = STATE_ACTIVE;
                      
                      // Remove IDLE location updates
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }
                      
                      // Start ACTIVE tracking with 5-second intervals
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
                          locationManager.requestLocationUpdates(
                              LocationManager.GPS_PROVIDER,
                              ACTIVE_GPS_INTERVAL,  // 5 seconds
                              5,  // 5 meters minimum distance
                              this
                          );
                      }
                      
                      // Update notification to show ACTIVE state
                      Notification notification = createNotification(
                          "MileTracker Active",
                          "Tracking your trip"
                      );
                      startForeground(NOTIFICATION_ID, notification);
                      
                      Log.d(TAG, "ACTIVE mode - GPS updates every 5 seconds");
                  } catch (Exception e) {
                      Log.e(TAG, "Error transitioning to ACTIVE mode", e);
                  }
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "GPS Tracking",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      channel.setSound(null, null);
                      channel.enableVibration(false);
                      channel.setShowBadge(false);

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

          cat > android/app/src/main/java/com/miletrackerpro/app/services/ManualTripService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.Manifest;
          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.Service;
          import android.content.Intent;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.widget.Toast;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.CloudBackupService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import com.miletrackerpro.app.utils.AddressLookup;
          import com.miletrackerpro.app.services.BluetoothVehicleService;
          import android.os.Handler;

          public class ManualTripService extends Service implements LocationListener {
              private static final String TAG = "ManualTripService";
              private static final String CHANNEL_ID = "MANUAL_TRIP_CHANNEL";
              private static final int NOTIFICATION_ID = 1002;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private AddressLookup addressLookup;

              private Trip currentTrip = null;
              private Location startLocation = null;
              private Location lastLocation = null;
              
              // Manual trip tracking variables
              private boolean autoDetectionEnabled = false;
              private boolean isCurrentlyTracking = false;
              private Handler speedHandler;
              private Handler blinkHandler;
              private Runnable speedRunnable;
              private Runnable blinkRunnable;

              @Override
              public void onCreate() {
                  super.onCreate();

                  tripStorage = new TripStorage(this);
                  cloudBackupService = new CloudBackupService(this);
                  addressLookup = new AddressLookup(this);
                  locationManager = (LocationManager) getSystemService(LOCATION_SERVICE);

                  createNotificationChannel();
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  if (intent != null && intent.getAction() != null) {
                      if ("START_MANUAL_TRIP".equals(intent.getAction())) {
                          startManualTrip();
                      } else if ("STOP_MANUAL_TRIP".equals(intent.getAction())) {
                          stopManualTrip();
                      } else if ("REGISTER_VEHICLE".equals(intent.getAction())) {
                          String deviceName = intent.getStringExtra("deviceName");
                          String macAddress = intent.getStringExtra("macAddress");
                          String vehicleType = intent.getStringExtra("vehicleType");
                          registerVehicle(deviceName, macAddress, vehicleType);
                      }
                  }
                  return START_STICKY;
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      // Transition to IDLE mode instead of stopping service
                      // Note: This is in ManualTripService, AutoDetectionService handles IDLE mode
                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              private void registerVehicle(String deviceName, String macAddress, String vehicleType) {
                  try {
                      // Send registration request to BluetoothVehicleService
                      Intent serviceIntent = new Intent(this, BluetoothVehicleService.class);
                      serviceIntent.setAction("REGISTER_VEHICLE");
                      serviceIntent.putExtra("deviceName", deviceName);
                      serviceIntent.putExtra("macAddress", macAddress);
                      serviceIntent.putExtra("vehicleType", vehicleType);
                      startService(serviceIntent);
                      
                      Log.d(TAG, "Vehicle registration sent: " + deviceName + " (" + vehicleType + ")");
                  } catch (Exception e) {
                      Log.e(TAG, "Error registering vehicle: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      long currentTime = System.currentTimeMillis();

                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());
                      currentTrip.setEndTime(currentTime);

                      long duration = currentTime - currentTrip.getStartTime();
                      currentTrip.setDuration(duration);

                      double distance = calculateDistance(
                          currentTrip.getStartLatitude(), currentTrip.getStartLongitude(),
                          currentTrip.getEndLatitude(), currentTrip.getEndLongitude()
                      );
                      currentTrip.setDistance(distance);

                      addressLookup.getAddressFromLocation(lastLocation.getLatitude(), lastLocation.getLongitude(), new AddressLookup.AddressCallback() {
                          @Override
                          public void onAddressFound(String address) {
                              currentTrip.setEndAddress(address);
                              saveTrip();
                          }

                          @Override
                          public void onAddressError(String error) {
                              currentTrip.setEndAddress("Unknown Location");
                              saveTrip();
                          }
                      });
                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959; // Radius of the Earth in miles
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  return R * c;
              }

              private void saveTrip() {
                  try {
                      boolean saved = tripStorage.saveTrip(currentTrip);
                      
                      if (!saved) {
                          // Trip limit reached - send broadcast to show upgrade prompt
                          Log.w(TAG, "Manual trip not saved - free tier limit reached");
                          Intent limitIntent = new Intent("com.miletrackerpro.TRIP_LIMIT_REACHED");
                          limitIntent.putExtra("trip_count", tripStorage.getMonthlyTripCount());
                          limitIntent.putExtra("trip_limit", 40);
                          sendBroadcast(limitIntent);
                          currentTrip = null;
                          return;
                      }
                      
                      // Backup to API if enabled
                      if (tripStorage.isApiSyncEnabled()) {
                          try {
                              CloudBackupService cloudService = new CloudBackupService(this);
                              cloudService.backupTrip(currentTrip);
                          } catch (Exception e) {
                              Log.e(TAG, "API backup failed: " + e.getMessage());
                          }
                      }

                      sendBroadcast("completed", currentTrip.getDistance(), currentTrip.getDuration());
                      currentTrip = null;
                  } catch (Exception e) {
                      Log.e(TAG, "Error saving trip: " + e.getMessage(), e);
                  }
              }



              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (currentTrip == null) return;

                      if (startLocation == null) {
                          startLocation = location;
                          currentTrip.setStartLatitude(location.getLatitude());
                          currentTrip.setStartLongitude(location.getLongitude());

                          addressLookup.getAddressFromLocation(location.getLatitude(), location.getLongitude(), new AddressLookup.AddressCallback() {
                              @Override
                              public void onAddressFound(String address) {
                                  currentTrip.setStartAddress(address);
                              }

                              @Override
                              public void onAddressError(String error) {
                                  currentTrip.setStartAddress("Unknown Location");
                              }
                          });
                      }

                      lastLocation = location;

                      if (startLocation != null) {
                          double currentDistance = calculateDistance(
                              startLocation.getLatitude(), startLocation.getLongitude(),
                              location.getLatitude(), location.getLongitude()
                          );
                          sendBroadcast("recording", currentDistance, 0);
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error in onLocationChanged: " + e.getMessage(), e);
                  }
              }

              private void sendBroadcast(String status) {
                  sendBroadcast(status, 0, 0);
              }

              private void sendBroadcast(String status, double distance, long duration) {
                  try {
                      Intent intent = new Intent("MANUAL_TRIP_UPDATE");
                      intent.putExtra("status", status);
                      intent.putExtra("distance", distance);
                      intent.putExtra("duration", duration);
                      sendBroadcast(intent);
                  } catch (Exception e) {
                      Log.e(TAG, "Error sending broadcast: " + e.getMessage(), e);
                  }
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Manual Trip Recording",
                          NotificationManager.IMPORTANCE_LOW
                      );

                      NotificationManager notificationManager = getSystemService(NotificationManager.class);
                      notificationManager.createNotificationChannel(channel);
                  }
              }



              // Bluetooth methods - Vehicle connection/disconnection now handled through AutoDetectionService
              // This provides proper trip detection with address lookup and automatic stopping when stationary
              
              public void onDestroy() {
                  super.onDestroy();
                  
                  if (speedRunnable != null) {
                      speedHandler.removeCallbacks(speedRunnable);
                  }
                  
                  if (blinkRunnable != null) {
                      blinkHandler.removeCallbacks(blinkRunnable);
                  }
              }

              private Notification createNotification(String title, String content) {
                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setOngoing(true)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) { return null; }
              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}
              @Override
              public void onProviderEnabled(String provider) {}
              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Build AAB for Google Play Store
        run: |
          cd android
          echo "🏪 BUILDING AAB (Android App Bundle) FOR GOOGLE PLAY STORE"
          echo "✅ Target: Google Play Console (Internal Testing / Production)"
          echo "✅ Format: AAB (required for Play Store)"
          echo "✅ Freemium: Complete with Google Play Billing"
          echo "✅ Features: Background GPS, Bluetooth, Trip detection, Cloud sync"
          ./gradlew clean bundleRelease --no-daemon --stacktrace

      - name: Upload AAB for Google Play Store
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-PlayStore-v4.9.154
          path: android/app/build/outputs/bundle/release/*.aab
