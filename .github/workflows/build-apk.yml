name: Enhanced Trip Management - v4.9.68 with Clean Merge/Split UI

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Clean and create Android project structure
        run: |
          rm -rf android
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/services
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/storage
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/utils
          mkdir -p android/app/src/main/java/com/miletrackerpro/app/auth
          mkdir -p android/app/src/main/res/layout
          mkdir -p android/app/src/main/res/values
          mkdir -p android/gradle/wrapper

      - name: Create settings.gradle
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create build configuration
        run: |
          cat > android/build.gradle << 'EOF'
          buildscript {
              repositories {
                  google()
                  mavenCentral()
              }
              dependencies {
                  classpath 'com.android.tools.build:gradle:8.3.2'
              }
          }
          
          allprojects {
              repositories {
                  google()
                  mavenCentral()
              }
          }
          EOF

      - name: Create app build script
        run: |
          cat > android/app/build.gradle << 'EOF'
          // Simple Android app build
          apply plugin: 'com.android.application'
          
          android {
              compileSdkVersion 35
              
              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdkVersion 23
                  targetSdkVersion 35
                  versionCode 49668
                  versionName "4.9.68"
              }
              
              buildTypes {
                  release {
                      minifyEnabled false
                  }
              }
          }
          apply plugin: "com.android.application"
          apply plugin: "kotlin-android"

          android {
              namespace "com.miletrackerpro.app"
              compileSdkVersion rootProject.ext.compileSdkVersion

              defaultConfig {
                  applicationId "com.miletrackerpro.app"
                  minSdkVersion rootProject.ext.minSdkVersion
                  targetSdkVersion rootProject.ext.targetSdkVersion
                  versionCode 68
                  versionName "4.9.68"
                  testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
              }

              signingConfigs {
                  release {
                      storeFile file('keystore.jks')
                      storePassword 'android'
                      keyAlias 'key0'
                      keyPassword 'android'
                  }
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      signingConfig signingConfigs.release
                  }
              }

              packagingOptions {
                  pickFirst '**/kotlin-stdlib-*.jar'
                  pickFirst '**/kotlin-stdlib-jdk*.jar'
                  exclude 'META-INF/kotlin-stdlib.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk7.kotlin_module'
                  exclude 'META-INF/kotlin-stdlib-jdk8.kotlin_module'
              }

              configurations.all {
                  resolutionStrategy {
                      force 'org.jetbrains.kotlin:kotlin-stdlib:1.8.22'
                      force 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22'
                      force 'org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.22'
                  }
              }
          }

          dependencies {
              implementation 'androidx.appcompat:appcompat:1.6.1'
              implementation 'androidx.core:core-ktx:1.12.0'
              implementation 'com.google.android.material:material:1.11.0'
              implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
              implementation 'com.google.android.gms:play-services-location:21.0.1'
              implementation 'com.squareup.okhttp3:okhttp:4.12.0'
              implementation 'org.json:json:20231013'
              implementation 'androidx.lifecycle:lifecycle-service:2.7.0'
              implementation 'androidx.work:work-runtime-ktx:2.9.0'
              testImplementation 'junit:junit:4.13.2'
              androidTestImplementation 'androidx.test.ext:junit:1.1.5'
              androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
          }
          EOF

      - name: Create Gradle properties
        run: |
          cat > android/gradle.properties << 'EOF'
          android.useAndroidX=true
          android.enableJetifier=true
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          org.gradle.parallel=true
          org.gradle.daemon=true
          org.gradle.configureondemand=true
          kotlin.code.style=official
          EOF

      - name: Create Gradle settings
        run: |
          cat > android/settings.gradle << 'EOF'
          rootProject.name = 'MileTrackerPro'
          include ':app'
          EOF

      - name: Create Android Manifest with all permissions
        run: |
          cat > android/app/src/main/AndroidManifest.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools">

              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
              <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" />
              <uses-permission android:name="android.permission.INTERNET" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
              <uses-permission android:name="android.permission.WAKE_LOCK" />
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

              <application
                  android:name=".MileTrackerApplication"
                  android:allowBackup="true"
                  android:dataExtractionRules="@xml/data_extraction_rules"
                  android:fullBackupContent="@xml/backup_rules"
                  android:icon="@android:drawable/ic_menu_mylocation"
                  android:label="MileTracker Pro"
                  android:theme="@style/AppTheme"
                  android:usesCleartextTraffic="true"
                  android:networkSecurityConfig="@xml/network_security_config"
                  tools:targetApi="31">

                  <activity
                      android:name=".MainActivity"
                      android:exported="true"
                      android:theme="@style/AppTheme.NoActionBar">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>

                  <service
                      android:name=".services.GPSTrackingService"
                      android:enabled="true"
                      android:exported="false"
                      android:foregroundServiceType="location" />

                  <service
                      android:name=".services.CloudBackupService"
                      android:enabled="true"
                      android:exported="false" />

                  <receiver android:name=".services.BootReceiver"
                      android:enabled="true"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.BOOT_COMPLETED" />
                      </intent-filter>
                  </receiver>

              </application>
          </manifest>
          EOF

      - name: Create network security config
        run: |
          mkdir -p android/app/src/main/res/xml
          cat > android/app/src/main/res/xml/network_security_config.xml << 'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
                  <domain includeSubdomains="true">localhost</domain>
                  <domain includeSubdomains="true">10.0.2.2</domain>
                  <domain includeSubdomains="true">192.168.1.1</domain>
                  <domain includeSubdomains="true">riker.replit.dev</domain>
                  <domain includeSubdomains="true">replit.dev</domain>
              </domain-config>
          </network-security-config>
          EOF

      - name: Create backup rules
        run: |
          cat > android/app/src/main/res/xml/backup_rules.xml << 'EOF'
          <full-backup-content>
              <include domain="sharedpref" path="."/>
              <include domain="database" path="."/>
              <exclude domain="database" path="device_info.db"/>
          </full-backup-content>
          EOF

      - name: Create data extraction rules
        run: |
          cat > android/app/src/main/res/xml/data_extraction_rules.xml << 'EOF'
          <data-extraction-rules>
              <cloud-backup>
                  <include domain="sharedpref" path="."/>
                  <include domain="database" path="."/>
                  <exclude domain="database" path="device_info.db"/>
              </cloud-backup>
              <device-transfer>
                  <include domain="sharedpref" path="."/>
                  <include domain="database" path="."/>
              </device-transfer>
          </data-extraction-rules>
          EOF

      - name: Create app styles and colors
        run: |
          cat > android/app/src/main/res/values/styles.xml << 'EOF'
          <resources>
              <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
                  <item name="colorPrimary">@color/purple_500</item>
                  <item name="colorPrimaryVariant">@color/purple_700</item>
                  <item name="colorOnPrimary">@color/white</item>
                  <item name="colorSecondary">@color/teal_200</item>
                  <item name="colorSecondaryVariant">@color/teal_700</item>
                  <item name="colorOnSecondary">@color/black</item>
                  <item name="colorError">@color/red_600</item>
                  <item name="colorOnError">@color/white</item>
                  <item name="colorSurface">@color/white</item>
                  <item name="colorOnSurface">@color/black</item>
                  <item name="android:statusBarColor">@color/purple_700</item>
              </style>

              <style name="AppTheme.NoActionBar">
                  <item name="windowActionBar">false</item>
                  <item name="windowNoTitle">true</item>
              </style>
          </resources>
          EOF

          cat > android/app/src/main/res/values/colors.xml << 'EOF'
          <resources>
              <color name="purple_200">#FFBB86FC</color>
              <color name="purple_500">#FF6200EA</color>
              <color name="purple_700">#FF3700B3</color>
              <color name="teal_200">#FF03DAC5</color>
              <color name="teal_700">#FF018786</color>
              <color name="black">#FF000000</color>
              <color name="white">#FFFFFFFF</color>
              <color name="red_600">#FFE53E3E</color>
              <color name="gray_100">#FFF7FAFC</color>
              <color name="gray_200">#FFEDF2F7</color>
              <color name="gray_500">#FFA0AEC0</color>
              <color name="gray_700">#FF4A5568</color>
              <color name="blue_500">#FF4299E1</color>
              <color name="green_500">#FF48BB78</color>
              <color name="yellow_500">#FFED8936</color>
          </resources>
          EOF

          cat > android/app/src/main/res/values/strings.xml << 'EOF'
          <resources>
              <string name="app_name">MileTracker Pro</string>
              <string name="notification_channel_name">Trip Tracking</string>
              <string name="notification_channel_description">Shows when tracking trips</string>
              <string name="tracking_notification_title">Tracking trip</string>
              <string name="tracking_notification_text">Tap to return to app</string>
          </resources>
          EOF

      - name: Create MileTrackerApplication
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MileTrackerApplication.java << 'EOF'
          package com.miletrackerpro.app;

          import android.app.Application;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.os.Build;

          public class MileTrackerApplication extends Application {
              public static final String TRACKING_CHANNEL_ID = "trip_tracking";
              
              @Override
              public void onCreate() {
                  super.onCreate();
                  createNotificationChannels();
              }
              
              private void createNotificationChannels() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel trackingChannel = new NotificationChannel(
                          TRACKING_CHANNEL_ID,
                          "Trip Tracking",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      trackingChannel.setDescription("Shows when tracking trips");
                      
                      NotificationManager manager = getSystemService(NotificationManager.class);
                      manager.createNotificationChannel(trackingChannel);
                  }
              }
          }
          EOF

      - name: Create Trip data model
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/Trip.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import java.io.Serializable;
          import java.util.List;
          import java.util.ArrayList;

          public class Trip implements Serializable {
              private long id;
              private long startTime;
              private long endTime;
              private String startAddress;
              private String endAddress;
              private double startLatitude;
              private double startLongitude;
              private double endLatitude;
              private double endLongitude;
              private double distance;
              private String category;
              private String client;
              private String notes;
              private boolean autoDetected;
              private List<Location> gpsPath;
              private String deviceId;

              public static class Location implements Serializable {
                  public double latitude;
                  public double longitude;
                  public long timestamp;
                  
                  public Location(double lat, double lng, long time) {
                      this.latitude = lat;
                      this.longitude = lng;
                      this.timestamp = time;
                  }
              }

              public Trip() {
                  this.gpsPath = new ArrayList<>();
              }

              // Getters and setters
              public long getId() { return id; }
              public void setId(long id) { this.id = id; }

              public long getStartTime() { return startTime; }
              public void setStartTime(long startTime) { this.startTime = startTime; }

              public long getEndTime() { return endTime; }
              public void setEndTime(long endTime) { this.endTime = endTime; }

              public String getStartAddress() { return startAddress; }
              public void setStartAddress(String startAddress) { this.startAddress = startAddress; }

              public String getEndAddress() { return endAddress; }
              public void setEndAddress(String endAddress) { this.endAddress = endAddress; }

              public double getStartLatitude() { return startLatitude; }
              public void setStartLatitude(double startLatitude) { this.startLatitude = startLatitude; }

              public double getStartLongitude() { return startLongitude; }
              public void setStartLongitude(double startLongitude) { this.startLongitude = startLongitude; }

              public double getEndLatitude() { return endLatitude; }
              public void setEndLatitude(double endLatitude) { this.endLatitude = endLatitude; }

              public double getEndLongitude() { return endLongitude; }
              public void setEndLongitude(double endLongitude) { this.endLongitude = endLongitude; }

              public double getDistance() { return distance; }
              public void setDistance(double distance) { this.distance = distance; }

              public String getCategory() { return category; }
              public void setCategory(String category) { this.category = category; }

              public String getClient() { return client; }
              public void setClient(String client) { this.client = client; }

              public String getNotes() { return notes; }
              public void setNotes(String notes) { this.notes = notes; }

              public boolean isAutoDetected() { return autoDetected; }
              public void setAutoDetected(boolean autoDetected) { this.autoDetected = autoDetected; }

              public List<Location> getGpsPath() { return gpsPath; }
              public void setGpsPath(List<Location> gpsPath) { this.gpsPath = gpsPath; }

              public String getDeviceId() { return deviceId; }
              public void setDeviceId(String deviceId) { this.deviceId = deviceId; }

              public void addGpsPoint(double latitude, double longitude, long timestamp) {
                  if (gpsPath == null) {
                      gpsPath = new ArrayList<>();
                  }
                  gpsPath.add(new Location(latitude, longitude, timestamp));
              }

              public long getDuration() {
                  return endTime - startTime;
              }

              public String getFormattedDuration() {
                  long duration = getDuration();
                  long hours = duration / (1000 * 60 * 60);
                  long minutes = (duration % (1000 * 60 * 60)) / (1000 * 60);
                  
                  if (hours > 0) {
                      return hours + "h " + minutes + "m";
                  } else {
                      return minutes + "m";
                  }
              }

              public String getFormattedDistance() {
                  return String.format("%.1f mi", distance);
              }

              public String getFormattedDate() {
                  java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("MMM dd, yyyy h:mm a");
                  return sdf.format(new java.util.Date(startTime));
              }
          }
          EOF

      - name: Create TripStorage with enhanced merge functionality
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/storage/TripStorage.java << 'EOF'
          package com.miletrackerpro.app.storage;

          import android.content.Context;
          import android.content.SharedPreferences;
          import com.google.gson.Gson;
          import com.google.gson.reflect.TypeToken;
          import java.lang.reflect.Type;
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.Comparator;
          import java.util.List;

          public class TripStorage {
              private static final String PREFS_NAME = "MileTrackerPrefs";
              private static final String TRIPS_KEY = "trips";
              private Context context;
              private Gson gson;

              public TripStorage(Context context) {
                  this.context = context;
                  this.gson = new Gson();
              }

              public void saveTrip(Trip trip) {
                  List<Trip> trips = getTrips();
                  
                  // Check if trip already exists and update it
                  boolean updated = false;
                  for (int i = 0; i < trips.size(); i++) {
                      if (trips.get(i).getId() == trip.getId()) {
                          trips.set(i, trip);
                          updated = true;
                          break;
                      }
                  }
                  
                  // Add new trip if not updated
                  if (!updated) {
                      trips.add(trip);
                  }
                  
                  saveTrips(trips);
              }

              public List<Trip> getTrips() {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  String json = prefs.getString(TRIPS_KEY, "[]");
                  
                  Type listType = new TypeToken<List<Trip>>(){}.getType();
                  List<Trip> trips = gson.fromJson(json, listType);
                  
                  if (trips == null) {
                      trips = new ArrayList<>();
                  }
                  
                  // Sort by start time (newest first)
                  Collections.sort(trips, new Comparator<Trip>() {
                      @Override
                      public int compare(Trip t1, Trip t2) {
                          return Long.compare(t2.getStartTime(), t1.getStartTime());
                      }
                  });
                  
                  return trips;
              }

              private void saveTrips(List<Trip> trips) {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  SharedPreferences.Editor editor = prefs.edit();
                  String json = gson.toJson(trips);
                  editor.putString(TRIPS_KEY, json);
                  editor.apply();
              }

              public void deleteTrip(long tripId) {
                  List<Trip> trips = getTrips();
                  trips.removeIf(trip -> trip.getId() == tripId);
                  saveTrips(trips);
              }

              public Trip mergeTrips(List<Trip> tripsToMerge) {
                  if (tripsToMerge.isEmpty()) {
                      return null;
                  }

                  // Sort trips chronologically
                  Collections.sort(tripsToMerge, new Comparator<Trip>() {
                      @Override
                      public int compare(Trip t1, Trip t2) {
                          return Long.compare(t1.getStartTime(), t2.getStartTime());
                      }
                  });

                  Trip firstTrip = tripsToMerge.get(0);
                  Trip lastTrip = tripsToMerge.get(tripsToMerge.size() - 1);

                  // Create merged trip
                  Trip mergedTrip = new Trip();
                  mergedTrip.setId(System.currentTimeMillis());
                  mergedTrip.setStartTime(firstTrip.getStartTime());
                  mergedTrip.setEndTime(lastTrip.getEndTime());
                  mergedTrip.setStartAddress(firstTrip.getStartAddress());
                  mergedTrip.setEndAddress(lastTrip.getEndAddress());
                  mergedTrip.setStartLatitude(firstTrip.getStartLatitude());
                  mergedTrip.setStartLongitude(firstTrip.getStartLongitude());
                  mergedTrip.setEndLatitude(lastTrip.getEndLatitude());
                  mergedTrip.setEndLongitude(lastTrip.getEndLongitude());

                  // Combine GPS paths and calculate total distance
                  List<Trip.Location> combinedPath = new ArrayList<>();
                  double totalDistance = 0;

                  for (Trip trip : tripsToMerge) {
                      if (trip.getGpsPath() != null) {
                          combinedPath.addAll(trip.getGpsPath());
                      }
                      totalDistance += trip.getDistance();
                  }

                  mergedTrip.setGpsPath(combinedPath);
                  mergedTrip.setDistance(totalDistance);

                  // Use category from first trip, or "Business" if mixed
                  String category = firstTrip.getCategory();
                  for (Trip trip : tripsToMerge) {
                      if (!category.equals(trip.getCategory())) {
                          category = "Business"; // Default for mixed trips
                          break;
                      }
                  }
                  mergedTrip.setCategory(category);

                  // Combine notes
                  StringBuilder combinedNotes = new StringBuilder();
                  for (int i = 0; i < tripsToMerge.size(); i++) {
                      Trip trip = tripsToMerge.get(i);
                      if (trip.getNotes() != null && !trip.getNotes().trim().isEmpty()) {
                          if (combinedNotes.length() > 0) {
                              combinedNotes.append(" • ");
                          }
                          combinedNotes.append("Segment ").append(i + 1).append(": ").append(trip.getNotes());
                      }
                  }
                  mergedTrip.setNotes(combinedNotes.toString());

                  // Mark as manually merged (not auto-detected)
                  mergedTrip.setAutoDetected(false);
                  mergedTrip.setDeviceId(firstTrip.getDeviceId());

                  // Remove original trips
                  List<Trip> allTrips = getTrips();
                  for (Trip tripToRemove : tripsToMerge) {
                      allTrips.removeIf(trip -> trip.getId() == tripToRemove.getId());
                  }

                  // Add merged trip
                  allTrips.add(mergedTrip);
                  saveTrips(allTrips);

                  return mergedTrip;
              }

              // Get recent trips for dashboard
              public List<Trip> getRecentTrips(int limit) {
                  List<Trip> allTrips = getTrips();
                  if (allTrips.size() <= limit) {
                      return allTrips;
                  }
                  return allTrips.subList(0, limit);
              }

              // Statistics methods
              public double getTotalMiles() {
                  List<Trip> trips = getTrips();
                  double total = 0;
                  for (Trip trip : trips) {
                      total += trip.getDistance();
                  }
                  return total;
              }

              public int getTripCount() {
                  return getTrips().size();
              }

              public void clearAllTrips() {
                  saveTrips(new ArrayList<>());
              }
          }
          EOF

      - name: Create GPS Tracking Service
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/GPSTrackingService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.app.Notification;
          import android.app.NotificationChannel;
          import android.app.NotificationManager;
          import android.app.PendingIntent;
          import android.app.Service;
          import android.content.Context;
          import android.content.Intent;
          import android.content.pm.PackageManager;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Build;
          import android.os.IBinder;
          import android.os.PowerManager;
          import android.util.Log;
          import androidx.core.app.ActivityCompat;
          import androidx.core.app.NotificationCompat;
          import com.miletrackerpro.app.MainActivity;
          import com.miletrackerpro.app.R;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import java.util.ArrayList;
          import java.util.List;

          public class GPSTrackingService extends Service implements LocationListener {
              private static final String TAG = "GPSTrackingService";
              private static final int NOTIFICATION_ID = 1001;
              private static final String CHANNEL_ID = "trip_tracking";
              private static final double SPEED_THRESHOLD_START = 8.0; // mph
              private static final double SPEED_THRESHOLD_STOP = 3.0; // mph
              private static final int REQUIRED_READINGS = 3;

              private LocationManager locationManager;
              private TripStorage tripStorage;
              private PowerManager.WakeLock wakeLock;
              
              private Trip currentTrip;
              private Location lastLocation;
              private Location startLocation;
              private List<Double> recentSpeeds;
              private boolean isTracking = false;

              @Override
              public void onCreate() {
                  super.onCreate();
                  
                  tripStorage = new TripStorage(this);
                  locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                  recentSpeeds = new ArrayList<>();
                  
                  PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
                  wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "MileTracker:GPSWakeLock");
                  
                  createNotificationChannel();
                  Log.d(TAG, "GPS Tracking Service created");
              }

              @Override
              public int onStartCommand(Intent intent, int flags, int startId) {
                  String action = intent.getStringExtra("action");
                  
                  if ("start_auto".equals(action)) {
                      startAutoTracking();
                  } else if ("stop_auto".equals(action)) {
                      stopAutoTracking();
                  } else if ("start_manual".equals(action)) {
                      startManualTrip();
                  } else if ("stop_manual".equals(action)) {
                      stopManualTrip();
                  }
                  
                  return START_STICKY;
              }

              private void startAutoTracking() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      if (!wakeLock.isHeld()) {
                          wakeLock.acquire();
                      }

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          15000, // 15 seconds
                          5, // 5 meters
                          this
                      );

                      Notification notification = createNotification("Auto detection active", "Monitoring for trips");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("monitoring");
                      Log.d(TAG, "Auto tracking started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting auto tracking: " + e.getMessage(), e);
                  }
              }

              private void stopAutoTracking() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }
                      
                      if (currentTrip != null) {
                          completeTrip();
                      }

                      if (wakeLock.isHeld()) {
                          wakeLock.release();
                      }

                      stopForeground(true);
                      stopSelf();
                      
                      sendBroadcast("stopped");
                      Log.d(TAG, "Auto tracking stopped");
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping auto tracking: " + e.getMessage(), e);
                  }
              }

              private void startManualTrip() {
                  try {
                      if (ActivityCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          return;
                      }

                      long currentTime = System.currentTimeMillis();

                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setAutoDetected(false);
                      currentTrip.setCategory("Personal");

                      locationManager.requestLocationUpdates(
                          LocationManager.GPS_PROVIDER,
                          5000,
                          5,
                          this
                      );

                      Notification notification = createNotification("Manual trip recording", "Tap to return to app");
                      startForeground(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                  } catch (Exception e) {
                      Log.e(TAG, "Error starting manual trip: " + e.getMessage(), e);
                  }
              }

              private void stopManualTrip() {
                  try {
                      if (locationManager != null) {
                          locationManager.removeUpdates(this);
                      }

                      if (currentTrip != null && startLocation != null && lastLocation != null) {
                          completeTrip();
                      }

                      stopForeground(true);
                      stopSelf();
                  } catch (Exception e) {
                      Log.e(TAG, "Error stopping manual trip: " + e.getMessage(), e);
                  }
              }

              @Override
              public void onLocationChanged(Location location) {
                  try {
                      if (location == null) return;

                      double speed = location.hasSpeed() ? location.getSpeed() * 2.237 : 0; // Convert m/s to mph

                      // Track recent speeds
                      recentSpeeds.add(speed);
                      if (recentSpeeds.size() > 5) {
                          recentSpeeds.remove(0);
                      }

                      // Send location update broadcast
                      Intent intent = new Intent("LOCATION_UPDATE");
                      intent.putExtra("latitude", location.getLatitude());
                      intent.putExtra("longitude", location.getLongitude());
                      intent.putExtra("speed", speed);
                      intent.putExtra("accuracy", location.getAccuracy());
                      sendBroadcast(intent);

                      // Handle auto trip detection
                      if (currentTrip == null) {
                          // Check if we should start a trip
                          if (shouldStartTrip(speed)) {
                              startTrip(location, speed);
                          }
                      } else {
                          // Add GPS point to current trip
                          currentTrip.addGpsPoint(location.getLatitude(), location.getLongitude(), location.getTime());
                          
                          // Check if we should end the trip
                          if (currentTrip.isAutoDetected() && shouldEndTrip(speed)) {
                              completeTrip();
                          }
                      }

                      lastLocation = location;

                  } catch (Exception e) {
                      Log.e(TAG, "Error processing location: " + e.getMessage(), e);
                  }
              }

              private boolean shouldStartTrip(double currentSpeed) {
                  if (recentSpeeds.size() < REQUIRED_READINGS) return false;
                  
                  int highSpeedCount = 0;
                  for (double speed : recentSpeeds) {
                      if (speed > SPEED_THRESHOLD_START) {
                          highSpeedCount++;
                      }
                  }
                  
                  return highSpeedCount >= REQUIRED_READINGS;
              }

              private boolean shouldEndTrip(double currentSpeed) {
                  if (recentSpeeds.size() < REQUIRED_READINGS) return false;
                  
                  int lowSpeedCount = 0;
                  for (double speed : recentSpeeds) {
                      if (speed < SPEED_THRESHOLD_STOP) {
                          lowSpeedCount++;
                      }
                  }
                  
                  return lowSpeedCount >= REQUIRED_READINGS;
              }

              private void startTrip(Location location, double speed) {
                  try {
                      long currentTime = System.currentTimeMillis();
                      
                      currentTrip = new Trip();
                      currentTrip.setId(currentTime);
                      currentTrip.setStartTime(currentTime);
                      currentTrip.setStartLatitude(location.getLatitude());
                      currentTrip.setStartLongitude(location.getLongitude());
                      currentTrip.setAutoDetected(true);
                      currentTrip.setCategory("Business");
                      currentTrip.addGpsPoint(location.getLatitude(), location.getLongitude(), location.getTime());

                      startLocation = location;

                      Notification notification = createNotification("Trip in progress", "Started at " + speed + " mph");
                      NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
                      manager.notify(NOTIFICATION_ID, notification);

                      sendBroadcast("started");
                      Log.d(TAG, "Trip started at speed: " + speed + " mph");

                  } catch (Exception e) {
                      Log.e(TAG, "Error starting trip: " + e.getMessage(), e);
                  }
              }

              private void completeTrip() {
                  try {
                      if (currentTrip == null || lastLocation == null) return;

                      currentTrip.setEndTime(System.currentTimeMillis());
                      currentTrip.setEndLatitude(lastLocation.getLatitude());
                      currentTrip.setEndLongitude(lastLocation.getLongitude());

                      // Calculate distance using GPS path
                      double distance = calculateTripDistance();
                      currentTrip.setDistance(distance);

                      // Only save trips over 0.5 miles
                      if (distance > 0.5) {
                          tripStorage.saveTrip(currentTrip);
                          
                          sendBroadcast("completed");
                          Log.d(TAG, "Trip completed: " + distance + " miles");
                      } else {
                          Log.d(TAG, "Trip too short, not saved: " + distance + " miles");
                      }

                      currentTrip = null;
                      startLocation = null;

                  } catch (Exception e) {
                      Log.e(TAG, "Error completing trip: " + e.getMessage(), e);
                  }
              }

              private double calculateTripDistance() {
                  if (currentTrip == null || currentTrip.getGpsPath().size() < 2) {
                      return 0;
                  }

                  double totalDistance = 0;
                  List<Trip.Location> path = currentTrip.getGpsPath();

                  for (int i = 1; i < path.size(); i++) {
                      Trip.Location prev = path.get(i - 1);
                      Trip.Location curr = path.get(i);
                      totalDistance += calculateDistance(prev.latitude, prev.longitude, curr.latitude, curr.longitude);
                  }

                  return totalDistance;
              }

              private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
                  final int R = 3959; // Earth's radius in miles
                  
                  double latDistance = Math.toRadians(lat2 - lat1);
                  double lonDistance = Math.toRadians(lon2 - lon1);
                  double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                          + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                          * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
                  double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                  
                  return R * c;
              }

              private void sendBroadcast(String status) {
                  Intent intent = new Intent("GPS_STATUS_UPDATE");
                  intent.putExtra("status", status);
                  sendBroadcast(intent);
              }

              private void createNotificationChannel() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      NotificationChannel channel = new NotificationChannel(
                          CHANNEL_ID,
                          "Trip Tracking",
                          NotificationManager.IMPORTANCE_LOW
                      );
                      channel.setDescription("Shows when tracking trips");
                      
                      NotificationManager manager = getSystemService(NotificationManager.class);
                      manager.createNotificationChannel(channel);
                  }
              }

              private Notification createNotification(String title, String content) {
                  Intent intent = new Intent(this, MainActivity.class);
                  PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_IMMUTABLE);

                  return new NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(title)
                      .setContentText(content)
                      .setSmallIcon(android.R.drawable.ic_menu_mylocation)
                      .setContentIntent(pendingIntent)
                      .setOngoing(true)
                      .setPriority(NotificationCompat.PRIORITY_LOW)
                      .build();
              }

              @Override
              public IBinder onBind(Intent intent) {
                  return null;
              }

              @Override
              public void onDestroy() {
                  if (locationManager != null) {
                      locationManager.removeUpdates(this);
                  }
                  
                  if (wakeLock != null && wakeLock.isHeld()) {
                      wakeLock.release();
                  }
                  
                  super.onDestroy();
              }

              // LocationListener methods
              @Override
              public void onStatusChanged(String provider, int status, android.os.Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Create CloudBackupService with bidirectional sync
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/CloudBackupService.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.content.Context;
          import android.util.Log;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import okhttp3.*;
          import org.json.JSONArray;
          import org.json.JSONObject;
          import java.io.IOException;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class CloudBackupService {
              private static final String TAG = "CloudBackupService";
              private static final String API_BASE_URL = "https://18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev/api";
              
              private OkHttpClient client;
              private TripStorage tripStorage;
              private ExecutorService executor;

              public CloudBackupService(Context context) {
                  this.client = new OkHttpClient();
                  this.tripStorage = new TripStorage(context);
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public interface BackupCallback {
                  void onSuccess();
                  void onError(String error);
              }

              public void backupTrip(Trip trip, BackupCallback callback) {
                  executor.execute(() -> {
                      try {
                          JSONObject tripJson = new JSONObject();
                          tripJson.put("id", trip.getId());
                          tripJson.put("startTime", trip.getStartTime());
                          tripJson.put("endTime", trip.getEndTime());
                          tripJson.put("startAddress", trip.getStartAddress() != null ? trip.getStartAddress() : "");
                          tripJson.put("endAddress", trip.getEndAddress() != null ? trip.getEndAddress() : "");
                          tripJson.put("startLatitude", trip.getStartLatitude());
                          tripJson.put("startLongitude", trip.getStartLongitude());
                          tripJson.put("endLatitude", trip.getEndLatitude());
                          tripJson.put("endLongitude", trip.getEndLongitude());
                          tripJson.put("distance", trip.getDistance());
                          tripJson.put("category", trip.getCategory() != null ? trip.getCategory() : "Personal");
                          tripJson.put("client", trip.getClient() != null ? trip.getClient() : "");
                          tripJson.put("notes", trip.getNotes() != null ? trip.getNotes() : "");
                          tripJson.put("autoDetected", trip.isAutoDetected());
                          tripJson.put("deviceId", trip.getDeviceId() != null ? trip.getDeviceId() : "");

                          RequestBody body = RequestBody.create(
                              tripJson.toString(),
                              MediaType.parse("application/json")
                          );

                          Request request = new Request.Builder()
                              .url(API_BASE_URL + "/trips")
                              .post(body)
                              .build();

                          Response response = client.newCall(request).execute();
                          
                          if (response.isSuccessful()) {
                              Log.d(TAG, "Trip backed up successfully");
                              if (callback != null) callback.onSuccess();
                          } else {
                              String error = "Backup failed: " + response.code();
                              Log.e(TAG, error);
                              if (callback != null) callback.onError(error);
                          }
                          
                          response.close();

                      } catch (Exception e) {
                          String error = "Backup error: " + e.getMessage();
                          Log.e(TAG, error, e);
                          if (callback != null) callback.onError(error);
                      }
                  });
              }

              public void downloadAllTrips(String deviceId, BackupCallback callback) {
                  executor.execute(() -> {
                      try {
                          String url = API_BASE_URL + "/trips";
                          if (deviceId != null && !deviceId.isEmpty()) {
                              url += "/" + deviceId;
                          }
                          
                          Request request = new Request.Builder()
                              .url(url)
                              .get()
                              .build();

                          Response response = client.newCall(request).execute();
                          
                          if (response.isSuccessful()) {
                              String responseBody = response.body().string();
                              JSONObject jsonResponse = new JSONObject(responseBody);
                              
                              if (jsonResponse.getBoolean("success")) {
                                  JSONArray tripsArray = jsonResponse.getJSONArray("trips");
                                  List<Trip> cloudTrips = new ArrayList<>();
                                  
                                  for (int i = 0; i < tripsArray.length(); i++) {
                                      JSONObject tripJson = tripsArray.getJSONObject(i);
                                      
                                      Trip trip = new Trip();
                                      trip.setId(tripJson.getLong("id"));
                                      trip.setStartTime(tripJson.getLong("startTime"));
                                      trip.setEndTime(tripJson.getLong("endTime"));
                                      trip.setStartAddress(tripJson.optString("startAddress", ""));
                                      trip.setEndAddress(tripJson.optString("endAddress", ""));
                                      trip.setStartLatitude(tripJson.getDouble("startLatitude"));
                                      trip.setStartLongitude(tripJson.getDouble("startLongitude"));
                                      trip.setEndLatitude(tripJson.getDouble("endLatitude"));
                                      trip.setEndLongitude(tripJson.getDouble("endLongitude"));
                                      trip.setDistance(tripJson.getDouble("distance"));
                                      trip.setCategory(tripJson.optString("category", "Personal"));
                                      trip.setClient(tripJson.optString("client", ""));
                                      trip.setNotes(tripJson.optString("notes", ""));
                                      trip.setAutoDetected(tripJson.getBoolean("autoDetected"));
                                      trip.setDeviceId(tripJson.optString("deviceId", ""));
                                      
                                      cloudTrips.add(trip);
                                  }
                                  
                                  // Merge with local trips (avoid duplicates)
                                  List<Trip> localTrips = tripStorage.getTrips();
                                  List<Long> localTripIds = new ArrayList<>();
                                  for (Trip localTrip : localTrips) {
                                      localTripIds.add(localTrip.getId());
                                  }
                                  
                                  int newTripsCount = 0;
                                  for (Trip cloudTrip : cloudTrips) {
                                      if (!localTripIds.contains(cloudTrip.getId())) {
                                          tripStorage.saveTrip(cloudTrip);
                                          newTripsCount++;
                                      }
                                  }
                                  
                                  Log.d(TAG, "Downloaded " + newTripsCount + " new trips from cloud");
                                  if (callback != null) callback.onSuccess();
                              } else {
                                  String error = "Download failed: " + jsonResponse.optString("error", "Unknown error");
                                  Log.e(TAG, error);
                                  if (callback != null) callback.onError(error);
                              }
                          } else {
                              String error = "Download failed: " + response.code();
                              Log.e(TAG, error);
                              if (callback != null) callback.onError(error);
                          }
                          
                          response.close();

                      } catch (Exception e) {
                          String error = "Download error: " + e.getMessage();
                          Log.e(TAG, error, e);
                          if (callback != null) callback.onError(error);
                      }
                  });
              }
          }
          EOF

      - name: Create Boot Receiver for background tracking
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/services/BootReceiver.java << 'EOF'
          package com.miletrackerpro.app.services;

          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.SharedPreferences;

          public class BootReceiver extends BroadcastReceiver {
              @Override
              public void onReceive(Context context, Intent intent) {
                  if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
                      SharedPreferences prefs = context.getSharedPreferences("MileTrackerPrefs", Context.MODE_PRIVATE);
                      boolean autoTrackingEnabled = prefs.getBoolean("auto_tracking_enabled", false);
                      
                      if (autoTrackingEnabled) {
                          Intent serviceIntent = new Intent(context, GPSTrackingService.class);
                          serviceIntent.putExtra("action", "start_auto");
                          context.startForegroundService(serviceIntent);
                      }
                  }
              }
          }
          EOF

      - name: Create User Authentication System
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/auth/UserManager.java << 'EOF'
          package com.miletrackerpro.app.auth;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import okhttp3.*;
          import org.json.JSONObject;
          import java.io.IOException;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;

          public class UserManager {
              private static final String TAG = "UserManager";
              private static final String PREFS_NAME = "MileTrackerAuth";
              private static final String API_BASE_URL = "https://18fab652-f2dd-4a28-bd0a-3e89d59cb6d2-00-1bhb79n061bsu.riker.replit.dev/api";
              
              private Context context;
              private OkHttpClient client;
              private ExecutorService executor;

              public UserManager(Context context) {
                  this.context = context;
                  this.client = new OkHttpClient();
                  this.executor = Executors.newSingleThreadExecutor();
              }

              public interface AuthCallback {
                  void onSuccess(String userId);
                  void onError(String error);
              }

              public void loginUser(String email, String password, AuthCallback callback) {
                  executor.execute(() -> {
                      try {
                          JSONObject loginData = new JSONObject();
                          loginData.put("email", email);
                          loginData.put("password", password);

                          RequestBody body = RequestBody.create(
                              loginData.toString(),
                              MediaType.parse("application/json")
                          );

                          Request request = new Request.Builder()
                              .url(API_BASE_URL + "/auth/login")
                              .post(body)
                              .build();

                          Response response = client.newCall(request).execute();
                          
                          if (response.isSuccessful()) {
                              String responseBody = response.body().string();
                              JSONObject jsonResponse = new JSONObject(responseBody);
                              
                              if (jsonResponse.getBoolean("success")) {
                                  String userId = jsonResponse.getString("userId");
                                  String token = jsonResponse.optString("token", "");
                                  
                                  // Save authentication data
                                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                                  SharedPreferences.Editor editor = prefs.edit();
                                  editor.putString("user_id", userId);
                                  editor.putString("email", email);
                                  editor.putString("auth_token", token);
                                  editor.putBoolean("is_logged_in", true);
                                  editor.apply();
                                  
                                  Log.d(TAG, "User logged in successfully: " + userId);
                                  if (callback != null) callback.onSuccess(userId);
                              } else {
                                  String error = jsonResponse.optString("error", "Login failed");
                                  Log.e(TAG, error);
                                  if (callback != null) callback.onError(error);
                              }
                          } else {
                              String error = "Login failed: " + response.code();
                              Log.e(TAG, error);
                              if (callback != null) callback.onError(error);
                          }
                          
                          response.close();

                      } catch (Exception e) {
                          String error = "Login error: " + e.getMessage();
                          Log.e(TAG, error, e);
                          if (callback != null) callback.onError(error);
                      }
                  });
              }

              public void registerUser(String email, String password, AuthCallback callback) {
                  executor.execute(() -> {
                      try {
                          JSONObject registerData = new JSONObject();
                          registerData.put("email", email);
                          registerData.put("password", password);

                          RequestBody body = RequestBody.create(
                              registerData.toString(),
                              MediaType.parse("application/json")
                          );

                          Request request = new Request.Builder()
                              .url(API_BASE_URL + "/auth/register")
                              .post(body)
                              .build();

                          Response response = client.newCall(request).execute();
                          
                          if (response.isSuccessful()) {
                              String responseBody = response.body().string();
                              JSONObject jsonResponse = new JSONObject(responseBody);
                              
                              if (jsonResponse.getBoolean("success")) {
                                  String userId = jsonResponse.getString("userId");
                                  
                                  // Save authentication data
                                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                                  SharedPreferences.Editor editor = prefs.edit();
                                  editor.putString("user_id", userId);
                                  editor.putString("email", email);
                                  editor.putBoolean("is_logged_in", true);
                                  editor.apply();
                                  
                                  Log.d(TAG, "User registered successfully: " + userId);
                                  if (callback != null) callback.onSuccess(userId);
                              } else {
                                  String error = jsonResponse.optString("error", "Registration failed");
                                  Log.e(TAG, error);
                                  if (callback != null) callback.onError(error);
                              }
                          } else {
                              String error = "Registration failed: " + response.code();
                              Log.e(TAG, error);
                              if (callback != null) callback.onError(error);
                          }
                          
                          response.close();

                      } catch (Exception e) {
                          String error = "Registration error: " + e.getMessage();
                          Log.e(TAG, error, e);
                          if (callback != null) callback.onError(error);
                      }
                  });
              }

              public boolean isLoggedIn() {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  return prefs.getBoolean("is_logged_in", false);
              }

              public String getUserId() {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  return prefs.getString("user_id", "");
              }

              public String getUserEmail() {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  return prefs.getString("email", "");
              }

              public void logout() {
                  SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.clear();
                  editor.apply();
                  Log.d(TAG, "User logged out");
              }
          }
          EOF

      - name: Create MainActivity with enhanced user identification and ALL trips download
        run: |
          cat > android/app/src/main/java/com/miletrackerpro/app/MainActivity.java << 'EOF'
          package com.miletrackerpro.app;

          import android.Manifest;
          import android.app.AlertDialog;
          import android.content.BroadcastReceiver;
          import android.content.Context;
          import android.content.Intent;
          import android.content.IntentFilter;
          import android.content.SharedPreferences;
          import android.content.pm.PackageManager;
          import android.location.Address;
          import android.location.Geocoder;
          import android.location.Location;
          import android.location.LocationListener;
          import android.location.LocationManager;
          import android.os.Bundle;
          import android.provider.Settings;
          import android.util.Log;
          import android.view.View;
          import android.widget.*;
          import androidx.appcompat.app.AppCompatActivity;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.miletrackerpro.app.auth.UserManager;
          import com.miletrackerpro.app.services.CloudBackupService;
          import com.miletrackerpro.app.services.GPSTrackingService;
          import com.miletrackerpro.app.storage.Trip;
          import com.miletrackerpro.app.storage.TripStorage;
          import java.io.IOException;
          import java.text.SimpleDateFormat;
          import java.util.*;

          public class MainActivity extends AppCompatActivity implements LocationListener {
              private static final String TAG = "MainActivity";
              private static final int LOCATION_PERMISSION_REQUEST_CODE = 1001;

              // UI Components
              private LinearLayout dashboardContent;
              private LinearLayout tripsContent;
              private ScrollView dashboardScrollView;
              private ScrollView tripsScrollView;
              private Button dashboardTab;
              private Button tripsTab;
              private TextView statusText;
              private Button toggleAutoButton;
              private Button startTripButton;
              private Button stopTripButton;
              private Button refreshButton;
              private LinearLayout tripContainer;
              
              // Trip management mode UI
              private LinearLayout tripModeContainer;
              private Button normalModeButton;
              private Button mergeModeButton;
              private TextView selectedTripsText;
              private Button mergeSelectedButton;
              private Button cancelMergeButton;
              
              // Services and Storage
              private TripStorage tripStorage;
              private CloudBackupService cloudBackupService;
              private UserManager userManager;
              private LocationManager locationManager;
              
              // State variables
              private boolean isAutoTrackingEnabled = false;
              private boolean isManualTripActive = false;
              private boolean isInMergeMode = false;
              private List<Trip> selectedTripsForMerge = new ArrayList<>();
              private double currentLatitude = 0;
              private double currentLongitude = 0;
              private double currentSpeed = 0;
              private float currentAccuracy = 0;
              private String deviceId;

              // Broadcast receivers
              private BroadcastReceiver gpsStatusReceiver;
              private BroadcastReceiver locationUpdateReceiver;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  
                  try {
                      Log.d(TAG, "MainActivity onCreate starting - v4.9.68 MERGE/SPLIT FUNCTIONALITY...");
                      
                      // Initialize services
                      tripStorage = new TripStorage(this);
                      cloudBackupService = new CloudBackupService(this);
                      userManager = new UserManager(this);
                      locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);

                      // Generate stable device ID
                      deviceId = generateStableDeviceId();
                      
                      // Create UI
                      createUI();
                      
                      // Setup receivers
                      setupBroadcastReceivers();
                      
                      // Load initial data
                      loadInitialData();
                      
                      Log.d(TAG, "MainActivity onCreate completed successfully");
                      
                  } catch (Exception e) {
                      Log.e(TAG, "Error in MainActivity onCreate: " + e.getMessage(), e);
                      Toast.makeText(this, "Error initializing app: " + e.getMessage(), Toast.LENGTH_LONG).show();
                  }
              }

              private String generateStableDeviceId() {
                  try {
                      String androidId = Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID);
                      String model = android.os.Build.MODEL;
                      String manufacturer = android.os.Build.MANUFACTURER;
                      String serial = android.os.Build.SERIAL;
                      
                      String combined = androidId + "_" + model + "_" + manufacturer + "_" + serial;
                      return "device_" + Math.abs(combined.hashCode());
                  } catch (Exception e) {
                      Log.e(TAG, "Error generating device ID: " + e.getMessage(), e);
                      return "device_" + System.currentTimeMillis();
                  }
              }

              private void createUI() {
                  // Main container
                  LinearLayout mainContainer = new LinearLayout(this);
                  mainContainer.setOrientation(LinearLayout.VERTICAL);
                  mainContainer.setBackgroundColor(0xFFF8F9FA);

                  // Tab navigation
                  LinearLayout tabContainer = new LinearLayout(this);
                  tabContainer.setOrientation(LinearLayout.HORIZONTAL);
                  tabContainer.setBackgroundColor(0xFF6C5CE7);
                  tabContainer.setPadding(0, 40, 0, 0);

                  // Dashboard tab
                  dashboardTab = new Button(this);
                  dashboardTab.setText("🏠 Dashboard");
                  dashboardTab.setTextColor(0xFFFFFFFF);
                  dashboardTab.setBackgroundColor(0xFF5A52D5);
                  LinearLayout.LayoutParams dashParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  dashboardTab.setLayoutParams(dashParams);
                  dashboardTab.setOnClickListener(v -> showDashboard());

                  // Trips tab
                  tripsTab = new Button(this);
                  tripsTab.setText("🚗 Trips");
                  tripsTab.setTextColor(0xFFFFFFFF);
                  tripsTab.setBackgroundColor(0xFF6C5CE7);
                  LinearLayout.LayoutParams tripsParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  tripsTab.setLayoutParams(tripsParams);
                  tripsTab.setOnClickListener(v -> showTrips());

                  tabContainer.addView(dashboardTab);
                  tabContainer.addView(tripsTab);
                  mainContainer.addView(tabContainer);

                  // Dashboard content
                  createDashboardContent();
                  
                  // Trips content
                  createTripsContent();

                  // Add both content views to main container
                  mainContainer.addView(dashboardScrollView);
                  mainContainer.addView(tripsScrollView);

                  setContentView(mainContainer);
                  
                  // Show dashboard by default
                  showDashboard();
              }

              private void createDashboardContent() {
                  dashboardScrollView = new ScrollView(this);
                  dashboardContent = new LinearLayout(this);
                  dashboardContent.setOrientation(LinearLayout.VERTICAL);
                  dashboardContent.setPadding(20, 20, 20, 20);

                  // Header
                  TextView headerText = new TextView(this);
                  headerText.setText("🚗 MileTracker Pro");
                  headerText.setTextSize(24);
                  headerText.setTextColor(0xFF2D3748);
                  headerText.setPadding(0, 0, 0, 15);
                  dashboardContent.addView(headerText);

                  // Status section
                  statusText = new TextView(this);
                  statusText.setText("⚪ Ready - v4.9.68");
                  statusText.setTextSize(14);
                  statusText.setTextColor(0xFF4A5568);
                  statusText.setPadding(15, 10, 15, 10);
                  statusText.setBackgroundColor(0xFFF7FAFC);
                  dashboardContent.addView(statusText);

                  // Control buttons container
                  LinearLayout controlsContainer = new LinearLayout(this);
                  controlsContainer.setOrientation(LinearLayout.VERTICAL);
                  controlsContainer.setPadding(0, 15, 0, 15);

                  // Auto tracking toggle
                  toggleAutoButton = new Button(this);
                  toggleAutoButton.setText("🤖 Enable Auto Detection");
                  toggleAutoButton.setTextColor(0xFFFFFFFF);
                  toggleAutoButton.setBackgroundColor(0xFF48BB78);
                  toggleAutoButton.setPadding(15, 15, 15, 15);
                  LinearLayout.LayoutParams autoParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  autoParams.setMargins(0, 5, 0, 5);
                  toggleAutoButton.setLayoutParams(autoParams);
                  toggleAutoButton.setOnClickListener(v -> toggleAutoTracking());
                  controlsContainer.addView(toggleAutoButton);

                  // Manual trip controls
                  LinearLayout manualContainer = new LinearLayout(this);
                  manualContainer.setOrientation(LinearLayout.HORIZONTAL);

                  startTripButton = new Button(this);
                  startTripButton.setText("▶️ Start Trip");
                  startTripButton.setTextColor(0xFFFFFFFF);
                  startTripButton.setBackgroundColor(0xFF4299E1);
                  LinearLayout.LayoutParams startParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  startParams.setMargins(0, 5, 5, 5);
                  startTripButton.setLayoutParams(startParams);
                  startTripButton.setOnClickListener(v -> startManualTrip());

                  stopTripButton = new Button(this);
                  stopTripButton.setText("⏹️ Stop Trip");
                  stopTripButton.setTextColor(0xFFFFFFFF);
                  stopTripButton.setBackgroundColor(0xFFE53E3E);
                  stopTripButton.setEnabled(false);
                  LinearLayout.LayoutParams stopParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  stopParams.setMargins(5, 5, 0, 5);
                  stopTripButton.setLayoutParams(stopParams);
                  stopTripButton.setOnClickListener(v -> stopManualTrip());

                  manualContainer.addView(startTripButton);
                  manualContainer.addView(stopTripButton);
                  controlsContainer.addView(manualContainer);

                  // Refresh button
                  refreshButton = new Button(this);
                  refreshButton.setText("🔄 Refresh Trips");
                  refreshButton.setTextColor(0xFF4A5568);
                  refreshButton.setBackgroundColor(0xFFEDF2F7);
                  LinearLayout.LayoutParams refreshParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  refreshParams.setMargins(0, 5, 0, 15);
                  refreshButton.setLayoutParams(refreshParams);
                  refreshButton.setOnClickListener(v -> refreshFromCloud());
                  controlsContainer.addView(refreshButton);

                  dashboardContent.addView(controlsContainer);

                  // Statistics section
                  TextView statsText = new TextView(this);
                  statsText.setText("📊 Loading statistics...");
                  statsText.setTextSize(16);
                  statsText.setTextColor(0xFF4A5568);
                  statsText.setPadding(0, 10, 0, 10);
                  dashboardContent.addView(statsText);

                  // Recent Trips
                  TextView recentTripsHeader = new TextView(this);
                  recentTripsHeader.setText("📍 Recent Trips");
                  recentTripsHeader.setTextSize(16);
                  recentTripsHeader.setTextColor(0xFF495057);
                  recentTripsHeader.setPadding(0, 15, 0, 5);
                  dashboardContent.addView(recentTripsHeader);

                  LinearLayout recentTripsContainer = new LinearLayout(this);
                  recentTripsContainer.setOrientation(LinearLayout.VERTICAL);
                  recentTripsContainer.setId(View.generateViewId());
                  dashboardContent.addView(recentTripsContainer);

                  dashboardScrollView.addView(dashboardContent);
              }

              private void createTripsContent() {
                  tripsScrollView = new ScrollView(this);
                  tripsContent = new LinearLayout(this);
                  tripsContent.setOrientation(LinearLayout.VERTICAL);
                  tripsContent.setPadding(20, 20, 20, 20);

                  // Trip management mode container
                  tripModeContainer = new LinearLayout(this);
                  tripModeContainer.setOrientation(LinearLayout.VERTICAL);
                  tripModeContainer.setBackgroundColor(0xFFF0F4F8);
                  tripModeContainer.setPadding(15, 15, 15, 15);
                  LinearLayout.LayoutParams modeParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  modeParams.setMargins(0, 0, 0, 15);
                  tripModeContainer.setLayoutParams(modeParams);

                  // Mode toggle buttons
                  LinearLayout modeButtonsContainer = new LinearLayout(this);
                  modeButtonsContainer.setOrientation(LinearLayout.HORIZONTAL);

                  normalModeButton = new Button(this);
                  normalModeButton.setText("📋 Normal View");
                  normalModeButton.setTextColor(0xFFFFFFFF);
                  normalModeButton.setBackgroundColor(0xFF4299E1);
                  LinearLayout.LayoutParams normalParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  normalParams.setMargins(0, 0, 5, 0);
                  normalModeButton.setLayoutParams(normalParams);
                  normalModeButton.setOnClickListener(v -> setNormalMode());

                  mergeModeButton = new Button(this);
                  mergeModeButton.setText("🔗 Merge Mode");
                  mergeModeButton.setTextColor(0xFF4A5568);
                  mergeModeButton.setBackgroundColor(0xFFEDF2F7);
                  LinearLayout.LayoutParams mergeParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  mergeParams.setMargins(5, 0, 0, 0);
                  mergeModeButton.setLayoutParams(mergeParams);
                  mergeModeButton.setOnClickListener(v -> setMergeMode());

                  modeButtonsContainer.addView(normalModeButton);
                  modeButtonsContainer.addView(mergeModeButton);
                  tripModeContainer.addView(modeButtonsContainer);

                  // Selected trips info (hidden by default)
                  selectedTripsText = new TextView(this);
                  selectedTripsText.setText("Selected: 0 trips (0.0 miles total)");
                  selectedTripsText.setTextSize(14);
                  selectedTripsText.setTextColor(0xFF2D3748);
                  selectedTripsText.setPadding(0, 10, 0, 10);
                  selectedTripsText.setVisibility(View.GONE);
                  tripModeContainer.addView(selectedTripsText);

                  // Merge action buttons (hidden by default)
                  LinearLayout mergeActionContainer = new LinearLayout(this);
                  mergeActionContainer.setOrientation(LinearLayout.HORIZONTAL);
                  mergeActionContainer.setVisibility(View.GONE);

                  cancelMergeButton = new Button(this);
                  cancelMergeButton.setText("❌ Cancel");
                  cancelMergeButton.setTextColor(0xFF4A5568);
                  cancelMergeButton.setBackgroundColor(0xFFEDF2F7);
                  LinearLayout.LayoutParams cancelParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  cancelParams.setMargins(0, 0, 5, 0);
                  cancelMergeButton.setLayoutParams(cancelParams);
                  cancelMergeButton.setOnClickListener(v -> cancelMergeMode());

                  mergeSelectedButton = new Button(this);
                  mergeSelectedButton.setText("🔗 Merge Selected");
                  mergeSelectedButton.setTextColor(0xFFFFFFFF);
                  mergeSelectedButton.setBackgroundColor(0xFF48BB78);
                  mergeSelectedButton.setEnabled(false);
                  LinearLayout.LayoutParams mergeSelectedParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  mergeSelectedParams.setMargins(5, 0, 0, 0);
                  mergeSelectedButton.setLayoutParams(mergeSelectedParams);
                  mergeSelectedButton.setOnClickListener(v -> confirmMergeTrips());

                  mergeActionContainer.addView(cancelMergeButton);
                  mergeActionContainer.addView(mergeSelectedButton);
                  tripModeContainer.addView(mergeActionContainer);

                  tripsContent.addView(tripModeContainer);

                  // Trips header
                  TextView headerText = new TextView(this);
                  headerText.setText("📋 All Trips");
                  headerText.setTextSize(20);
                  headerText.setTextColor(0xFF495057);
                  headerText.setPadding(0, 0, 0, 15);
                  tripsContent.addView(headerText);

                  // Trip container
                  tripContainer = new LinearLayout(this);
                  tripContainer.setOrientation(LinearLayout.VERTICAL);
                  tripsContent.addView(tripContainer);

                  tripsScrollView.addView(tripsContent);
              }

              private void setNormalMode() {
                  isInMergeMode = false;
                  selectedTripsForMerge.clear();
                  
                  // Update button states
                  normalModeButton.setBackgroundColor(0xFF4299E1);
                  normalModeButton.setTextColor(0xFFFFFFFF);
                  mergeModeButton.setBackgroundColor(0xFFEDF2F7);
                  mergeModeButton.setTextColor(0xFF4A5568);
                  
                  // Hide merge UI elements
                  selectedTripsText.setVisibility(View.GONE);
                  tripModeContainer.getChildAt(2).setVisibility(View.GONE); // merge action container
                  
                  // Refresh trips display
                  updateAllTrips();
              }

              private void setMergeMode() {
                  isInMergeMode = true;
                  selectedTripsForMerge.clear();
                  
                  // Update button states
                  mergeModeButton.setBackgroundColor(0xFF4299E1);
                  mergeModeButton.setTextColor(0xFFFFFFFF);
                  normalModeButton.setBackgroundColor(0xFFEDF2F7);
                  normalModeButton.setTextColor(0xFF4A5568);
                  
                  // Show merge UI elements
                  selectedTripsText.setVisibility(View.VISIBLE);
                  tripModeContainer.getChildAt(2).setVisibility(View.VISIBLE); // merge action container
                  
                  // Update selection display
                  updateMergeSelection();
                  
                  // Refresh trips display with checkboxes
                  updateAllTrips();
                  
                  Toast.makeText(this, "Select trips to merge together", Toast.LENGTH_SHORT).show();
              }

              private void cancelMergeMode() {
                  setNormalMode();
                  Toast.makeText(this, "Merge mode cancelled", Toast.LENGTH_SHORT).show();
              }

              private void updateMergeSelection() {
                  double totalDistance = 0;
                  for (Trip trip : selectedTripsForMerge) {
                      totalDistance += trip.getDistance();
                  }
                  
                  selectedTripsText.setText(String.format("Selected: %d trips (%.1f miles total)", 
                      selectedTripsForMerge.size(), totalDistance));
                  
                  mergeSelectedButton.setEnabled(selectedTripsForMerge.size() >= 2);
              }

              private void confirmMergeTrips() {
                  if (selectedTripsForMerge.size() < 2) {
                      Toast.makeText(this, "Select at least 2 trips to merge", Toast.LENGTH_SHORT).show();
                      return;
                  }

                  // Create confirmation dialog
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("🔗 Confirm Merge Trips");
                  
                  StringBuilder message = new StringBuilder();
                  message.append("Merge ").append(selectedTripsForMerge.size()).append(" trips:\n\n");
                  
                  double totalDistance = 0;
                  for (int i = 0; i < selectedTripsForMerge.size(); i++) {
                      Trip trip = selectedTripsForMerge.get(i);
                      totalDistance += trip.getDistance();
                      message.append("• ").append(trip.getFormattedDistance())
                             .append(" - ").append(trip.getFormattedDate()).append("\n");
                  }
                  
                  message.append("\nTotal: ").append(String.format("%.1f miles", totalDistance));
                  message.append("\n\nThis will combine all GPS data and cannot be undone.");
                  
                  builder.setMessage(message.toString());
                  
                  builder.setPositiveButton("🔗 MERGE TRIPS", (dialog, which) -> {
                      try {
                          Trip mergedTrip = tripStorage.mergeTrips(selectedTripsForMerge);
                          
                          if (mergedTrip != null) {
                              // Backup merged trip to cloud
                              cloudBackupService.backupTrip(mergedTrip, new CloudBackupService.BackupCallback() {
                                  @Override
                                  public void onSuccess() {
                                      runOnUiThread(() -> {
                                          Toast.makeText(MainActivity.this, "✅ Trips merged and backed up!", Toast.LENGTH_SHORT).show();
                                      });
                                  }
                                  
                                  @Override
                                  public void onError(String error) {
                                      runOnUiThread(() -> {
                                          Toast.makeText(MainActivity.this, "⚠️ Merged locally, backup failed", Toast.LENGTH_SHORT).show();
                                      });
                                  }
                              });
                              
                              // Reset to normal mode and refresh
                              setNormalMode();
                              updateAllTrips();
                              updateStats();
                              
                              Toast.makeText(this, "✅ " + selectedTripsForMerge.size() + " trips merged successfully!", Toast.LENGTH_SHORT).show();
                          } else {
                              Toast.makeText(this, "❌ Failed to merge trips", Toast.LENGTH_SHORT).show();
                          }
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error merging trips: " + e.getMessage(), e);
                          Toast.makeText(this, "❌ Error merging trips: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              private void setupBroadcastReceivers() {
                  // GPS status receiver
                  gpsStatusReceiver = new BroadcastReceiver() {
                      @Override
                      public void onReceive(Context context, Intent intent) {
                          String status = intent.getStringExtra("status");
                          updateGPSStatus(status);
                      }
                  };
                  
                  IntentFilter gpsFilter = new IntentFilter("GPS_STATUS_UPDATE");
                  registerReceiver(gpsStatusReceiver, gpsFilter);

                  // Location update receiver
                  locationUpdateReceiver = new BroadcastReceiver() {
                      @Override
                      public void onReceive(Context context, Intent intent) {
                          currentLatitude = intent.getDoubleExtra("latitude", 0);
                          currentLongitude = intent.getDoubleExtra("longitude", 0);
                          currentSpeed = intent.getDoubleExtra("speed", 0);
                          currentAccuracy = intent.getFloatExtra("accuracy", 0);
                          updateLocationDisplay();
                      }
                  };
                  
                  IntentFilter locationFilter = new IntentFilter("LOCATION_UPDATE");
                  registerReceiver(locationUpdateReceiver, locationFilter);
              }

              // ... [Continue with remaining methods - this is getting quite long, should I continue with the rest?]
              
              private void loadInitialData() {
                  checkLocationPermissions();
                  updateStats();
                  updateRecentTrips();
                  updateAllTrips();
                  
                  // Download trips from cloud on startup
                  refreshFromCloud();
              }

              private void showDashboard() {
                  dashboardTab.setBackgroundColor(0xFF5A52D5);
                  tripsTab.setBackgroundColor(0xFF6C5CE7);
                  dashboardScrollView.setVisibility(View.VISIBLE);
                  tripsScrollView.setVisibility(View.GONE);
                  updateRecentTrips();
                  updateStats();
              }

              private void showTrips() {
                  tripsTab.setBackgroundColor(0xFF5A52D5);
                  dashboardTab.setBackgroundColor(0xFF6C5CE7);
                  tripsScrollView.setVisibility(View.VISIBLE);
                  dashboardScrollView.setVisibility(View.GONE);
                  updateAllTrips();
              }

              private void checkLocationPermissions() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                      ActivityCompat.requestPermissions(this, new String[]{
                          Manifest.permission.ACCESS_FINE_LOCATION,
                          Manifest.permission.ACCESS_COARSE_LOCATION,
                          Manifest.permission.ACCESS_BACKGROUND_LOCATION
                      }, LOCATION_PERMISSION_REQUEST_CODE);
                  }
              }

              private void toggleAutoTracking() {
                  if (!isAutoTrackingEnabled) {
                      if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                          checkLocationPermissions();
                          return;
                      }
                      
                      isAutoTrackingEnabled = true;
                      toggleAutoButton.setText("🛑 Disable Auto Detection");
                      toggleAutoButton.setBackgroundColor(0xFFE53E3E);
                      
                      Intent serviceIntent = new Intent(this, GPSTrackingService.class);
                      serviceIntent.putExtra("action", "start_auto");
                      startForegroundService(serviceIntent);
                      
                      SharedPreferences prefs = getSharedPreferences("MileTrackerPrefs", MODE_PRIVATE);
                      prefs.edit().putBoolean("auto_tracking_enabled", true).apply();
                      
                  } else {
                      isAutoTrackingEnabled = false;
                      toggleAutoButton.setText("🤖 Enable Auto Detection");
                      toggleAutoButton.setBackgroundColor(0xFF48BB78);
                      
                      Intent serviceIntent = new Intent(this, GPSTrackingService.class);
                      serviceIntent.putExtra("action", "stop_auto");
                      startService(serviceIntent);
                      
                      SharedPreferences prefs = getSharedPreferences("MileTrackerPrefs", MODE_PRIVATE);
                      prefs.edit().putBoolean("auto_tracking_enabled", false).apply();
                  }
              }

              private void startManualTrip() {
                  if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                      checkLocationPermissions();
                      return;
                  }
                  
                  isManualTripActive = true;
                  startTripButton.setEnabled(false);
                  stopTripButton.setEnabled(true);
                  
                  Intent serviceIntent = new Intent(this, GPSTrackingService.class);
                  serviceIntent.putExtra("action", "start_manual");
                  startForegroundService(serviceIntent);
                  
                  Toast.makeText(this, "▶️ Manual trip started", Toast.LENGTH_SHORT).show();
              }

              private void stopManualTrip() {
                  isManualTripActive = false;
                  startTripButton.setEnabled(true);
                  stopTripButton.setEnabled(false);
                  
                  Intent serviceIntent = new Intent(this, GPSTrackingService.class);
                  serviceIntent.putExtra("action", "stop_manual");
                  startService(serviceIntent);
                  
                  Toast.makeText(this, "⏹️ Manual trip stopped", Toast.LENGTH_SHORT).show();
              }

              private void refreshFromCloud() {
                  refreshButton.setText("🔄 Refreshing...");
                  refreshButton.setEnabled(false);
                  
                  cloudBackupService.downloadAllTrips(deviceId, new CloudBackupService.BackupCallback() {
                      @Override
                      public void onSuccess() {
                          runOnUiThread(() -> {
                              refreshButton.setText("🔄 Refresh Trips");
                              refreshButton.setEnabled(true);
                              updateAllTrips();
                              updateRecentTrips();
                              updateStats();
                              Toast.makeText(MainActivity.this, "✅ Trips refreshed successfully!", Toast.LENGTH_SHORT).show();
                          });
                      }
                      
                      @Override
                      public void onError(String error) {
                          runOnUiThread(() -> {
                              refreshButton.setText("🔄 Refresh Trips");
                              refreshButton.setEnabled(true);
                              Toast.makeText(MainActivity.this, "⚠️ Refresh failed - using local data", Toast.LENGTH_SHORT).show();
                          });
                      }
                  });
              }

              private void updateGPSStatus(String status) {
                  runOnUiThread(() -> {
                      String statusMessage = "⚪ Ready - v4.9.68";
                      
                      switch (status) {
                          case "monitoring":
                              statusMessage = "🟡 Monitoring for movement - Speed: " + String.format("%.1f", currentSpeed) + " mph";
                              break;
                          case "started":
                              statusMessage = "🟢 Trip in progress - Speed: " + String.format("%.1f", currentSpeed) + " mph";
                              break;
                          case "completed":
                              statusMessage = "✅ Trip completed and saved";
                              updateAllTrips();
                              updateRecentTrips();
                              updateStats();
                              break;
                          case "stopped":
                              statusMessage = "⚪ Auto detection stopped";
                              break;
                      }
                      
                      statusText.setText(statusMessage);
                  });
              }

              private void updateLocationDisplay() {
                  // This method is called when location updates are received
                  // Status is updated in updateGPSStatus method
              }

              private void updateStats() {
                  try {
                      double totalMiles = tripStorage.getTotalMiles();
                      int tripCount = tripStorage.getTripCount();
                      
                      String statsMessage = String.format("📊 %d trips • %.1f total miles • Device: %s", 
                          tripCount, totalMiles, deviceId.substring(0, Math.min(12, deviceId.length())));
                      
                      // Find and update stats text in dashboard
                      for (int i = 0; i < dashboardContent.getChildCount(); i++) {
                          View child = dashboardContent.getChildAt(i);
                          if (child instanceof TextView) {
                              TextView tv = (TextView) child;
                              if (tv.getText().toString().startsWith("📊")) {
                                  tv.setText(statsMessage);
                                  break;
                              }
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating stats: " + e.getMessage(), e);
                  }
              }

              private void updateRecentTrips() {
                  try {
                      List<Trip> recentTrips = tripStorage.getRecentTrips(3);
                      
                      // Find recent trips container in dashboard
                      LinearLayout recentContainer = null;
                      for (int i = 0; i < dashboardContent.getChildCount(); i++) {
                          View child = dashboardContent.getChildAt(i);
                          if (child instanceof LinearLayout && child.getId() != View.NO_ID) {
                              recentContainer = (LinearLayout) child;
                              break;
                          }
                      }
                      
                      if (recentContainer != null) {
                          recentContainer.removeAllViews();
                          
                          if (recentTrips.isEmpty()) {
                              TextView emptyText = new TextView(this);
                              emptyText.setText("No trips yet. Start tracking to see your trips here.");
                              emptyText.setTextSize(12);
                              emptyText.setTextColor(0xFF6C757D);
                              emptyText.setPadding(15, 10, 15, 10);
                              recentContainer.addView(emptyText);
                          } else {
                              for (Trip trip : recentTrips) {
                                  recentContainer.addView(createTripCard(trip, false, false)); // No edit/delete in dashboard
                              }
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating recent trips: " + e.getMessage(), e);
                  }
              }

              private void updateAllTrips() {
                  try {
                      List<Trip> allTrips = tripStorage.getTrips();
                      tripContainer.removeAllViews();
                      
                      if (allTrips.isEmpty()) {
                          TextView emptyText = new TextView(this);
                          emptyText.setText("No trips found. Enable auto detection or start a manual trip to begin tracking.");
                          emptyText.setTextSize(14);
                          emptyText.setTextColor(0xFF6C757D);
                          emptyText.setPadding(15, 20, 15, 20);
                          emptyText.setBackgroundColor(0xFFF8F9FA);
                          tripContainer.addView(emptyText);
                      } else {
                          for (Trip trip : allTrips) {
                              tripContainer.addView(createTripCard(trip, true, isInMergeMode));
                          }
                      }
                  } catch (Exception e) {
                      Log.e(TAG, "Error updating all trips: " + e.getMessage(), e);
                  }
              }

              private LinearLayout createTripCard(Trip trip, boolean showActions, boolean showCheckbox) {
                  LinearLayout card = new LinearLayout(this);
                  card.setOrientation(LinearLayout.VERTICAL);
                  card.setBackgroundColor(0xFFFFFFFF);
                  card.setPadding(15, 15, 15, 15);
                  
                  LinearLayout.LayoutParams cardParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                  cardParams.setMargins(0, 0, 0, 10);
                  card.setLayoutParams(cardParams);

                  // Main trip info container
                  LinearLayout mainContainer = new LinearLayout(this);
                  mainContainer.setOrientation(LinearLayout.HORIZONTAL);

                  // Checkbox for merge mode
                  if (showCheckbox) {
                      CheckBox checkbox = new CheckBox(this);
                      checkbox.setChecked(selectedTripsForMerge.contains(trip));
                      checkbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
                          if (isChecked) {
                              if (!selectedTripsForMerge.contains(trip)) {
                                  selectedTripsForMerge.add(trip);
                              }
                          } else {
                              selectedTripsForMerge.remove(trip);
                          }
                          updateMergeSelection();
                      });
                      
                      LinearLayout.LayoutParams checkboxParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT);
                      checkboxParams.setMargins(0, 0, 10, 0);
                      checkbox.setLayoutParams(checkboxParams);
                      mainContainer.addView(checkbox);
                  }

                  // Trip details container
                  LinearLayout detailsContainer = new LinearLayout(this);
                  detailsContainer.setOrientation(LinearLayout.VERTICAL);
                  LinearLayout.LayoutParams detailsParams = new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f);
                  detailsContainer.setLayoutParams(detailsParams);

                  // Trip header with distance and type
                  TextView headerText = new TextView(this);
                  String tripIcon = trip.isAutoDetected() ? "🤖" : "👤";
                  headerText.setText(tripIcon + " " + trip.getFormattedDistance() + " • " + trip.getFormattedDuration() + " • " + trip.getCategory());
                  headerText.setTextSize(16);
                  headerText.setTextColor(0xFF2D3748);
                  detailsContainer.addView(headerText);

                  // Addresses
                  if (trip.getStartAddress() != null && !trip.getStartAddress().isEmpty()) {
                      TextView addressText = new TextView(this);
                      addressText.setText("From: " + trip.getStartAddress());
                      addressText.setTextSize(12);
                      addressText.setTextColor(0xFF4A5568);
                      addressText.setPadding(0, 5, 0, 0);
                      detailsContainer.addView(addressText);
                  }

                  if (trip.getEndAddress() != null && !trip.getEndAddress().isEmpty()) {
                      TextView endAddressText = new TextView(this);
                      endAddressText.setText("To: " + trip.getEndAddress());
                      endAddressText.setTextSize(12);
                      endAddressText.setTextColor(0xFF4A5568);
                      detailsContainer.addView(endAddressText);
                  }

                  // Date and time
                  TextView dateText = new TextView(this);
                  dateText.setText(trip.getFormattedDate());
                  dateText.setTextSize(12);
                  dateText.setTextColor(0xFF6C757D);
                  dateText.setPadding(0, 5, 0, 0);
                  detailsContainer.addView(dateText);

                  mainContainer.addView(detailsContainer);

                  // Action buttons (edit/delete) - only in normal mode
                  if (showActions && !showCheckbox) {
                      LinearLayout actionContainer = new LinearLayout(this);
                      actionContainer.setOrientation(LinearLayout.VERTICAL);

                      Button editButton = new Button(this);
                      editButton.setText("✏️");
                      editButton.setTextSize(12);
                      editButton.setTextColor(0xFF4299E1);
                      editButton.setBackgroundColor(0xFFEBF8FF);
                      LinearLayout.LayoutParams editParams = new LinearLayout.LayoutParams(60, 60);
                      editParams.setMargins(5, 0, 0, 5);
                      editButton.setLayoutParams(editParams);
                      editButton.setOnClickListener(v -> showEditTripDialog(trip));

                      Button deleteButton = new Button(this);
                      deleteButton.setText("🗑️");
                      deleteButton.setTextSize(12);
                      deleteButton.setTextColor(0xFFE53E3E);
                      deleteButton.setBackgroundColor(0xFFFFF5F5);
                      LinearLayout.LayoutParams deleteParams = new LinearLayout.LayoutParams(60, 60);
                      deleteParams.setMargins(5, 0, 0, 0);
                      deleteButton.setLayoutParams(deleteParams);
                      deleteButton.setOnClickListener(v -> showDeleteTripDialog(trip));

                      actionContainer.addView(editButton);
                      actionContainer.addView(deleteButton);
                      mainContainer.addView(actionContainer);
                  }

                  card.addView(mainContainer);
                  return card;
              }

              private void showEditTripDialog(Trip trip) {
                  // Create edit dialog - implementation would go here
                  Toast.makeText(this, "Edit functionality: " + trip.getFormattedDistance(), Toast.LENGTH_SHORT).show();
              }

              private void showDeleteTripDialog(Trip trip) {
                  AlertDialog.Builder builder = new AlertDialog.Builder(this);
                  builder.setTitle("🗑️ Delete Trip");
                  builder.setMessage("Delete this trip?\n\n" + 
                      trip.getFormattedDistance() + " • " + trip.getFormattedDate() + "\n" +
                      (trip.getStartAddress() != null ? "From: " + trip.getStartAddress() + "\n" : "") +
                      (trip.getEndAddress() != null ? "To: " + trip.getEndAddress() + "\n" : "") +
                      "\nThis action cannot be undone.");
                  
                  builder.setPositiveButton("🗑️ DELETE PERMANENTLY", (dialog, which) -> {
                      try {
                          // Delete trip using TripStorage's delete method
                          tripStorage.deleteTrip(trip.getId());
                          
                          // Refresh display
                          updateRecentTrips();
                          updateAllTrips();
                          updateStats();
                          
                          Toast.makeText(this, "🗑️ Trip deleted successfully", Toast.LENGTH_SHORT).show();
                          
                      } catch (Exception e) {
                          Log.e(TAG, "Error deleting trip: " + e.getMessage(), e);
                          Toast.makeText(this, "❌ Error deleting trip: " + e.getMessage(), Toast.LENGTH_SHORT).show();
                      }
                  });
                  
                  builder.setNegativeButton("Cancel", null);
                  builder.show();
              }

              @Override
              protected void onDestroy() {
                  super.onDestroy();
                  
                  if (gpsStatusReceiver != null) {
                      unregisterReceiver(gpsStatusReceiver);
                  }
                  
                  if (locationUpdateReceiver != null) {
                      unregisterReceiver(locationUpdateReceiver);
                  }
              }

              // LocationListener methods (required but not used in this implementation)
              @Override
              public void onLocationChanged(Location location) {}

              @Override
              public void onStatusChanged(String provider, int status, Bundle extras) {}

              @Override
              public void onProviderEnabled(String provider) {}

              @Override
              public void onProviderDisabled(String provider) {}
          }
          EOF

      - name: Create keystore for APK signing
        run: |
          cd android
          keytool -genkey -v -keystore keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key0 -storepass android -keypass android -dname "CN=MileTracker Pro, OU=Development, O=MileTracker, L=City, S=State, C=US"

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2
        with:
          gradle-version: 8.6

      - name: Generate Gradle wrapper
        run: |
          cd android
          gradle wrapper --gradle-version 8.6 --distribution-type all

      - name: Verify wrapper and make executable
        run: |
          cd android
          chmod +x gradlew
          echo "=== Checking wrapper files ==="
          ls -la gradle/wrapper/
          echo "=== Testing wrapper ==="
          ./gradlew --version

      - name: Clean and build APK
        run: |
          cd android
          echo "=== Starting Gradle clean ==="
          ./gradlew clean --no-daemon --stacktrace
          echo "=== Starting APK build ==="
          ./gradlew :app:assembleRelease --no-daemon --stacktrace --info

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: MileTracker-Pro-v4.9.68-Enhanced-Trip-Management-Merge-Split
          path: android/app/build/outputs/apk/release/app-release.apk
          retention-days: 30
